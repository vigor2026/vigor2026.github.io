function _mergeNamespaces(fe, K) { for (var pe = 0; pe < K.length; pe++) { const me = K[pe]; if (typeof me != "string" && !Array.isArray(me)) { for (const ge in me) if (ge !== "default" && !(ge in fe)) { const xe = Object.getOwnPropertyDescriptor(me, ge); xe && Object.defineProperty(fe, ge, xe.get ? xe : { enumerable: !0, get: () => me[ge] }) } } } return Object.freeze(Object.defineProperty(fe, Symbol.toStringTag, { value: "Module" })) } (function () { const K = document.createElement("link").relList; if (K && K.supports && K.supports("modulepreload")) return; for (const ge of document.querySelectorAll('link[rel="modulepreload"]')) me(ge); new MutationObserver(ge => { for (const xe of ge) if (xe.type === "childList") for (const ye of xe.addedNodes) ye.tagName === "LINK" && ye.rel === "modulepreload" && me(ye) }).observe(document, { childList: !0, subtree: !0 }); function pe(ge) { const xe = {}; return ge.integrity && (xe.integrity = ge.integrity), ge.referrerPolicy && (xe.referrerPolicy = ge.referrerPolicy), ge.crossOrigin === "use-credentials" ? xe.credentials = "include" : ge.crossOrigin === "anonymous" ? xe.credentials = "omit" : xe.credentials = "same-origin", xe } function me(ge) { if (ge.ep) return; ge.ep = !0; const xe = pe(ge); fetch(ge.href, xe) } })(); var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(fe) { return fe && fe.__esModule && Object.prototype.hasOwnProperty.call(fe, "default") ? fe.default : fe } function getAugmentedNamespace(fe) { if (fe.__esModule) return fe; var K = fe.default; if (typeof K == "function") { var pe = function me() { return this instanceof me ? Reflect.construct(K, arguments, this.constructor) : K.apply(this, arguments) }; pe.prototype = K.prototype } else pe = {}; return Object.defineProperty(pe, "__esModule", { value: !0 }), Object.keys(fe).forEach(function (me) { var ge = Object.getOwnPropertyDescriptor(fe, me); Object.defineProperty(pe, me, ge.get ? ge : { enumerable: !0, get: function () { return fe[me] } }) }), pe } var jsxRuntime$1 = { exports: {} }, reactJsxRuntime_production = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"); function jsxProd(fe, K, pe) { var me = null; if (pe !== void 0 && (me = "" + pe), K.key !== void 0 && (me = "" + K.key), "key" in K) { pe = {}; for (var ge in K) ge !== "key" && (pe[ge] = K[ge]) } else pe = K; return K = pe.ref, { $$typeof: REACT_ELEMENT_TYPE$2, type: fe, key: me, ref: K !== void 0 ? K : null, props: pe } } reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE$2; reactJsxRuntime_production.jsx = jsxProd; reactJsxRuntime_production.jsxs = jsxProd; jsxRuntime$1.exports = reactJsxRuntime_production; var jsxRuntimeExports = jsxRuntime$1.exports; const jsxRuntime = getDefaultExportFromCjs(jsxRuntimeExports), runtime = _mergeNamespaces({ __proto__: null, default: jsxRuntime }, [jsxRuntimeExports]); var client = { exports: {} }, reactDomClient_production = {}, scheduler = { exports: {} }, scheduler_production = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (fe) { function K(qe, Qe) { var st = qe.length; qe.push(Qe); e: for (; 0 < st;) { var Nt = st - 1 >>> 1, Je = qe[Nt]; if (0 < ge(Je, Qe)) qe[Nt] = Qe, qe[st] = Je, st = Nt; else break e } } function pe(qe) { return qe.length === 0 ? null : qe[0] } function me(qe) { if (qe.length === 0) return null; var Qe = qe[0], st = qe.pop(); if (st !== Qe) { qe[0] = st; e: for (var Nt = 0, Je = qe.length, jt = Je >>> 1; Nt < jt;) { var Xt = 2 * (Nt + 1) - 1, ct = qe[Xt], nn = Xt + 1, $t = qe[nn]; if (0 > ge(ct, st)) nn < Je && 0 > ge($t, ct) ? (qe[Nt] = $t, qe[nn] = st, Nt = nn) : (qe[Nt] = ct, qe[Xt] = st, Nt = Xt); else if (nn < Je && 0 > ge($t, st)) qe[Nt] = $t, qe[nn] = st, Nt = nn; else break e } } return Qe } function ge(qe, Qe) { var st = qe.sortIndex - Qe.sortIndex; return st !== 0 ? st : qe.id - Qe.id } if (fe.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var xe = performance; fe.unstable_now = function () { return xe.now() } } else { var ye = Date, ve = ye.now(); fe.unstable_now = function () { return ye.now() - ve } } var _e = [], Ee = [], be = 1, Ae = null, Se = 3, Ce = !1, we = !1, Be = !1, De = typeof setTimeout == "function" ? setTimeout : null, Re = typeof clearTimeout == "function" ? clearTimeout : null, Ie = typeof setImmediate < "u" ? setImmediate : null; function Pe(qe) { for (var Qe = pe(Ee); Qe !== null;) { if (Qe.callback === null) me(Ee); else if (Qe.startTime <= qe) me(Ee), Qe.sortIndex = Qe.expirationTime, K(_e, Qe); else break; Qe = pe(Ee) } } function Ne(qe) { if (Be = !1, Pe(qe), !we) if (pe(_e) !== null) we = !0, Ze(); else { var Qe = pe(Ee); Qe !== null && ot(Ne, Qe.startTime - qe) } } var ke = !1, Oe = -1, Ue = 5, He = -1; function Ge() { return !(fe.unstable_now() - He < Ue) } function ze() { if (ke) { var qe = fe.unstable_now(); He = qe; var Qe = !0; try { e: { we = !1, Be && (Be = !1, Re(Oe), Oe = -1), Ce = !0; var st = Se; try { t: { for (Pe(qe), Ae = pe(_e); Ae !== null && !(Ae.expirationTime > qe && Ge());) { var Nt = Ae.callback; if (typeof Nt == "function") { Ae.callback = null, Se = Ae.priorityLevel; var Je = Nt(Ae.expirationTime <= qe); if (qe = fe.unstable_now(), typeof Je == "function") { Ae.callback = Je, Pe(qe), Qe = !0; break t } Ae === pe(_e) && me(_e), Pe(qe) } else me(_e); Ae = pe(_e) } if (Ae !== null) Qe = !0; else { var jt = pe(Ee); jt !== null && ot(Ne, jt.startTime - qe), Qe = !1 } } break e } finally { Ae = null, Se = st, Ce = !1 } Qe = void 0 } } finally { Qe ? We() : ke = !1 } } } var We; if (typeof Ie == "function") We = function () { Ie(ze) }; else if (typeof MessageChannel < "u") { var Xe = new MessageChannel, Ye = Xe.port2; Xe.port1.onmessage = ze, We = function () { Ye.postMessage(null) } } else We = function () { De(ze, 0) }; function Ze() { ke || (ke = !0, We()) } function ot(qe, Qe) { Oe = De(function () { qe(fe.unstable_now()) }, Qe) } fe.unstable_IdlePriority = 5, fe.unstable_ImmediatePriority = 1, fe.unstable_LowPriority = 4, fe.unstable_NormalPriority = 3, fe.unstable_Profiling = null, fe.unstable_UserBlockingPriority = 2, fe.unstable_cancelCallback = function (qe) { qe.callback = null }, fe.unstable_continueExecution = function () { we || Ce || (we = !0, Ze()) }, fe.unstable_forceFrameRate = function (qe) { 0 > qe || 125 < qe ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ue = 0 < qe ? Math.floor(1e3 / qe) : 5 }, fe.unstable_getCurrentPriorityLevel = function () { return Se }, fe.unstable_getFirstCallbackNode = function () { return pe(_e) }, fe.unstable_next = function (qe) { switch (Se) { case 1: case 2: case 3: var Qe = 3; break; default: Qe = Se }var st = Se; Se = Qe; try { return qe() } finally { Se = st } }, fe.unstable_pauseExecution = function () { }, fe.unstable_requestPaint = function () { }, fe.unstable_runWithPriority = function (qe, Qe) { switch (qe) { case 1: case 2: case 3: case 4: case 5: break; default: qe = 3 }var st = Se; Se = qe; try { return Qe() } finally { Se = st } }, fe.unstable_scheduleCallback = function (qe, Qe, st) { var Nt = fe.unstable_now(); switch (typeof st == "object" && st !== null ? (st = st.delay, st = typeof st == "number" && 0 < st ? Nt + st : Nt) : st = Nt, qe) { case 1: var Je = -1; break; case 2: Je = 250; break; case 5: Je = 1073741823; break; case 4: Je = 1e4; break; default: Je = 5e3 }return Je = st + Je, qe = { id: be++, callback: Qe, priorityLevel: qe, startTime: st, expirationTime: Je, sortIndex: -1 }, st > Nt ? (qe.sortIndex = st, K(Ee, qe), pe(_e) === null && qe === pe(Ee) && (Be ? (Re(Oe), Oe = -1) : Be = !0, ot(Ne, st - Nt))) : (qe.sortIndex = Je, K(_e, qe), we || Ce || (we = !0, Ze())), qe }, fe.unstable_shouldYield = Ge, fe.unstable_wrapCallback = function (qe) { var Qe = Se; return function () { var st = Se; Se = Qe; try { return qe.apply(this, arguments) } finally { Se = st } } } })(scheduler_production); scheduler.exports = scheduler_production; var schedulerExports = scheduler.exports, react = { exports: {} }, react_production = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator; function getIteratorFn$1(fe) { return fe === null || typeof fe != "object" ? null : (fe = MAYBE_ITERATOR_SYMBOL$1 && fe[MAYBE_ITERATOR_SYMBOL$1] || fe["@@iterator"], typeof fe == "function" ? fe : null) } var ReactNoopUpdateQueue = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, assign$2 = Object.assign, emptyObject = {}; function Component(fe, K, pe) { this.props = fe, this.context = K, this.refs = emptyObject, this.updater = pe || ReactNoopUpdateQueue } Component.prototype.isReactComponent = {}; Component.prototype.setState = function (fe, K) { if (typeof fe != "object" && typeof fe != "function" && fe != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, fe, K, "setState") }; Component.prototype.forceUpdate = function (fe) { this.updater.enqueueForceUpdate(this, fe, "forceUpdate") }; function ComponentDummy() { } ComponentDummy.prototype = Component.prototype; function PureComponent(fe, K, pe) { this.props = fe, this.context = K, this.refs = emptyObject, this.updater = pe || ReactNoopUpdateQueue } var pureComponentPrototype = PureComponent.prototype = new ComponentDummy; pureComponentPrototype.constructor = PureComponent; assign$2(pureComponentPrototype, Component.prototype); pureComponentPrototype.isPureReactComponent = !0; var isArrayImpl$1 = Array.isArray, ReactSharedInternals$2 = { H: null, A: null, T: null, S: null }, hasOwnProperty$2 = Object.prototype.hasOwnProperty; function ReactElement(fe, K, pe, me, ge, xe) { return pe = xe.ref, { $$typeof: REACT_ELEMENT_TYPE$1, type: fe, key: K, ref: pe !== void 0 ? pe : null, props: xe } } function cloneAndReplaceKey(fe, K) { return ReactElement(fe.type, K, void 0, void 0, void 0, fe.props) } function isValidElement(fe) { return typeof fe == "object" && fe !== null && fe.$$typeof === REACT_ELEMENT_TYPE$1 } function escape$1(fe) { var K = { "=": "=0", ":": "=2" }; return "$" + fe.replace(/[=:]/g, function (pe) { return K[pe] }) } var userProvidedKeyEscapeRegex = /\/+/g; function getElementKey(fe, K) { return typeof fe == "object" && fe !== null && fe.key != null ? escape$1("" + fe.key) : K.toString(36) } function noop$1$2() { } function resolveThenable(fe) { switch (fe.status) { case "fulfilled": return fe.value; case "rejected": throw fe.reason; default: switch (typeof fe.status == "string" ? fe.then(noop$1$2, noop$1$2) : (fe.status = "pending", fe.then(function (K) { fe.status === "pending" && (fe.status = "fulfilled", fe.value = K) }, function (K) { fe.status === "pending" && (fe.status = "rejected", fe.reason = K) })), fe.status) { case "fulfilled": return fe.value; case "rejected": throw fe.reason } }throw fe } function mapIntoArray(fe, K, pe, me, ge) { var xe = typeof fe; (xe === "undefined" || xe === "boolean") && (fe = null); var ye = !1; if (fe === null) ye = !0; else switch (xe) { case "bigint": case "string": case "number": ye = !0; break; case "object": switch (fe.$$typeof) { case REACT_ELEMENT_TYPE$1: case REACT_PORTAL_TYPE$2: ye = !0; break; case REACT_LAZY_TYPE$1: return ye = fe._init, mapIntoArray(ye(fe._payload), K, pe, me, ge) } }if (ye) return ge = ge(fe), ye = me === "" ? "." + getElementKey(fe, 0) : me, isArrayImpl$1(ge) ? (pe = "", ye != null && (pe = ye.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(ge, K, pe, "", function (Ee) { return Ee })) : ge != null && (isValidElement(ge) && (ge = cloneAndReplaceKey(ge, pe + (ge.key == null || fe && fe.key === ge.key ? "" : ("" + ge.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + ye)), K.push(ge)), 1; ye = 0; var ve = me === "" ? "." : me + ":"; if (isArrayImpl$1(fe)) for (var _e = 0; _e < fe.length; _e++)me = fe[_e], xe = ve + getElementKey(me, _e), ye += mapIntoArray(me, K, pe, xe, ge); else if (_e = getIteratorFn$1(fe), typeof _e == "function") for (fe = _e.call(fe), _e = 0; !(me = fe.next()).done;)me = me.value, xe = ve + getElementKey(me, _e++), ye += mapIntoArray(me, K, pe, xe, ge); else if (xe === "object") { if (typeof fe.then == "function") return mapIntoArray(resolveThenable(fe), K, pe, me, ge); throw K = String(fe), Error("Objects are not valid as a React child (found: " + (K === "[object Object]" ? "object with keys {" + Object.keys(fe).join(", ") + "}" : K) + "). If you meant to render a collection of children, use an array instead.") } return ye } function mapChildren(fe, K, pe) { if (fe == null) return fe; var me = [], ge = 0; return mapIntoArray(fe, me, "", "", function (xe) { return K.call(pe, xe, ge++) }), me } function lazyInitializer(fe) { if (fe._status === -1) { var K = fe._result; K = K(), K.then(function (pe) { (fe._status === 0 || fe._status === -1) && (fe._status = 1, fe._result = pe) }, function (pe) { (fe._status === 0 || fe._status === -1) && (fe._status = 2, fe._result = pe) }), fe._status === -1 && (fe._status = 0, fe._result = K) } if (fe._status === 1) return fe._result.default; throw fe._result } var reportGlobalError$1 = typeof reportError == "function" ? reportError : function (fe) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var K = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof fe == "object" && fe !== null && typeof fe.message == "string" ? String(fe.message) : String(fe), error: fe }); if (!window.dispatchEvent(K)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", fe); return } console.error(fe) }; function noop$7() { } react_production.Children = { map: mapChildren, forEach: function (fe, K, pe) { mapChildren(fe, function () { K.apply(this, arguments) }, pe) }, count: function (fe) { var K = 0; return mapChildren(fe, function () { K++ }), K }, toArray: function (fe) { return mapChildren(fe, function (K) { return K }) || [] }, only: function (fe) { if (!isValidElement(fe)) throw Error("React.Children.only expected to receive a single React element child."); return fe } }; react_production.Component = Component; react_production.Fragment = REACT_FRAGMENT_TYPE$1; react_production.Profiler = REACT_PROFILER_TYPE$1; react_production.PureComponent = PureComponent; react_production.StrictMode = REACT_STRICT_MODE_TYPE$1; react_production.Suspense = REACT_SUSPENSE_TYPE$1; react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2; react_production.act = function () { throw Error("act(...) is not supported in production builds of React.") }; react_production.cache = function (fe) { return function () { return fe.apply(null, arguments) } }; react_production.cloneElement = function (fe, K, pe) { if (fe == null) throw Error("The argument must be a React element, but you passed " + fe + "."); var me = assign$2({}, fe.props), ge = fe.key, xe = void 0; if (K != null) for (ye in K.ref !== void 0 && (xe = void 0), K.key !== void 0 && (ge = "" + K.key), K) !hasOwnProperty$2.call(K, ye) || ye === "key" || ye === "__self" || ye === "__source" || ye === "ref" && K.ref === void 0 || (me[ye] = K[ye]); var ye = arguments.length - 2; if (ye === 1) me.children = pe; else if (1 < ye) { for (var ve = Array(ye), _e = 0; _e < ye; _e++)ve[_e] = arguments[_e + 2]; me.children = ve } return ReactElement(fe.type, ge, void 0, void 0, xe, me) }; react_production.createContext = function (fe) { return fe = { $$typeof: REACT_CONTEXT_TYPE$1, _currentValue: fe, _currentValue2: fe, _threadCount: 0, Provider: null, Consumer: null }, fe.Provider = fe, fe.Consumer = { $$typeof: REACT_CONSUMER_TYPE$1, _context: fe }, fe }; react_production.createElement = function (fe, K, pe) { var me, ge = {}, xe = null; if (K != null) for (me in K.key !== void 0 && (xe = "" + K.key), K) hasOwnProperty$2.call(K, me) && me !== "key" && me !== "__self" && me !== "__source" && (ge[me] = K[me]); var ye = arguments.length - 2; if (ye === 1) ge.children = pe; else if (1 < ye) { for (var ve = Array(ye), _e = 0; _e < ye; _e++)ve[_e] = arguments[_e + 2]; ge.children = ve } if (fe && fe.defaultProps) for (me in ye = fe.defaultProps, ye) ge[me] === void 0 && (ge[me] = ye[me]); return ReactElement(fe, xe, void 0, void 0, null, ge) }; react_production.createRef = function () { return { current: null } }; react_production.forwardRef = function (fe) { return { $$typeof: REACT_FORWARD_REF_TYPE$1, render: fe } }; react_production.isValidElement = isValidElement; react_production.lazy = function (fe) { return { $$typeof: REACT_LAZY_TYPE$1, _payload: { _status: -1, _result: fe }, _init: lazyInitializer } }; react_production.memo = function (fe, K) { return { $$typeof: REACT_MEMO_TYPE$1, type: fe, compare: K === void 0 ? null : K } }; react_production.startTransition = function (fe) { var K = ReactSharedInternals$2.T, pe = {}; ReactSharedInternals$2.T = pe; try { var me = fe(), ge = ReactSharedInternals$2.S; ge !== null && ge(pe, me), typeof me == "object" && me !== null && typeof me.then == "function" && me.then(noop$7, reportGlobalError$1) } catch (xe) { reportGlobalError$1(xe) } finally { ReactSharedInternals$2.T = K } }; react_production.unstable_useCacheRefresh = function () { return ReactSharedInternals$2.H.useCacheRefresh() }; react_production.use = function (fe) { return ReactSharedInternals$2.H.use(fe) }; react_production.useActionState = function (fe, K, pe) { return ReactSharedInternals$2.H.useActionState(fe, K, pe) }; react_production.useCallback = function (fe, K) { return ReactSharedInternals$2.H.useCallback(fe, K) }; react_production.useContext = function (fe) { return ReactSharedInternals$2.H.useContext(fe) }; react_production.useDebugValue = function () { }; react_production.useDeferredValue = function (fe, K) { return ReactSharedInternals$2.H.useDeferredValue(fe, K) }; react_production.useEffect = function (fe, K) { return ReactSharedInternals$2.H.useEffect(fe, K) }; react_production.useId = function () { return ReactSharedInternals$2.H.useId() }; react_production.useImperativeHandle = function (fe, K, pe) { return ReactSharedInternals$2.H.useImperativeHandle(fe, K, pe) }; react_production.useInsertionEffect = function (fe, K) { return ReactSharedInternals$2.H.useInsertionEffect(fe, K) }; react_production.useLayoutEffect = function (fe, K) { return ReactSharedInternals$2.H.useLayoutEffect(fe, K) }; react_production.useMemo = function (fe, K) { return ReactSharedInternals$2.H.useMemo(fe, K) }; react_production.useOptimistic = function (fe, K) { return ReactSharedInternals$2.H.useOptimistic(fe, K) }; react_production.useReducer = function (fe, K, pe) { return ReactSharedInternals$2.H.useReducer(fe, K, pe) }; react_production.useRef = function (fe) { return ReactSharedInternals$2.H.useRef(fe) }; react_production.useState = function (fe) { return ReactSharedInternals$2.H.useState(fe) }; react_production.useSyncExternalStore = function (fe, K, pe) { return ReactSharedInternals$2.H.useSyncExternalStore(fe, K, pe) }; react_production.useTransition = function () { return ReactSharedInternals$2.H.useTransition() }; react_production.version = "19.0.0"; react.exports = react_production; var reactExports = react.exports; const React$4 = getDefaultExportFromCjs(reactExports), React$5 = _mergeNamespaces({ __proto__: null, default: React$4 }, [reactExports]); var reactDom = { exports: {} }, reactDom_production = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var React$3 = reactExports; function formatProdErrorMessage$1(fe) { var K = "https://react.dev/errors/" + fe; if (1 < arguments.length) { K += "?args[]=" + encodeURIComponent(arguments[1]); for (var pe = 2; pe < arguments.length; pe++)K += "&args[]=" + encodeURIComponent(arguments[pe]) } return "Minified React error #" + fe + "; visit " + K + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function noop$6() { } var Internals = { d: { f: noop$6, r: function () { throw Error(formatProdErrorMessage$1(522)) }, D: noop$6, C: noop$6, L: noop$6, m: noop$6, X: noop$6, S: noop$6, M: noop$6 }, p: 0, findDOMNode: null }, REACT_PORTAL_TYPE$1 = Symbol.for("react.portal"); function createPortal$1(fe, K, pe) { var me = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: REACT_PORTAL_TYPE$1, key: me == null ? null : "" + me, children: fe, containerInfo: K, implementation: pe } } var ReactSharedInternals$1 = React$3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function getCrossOriginStringAs(fe, K) { if (fe === "font") return ""; if (typeof K == "string") return K === "use-credentials" ? K : "" } reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals; reactDom_production.createPortal = function (fe, K) { var pe = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!K || K.nodeType !== 1 && K.nodeType !== 9 && K.nodeType !== 11) throw Error(formatProdErrorMessage$1(299)); return createPortal$1(fe, K, null, pe) }; reactDom_production.flushSync = function (fe) { var K = ReactSharedInternals$1.T, pe = Internals.p; try { if (ReactSharedInternals$1.T = null, Internals.p = 2, fe) return fe() } finally { ReactSharedInternals$1.T = K, Internals.p = pe, Internals.d.f() } }; reactDom_production.preconnect = function (fe, K) { typeof fe == "string" && (K ? (K = K.crossOrigin, K = typeof K == "string" ? K === "use-credentials" ? K : "" : void 0) : K = null, Internals.d.C(fe, K)) }; reactDom_production.prefetchDNS = function (fe) { typeof fe == "string" && Internals.d.D(fe) }; reactDom_production.preinit = function (fe, K) { if (typeof fe == "string" && K && typeof K.as == "string") { var pe = K.as, me = getCrossOriginStringAs(pe, K.crossOrigin), ge = typeof K.integrity == "string" ? K.integrity : void 0, xe = typeof K.fetchPriority == "string" ? K.fetchPriority : void 0; pe === "style" ? Internals.d.S(fe, typeof K.precedence == "string" ? K.precedence : void 0, { crossOrigin: me, integrity: ge, fetchPriority: xe }) : pe === "script" && Internals.d.X(fe, { crossOrigin: me, integrity: ge, fetchPriority: xe, nonce: typeof K.nonce == "string" ? K.nonce : void 0 }) } }; reactDom_production.preinitModule = function (fe, K) { if (typeof fe == "string") if (typeof K == "object" && K !== null) { if (K.as == null || K.as === "script") { var pe = getCrossOriginStringAs(K.as, K.crossOrigin); Internals.d.M(fe, { crossOrigin: pe, integrity: typeof K.integrity == "string" ? K.integrity : void 0, nonce: typeof K.nonce == "string" ? K.nonce : void 0 }) } } else K == null && Internals.d.M(fe) }; reactDom_production.preload = function (fe, K) { if (typeof fe == "string" && typeof K == "object" && K !== null && typeof K.as == "string") { var pe = K.as, me = getCrossOriginStringAs(pe, K.crossOrigin); Internals.d.L(fe, pe, { crossOrigin: me, integrity: typeof K.integrity == "string" ? K.integrity : void 0, nonce: typeof K.nonce == "string" ? K.nonce : void 0, type: typeof K.type == "string" ? K.type : void 0, fetchPriority: typeof K.fetchPriority == "string" ? K.fetchPriority : void 0, referrerPolicy: typeof K.referrerPolicy == "string" ? K.referrerPolicy : void 0, imageSrcSet: typeof K.imageSrcSet == "string" ? K.imageSrcSet : void 0, imageSizes: typeof K.imageSizes == "string" ? K.imageSizes : void 0, media: typeof K.media == "string" ? K.media : void 0 }) } }; reactDom_production.preloadModule = function (fe, K) { if (typeof fe == "string") if (K) { var pe = getCrossOriginStringAs(K.as, K.crossOrigin); Internals.d.m(fe, { as: typeof K.as == "string" && K.as !== "script" ? K.as : void 0, crossOrigin: pe, integrity: typeof K.integrity == "string" ? K.integrity : void 0 }) } else Internals.d.m(fe) }; reactDom_production.requestFormReset = function (fe) { Internals.d.r(fe) }; reactDom_production.unstable_batchedUpdates = function (fe, K) { return fe(K) }; reactDom_production.useFormState = function (fe, K, pe) { return ReactSharedInternals$1.H.useFormState(fe, K, pe) }; reactDom_production.useFormStatus = function () { return ReactSharedInternals$1.H.useHostTransitionStatus() }; reactDom_production.version = "19.0.0"; function checkDCE$1() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1) } catch (fe) { console.error(fe) } } checkDCE$1(), reactDom.exports = reactDom_production; var reactDomExports = reactDom.exports; const ReactDOM$2 = getDefaultExportFromCjs(reactDomExports);/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Scheduler = schedulerExports, React$2 = reactExports, ReactDOM$1 = reactDomExports; function formatProdErrorMessage(fe) { var K = "https://react.dev/errors/" + fe; if (1 < arguments.length) { K += "?args[]=" + encodeURIComponent(arguments[1]); for (var pe = 2; pe < arguments.length; pe++)K += "&args[]=" + encodeURIComponent(arguments[pe]) } return "Minified React error #" + fe + "; visit " + K + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function isValidContainer(fe) { return !(!fe || fe.nodeType !== 1 && fe.nodeType !== 9 && fe.nodeType !== 11) } var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator; function getIteratorFn(fe) { return fe === null || typeof fe != "object" ? null : (fe = MAYBE_ITERATOR_SYMBOL && fe[MAYBE_ITERATOR_SYMBOL] || fe["@@iterator"], typeof fe == "function" ? fe : null) } var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"); function getComponentNameFromType(fe) { if (fe == null) return null; if (typeof fe == "function") return fe.$$typeof === REACT_CLIENT_REFERENCE ? null : fe.displayName || fe.name || null; if (typeof fe == "string") return fe; switch (fe) { case REACT_FRAGMENT_TYPE: return "Fragment"; case REACT_PORTAL_TYPE: return "Portal"; case REACT_PROFILER_TYPE: return "Profiler"; case REACT_STRICT_MODE_TYPE: return "StrictMode"; case REACT_SUSPENSE_TYPE: return "Suspense"; case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList" }if (typeof fe == "object") switch (fe.$$typeof) { case REACT_CONTEXT_TYPE: return (fe.displayName || "Context") + ".Provider"; case REACT_CONSUMER_TYPE: return (fe._context.displayName || "Context") + ".Consumer"; case REACT_FORWARD_REF_TYPE: var K = fe.render; return fe = fe.displayName, fe || (fe = K.displayName || K.name || "", fe = fe !== "" ? "ForwardRef(" + fe + ")" : "ForwardRef"), fe; case REACT_MEMO_TYPE: return K = fe.displayName || null, K !== null ? K : getComponentNameFromType(fe.type) || "Memo"; case REACT_LAZY_TYPE: K = fe._payload, fe = fe._init; try { return getComponentNameFromType(fe(K)) } catch { } }return null } var ReactSharedInternals = React$2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, assign$1 = Object.assign, prefix, suffix; function describeBuiltInComponentFrame(fe) {
	if (prefix === void 0) try { throw Error() } catch (pe) {
		var K = pe.stack.trim().match(/\n( *(at )?)/); prefix = K && K[1] || "", suffix = -1 < pe.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < pe.stack.indexOf("@") ? "@unknown:0:0" : ""
	} return `
`+ prefix + fe + suffix
} var reentry = !1; function describeNativeComponentFrame(fe, K) {
	if (!fe || reentry) return ""; reentry = !0; var pe = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
		var me = { DetermineComponentFrameRoot: function () { try { if (K) { var Ae = function () { throw Error() }; if (Object.defineProperty(Ae.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(Ae, []) } catch (Ce) { var Se = Ce } Reflect.construct(fe, [], Ae) } else { try { Ae.call() } catch (Ce) { Se = Ce } fe.call(Ae.prototype) } } else { try { throw Error() } catch (Ce) { Se = Ce } (Ae = fe()) && typeof Ae.catch == "function" && Ae.catch(function () { }) } } catch (Ce) { if (Ce && Se && typeof Ce.stack == "string") return [Ce.stack, Se.stack] } return [null, null] } }; me.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var ge = Object.getOwnPropertyDescriptor(me.DetermineComponentFrameRoot, "name"); ge && ge.configurable && Object.defineProperty(me.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var xe = me.DetermineComponentFrameRoot(), ye = xe[0], ve = xe[1]; if (ye && ve) {
			var _e = ye.split(`
`), Ee = ve.split(`
`); for (ge = me = 0; me < _e.length && !_e[me].includes("DetermineComponentFrameRoot");)me++; for (; ge < Ee.length && !Ee[ge].includes("DetermineComponentFrameRoot");)ge++; if (me === _e.length || ge === Ee.length) for (me = _e.length - 1, ge = Ee.length - 1; 1 <= me && 0 <= ge && _e[me] !== Ee[ge];)ge--; for (; 1 <= me && 0 <= ge; me--, ge--)if (_e[me] !== Ee[ge]) {
				if (me !== 1 || ge !== 1) do if (me--, ge--, 0 > ge || _e[me] !== Ee[ge]) {
					var be = `
`+ _e[me].replace(" at new ", " at "); return fe.displayName && be.includes("<anonymous>") && (be = be.replace("<anonymous>", fe.displayName)), be
				} while (1 <= me && 0 <= ge); break
			}
		}
	} finally { reentry = !1, Error.prepareStackTrace = pe } return (pe = fe ? fe.displayName || fe.name : "") ? describeBuiltInComponentFrame(pe) : ""
} function describeFiber(fe) { switch (fe.tag) { case 26: case 27: case 5: return describeBuiltInComponentFrame(fe.type); case 16: return describeBuiltInComponentFrame("Lazy"); case 13: return describeBuiltInComponentFrame("Suspense"); case 19: return describeBuiltInComponentFrame("SuspenseList"); case 0: case 15: return fe = describeNativeComponentFrame(fe.type, !1), fe; case 11: return fe = describeNativeComponentFrame(fe.type.render, !1), fe; case 1: return fe = describeNativeComponentFrame(fe.type, !0), fe; default: return "" } } function getStackByFiberInDevAndProd(fe) {
	try { var K = ""; do K += describeFiber(fe), fe = fe.return; while (fe); return K } catch (pe) {
		return `
Error generating stack: `+ pe.message + `
`+ pe.stack
	}
} function getNearestMountedFiber(fe) { var K = fe, pe = fe; if (fe.alternate) for (; K.return;)K = K.return; else { fe = K; do K = fe, K.flags & 4098 && (pe = K.return), fe = K.return; while (fe) } return K.tag === 3 ? pe : null } function getSuspenseInstanceFromFiber(fe) { if (fe.tag === 13) { var K = fe.memoizedState; if (K === null && (fe = fe.alternate, fe !== null && (K = fe.memoizedState)), K !== null) return K.dehydrated } return null } function assertIsMounted(fe) { if (getNearestMountedFiber(fe) !== fe) throw Error(formatProdErrorMessage(188)) } function findCurrentFiberUsingSlowPath(fe) { var K = fe.alternate; if (!K) { if (K = getNearestMountedFiber(fe), K === null) throw Error(formatProdErrorMessage(188)); return K !== fe ? null : fe } for (var pe = fe, me = K; ;) { var ge = pe.return; if (ge === null) break; var xe = ge.alternate; if (xe === null) { if (me = ge.return, me !== null) { pe = me; continue } break } if (ge.child === xe.child) { for (xe = ge.child; xe;) { if (xe === pe) return assertIsMounted(ge), fe; if (xe === me) return assertIsMounted(ge), K; xe = xe.sibling } throw Error(formatProdErrorMessage(188)) } if (pe.return !== me.return) pe = ge, me = xe; else { for (var ye = !1, ve = ge.child; ve;) { if (ve === pe) { ye = !0, pe = ge, me = xe; break } if (ve === me) { ye = !0, me = ge, pe = xe; break } ve = ve.sibling } if (!ye) { for (ve = xe.child; ve;) { if (ve === pe) { ye = !0, pe = xe, me = ge; break } if (ve === me) { ye = !0, me = xe, pe = ge; break } ve = ve.sibling } if (!ye) throw Error(formatProdErrorMessage(189)) } } if (pe.alternate !== me) throw Error(formatProdErrorMessage(190)) } if (pe.tag !== 3) throw Error(formatProdErrorMessage(188)); return pe.stateNode.current === pe ? fe : K } function findCurrentHostFiberImpl(fe) { var K = fe.tag; if (K === 5 || K === 26 || K === 27 || K === 6) return fe; for (fe = fe.child; fe !== null;) { if (K = findCurrentHostFiberImpl(fe), K !== null) return K; fe = fe.sibling } return null } var isArrayImpl = Array.isArray, ReactDOMSharedInternals = ReactDOM$1.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = { pending: !1, data: null, method: null, action: null }, valueStack = [], index$5 = -1; function createCursor(fe) { return { current: fe } } function pop(fe) { 0 > index$5 || (fe.current = valueStack[index$5], valueStack[index$5] = null, index$5--) } function push$1(fe, K) { index$5++, valueStack[index$5] = fe.current, fe.current = K } var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null); function pushHostContainer(fe, K) { switch (push$1(rootInstanceStackCursor, K), push$1(contextFiberStackCursor, fe), push$1(contextStackCursor, null), fe = K.nodeType, fe) { case 9: case 11: K = (K = K.documentElement) && (K = K.namespaceURI) ? getOwnHostContext(K) : 0; break; default: if (fe = fe === 8 ? K.parentNode : K, K = fe.tagName, fe = fe.namespaceURI) fe = getOwnHostContext(fe), K = getChildHostContextProd(fe, K); else switch (K) { case "svg": K = 1; break; case "math": K = 2; break; default: K = 0 } }pop(contextStackCursor), push$1(contextStackCursor, K) } function popHostContainer() { pop(contextStackCursor), pop(contextFiberStackCursor), pop(rootInstanceStackCursor) } function pushHostContext(fe) { fe.memoizedState !== null && push$1(hostTransitionProviderCursor, fe); var K = contextStackCursor.current, pe = getChildHostContextProd(K, fe.type); K !== pe && (push$1(contextFiberStackCursor, fe), push$1(contextStackCursor, pe)) } function popHostContext(fe) { contextFiberStackCursor.current === fe && (pop(contextStackCursor), pop(contextFiberStackCursor)), hostTransitionProviderCursor.current === fe && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject) } var hasOwnProperty$1 = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null; function onCommitRoot(fe) { if (injectedHook && typeof injectedHook.onCommitFiberRoot == "function") try { injectedHook.onCommitFiberRoot(rendererID, fe, void 0, (fe.current.flags & 128) === 128) } catch { } } function setIsStrictModeForDevtools(fe) { if (typeof log$1 == "function" && unstable_setDisableYieldValue(fe), injectedHook && typeof injectedHook.setStrictMode == "function") try { injectedHook.setStrictMode(rendererID, fe) } catch { } } var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2; function clz32Fallback(fe) { return fe >>>= 0, fe === 0 ? 32 : 31 - (log(fe) / LN2 | 0) | 0 } var nextTransitionLane = 128, nextRetryLane = 4194304; function getHighestPriorityLanes(fe) { var K = fe & 42; if (K !== 0) return K; switch (fe & -fe) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return fe & 4194176; case 4194304: case 8388608: case 16777216: case 33554432: return fe & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return fe } } function getNextLanes(fe, K) { var pe = fe.pendingLanes; if (pe === 0) return 0; var me = 0, ge = fe.suspendedLanes, xe = fe.pingedLanes, ye = fe.warmLanes; fe = fe.finishedLanes !== 0; var ve = pe & 134217727; return ve !== 0 ? (pe = ve & ~ge, pe !== 0 ? me = getHighestPriorityLanes(pe) : (xe &= ve, xe !== 0 ? me = getHighestPriorityLanes(xe) : fe || (ye = ve & ~ye, ye !== 0 && (me = getHighestPriorityLanes(ye))))) : (ve = pe & ~ge, ve !== 0 ? me = getHighestPriorityLanes(ve) : xe !== 0 ? me = getHighestPriorityLanes(xe) : fe || (ye = pe & ~ye, ye !== 0 && (me = getHighestPriorityLanes(ye)))), me === 0 ? 0 : K !== 0 && K !== me && !(K & ge) && (ge = me & -me, ye = K & -K, ge >= ye || ge === 32 && (ye & 4194176) !== 0) ? K : me } function checkIfRootIsPrerendering(fe, K) { return (fe.pendingLanes & ~(fe.suspendedLanes & ~fe.pingedLanes) & K) === 0 } function computeExpirationTime(fe, K) { switch (fe) { case 1: case 2: case 4: case 8: return K + 250; case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return K + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function claimNextTransitionLane() { var fe = nextTransitionLane; return nextTransitionLane <<= 1, !(nextTransitionLane & 4194176) && (nextTransitionLane = 128), fe } function claimNextRetryLane() { var fe = nextRetryLane; return nextRetryLane <<= 1, !(nextRetryLane & 62914560) && (nextRetryLane = 4194304), fe } function createLaneMap(fe) { for (var K = [], pe = 0; 31 > pe; pe++)K.push(fe); return K } function markRootUpdated$1(fe, K) { fe.pendingLanes |= K, K !== 268435456 && (fe.suspendedLanes = 0, fe.pingedLanes = 0, fe.warmLanes = 0) } function markRootFinished(fe, K, pe, me, ge, xe) { var ye = fe.pendingLanes; fe.pendingLanes = pe, fe.suspendedLanes = 0, fe.pingedLanes = 0, fe.warmLanes = 0, fe.expiredLanes &= pe, fe.entangledLanes &= pe, fe.errorRecoveryDisabledLanes &= pe, fe.shellSuspendCounter = 0; var ve = fe.entanglements, _e = fe.expirationTimes, Ee = fe.hiddenUpdates; for (pe = ye & ~pe; 0 < pe;) { var be = 31 - clz32(pe), Ae = 1 << be; ve[be] = 0, _e[be] = -1; var Se = Ee[be]; if (Se !== null) for (Ee[be] = null, be = 0; be < Se.length; be++) { var Ce = Se[be]; Ce !== null && (Ce.lane &= -536870913) } pe &= ~Ae } me !== 0 && markSpawnedDeferredLane(fe, me, 0), xe !== 0 && ge === 0 && fe.tag !== 0 && (fe.suspendedLanes |= xe & ~(ye & ~K)) } function markSpawnedDeferredLane(fe, K, pe) { fe.pendingLanes |= K, fe.suspendedLanes &= ~K; var me = 31 - clz32(K); fe.entangledLanes |= K, fe.entanglements[me] = fe.entanglements[me] | 1073741824 | pe & 4194218 } function markRootEntangled(fe, K) { var pe = fe.entangledLanes |= K; for (fe = fe.entanglements; pe;) { var me = 31 - clz32(pe), ge = 1 << me; ge & K | fe[me] & K && (fe[me] |= K), pe &= ~ge } } function lanesToEventPriority(fe) { return fe &= -fe, 2 < fe ? 8 < fe ? fe & 134217727 ? 32 : 268435456 : 8 : 2 } function resolveUpdatePriority() { var fe = ReactDOMSharedInternals.p; return fe !== 0 ? fe : (fe = window.event, fe === void 0 ? 32 : getEventPriority(fe.type)) } function runWithPriority(fe, K) { var pe = ReactDOMSharedInternals.p; try { return ReactDOMSharedInternals.p = fe, K() } finally { ReactDOMSharedInternals.p = pe } } var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey; function detachDeletedInstance(fe) { delete fe[internalInstanceKey], delete fe[internalPropsKey], delete fe[internalEventHandlersKey], delete fe[internalEventHandlerListenersKey], delete fe[internalEventHandlesSetKey] } function getClosestInstanceFromNode(fe) { var K = fe[internalInstanceKey]; if (K) return K; for (var pe = fe.parentNode; pe;) { if (K = pe[internalContainerInstanceKey] || pe[internalInstanceKey]) { if (pe = K.alternate, K.child !== null || pe !== null && pe.child !== null) for (fe = getParentSuspenseInstance(fe); fe !== null;) { if (pe = fe[internalInstanceKey]) return pe; fe = getParentSuspenseInstance(fe) } return K } fe = pe, pe = fe.parentNode } return null } function getInstanceFromNode(fe) { if (fe = fe[internalInstanceKey] || fe[internalContainerInstanceKey]) { var K = fe.tag; if (K === 5 || K === 6 || K === 13 || K === 26 || K === 27 || K === 3) return fe } return null } function getNodeFromInstance(fe) { var K = fe.tag; if (K === 5 || K === 26 || K === 27 || K === 6) return fe.stateNode; throw Error(formatProdErrorMessage(33)) } function getResourcesFromRoot(fe) { var K = fe[internalRootNodeResourcesKey]; return K || (K = fe[internalRootNodeResourcesKey] = { hoistableStyles: new Map, hoistableScripts: new Map }), K } function markNodeAsHoistable(fe) { fe[internalHoistableMarker] = !0 } var allNativeEvents = new Set, registrationNameDependencies = {}; function registerTwoPhaseEvent(fe, K) { registerDirectEvent(fe, K), registerDirectEvent(fe + "Capture", K) } function registerDirectEvent(fe, K) { for (registrationNameDependencies[fe] = K, fe = 0; fe < K.length; fe++)allNativeEvents.add(K[fe]) } var canUseDOM = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}; function isAttributeNameSafe(fe) { return hasOwnProperty$1.call(validatedAttributeNameCache, fe) ? !0 : hasOwnProperty$1.call(illegalAttributeNameCache, fe) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(fe) ? validatedAttributeNameCache[fe] = !0 : (illegalAttributeNameCache[fe] = !0, !1) } function setValueForAttribute(fe, K, pe) { if (isAttributeNameSafe(K)) if (pe === null) fe.removeAttribute(K); else { switch (typeof pe) { case "undefined": case "function": case "symbol": fe.removeAttribute(K); return; case "boolean": var me = K.toLowerCase().slice(0, 5); if (me !== "data-" && me !== "aria-") { fe.removeAttribute(K); return } }fe.setAttribute(K, "" + pe) } } function setValueForKnownAttribute(fe, K, pe) { if (pe === null) fe.removeAttribute(K); else { switch (typeof pe) { case "undefined": case "function": case "symbol": case "boolean": fe.removeAttribute(K); return }fe.setAttribute(K, "" + pe) } } function setValueForNamespacedAttribute(fe, K, pe, me) { if (me === null) fe.removeAttribute(pe); else { switch (typeof me) { case "undefined": case "function": case "symbol": case "boolean": fe.removeAttribute(pe); return }fe.setAttributeNS(K, pe, "" + me) } } function getToStringValue(fe) { switch (typeof fe) { case "bigint": case "boolean": case "number": case "string": case "undefined": return fe; case "object": return fe; default: return "" } } function isCheckable(fe) { var K = fe.type; return (fe = fe.nodeName) && fe.toLowerCase() === "input" && (K === "checkbox" || K === "radio") } function trackValueOnNode(fe) { var K = isCheckable(fe) ? "checked" : "value", pe = Object.getOwnPropertyDescriptor(fe.constructor.prototype, K), me = "" + fe[K]; if (!fe.hasOwnProperty(K) && typeof pe < "u" && typeof pe.get == "function" && typeof pe.set == "function") { var ge = pe.get, xe = pe.set; return Object.defineProperty(fe, K, { configurable: !0, get: function () { return ge.call(this) }, set: function (ye) { me = "" + ye, xe.call(this, ye) } }), Object.defineProperty(fe, K, { enumerable: pe.enumerable }), { getValue: function () { return me }, setValue: function (ye) { me = "" + ye }, stopTracking: function () { fe._valueTracker = null, delete fe[K] } } } } function track(fe) { fe._valueTracker || (fe._valueTracker = trackValueOnNode(fe)) } function updateValueIfChanged(fe) { if (!fe) return !1; var K = fe._valueTracker; if (!K) return !0; var pe = K.getValue(), me = ""; return fe && (me = isCheckable(fe) ? fe.checked ? "true" : "false" : fe.value), fe = me, fe !== pe ? (K.setValue(fe), !0) : !1 } function getActiveElement(fe) { if (fe = fe || (typeof document < "u" ? document : void 0), typeof fe > "u") return null; try { return fe.activeElement || fe.body } catch { return fe.body } } var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g; function escapeSelectorAttributeValueInsideDoubleQuotes(fe) { return fe.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (K) { return "\\" + K.charCodeAt(0).toString(16) + " " }) } function updateInput(fe, K, pe, me, ge, xe, ye, ve) { fe.name = "", ye != null && typeof ye != "function" && typeof ye != "symbol" && typeof ye != "boolean" ? fe.type = ye : fe.removeAttribute("type"), K != null ? ye === "number" ? (K === 0 && fe.value === "" || fe.value != K) && (fe.value = "" + getToStringValue(K)) : fe.value !== "" + getToStringValue(K) && (fe.value = "" + getToStringValue(K)) : ye !== "submit" && ye !== "reset" || fe.removeAttribute("value"), K != null ? setDefaultValue(fe, ye, getToStringValue(K)) : pe != null ? setDefaultValue(fe, ye, getToStringValue(pe)) : me != null && fe.removeAttribute("value"), ge == null && xe != null && (fe.defaultChecked = !!xe), ge != null && (fe.checked = ge && typeof ge != "function" && typeof ge != "symbol"), ve != null && typeof ve != "function" && typeof ve != "symbol" && typeof ve != "boolean" ? fe.name = "" + getToStringValue(ve) : fe.removeAttribute("name") } function initInput(fe, K, pe, me, ge, xe, ye, ve) { if (xe != null && typeof xe != "function" && typeof xe != "symbol" && typeof xe != "boolean" && (fe.type = xe), K != null || pe != null) { if (!(xe !== "submit" && xe !== "reset" || K != null)) return; pe = pe != null ? "" + getToStringValue(pe) : "", K = K != null ? "" + getToStringValue(K) : pe, ve || K === fe.value || (fe.value = K), fe.defaultValue = K } me = me ?? ge, me = typeof me != "function" && typeof me != "symbol" && !!me, fe.checked = ve ? fe.checked : !!me, fe.defaultChecked = !!me, ye != null && typeof ye != "function" && typeof ye != "symbol" && typeof ye != "boolean" && (fe.name = ye) } function setDefaultValue(fe, K, pe) { K === "number" && getActiveElement(fe.ownerDocument) === fe || fe.defaultValue === "" + pe || (fe.defaultValue = "" + pe) } function updateOptions(fe, K, pe, me) { if (fe = fe.options, K) { K = {}; for (var ge = 0; ge < pe.length; ge++)K["$" + pe[ge]] = !0; for (pe = 0; pe < fe.length; pe++)ge = K.hasOwnProperty("$" + fe[pe].value), fe[pe].selected !== ge && (fe[pe].selected = ge), ge && me && (fe[pe].defaultSelected = !0) } else { for (pe = "" + getToStringValue(pe), K = null, ge = 0; ge < fe.length; ge++) { if (fe[ge].value === pe) { fe[ge].selected = !0, me && (fe[ge].defaultSelected = !0); return } K !== null || fe[ge].disabled || (K = fe[ge]) } K !== null && (K.selected = !0) } } function updateTextarea(fe, K, pe) { if (K != null && (K = "" + getToStringValue(K), K !== fe.value && (fe.value = K), pe == null)) { fe.defaultValue !== K && (fe.defaultValue = K); return } fe.defaultValue = pe != null ? "" + getToStringValue(pe) : "" } function initTextarea(fe, K, pe, me) { if (K == null) { if (me != null) { if (pe != null) throw Error(formatProdErrorMessage(92)); if (isArrayImpl(me)) { if (1 < me.length) throw Error(formatProdErrorMessage(93)); me = me[0] } pe = me } pe == null && (pe = ""), K = pe } pe = getToStringValue(K), fe.defaultValue = pe, me = fe.textContent, me === pe && me !== "" && me !== null && (fe.value = me) } function setTextContent(fe, K) { if (K) { var pe = fe.firstChild; if (pe && pe === fe.lastChild && pe.nodeType === 3) { pe.nodeValue = K; return } } fe.textContent = K } var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function setValueForStyle(fe, K, pe) { var me = K.indexOf("--") === 0; pe == null || typeof pe == "boolean" || pe === "" ? me ? fe.setProperty(K, "") : K === "float" ? fe.cssFloat = "" : fe[K] = "" : me ? fe.setProperty(K, pe) : typeof pe != "number" || pe === 0 || unitlessNumbers.has(K) ? K === "float" ? fe.cssFloat = pe : fe[K] = ("" + pe).trim() : fe[K] = pe + "px" } function setValueForStyles(fe, K, pe) { if (K != null && typeof K != "object") throw Error(formatProdErrorMessage(62)); if (fe = fe.style, pe != null) { for (var me in pe) !pe.hasOwnProperty(me) || K != null && K.hasOwnProperty(me) || (me.indexOf("--") === 0 ? fe.setProperty(me, "") : me === "float" ? fe.cssFloat = "" : fe[me] = ""); for (var ge in K) me = K[ge], K.hasOwnProperty(ge) && pe[ge] !== me && setValueForStyle(fe, ge, me) } else for (var xe in K) K.hasOwnProperty(xe) && setValueForStyle(fe, xe, K[xe]) } function isCustomElement(fe) { if (fe.indexOf("-") === -1) return !1; switch (fe) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function sanitizeURL(fe) { return isJavaScriptProtocol.test("" + fe) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : fe } var currentReplayingEvent = null; function getEventTarget(fe) { return fe = fe.target || fe.srcElement || window, fe.correspondingUseElement && (fe = fe.correspondingUseElement), fe.nodeType === 3 ? fe.parentNode : fe } var restoreTarget = null, restoreQueue = null; function restoreStateOfTarget(fe) { var K = getInstanceFromNode(fe); if (K && (fe = K.stateNode)) { var pe = fe[internalPropsKey] || null; e: switch (fe = K.stateNode, K.type) { case "input": if (updateInput(fe, pe.value, pe.defaultValue, pe.defaultValue, pe.checked, pe.defaultChecked, pe.type, pe.name), K = pe.name, pe.type === "radio" && K != null) { for (pe = fe; pe.parentNode;)pe = pe.parentNode; for (pe = pe.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + K) + '"][type="radio"]'), K = 0; K < pe.length; K++) { var me = pe[K]; if (me !== fe && me.form === fe.form) { var ge = me[internalPropsKey] || null; if (!ge) throw Error(formatProdErrorMessage(90)); updateInput(me, ge.value, ge.defaultValue, ge.defaultValue, ge.checked, ge.defaultChecked, ge.type, ge.name) } } for (K = 0; K < pe.length; K++)me = pe[K], me.form === fe.form && updateValueIfChanged(me) } break e; case "textarea": updateTextarea(fe, pe.value, pe.defaultValue); break e; case "select": K = pe.value, K != null && updateOptions(fe, !!pe.multiple, K, !1) } } } var isInsideEventHandler = !1; function batchedUpdates$1(fe, K, pe) { if (isInsideEventHandler) return fe(K, pe); isInsideEventHandler = !0; try { var me = fe(K); return me } finally { if (isInsideEventHandler = !1, (restoreTarget !== null || restoreQueue !== null) && (flushSyncWork$1(), restoreTarget && (K = restoreTarget, fe = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(K), fe))) for (K = 0; K < fe.length; K++)restoreStateOfTarget(fe[K]) } } function getListener(fe, K) { var pe = fe.stateNode; if (pe === null) return null; var me = pe[internalPropsKey] || null; if (me === null) return null; pe = me[K]; e: switch (K) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (me = !me.disabled) || (fe = fe.type, me = !(fe === "button" || fe === "input" || fe === "select" || fe === "textarea")), fe = !me; break e; default: fe = !1 }if (fe) return null; if (pe && typeof pe != "function") throw Error(formatProdErrorMessage(231, K, typeof pe)); return pe } var passiveBrowserEventsSupported = !1; if (canUseDOM) try { var options$1 = {}; Object.defineProperty(options$1, "passive", { get: function () { passiveBrowserEventsSupported = !0 } }), window.addEventListener("test", options$1, options$1), window.removeEventListener("test", options$1, options$1) } catch { passiveBrowserEventsSupported = !1 } var root$3 = null, startText = null, fallbackText = null; function getData() { if (fallbackText) return fallbackText; var fe, K = startText, pe = K.length, me, ge = "value" in root$3 ? root$3.value : root$3.textContent, xe = ge.length; for (fe = 0; fe < pe && K[fe] === ge[fe]; fe++); var ye = pe - fe; for (me = 1; me <= ye && K[pe - me] === ge[xe - me]; me++); return fallbackText = ge.slice(fe, 1 < me ? 1 - me : void 0) } function getEventCharCode(fe) { var K = fe.keyCode; return "charCode" in fe ? (fe = fe.charCode, fe === 0 && K === 13 && (fe = 13)) : fe = K, fe === 10 && (fe = 13), 32 <= fe || fe === 13 ? fe : 0 } function functionThatReturnsTrue() { return !0 } function functionThatReturnsFalse() { return !1 } function createSyntheticEvent(fe) { function K(pe, me, ge, xe, ye) { this._reactName = pe, this._targetInst = ge, this.type = me, this.nativeEvent = xe, this.target = ye, this.currentTarget = null; for (var ve in fe) fe.hasOwnProperty(ve) && (pe = fe[ve], this[ve] = pe ? pe(xe) : xe[ve]); return this.isDefaultPrevented = (xe.defaultPrevented != null ? xe.defaultPrevented : xe.returnValue === !1) ? functionThatReturnsTrue : functionThatReturnsFalse, this.isPropagationStopped = functionThatReturnsFalse, this } return assign$1(K.prototype, { preventDefault: function () { this.defaultPrevented = !0; var pe = this.nativeEvent; pe && (pe.preventDefault ? pe.preventDefault() : typeof pe.returnValue != "unknown" && (pe.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue) }, stopPropagation: function () { var pe = this.nativeEvent; pe && (pe.stopPropagation ? pe.stopPropagation() : typeof pe.cancelBubble != "unknown" && (pe.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue) }, persist: function () { }, isPersistent: functionThatReturnsTrue }), K } var EventInterface = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (fe) { return fe.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign$1({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign$1({}, UIEventInterface, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: getEventModifierState, button: 0, buttons: 0, relatedTarget: function (fe) { return fe.relatedTarget === void 0 ? fe.fromElement === fe.srcElement ? fe.toElement : fe.fromElement : fe.relatedTarget }, movementX: function (fe) { return "movementX" in fe ? fe.movementX : (fe !== lastMouseEvent && (lastMouseEvent && fe.type === "mousemove" ? (lastMovementX = fe.screenX - lastMouseEvent.screenX, lastMovementY = fe.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = fe), lastMovementX) }, movementY: function (fe) { return "movementY" in fe ? fe.movementY : lastMovementY } }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign$1({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign$1({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign$1({}, EventInterface, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign$1({}, EventInterface, { clipboardData: function (fe) { return "clipboardData" in fe ? fe.clipboardData : window.clipboardData } }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign$1({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, translateToKey = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, modifierKeyToProp = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function modifierStateGetter(fe) { var K = this.nativeEvent; return K.getModifierState ? K.getModifierState(fe) : (fe = modifierKeyToProp[fe]) ? !!K[fe] : !1 } function getEventModifierState() { return modifierStateGetter } var KeyboardEventInterface = assign$1({}, UIEventInterface, { key: function (fe) { if (fe.key) { var K = normalizeKey[fe.key] || fe.key; if (K !== "Unidentified") return K } return fe.type === "keypress" ? (fe = getEventCharCode(fe), fe === 13 ? "Enter" : String.fromCharCode(fe)) : fe.type === "keydown" || fe.type === "keyup" ? translateToKey[fe.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: getEventModifierState, charCode: function (fe) { return fe.type === "keypress" ? getEventCharCode(fe) : 0 }, keyCode: function (fe) { return fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0 }, which: function (fe) { return fe.type === "keypress" ? getEventCharCode(fe) : fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0 } }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign$1({}, MouseEventInterface, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign$1({}, UIEventInterface, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: getEventModifierState }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign$1({}, EventInterface, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign$1({}, MouseEventInterface, { deltaX: function (fe) { return "deltaX" in fe ? fe.deltaX : "wheelDeltaX" in fe ? -fe.wheelDeltaX : 0 }, deltaY: function (fe) { return "deltaY" in fe ? fe.deltaY : "wheelDeltaY" in fe ? -fe.wheelDeltaY : "wheelDelta" in fe ? -fe.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign$1({}, EventInterface, { newState: 0, oldState: 0 }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null; canUseDOM && "documentMode" in document && (documentMode = document.documentMode); var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = " ", hasSpaceKeypress = !1; function isFallbackCompositionEnd(fe, K) { switch (fe) { case "keyup": return END_KEYCODES.indexOf(K.keyCode) !== -1; case "keydown": return K.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function getDataFromCustomEvent(fe) { return fe = fe.detail, typeof fe == "object" && "data" in fe ? fe.data : null } var isComposing = !1; function getNativeBeforeInputChars(fe, K) { switch (fe) { case "compositionend": return getDataFromCustomEvent(K); case "keypress": return K.which !== 32 ? null : (hasSpaceKeypress = !0, SPACEBAR_CHAR); case "textInput": return fe = K.data, fe === SPACEBAR_CHAR && hasSpaceKeypress ? null : fe; default: return null } } function getFallbackBeforeInputChars(fe, K) { if (isComposing) return fe === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(fe, K) ? (fe = getData(), fallbackText = startText = root$3 = null, isComposing = !1, fe) : null; switch (fe) { case "paste": return null; case "keypress": if (!(K.ctrlKey || K.altKey || K.metaKey) || K.ctrlKey && K.altKey) { if (K.char && 1 < K.char.length) return K.char; if (K.which) return String.fromCharCode(K.which) } return null; case "compositionend": return useFallbackCompositionData && K.locale !== "ko" ? null : K.data; default: return null } } var supportedInputTypes = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function isTextInputElement(fe) { var K = fe && fe.nodeName && fe.nodeName.toLowerCase(); return K === "input" ? !!supportedInputTypes[fe.type] : K === "textarea" } function createAndAccumulateChangeEvent(fe, K, pe, me) { restoreTarget ? restoreQueue ? restoreQueue.push(me) : restoreQueue = [me] : restoreTarget = me, K = accumulateTwoPhaseListeners(K, "onChange"), 0 < K.length && (pe = new SyntheticEvent("onChange", "change", null, pe, me), fe.push({ event: pe, listeners: K })) } var activeElement$1 = null, activeElementInst$1 = null; function runEventInBatch(fe) { processDispatchQueue(fe, 0) } function getInstIfValueChanged(fe) { var K = getNodeFromInstance(fe); if (updateValueIfChanged(K)) return fe } function getTargetInstForChangeEvent(fe, K) { if (fe === "change") return K } var isInputEventSupported = !1; if (canUseDOM) { var JSCompiler_inline_result$jscomp$283; if (canUseDOM) { var isSupported$jscomp$inline_418 = "oninput" in document; if (!isSupported$jscomp$inline_418) { var element$jscomp$inline_419 = document.createElement("div"); element$jscomp$inline_419.setAttribute("oninput", "return;"), isSupported$jscomp$inline_418 = typeof element$jscomp$inline_419.oninput == "function" } JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418 } else JSCompiler_inline_result$jscomp$283 = !1; isInputEventSupported = JSCompiler_inline_result$jscomp$283 && (!document.documentMode || 9 < document.documentMode) } function stopWatchingForValueChange() { activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null) } function handlePropertyChange(fe) { if (fe.propertyName === "value" && getInstIfValueChanged(activeElementInst$1)) { var K = []; createAndAccumulateChangeEvent(K, activeElementInst$1, fe, getEventTarget(fe)), batchedUpdates$1(runEventInBatch, K) } } function handleEventsForInputEventPolyfill(fe, K, pe) { fe === "focusin" ? (stopWatchingForValueChange(), activeElement$1 = K, activeElementInst$1 = pe, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : fe === "focusout" && stopWatchingForValueChange() } function getTargetInstForInputEventPolyfill(fe) { if (fe === "selectionchange" || fe === "keyup" || fe === "keydown") return getInstIfValueChanged(activeElementInst$1) } function getTargetInstForClickEvent(fe, K) { if (fe === "click") return getInstIfValueChanged(K) } function getTargetInstForInputOrChangeEvent(fe, K) { if (fe === "input" || fe === "change") return getInstIfValueChanged(K) } function is$4(fe, K) { return fe === K && (fe !== 0 || 1 / fe === 1 / K) || fe !== fe && K !== K } var objectIs$2 = typeof Object.is == "function" ? Object.is : is$4; function shallowEqual(fe, K) { if (objectIs$2(fe, K)) return !0; if (typeof fe != "object" || fe === null || typeof K != "object" || K === null) return !1; var pe = Object.keys(fe), me = Object.keys(K); if (pe.length !== me.length) return !1; for (me = 0; me < pe.length; me++) { var ge = pe[me]; if (!hasOwnProperty$1.call(K, ge) || !objectIs$2(fe[ge], K[ge])) return !1 } return !0 } function getLeafNode(fe) { for (; fe && fe.firstChild;)fe = fe.firstChild; return fe } function getNodeForCharacterOffset(fe, K) { var pe = getLeafNode(fe); fe = 0; for (var me; pe;) { if (pe.nodeType === 3) { if (me = fe + pe.textContent.length, fe <= K && me >= K) return { node: pe, offset: K - fe }; fe = me } e: { for (; pe;) { if (pe.nextSibling) { pe = pe.nextSibling; break e } pe = pe.parentNode } pe = void 0 } pe = getLeafNode(pe) } } function containsNode(fe, K) { return fe && K ? fe === K ? !0 : fe && fe.nodeType === 3 ? !1 : K && K.nodeType === 3 ? containsNode(fe, K.parentNode) : "contains" in fe ? fe.contains(K) : fe.compareDocumentPosition ? !!(fe.compareDocumentPosition(K) & 16) : !1 : !1 } function getActiveElementDeep(fe) { fe = fe != null && fe.ownerDocument != null && fe.ownerDocument.defaultView != null ? fe.ownerDocument.defaultView : window; for (var K = getActiveElement(fe.document); K instanceof fe.HTMLIFrameElement;) { try { var pe = typeof K.contentWindow.location.href == "string" } catch { pe = !1 } if (pe) fe = K.contentWindow; else break; K = getActiveElement(fe.document) } return K } function hasSelectionCapabilities(fe) { var K = fe && fe.nodeName && fe.nodeName.toLowerCase(); return K && (K === "input" && (fe.type === "text" || fe.type === "search" || fe.type === "tel" || fe.type === "url" || fe.type === "password") || K === "textarea" || fe.contentEditable === "true") } function restoreSelection(fe, K) { var pe = getActiveElementDeep(K); K = fe.focusedElem; var me = fe.selectionRange; if (pe !== K && K && K.ownerDocument && containsNode(K.ownerDocument.documentElement, K)) { if (me !== null && hasSelectionCapabilities(K)) { if (fe = me.start, pe = me.end, pe === void 0 && (pe = fe), "selectionStart" in K) K.selectionStart = fe, K.selectionEnd = Math.min(pe, K.value.length); else if (pe = (fe = K.ownerDocument || document) && fe.defaultView || window, pe.getSelection) { pe = pe.getSelection(); var ge = K.textContent.length, xe = Math.min(me.start, ge); me = me.end === void 0 ? xe : Math.min(me.end, ge), !pe.extend && xe > me && (ge = me, me = xe, xe = ge), ge = getNodeForCharacterOffset(K, xe); var ye = getNodeForCharacterOffset(K, me); ge && ye && (pe.rangeCount !== 1 || pe.anchorNode !== ge.node || pe.anchorOffset !== ge.offset || pe.focusNode !== ye.node || pe.focusOffset !== ye.offset) && (fe = fe.createRange(), fe.setStart(ge.node, ge.offset), pe.removeAllRanges(), xe > me ? (pe.addRange(fe), pe.extend(ye.node, ye.offset)) : (fe.setEnd(ye.node, ye.offset), pe.addRange(fe))) } } for (fe = [], pe = K; pe = pe.parentNode;)pe.nodeType === 1 && fe.push({ element: pe, left: pe.scrollLeft, top: pe.scrollTop }); for (typeof K.focus == "function" && K.focus(), K = 0; K < fe.length; K++)pe = fe[K], pe.element.scrollLeft = pe.left, pe.element.scrollTop = pe.top } } var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement$2 = null, activeElementInst = null, lastSelection = null, mouseDown = !1; function constructSelectEvent(fe, K, pe) { var me = pe.window === pe ? pe.document : pe.nodeType === 9 ? pe : pe.ownerDocument; mouseDown || activeElement$2 == null || activeElement$2 !== getActiveElement(me) || (me = activeElement$2, "selectionStart" in me && hasSelectionCapabilities(me) ? me = { start: me.selectionStart, end: me.selectionEnd } : (me = (me.ownerDocument && me.ownerDocument.defaultView || window).getSelection(), me = { anchorNode: me.anchorNode, anchorOffset: me.anchorOffset, focusNode: me.focusNode, focusOffset: me.focusOffset }), lastSelection && shallowEqual(lastSelection, me) || (lastSelection = me, me = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < me.length && (K = new SyntheticEvent("onSelect", "select", null, K, pe), fe.push({ event: K, listeners: me }), K.target = activeElement$2))) } function makePrefixMap(fe, K) { var pe = {}; return pe[fe.toLowerCase()] = K.toLowerCase(), pe["Webkit" + fe] = "webkit" + K, pe["Moz" + fe] = "moz" + K, pe } var vendorPrefixes = { animationend: makePrefixMap("Animation", "AnimationEnd"), animationiteration: makePrefixMap("Animation", "AnimationIteration"), animationstart: makePrefixMap("Animation", "AnimationStart"), transitionrun: makePrefixMap("Transition", "TransitionRun"), transitionstart: makePrefixMap("Transition", "TransitionStart"), transitioncancel: makePrefixMap("Transition", "TransitionCancel"), transitionend: makePrefixMap("Transition", "TransitionEnd") }, prefixedEventNames = {}, style = {}; canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition); function getVendorPrefixedEventName(fe) { if (prefixedEventNames[fe]) return prefixedEventNames[fe]; if (!vendorPrefixes[fe]) return fe; var K = vendorPrefixes[fe], pe; for (pe in K) if (K.hasOwnProperty(pe) && pe in style) return prefixedEventNames[fe] = K[pe]; return fe } var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map, simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" "); function registerSimpleEvent(fe, K) { topLevelEventsToReactNames.set(fe, K), registerTwoPhaseEvent(K, [fe]) } var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0; function finishQueueingConcurrentUpdates() { for (var fe = concurrentQueuesIndex, K = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; K < fe;) { var pe = concurrentQueues[K]; concurrentQueues[K++] = null; var me = concurrentQueues[K]; concurrentQueues[K++] = null; var ge = concurrentQueues[K]; concurrentQueues[K++] = null; var xe = concurrentQueues[K]; if (concurrentQueues[K++] = null, me !== null && ge !== null) { var ye = me.pending; ye === null ? ge.next = ge : (ge.next = ye.next, ye.next = ge), me.pending = ge } xe !== 0 && markUpdateLaneFromFiberToRoot(pe, ge, xe) } } function enqueueUpdate$1(fe, K, pe, me) { concurrentQueues[concurrentQueuesIndex++] = fe, concurrentQueues[concurrentQueuesIndex++] = K, concurrentQueues[concurrentQueuesIndex++] = pe, concurrentQueues[concurrentQueuesIndex++] = me, concurrentlyUpdatedLanes |= me, fe.lanes |= me, fe = fe.alternate, fe !== null && (fe.lanes |= me) } function enqueueConcurrentHookUpdate(fe, K, pe, me) { return enqueueUpdate$1(fe, K, pe, me), getRootForUpdatedFiber(fe) } function enqueueConcurrentRenderForLane(fe, K) { return enqueueUpdate$1(fe, null, null, K), getRootForUpdatedFiber(fe) } function markUpdateLaneFromFiberToRoot(fe, K, pe) { fe.lanes |= pe; var me = fe.alternate; me !== null && (me.lanes |= pe); for (var ge = !1, xe = fe.return; xe !== null;)xe.childLanes |= pe, me = xe.alternate, me !== null && (me.childLanes |= pe), xe.tag === 22 && (fe = xe.stateNode, fe === null || fe._visibility & 1 || (ge = !0)), fe = xe, xe = xe.return; ge && K !== null && fe.tag === 3 && (xe = fe.stateNode, ge = 31 - clz32(pe), xe = xe.hiddenUpdates, fe = xe[ge], fe === null ? xe[ge] = [K] : fe.push(K), K.lane = pe | 536870912) } function getRootForUpdatedFiber(fe) { if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185)); for (var K = fe.return; K !== null;)fe = K, K = fe.return; return fe.tag === 3 ? fe.stateNode : null } var emptyContextObject = {}, CapturedStacks = new WeakMap; function createCapturedValueAtFiber(fe, K) { if (typeof fe == "object" && fe !== null) { var pe = CapturedStacks.get(fe); return pe !== void 0 ? pe : (K = { value: fe, source: K, stack: getStackByFiberInDevAndProd(K) }, CapturedStacks.set(fe, K), K) } return { value: fe, source: K, stack: getStackByFiberInDevAndProd(K) } } var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = ""; function pushTreeFork(fe, K) { forkStack[forkStackIndex++] = treeForkCount, forkStack[forkStackIndex++] = treeForkProvider, treeForkProvider = fe, treeForkCount = K } function pushTreeId(fe, K, pe) { idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextProvider = fe; var me = treeContextId; fe = treeContextOverflow; var ge = 32 - clz32(me) - 1; me &= ~(1 << ge), pe += 1; var xe = 32 - clz32(K) + ge; if (30 < xe) { var ye = ge - ge % 5; xe = (me & (1 << ye) - 1).toString(32), me >>= ye, ge -= ye, treeContextId = 1 << 32 - clz32(K) + ge | pe << ge | me, treeContextOverflow = xe + fe } else treeContextId = 1 << xe | pe << ge | me, treeContextOverflow = fe } function pushMaterializedTreeId(fe) { fe.return !== null && (pushTreeFork(fe, 1), pushTreeId(fe, 1, 0)) } function popTreeContext(fe) { for (; fe === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null; for (; fe === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null } var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(formatProdErrorMessage(519)); function throwOnHydrationMismatch(fe) { var K = Error(formatProdErrorMessage(418, "")); throw queueHydrationError(createCapturedValueAtFiber(K, fe)), HydrationMismatchException } function prepareToHydrateHostInstance(fe) { var K = fe.stateNode, pe = fe.type, me = fe.memoizedProps; switch (K[internalInstanceKey] = fe, K[internalPropsKey] = me, pe) { case "dialog": listenToNonDelegatedEvent("cancel", K), listenToNonDelegatedEvent("close", K); break; case "iframe": case "object": case "embed": listenToNonDelegatedEvent("load", K); break; case "video": case "audio": for (pe = 0; pe < mediaEventTypes.length; pe++)listenToNonDelegatedEvent(mediaEventTypes[pe], K); break; case "source": listenToNonDelegatedEvent("error", K); break; case "img": case "image": case "link": listenToNonDelegatedEvent("error", K), listenToNonDelegatedEvent("load", K); break; case "details": listenToNonDelegatedEvent("toggle", K); break; case "input": listenToNonDelegatedEvent("invalid", K), initInput(K, me.value, me.defaultValue, me.checked, me.defaultChecked, me.type, me.name, !0), track(K); break; case "select": listenToNonDelegatedEvent("invalid", K); break; case "textarea": listenToNonDelegatedEvent("invalid", K), initTextarea(K, me.value, me.defaultValue, me.children), track(K) }pe = me.children, typeof pe != "string" && typeof pe != "number" && typeof pe != "bigint" || K.textContent === "" + pe || me.suppressHydrationWarning === !0 || checkForUnmatchedText(K.textContent, pe) ? (me.popover != null && (listenToNonDelegatedEvent("beforetoggle", K), listenToNonDelegatedEvent("toggle", K)), me.onScroll != null && listenToNonDelegatedEvent("scroll", K), me.onScrollEnd != null && listenToNonDelegatedEvent("scrollend", K), me.onClick != null && (K.onclick = noop$1$1), K = !0) : K = !1, K || throwOnHydrationMismatch(fe) } function popToNextHostParent(fe) { for (hydrationParentFiber = fe.return; hydrationParentFiber;)switch (hydrationParentFiber.tag) { case 3: case 27: rootOrSingletonContext = !0; return; case 5: case 13: rootOrSingletonContext = !1; return; default: hydrationParentFiber = hydrationParentFiber.return } } function popHydrationState(fe) { if (fe !== hydrationParentFiber) return !1; if (!isHydrating) return popToNextHostParent(fe), isHydrating = !0, !1; var K = !1, pe; if ((pe = fe.tag !== 3 && fe.tag !== 27) && ((pe = fe.tag === 5) && (pe = fe.type, pe = !(pe !== "form" && pe !== "button") || shouldSetTextContent(fe.type, fe.memoizedProps)), pe = !pe), pe && (K = !0), K && nextHydratableInstance && throwOnHydrationMismatch(fe), popToNextHostParent(fe), fe.tag === 13) { if (fe = fe.memoizedState, fe = fe !== null ? fe.dehydrated : null, !fe) throw Error(formatProdErrorMessage(317)); e: { for (fe = fe.nextSibling, K = 0; fe;) { if (fe.nodeType === 8) if (pe = fe.data, pe === "/$") { if (K === 0) { nextHydratableInstance = getNextHydratable(fe.nextSibling); break e } K-- } else pe !== "$" && pe !== "$!" && pe !== "$?" || K++; fe = fe.nextSibling } nextHydratableInstance = null } } else nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fe.stateNode.nextSibling) : null; return !0 } function resetHydrationState() { nextHydratableInstance = hydrationParentFiber = null, isHydrating = !1 } function queueHydrationError(fe) { hydrationErrors === null ? hydrationErrors = [fe] : hydrationErrors.push(fe) } var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), noopSuspenseyCommitThenable = { then: function () { } }; function isThenableResolved(fe) { return fe = fe.status, fe === "fulfilled" || fe === "rejected" } function noop$3$1() { } function trackUsedThenable(fe, K, pe) { switch (pe = fe[pe], pe === void 0 ? fe.push(K) : pe !== K && (K.then(noop$3$1, noop$3$1), K = pe), K.status) { case "fulfilled": return K.value; case "rejected": throw fe = K.reason, fe === SuspenseException ? Error(formatProdErrorMessage(483)) : fe; default: if (typeof K.status == "string") K.then(noop$3$1, noop$3$1); else { if (fe = workInProgressRoot, fe !== null && 100 < fe.shellSuspendCounter) throw Error(formatProdErrorMessage(482)); fe = K, fe.status = "pending", fe.then(function (me) { if (K.status === "pending") { var ge = K; ge.status = "fulfilled", ge.value = me } }, function (me) { if (K.status === "pending") { var ge = K; ge.status = "rejected", ge.reason = me } }) } switch (K.status) { case "fulfilled": return K.value; case "rejected": throw fe = K.reason, fe === SuspenseException ? Error(formatProdErrorMessage(483)) : fe }throw suspendedThenable = K, SuspenseException } } var suspendedThenable = null; function getSuspendedThenable() { if (suspendedThenable === null) throw Error(formatProdErrorMessage(459)); var fe = suspendedThenable; return suspendedThenable = null, fe } var thenableState$1 = null, thenableIndexCounter$1 = 0; function unwrapThenable(fe) { var K = thenableIndexCounter$1; return thenableIndexCounter$1 += 1, thenableState$1 === null && (thenableState$1 = []), trackUsedThenable(thenableState$1, fe, K) } function coerceRef(fe, K) { K = K.props.ref, fe.ref = K !== void 0 ? K : null } function throwOnInvalidObjectType(fe, K) { throw K.$$typeof === REACT_LEGACY_ELEMENT_TYPE ? Error(formatProdErrorMessage(525)) : (fe = Object.prototype.toString.call(K), Error(formatProdErrorMessage(31, fe === "[object Object]" ? "object with keys {" + Object.keys(K).join(", ") + "}" : fe))) } function resolveLazy(fe) { var K = fe._init; return K(fe._payload) } function createChildReconciler(fe) { function K(Re, Ie) { if (fe) { var Pe = Re.deletions; Pe === null ? (Re.deletions = [Ie], Re.flags |= 16) : Pe.push(Ie) } } function pe(Re, Ie) { if (!fe) return null; for (; Ie !== null;)K(Re, Ie), Ie = Ie.sibling; return null } function me(Re) { for (var Ie = new Map; Re !== null;)Re.key !== null ? Ie.set(Re.key, Re) : Ie.set(Re.index, Re), Re = Re.sibling; return Ie } function ge(Re, Ie) { return Re = createWorkInProgress(Re, Ie), Re.index = 0, Re.sibling = null, Re } function xe(Re, Ie, Pe) { return Re.index = Pe, fe ? (Pe = Re.alternate, Pe !== null ? (Pe = Pe.index, Pe < Ie ? (Re.flags |= 33554434, Ie) : Pe) : (Re.flags |= 33554434, Ie)) : (Re.flags |= 1048576, Ie) } function ye(Re) { return fe && Re.alternate === null && (Re.flags |= 33554434), Re } function ve(Re, Ie, Pe, Ne) { return Ie === null || Ie.tag !== 6 ? (Ie = createFiberFromText(Pe, Re.mode, Ne), Ie.return = Re, Ie) : (Ie = ge(Ie, Pe), Ie.return = Re, Ie) } function _e(Re, Ie, Pe, Ne) { var ke = Pe.type; return ke === REACT_FRAGMENT_TYPE ? be(Re, Ie, Pe.props.children, Ne, Pe.key) : Ie !== null && (Ie.elementType === ke || typeof ke == "object" && ke !== null && ke.$$typeof === REACT_LAZY_TYPE && resolveLazy(ke) === Ie.type) ? (Ie = ge(Ie, Pe.props), coerceRef(Ie, Pe), Ie.return = Re, Ie) : (Ie = createFiberFromTypeAndProps(Pe.type, Pe.key, Pe.props, null, Re.mode, Ne), coerceRef(Ie, Pe), Ie.return = Re, Ie) } function Ee(Re, Ie, Pe, Ne) { return Ie === null || Ie.tag !== 4 || Ie.stateNode.containerInfo !== Pe.containerInfo || Ie.stateNode.implementation !== Pe.implementation ? (Ie = createFiberFromPortal(Pe, Re.mode, Ne), Ie.return = Re, Ie) : (Ie = ge(Ie, Pe.children || []), Ie.return = Re, Ie) } function be(Re, Ie, Pe, Ne, ke) { return Ie === null || Ie.tag !== 7 ? (Ie = createFiberFromFragment(Pe, Re.mode, Ne, ke), Ie.return = Re, Ie) : (Ie = ge(Ie, Pe), Ie.return = Re, Ie) } function Ae(Re, Ie, Pe) { if (typeof Ie == "string" && Ie !== "" || typeof Ie == "number" || typeof Ie == "bigint") return Ie = createFiberFromText("" + Ie, Re.mode, Pe), Ie.return = Re, Ie; if (typeof Ie == "object" && Ie !== null) { switch (Ie.$$typeof) { case REACT_ELEMENT_TYPE: return Pe = createFiberFromTypeAndProps(Ie.type, Ie.key, Ie.props, null, Re.mode, Pe), coerceRef(Pe, Ie), Pe.return = Re, Pe; case REACT_PORTAL_TYPE: return Ie = createFiberFromPortal(Ie, Re.mode, Pe), Ie.return = Re, Ie; case REACT_LAZY_TYPE: var Ne = Ie._init; return Ie = Ne(Ie._payload), Ae(Re, Ie, Pe) }if (isArrayImpl(Ie) || getIteratorFn(Ie)) return Ie = createFiberFromFragment(Ie, Re.mode, Pe, null), Ie.return = Re, Ie; if (typeof Ie.then == "function") return Ae(Re, unwrapThenable(Ie), Pe); if (Ie.$$typeof === REACT_CONTEXT_TYPE) return Ae(Re, readContextDuringReconciliation(Re, Ie), Pe); throwOnInvalidObjectType(Re, Ie) } return null } function Se(Re, Ie, Pe, Ne) { var ke = Ie !== null ? Ie.key : null; if (typeof Pe == "string" && Pe !== "" || typeof Pe == "number" || typeof Pe == "bigint") return ke !== null ? null : ve(Re, Ie, "" + Pe, Ne); if (typeof Pe == "object" && Pe !== null) { switch (Pe.$$typeof) { case REACT_ELEMENT_TYPE: return Pe.key === ke ? _e(Re, Ie, Pe, Ne) : null; case REACT_PORTAL_TYPE: return Pe.key === ke ? Ee(Re, Ie, Pe, Ne) : null; case REACT_LAZY_TYPE: return ke = Pe._init, Pe = ke(Pe._payload), Se(Re, Ie, Pe, Ne) }if (isArrayImpl(Pe) || getIteratorFn(Pe)) return ke !== null ? null : be(Re, Ie, Pe, Ne, null); if (typeof Pe.then == "function") return Se(Re, Ie, unwrapThenable(Pe), Ne); if (Pe.$$typeof === REACT_CONTEXT_TYPE) return Se(Re, Ie, readContextDuringReconciliation(Re, Pe), Ne); throwOnInvalidObjectType(Re, Pe) } return null } function Ce(Re, Ie, Pe, Ne, ke) { if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number" || typeof Ne == "bigint") return Re = Re.get(Pe) || null, ve(Ie, Re, "" + Ne, ke); if (typeof Ne == "object" && Ne !== null) { switch (Ne.$$typeof) { case REACT_ELEMENT_TYPE: return Re = Re.get(Ne.key === null ? Pe : Ne.key) || null, _e(Ie, Re, Ne, ke); case REACT_PORTAL_TYPE: return Re = Re.get(Ne.key === null ? Pe : Ne.key) || null, Ee(Ie, Re, Ne, ke); case REACT_LAZY_TYPE: var Oe = Ne._init; return Ne = Oe(Ne._payload), Ce(Re, Ie, Pe, Ne, ke) }if (isArrayImpl(Ne) || getIteratorFn(Ne)) return Re = Re.get(Pe) || null, be(Ie, Re, Ne, ke, null); if (typeof Ne.then == "function") return Ce(Re, Ie, Pe, unwrapThenable(Ne), ke); if (Ne.$$typeof === REACT_CONTEXT_TYPE) return Ce(Re, Ie, Pe, readContextDuringReconciliation(Ie, Ne), ke); throwOnInvalidObjectType(Ie, Ne) } return null } function we(Re, Ie, Pe, Ne) { for (var ke = null, Oe = null, Ue = Ie, He = Ie = 0, Ge = null; Ue !== null && He < Pe.length; He++) { Ue.index > He ? (Ge = Ue, Ue = null) : Ge = Ue.sibling; var ze = Se(Re, Ue, Pe[He], Ne); if (ze === null) { Ue === null && (Ue = Ge); break } fe && Ue && ze.alternate === null && K(Re, Ue), Ie = xe(ze, Ie, He), Oe === null ? ke = ze : Oe.sibling = ze, Oe = ze, Ue = Ge } if (He === Pe.length) return pe(Re, Ue), isHydrating && pushTreeFork(Re, He), ke; if (Ue === null) { for (; He < Pe.length; He++)Ue = Ae(Re, Pe[He], Ne), Ue !== null && (Ie = xe(Ue, Ie, He), Oe === null ? ke = Ue : Oe.sibling = Ue, Oe = Ue); return isHydrating && pushTreeFork(Re, He), ke } for (Ue = me(Ue); He < Pe.length; He++)Ge = Ce(Ue, Re, He, Pe[He], Ne), Ge !== null && (fe && Ge.alternate !== null && Ue.delete(Ge.key === null ? He : Ge.key), Ie = xe(Ge, Ie, He), Oe === null ? ke = Ge : Oe.sibling = Ge, Oe = Ge); return fe && Ue.forEach(function (We) { return K(Re, We) }), isHydrating && pushTreeFork(Re, He), ke } function Be(Re, Ie, Pe, Ne) { if (Pe == null) throw Error(formatProdErrorMessage(151)); for (var ke = null, Oe = null, Ue = Ie, He = Ie = 0, Ge = null, ze = Pe.next(); Ue !== null && !ze.done; He++, ze = Pe.next()) { Ue.index > He ? (Ge = Ue, Ue = null) : Ge = Ue.sibling; var We = Se(Re, Ue, ze.value, Ne); if (We === null) { Ue === null && (Ue = Ge); break } fe && Ue && We.alternate === null && K(Re, Ue), Ie = xe(We, Ie, He), Oe === null ? ke = We : Oe.sibling = We, Oe = We, Ue = Ge } if (ze.done) return pe(Re, Ue), isHydrating && pushTreeFork(Re, He), ke; if (Ue === null) { for (; !ze.done; He++, ze = Pe.next())ze = Ae(Re, ze.value, Ne), ze !== null && (Ie = xe(ze, Ie, He), Oe === null ? ke = ze : Oe.sibling = ze, Oe = ze); return isHydrating && pushTreeFork(Re, He), ke } for (Ue = me(Ue); !ze.done; He++, ze = Pe.next())ze = Ce(Ue, Re, He, ze.value, Ne), ze !== null && (fe && ze.alternate !== null && Ue.delete(ze.key === null ? He : ze.key), Ie = xe(ze, Ie, He), Oe === null ? ke = ze : Oe.sibling = ze, Oe = ze); return fe && Ue.forEach(function (Xe) { return K(Re, Xe) }), isHydrating && pushTreeFork(Re, He), ke } function De(Re, Ie, Pe, Ne) { if (typeof Pe == "object" && Pe !== null && Pe.type === REACT_FRAGMENT_TYPE && Pe.key === null && (Pe = Pe.props.children), typeof Pe == "object" && Pe !== null) { switch (Pe.$$typeof) { case REACT_ELEMENT_TYPE: e: { for (var ke = Pe.key; Ie !== null;) { if (Ie.key === ke) { if (ke = Pe.type, ke === REACT_FRAGMENT_TYPE) { if (Ie.tag === 7) { pe(Re, Ie.sibling), Ne = ge(Ie, Pe.props.children), Ne.return = Re, Re = Ne; break e } } else if (Ie.elementType === ke || typeof ke == "object" && ke !== null && ke.$$typeof === REACT_LAZY_TYPE && resolveLazy(ke) === Ie.type) { pe(Re, Ie.sibling), Ne = ge(Ie, Pe.props), coerceRef(Ne, Pe), Ne.return = Re, Re = Ne; break e } pe(Re, Ie); break } else K(Re, Ie); Ie = Ie.sibling } Pe.type === REACT_FRAGMENT_TYPE ? (Ne = createFiberFromFragment(Pe.props.children, Re.mode, Ne, Pe.key), Ne.return = Re, Re = Ne) : (Ne = createFiberFromTypeAndProps(Pe.type, Pe.key, Pe.props, null, Re.mode, Ne), coerceRef(Ne, Pe), Ne.return = Re, Re = Ne) } return ye(Re); case REACT_PORTAL_TYPE: e: { for (ke = Pe.key; Ie !== null;) { if (Ie.key === ke) if (Ie.tag === 4 && Ie.stateNode.containerInfo === Pe.containerInfo && Ie.stateNode.implementation === Pe.implementation) { pe(Re, Ie.sibling), Ne = ge(Ie, Pe.children || []), Ne.return = Re, Re = Ne; break e } else { pe(Re, Ie); break } else K(Re, Ie); Ie = Ie.sibling } Ne = createFiberFromPortal(Pe, Re.mode, Ne), Ne.return = Re, Re = Ne } return ye(Re); case REACT_LAZY_TYPE: return ke = Pe._init, Pe = ke(Pe._payload), De(Re, Ie, Pe, Ne) }if (isArrayImpl(Pe)) return we(Re, Ie, Pe, Ne); if (getIteratorFn(Pe)) { if (ke = getIteratorFn(Pe), typeof ke != "function") throw Error(formatProdErrorMessage(150)); return Pe = ke.call(Pe), Be(Re, Ie, Pe, Ne) } if (typeof Pe.then == "function") return De(Re, Ie, unwrapThenable(Pe), Ne); if (Pe.$$typeof === REACT_CONTEXT_TYPE) return De(Re, Ie, readContextDuringReconciliation(Re, Pe), Ne); throwOnInvalidObjectType(Re, Pe) } return typeof Pe == "string" && Pe !== "" || typeof Pe == "number" || typeof Pe == "bigint" ? (Pe = "" + Pe, Ie !== null && Ie.tag === 6 ? (pe(Re, Ie.sibling), Ne = ge(Ie, Pe), Ne.return = Re, Re = Ne) : (pe(Re, Ie), Ne = createFiberFromText(Pe, Re.mode, Ne), Ne.return = Re, Re = Ne), ye(Re)) : pe(Re, Ie) } return function (Re, Ie, Pe, Ne) { try { thenableIndexCounter$1 = 0; var ke = De(Re, Ie, Pe, Ne); return thenableState$1 = null, ke } catch (Ue) { if (Ue === SuspenseException) throw Ue; var Oe = createFiberImplClass(29, Ue, null, Re.mode); return Oe.lanes = Ne, Oe.return = Re, Oe } finally { } } } var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0); function pushHiddenContext(fe, K) { fe = entangledRenderLanes, push$1(prevEntangledRenderLanesCursor, fe), push$1(currentTreeHiddenStackCursor, K), entangledRenderLanes = fe | K.baseLanes } function reuseHiddenContextOnStack() { push$1(prevEntangledRenderLanesCursor, entangledRenderLanes), push$1(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current) } function popHiddenContext() { entangledRenderLanes = prevEntangledRenderLanesCursor.current, pop(currentTreeHiddenStackCursor), pop(prevEntangledRenderLanesCursor) } var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null; function pushPrimaryTreeSuspenseHandler(fe) { var K = fe.alternate; push$1(suspenseStackCursor, suspenseStackCursor.current & 1), push$1(suspenseHandlerStackCursor, fe), shellBoundary === null && (K === null || currentTreeHiddenStackCursor.current !== null || K.memoizedState !== null) && (shellBoundary = fe) } function pushOffscreenSuspenseHandler(fe) { if (fe.tag === 22) { if (push$1(suspenseStackCursor, suspenseStackCursor.current), push$1(suspenseHandlerStackCursor, fe), shellBoundary === null) { var K = fe.alternate; K !== null && K.memoizedState !== null && (shellBoundary = fe) } } else reuseSuspenseHandlerOnStack() } function reuseSuspenseHandlerOnStack() { push$1(suspenseStackCursor, suspenseStackCursor.current), push$1(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current) } function popSuspenseHandler(fe) { pop(suspenseHandlerStackCursor), shellBoundary === fe && (shellBoundary = null), pop(suspenseStackCursor) } var suspenseStackCursor = createCursor(0); function findFirstSuspended(fe) { for (var K = fe; K !== null;) { if (K.tag === 13) { var pe = K.memoizedState; if (pe !== null && (pe = pe.dehydrated, pe === null || pe.data === "$?" || pe.data === "$!")) return K } else if (K.tag === 19 && K.memoizedProps.revealOrder !== void 0) { if (K.flags & 128) return K } else if (K.child !== null) { K.child.return = K, K = K.child; continue } if (K === fe) break; for (; K.sibling === null;) { if (K.return === null || K.return === fe) return null; K = K.return } K.sibling.return = K.return, K = K.sibling } return null } var AbortControllerLocal = typeof AbortController < "u" ? AbortController : function () { var fe = [], K = this.signal = { aborted: !1, addEventListener: function (pe, me) { fe.push(me) } }; this.abort = function () { K.aborted = !0, fe.forEach(function (pe) { return pe() }) } }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = { $$typeof: REACT_CONTEXT_TYPE, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function createCache() { return { controller: new AbortControllerLocal, data: new Map, refCount: 0 } } function releaseCache(fe) { fe.refCount--, fe.refCount === 0 && scheduleCallback$2(NormalPriority, function () { fe.controller.abort() }) } var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null; function entangleAsyncAction(fe, K) { if (currentEntangledListeners === null) { var pe = currentEntangledListeners = []; currentEntangledPendingCount = 0, currentEntangledLane = requestTransitionLane(), currentEntangledActionThenable = { status: "pending", value: void 0, then: function (me) { pe.push(me) } } } return currentEntangledPendingCount++, K.then(pingEngtangledActionScope, pingEngtangledActionScope), K } function pingEngtangledActionScope() { if (--currentEntangledPendingCount === 0 && currentEntangledListeners !== null) { currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled"); var fe = currentEntangledListeners; currentEntangledListeners = null, currentEntangledLane = 0, currentEntangledActionThenable = null; for (var K = 0; K < fe.length; K++)(0, fe[K])() } } function chainThenableValue(fe, K) { var pe = [], me = { status: "pending", value: null, reason: null, then: function (ge) { pe.push(ge) } }; return fe.then(function () { me.status = "fulfilled", me.value = K; for (var ge = 0; ge < pe.length; ge++)(0, pe[ge])(K) }, function (ge) { for (me.status = "rejected", me.reason = ge, ge = 0; ge < pe.length; ge++)(0, pe[ge])(void 0) }), me } var prevOnStartTransitionFinish = ReactSharedInternals.S; ReactSharedInternals.S = function (fe, K) { typeof K == "object" && K !== null && typeof K.then == "function" && entangleAsyncAction(fe, K), prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(fe, K) }; var resumedCache = createCursor(null); function peekCacheFromPool() { var fe = resumedCache.current; return fe !== null ? fe : workInProgressRoot.pooledCache } function pushTransition(fe, K) { K === null ? push$1(resumedCache, resumedCache.current) : push$1(resumedCache, K.pool) } function getSuspendedCache() { var fe = peekCacheFromPool(); return fe === null ? null : { parent: CacheContext._currentValue, pool: fe } } var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0; function throwInvalidHookError() { throw Error(formatProdErrorMessage(321)) } function areHookInputsEqual(fe, K) { if (K === null) return !1; for (var pe = 0; pe < K.length && pe < fe.length; pe++)if (!objectIs$2(fe[pe], K[pe])) return !1; return !0 } function renderWithHooks(fe, K, pe, me, ge, xe) { return renderLanes = xe, currentlyRenderingFiber$1 = K, K.memoizedState = null, K.updateQueue = null, K.lanes = 0, ReactSharedInternals.H = fe === null || fe.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate, shouldDoubleInvokeUserFnsInHooksDEV = !1, xe = pe(me, ge), shouldDoubleInvokeUserFnsInHooksDEV = !1, didScheduleRenderPhaseUpdateDuringThisPass && (xe = renderWithHooksAgain(K, pe, me, ge)), finishRenderingHooks(fe), xe } function finishRenderingHooks(fe) { ReactSharedInternals.H = ContextOnlyDispatcher; var K = currentHook !== null && currentHook.next !== null; if (renderLanes = 0, workInProgressHook = currentHook = currentlyRenderingFiber$1 = null, didScheduleRenderPhaseUpdate = !1, thenableIndexCounter = 0, thenableState = null, K) throw Error(formatProdErrorMessage(300)); fe === null || didReceiveUpdate || (fe = fe.dependencies, fe !== null && checkIfContextChanged(fe) && (didReceiveUpdate = !0)) } function renderWithHooksAgain(fe, K, pe, me) { currentlyRenderingFiber$1 = fe; var ge = 0; do { if (didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null), thenableIndexCounter = 0, didScheduleRenderPhaseUpdateDuringThisPass = !1, 25 <= ge) throw Error(formatProdErrorMessage(301)); if (ge += 1, workInProgressHook = currentHook = null, fe.updateQueue != null) { var xe = fe.updateQueue; xe.lastEffect = null, xe.events = null, xe.stores = null, xe.memoCache != null && (xe.memoCache.index = 0) } ReactSharedInternals.H = HooksDispatcherOnRerender, xe = K(pe, me) } while (didScheduleRenderPhaseUpdateDuringThisPass); return xe } function TransitionAwareHostComponent() { var fe = ReactSharedInternals.H, K = fe.useState()[0]; return K = typeof K.then == "function" ? useThenable(K) : K, fe = fe.useState()[0], (currentHook !== null ? currentHook.memoizedState : null) !== fe && (currentlyRenderingFiber$1.flags |= 1024), K } function checkDidRenderIdHook() { var fe = localIdCounter !== 0; return localIdCounter = 0, fe } function bailoutHooks(fe, K, pe) { K.updateQueue = fe.updateQueue, K.flags &= -2053, fe.lanes &= ~pe } function resetHooksOnUnwind(fe) { if (didScheduleRenderPhaseUpdate) { for (fe = fe.memoizedState; fe !== null;) { var K = fe.queue; K !== null && (K.pending = null), fe = fe.next } didScheduleRenderPhaseUpdate = !1 } renderLanes = 0, workInProgressHook = currentHook = currentlyRenderingFiber$1 = null, didScheduleRenderPhaseUpdateDuringThisPass = !1, thenableIndexCounter = localIdCounter = 0, thenableState = null } function mountWorkInProgressHook() { var fe = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = fe : workInProgressHook = workInProgressHook.next = fe, workInProgressHook } function updateWorkInProgressHook() { if (currentHook === null) { var fe = currentlyRenderingFiber$1.alternate; fe = fe !== null ? fe.memoizedState : null } else fe = currentHook.next; var K = workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next; if (K !== null) workInProgressHook = K, currentHook = fe; else { if (fe === null) throw currentlyRenderingFiber$1.alternate === null ? Error(formatProdErrorMessage(467)) : Error(formatProdErrorMessage(310)); currentHook = fe, fe = { memoizedState: currentHook.memoizedState, baseState: currentHook.baseState, baseQueue: currentHook.baseQueue, queue: currentHook.queue, next: null }, workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = fe : workInProgressHook = workInProgressHook.next = fe } return workInProgressHook } var createFunctionComponentUpdateQueue; createFunctionComponentUpdateQueue = function () { return { lastEffect: null, events: null, stores: null, memoCache: null } }; function useThenable(fe) { var K = thenableIndexCounter; return thenableIndexCounter += 1, thenableState === null && (thenableState = []), fe = trackUsedThenable(thenableState, fe, K), K = currentlyRenderingFiber$1, (workInProgressHook === null ? K.memoizedState : workInProgressHook.next) === null && (K = K.alternate, ReactSharedInternals.H = K === null || K.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate), fe } function use(fe) { if (fe !== null && typeof fe == "object") { if (typeof fe.then == "function") return useThenable(fe); if (fe.$$typeof === REACT_CONTEXT_TYPE) return readContext(fe) } throw Error(formatProdErrorMessage(438, String(fe))) } function useMemoCache(fe) { var K = null, pe = currentlyRenderingFiber$1.updateQueue; if (pe !== null && (K = pe.memoCache), K == null) { var me = currentlyRenderingFiber$1.alternate; me !== null && (me = me.updateQueue, me !== null && (me = me.memoCache, me != null && (K = { data: me.data.map(function (ge) { return ge.slice() }), index: 0 }))) } if (K == null && (K = { data: [], index: 0 }), pe === null && (pe = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = pe), pe.memoCache = K, pe = K.data[K.index], pe === void 0) for (pe = K.data[K.index] = Array(fe), me = 0; me < fe; me++)pe[me] = REACT_MEMO_CACHE_SENTINEL; return K.index++, pe } function basicStateReducer(fe, K) { return typeof K == "function" ? K(fe) : K } function updateReducer(fe) { var K = updateWorkInProgressHook(); return updateReducerImpl(K, currentHook, fe) } function updateReducerImpl(fe, K, pe) { var me = fe.queue; if (me === null) throw Error(formatProdErrorMessage(311)); me.lastRenderedReducer = pe; var ge = fe.baseQueue, xe = me.pending; if (xe !== null) { if (ge !== null) { var ye = ge.next; ge.next = xe.next, xe.next = ye } K.baseQueue = ge = xe, me.pending = null } if (xe = fe.baseState, ge === null) fe.memoizedState = xe; else { K = ge.next; var ve = ye = null, _e = null, Ee = K, be = !1; do { var Ae = Ee.lane & -536870913; if (Ae !== Ee.lane ? (workInProgressRootRenderLanes & Ae) === Ae : (renderLanes & Ae) === Ae) { var Se = Ee.revertLane; if (Se === 0) _e !== null && (_e = _e.next = { lane: 0, revertLane: 0, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }), Ae === currentEntangledLane && (be = !0); else if ((renderLanes & Se) === Se) { Ee = Ee.next, Se === currentEntangledLane && (be = !0); continue } else Ae = { lane: 0, revertLane: Ee.revertLane, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }, _e === null ? (ve = _e = Ae, ye = xe) : _e = _e.next = Ae, currentlyRenderingFiber$1.lanes |= Se, workInProgressRootSkippedLanes |= Se; Ae = Ee.action, shouldDoubleInvokeUserFnsInHooksDEV && pe(xe, Ae), xe = Ee.hasEagerState ? Ee.eagerState : pe(xe, Ae) } else Se = { lane: Ae, revertLane: Ee.revertLane, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }, _e === null ? (ve = _e = Se, ye = xe) : _e = _e.next = Se, currentlyRenderingFiber$1.lanes |= Ae, workInProgressRootSkippedLanes |= Ae; Ee = Ee.next } while (Ee !== null && Ee !== K); if (_e === null ? ye = xe : _e.next = ve, !objectIs$2(xe, fe.memoizedState) && (didReceiveUpdate = !0, be && (pe = currentEntangledActionThenable, pe !== null))) throw pe; fe.memoizedState = xe, fe.baseState = ye, fe.baseQueue = _e, me.lastRenderedState = xe } return ge === null && (me.lanes = 0), [fe.memoizedState, me.dispatch] } function rerenderReducer(fe) { var K = updateWorkInProgressHook(), pe = K.queue; if (pe === null) throw Error(formatProdErrorMessage(311)); pe.lastRenderedReducer = fe; var me = pe.dispatch, ge = pe.pending, xe = K.memoizedState; if (ge !== null) { pe.pending = null; var ye = ge = ge.next; do xe = fe(xe, ye.action), ye = ye.next; while (ye !== ge); objectIs$2(xe, K.memoizedState) || (didReceiveUpdate = !0), K.memoizedState = xe, K.baseQueue === null && (K.baseState = xe), pe.lastRenderedState = xe } return [xe, me] } function updateSyncExternalStore(fe, K, pe) { var me = currentlyRenderingFiber$1, ge = updateWorkInProgressHook(), xe = isHydrating; if (xe) { if (pe === void 0) throw Error(formatProdErrorMessage(407)); pe = pe() } else pe = K(); var ye = !objectIs$2((currentHook || ge).memoizedState, pe); if (ye && (ge.memoizedState = pe, didReceiveUpdate = !0), ge = ge.queue, updateEffect(subscribeToStore.bind(null, me, ge, fe), [fe]), ge.getSnapshot !== K || ye || workInProgressHook !== null && workInProgressHook.memoizedState.tag & 1) { if (me.flags |= 2048, pushEffect(9, updateStoreInstance.bind(null, me, ge, pe, K), { destroy: void 0 }, null), workInProgressRoot === null) throw Error(formatProdErrorMessage(349)); xe || renderLanes & 60 || pushStoreConsistencyCheck(me, K, pe) } return pe } function pushStoreConsistencyCheck(fe, K, pe) { fe.flags |= 16384, fe = { getSnapshot: K, value: pe }, K = currentlyRenderingFiber$1.updateQueue, K === null ? (K = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = K, K.stores = [fe]) : (pe = K.stores, pe === null ? K.stores = [fe] : pe.push(fe)) } function updateStoreInstance(fe, K, pe, me) { K.value = pe, K.getSnapshot = me, checkIfSnapshotChanged$1(K) && forceStoreRerender(fe) } function subscribeToStore(fe, K, pe) { return pe(function () { checkIfSnapshotChanged$1(K) && forceStoreRerender(fe) }) } function checkIfSnapshotChanged$1(fe) { var K = fe.getSnapshot; fe = fe.value; try { var pe = K(); return !objectIs$2(fe, pe) } catch { return !0 } } function forceStoreRerender(fe) { var K = enqueueConcurrentRenderForLane(fe, 2); K !== null && scheduleUpdateOnFiber(K, fe, 2) } function mountStateImpl(fe) { var K = mountWorkInProgressHook(); if (typeof fe == "function") { var pe = fe; if (fe = pe(), shouldDoubleInvokeUserFnsInHooksDEV) { setIsStrictModeForDevtools(!0); try { pe() } finally { setIsStrictModeForDevtools(!1) } } } return K.memoizedState = K.baseState = fe, K.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: fe }, K } function updateOptimisticImpl(fe, K, pe, me) { return fe.baseState = pe, updateReducerImpl(fe, currentHook, typeof me == "function" ? me : basicStateReducer) } function dispatchActionState(fe, K, pe, me, ge) { if (isRenderPhaseUpdate(fe)) throw Error(formatProdErrorMessage(485)); if (fe = K.action, fe !== null) { var xe = { payload: ge, action: fe, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (ye) { xe.listeners.push(ye) } }; ReactSharedInternals.T !== null ? pe(!0) : xe.isTransition = !1, me(xe), pe = K.pending, pe === null ? (xe.next = K.pending = xe, runActionStateAction(K, xe)) : (xe.next = pe.next, K.pending = pe.next = xe) } } function runActionStateAction(fe, K) { var pe = K.action, me = K.payload, ge = fe.state; if (K.isTransition) { var xe = ReactSharedInternals.T, ye = {}; ReactSharedInternals.T = ye; try { var ve = pe(ge, me), _e = ReactSharedInternals.S; _e !== null && _e(ye, ve), handleActionReturnValue(fe, K, ve) } catch (Ee) { onActionError(fe, K, Ee) } finally { ReactSharedInternals.T = xe } } else try { xe = pe(ge, me), handleActionReturnValue(fe, K, xe) } catch (Ee) { onActionError(fe, K, Ee) } } function handleActionReturnValue(fe, K, pe) { pe !== null && typeof pe == "object" && typeof pe.then == "function" ? pe.then(function (me) { onActionSuccess(fe, K, me) }, function (me) { return onActionError(fe, K, me) }) : onActionSuccess(fe, K, pe) } function onActionSuccess(fe, K, pe) { K.status = "fulfilled", K.value = pe, notifyActionListeners(K), fe.state = pe, K = fe.pending, K !== null && (pe = K.next, pe === K ? fe.pending = null : (pe = pe.next, K.next = pe, runActionStateAction(fe, pe))) } function onActionError(fe, K, pe) { var me = fe.pending; if (fe.pending = null, me !== null) { me = me.next; do K.status = "rejected", K.reason = pe, notifyActionListeners(K), K = K.next; while (K !== me) } fe.action = null } function notifyActionListeners(fe) { fe = fe.listeners; for (var K = 0; K < fe.length; K++)(0, fe[K])() } function actionStateReducer(fe, K) { return K } function mountActionState(fe, K) { if (isHydrating) { var pe = workInProgressRoot.formState; if (pe !== null) { e: { var me = currentlyRenderingFiber$1; if (isHydrating) { if (nextHydratableInstance) { t: { for (var ge = nextHydratableInstance, xe = rootOrSingletonContext; ge.nodeType !== 8;) { if (!xe) { ge = null; break t } if (ge = getNextHydratable(ge.nextSibling), ge === null) { ge = null; break t } } xe = ge.data, ge = xe === "F!" || xe === "F" ? ge : null } if (ge) { nextHydratableInstance = getNextHydratable(ge.nextSibling), me = ge.data === "F!"; break e } } throwOnHydrationMismatch(me) } me = !1 } me && (K = pe[0]) } } return pe = mountWorkInProgressHook(), pe.memoizedState = pe.baseState = K, me = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: actionStateReducer, lastRenderedState: K }, pe.queue = me, pe = dispatchSetState.bind(null, currentlyRenderingFiber$1, me), me.dispatch = pe, me = mountStateImpl(!1), xe = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, me.queue), me = mountWorkInProgressHook(), ge = { state: K, dispatch: null, action: fe, pending: null }, me.queue = ge, pe = dispatchActionState.bind(null, currentlyRenderingFiber$1, ge, xe, pe), ge.dispatch = pe, me.memoizedState = fe, [K, pe, !1] } function updateActionState(fe) { var K = updateWorkInProgressHook(); return updateActionStateImpl(K, currentHook, fe) } function updateActionStateImpl(fe, K, pe) { K = updateReducerImpl(fe, K, actionStateReducer)[0], fe = updateReducer(basicStateReducer)[0], K = typeof K == "object" && K !== null && typeof K.then == "function" ? useThenable(K) : K; var me = updateWorkInProgressHook(), ge = me.queue, xe = ge.dispatch; return pe !== me.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(9, actionStateActionEffect.bind(null, ge, pe), { destroy: void 0 }, null)), [K, xe, fe] } function actionStateActionEffect(fe, K) { fe.action = K } function rerenderActionState(fe) { var K = updateWorkInProgressHook(), pe = currentHook; if (pe !== null) return updateActionStateImpl(K, pe, fe); updateWorkInProgressHook(), K = K.memoizedState, pe = updateWorkInProgressHook(); var me = pe.queue.dispatch; return pe.memoizedState = fe, [K, me, !1] } function pushEffect(fe, K, pe, me) { return fe = { tag: fe, create: K, inst: pe, deps: me, next: null }, K = currentlyRenderingFiber$1.updateQueue, K === null && (K = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = K), pe = K.lastEffect, pe === null ? K.lastEffect = fe.next = fe : (me = pe.next, pe.next = fe, fe.next = me, K.lastEffect = fe), fe } function updateRef$1() { return updateWorkInProgressHook().memoizedState } function mountEffectImpl(fe, K, pe, me) { var ge = mountWorkInProgressHook(); currentlyRenderingFiber$1.flags |= fe, ge.memoizedState = pushEffect(1 | K, pe, { destroy: void 0 }, me === void 0 ? null : me) } function updateEffectImpl(fe, K, pe, me) { var ge = updateWorkInProgressHook(); me = me === void 0 ? null : me; var xe = ge.memoizedState.inst; currentHook !== null && me !== null && areHookInputsEqual(me, currentHook.memoizedState.deps) ? ge.memoizedState = pushEffect(K, pe, xe, me) : (currentlyRenderingFiber$1.flags |= fe, ge.memoizedState = pushEffect(1 | K, pe, xe, me)) } function mountEffect(fe, K) { mountEffectImpl(8390656, 8, fe, K) } function updateEffect(fe, K) { updateEffectImpl(2048, 8, fe, K) } function updateInsertionEffect(fe, K) { return updateEffectImpl(4, 2, fe, K) } function updateLayoutEffect(fe, K) { return updateEffectImpl(4, 4, fe, K) } function imperativeHandleEffect(fe, K) { if (typeof K == "function") { fe = fe(); var pe = K(fe); return function () { typeof pe == "function" ? pe() : K(null) } } if (K != null) return fe = fe(), K.current = fe, function () { K.current = null } } function updateImperativeHandle(fe, K, pe) { pe = pe != null ? pe.concat([fe]) : null, updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, K, fe), pe) } function mountDebugValue() { } function updateCallback(fe, K) { var pe = updateWorkInProgressHook(); K = K === void 0 ? null : K; var me = pe.memoizedState; return K !== null && areHookInputsEqual(K, me[1]) ? me[0] : (pe.memoizedState = [fe, K], fe) } function updateMemo(fe, K) { var pe = updateWorkInProgressHook(); K = K === void 0 ? null : K; var me = pe.memoizedState; if (K !== null && areHookInputsEqual(K, me[1])) return me[0]; if (me = fe(), shouldDoubleInvokeUserFnsInHooksDEV) { setIsStrictModeForDevtools(!0); try { fe() } finally { setIsStrictModeForDevtools(!1) } } return pe.memoizedState = [me, K], me } function mountDeferredValueImpl(fe, K, pe) { return pe === void 0 || renderLanes & 1073741824 ? fe.memoizedState = K : (fe.memoizedState = pe, fe = requestDeferredLane(), currentlyRenderingFiber$1.lanes |= fe, workInProgressRootSkippedLanes |= fe, pe) } function updateDeferredValueImpl(fe, K, pe, me) { return objectIs$2(pe, K) ? pe : currentTreeHiddenStackCursor.current !== null ? (fe = mountDeferredValueImpl(fe, pe, me), objectIs$2(fe, K) || (didReceiveUpdate = !0), fe) : renderLanes & 42 ? (fe = requestDeferredLane(), currentlyRenderingFiber$1.lanes |= fe, workInProgressRootSkippedLanes |= fe, K) : (didReceiveUpdate = !0, fe.memoizedState = pe) } function startTransition(fe, K, pe, me, ge) { var xe = ReactDOMSharedInternals.p; ReactDOMSharedInternals.p = xe !== 0 && 8 > xe ? xe : 8; var ye = ReactSharedInternals.T, ve = {}; ReactSharedInternals.T = ve, dispatchOptimisticSetState(fe, !1, K, pe); try { var _e = ge(), Ee = ReactSharedInternals.S; if (Ee !== null && Ee(ve, _e), _e !== null && typeof _e == "object" && typeof _e.then == "function") { var be = chainThenableValue(_e, me); dispatchSetStateInternal(fe, K, be, requestUpdateLane(fe)) } else dispatchSetStateInternal(fe, K, me, requestUpdateLane(fe)) } catch (Ae) { dispatchSetStateInternal(fe, K, { then: function () { }, status: "rejected", reason: Ae }, requestUpdateLane()) } finally { ReactDOMSharedInternals.p = xe, ReactSharedInternals.T = ye } } function noop$2$1() { } function startHostTransition(fe, K, pe, me) { if (fe.tag !== 5) throw Error(formatProdErrorMessage(476)); var ge = ensureFormComponentIsStateful(fe).queue; startTransition(fe, ge, K, sharedNotPendingObject, pe === null ? noop$2$1 : function () { return requestFormReset$1(fe), pe(me) }) } function ensureFormComponentIsStateful(fe) { var K = fe.memoizedState; if (K !== null) return K; K = { memoizedState: sharedNotPendingObject, baseState: sharedNotPendingObject, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: sharedNotPendingObject }, next: null }; var pe = {}; return K.next = { memoizedState: pe, baseState: pe, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: pe }, next: null }, fe.memoizedState = K, fe = fe.alternate, fe !== null && (fe.memoizedState = K), K } function requestFormReset$1(fe) { var K = ensureFormComponentIsStateful(fe).next.queue; dispatchSetStateInternal(fe, K, {}, requestUpdateLane()) } function useHostTransitionStatus() { return readContext(HostTransitionContext) } function updateId() { return updateWorkInProgressHook().memoizedState } function updateRefresh() { return updateWorkInProgressHook().memoizedState } function refreshCache(fe) { for (var K = fe.return; K !== null;) { switch (K.tag) { case 24: case 3: var pe = requestUpdateLane(); fe = createUpdate(pe); var me = enqueueUpdate(K, fe, pe); me !== null && (scheduleUpdateOnFiber(me, K, pe), entangleTransitions(me, K, pe)), K = { cache: createCache() }, fe.payload = K; return }K = K.return } } function dispatchReducerAction(fe, K, pe) { var me = requestUpdateLane(); pe = { lane: me, revertLane: 0, action: pe, hasEagerState: !1, eagerState: null, next: null }, isRenderPhaseUpdate(fe) ? enqueueRenderPhaseUpdate(K, pe) : (pe = enqueueConcurrentHookUpdate(fe, K, pe, me), pe !== null && (scheduleUpdateOnFiber(pe, fe, me), entangleTransitionUpdate(pe, K, me))) } function dispatchSetState(fe, K, pe) { var me = requestUpdateLane(); dispatchSetStateInternal(fe, K, pe, me) } function dispatchSetStateInternal(fe, K, pe, me) { var ge = { lane: me, revertLane: 0, action: pe, hasEagerState: !1, eagerState: null, next: null }; if (isRenderPhaseUpdate(fe)) enqueueRenderPhaseUpdate(K, ge); else { var xe = fe.alternate; if (fe.lanes === 0 && (xe === null || xe.lanes === 0) && (xe = K.lastRenderedReducer, xe !== null)) try { var ye = K.lastRenderedState, ve = xe(ye, pe); if (ge.hasEagerState = !0, ge.eagerState = ve, objectIs$2(ve, ye)) return enqueueUpdate$1(fe, K, ge, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), !1 } catch { } finally { } if (pe = enqueueConcurrentHookUpdate(fe, K, ge, me), pe !== null) return scheduleUpdateOnFiber(pe, fe, me), entangleTransitionUpdate(pe, K, me), !0 } return !1 } function dispatchOptimisticSetState(fe, K, pe, me) { if (me = { lane: 2, revertLane: requestTransitionLane(), action: me, hasEagerState: !1, eagerState: null, next: null }, isRenderPhaseUpdate(fe)) { if (K) throw Error(formatProdErrorMessage(479)) } else K = enqueueConcurrentHookUpdate(fe, pe, me, 2), K !== null && scheduleUpdateOnFiber(K, fe, 2) } function isRenderPhaseUpdate(fe) { var K = fe.alternate; return fe === currentlyRenderingFiber$1 || K !== null && K === currentlyRenderingFiber$1 } function enqueueRenderPhaseUpdate(fe, K) { didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0; var pe = fe.pending; pe === null ? K.next = K : (K.next = pe.next, pe.next = K), fe.pending = K } function entangleTransitionUpdate(fe, K, pe) { if (pe & 4194176) { var me = K.lanes; me &= fe.pendingLanes, pe |= me, K.lanes = pe, markRootEntangled(fe, pe) } } var ContextOnlyDispatcher = { readContext, use, useCallback: throwInvalidHookError, useContext: throwInvalidHookError, useEffect: throwInvalidHookError, useImperativeHandle: throwInvalidHookError, useLayoutEffect: throwInvalidHookError, useInsertionEffect: throwInvalidHookError, useMemo: throwInvalidHookError, useReducer: throwInvalidHookError, useRef: throwInvalidHookError, useState: throwInvalidHookError, useDebugValue: throwInvalidHookError, useDeferredValue: throwInvalidHookError, useTransition: throwInvalidHookError, useSyncExternalStore: throwInvalidHookError, useId: throwInvalidHookError }; ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError; ContextOnlyDispatcher.useMemoCache = throwInvalidHookError; ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError; ContextOnlyDispatcher.useFormState = throwInvalidHookError; ContextOnlyDispatcher.useActionState = throwInvalidHookError; ContextOnlyDispatcher.useOptimistic = throwInvalidHookError; var HooksDispatcherOnMount = { readContext, use, useCallback: function (fe, K) { return mountWorkInProgressHook().memoizedState = [fe, K === void 0 ? null : K], fe }, useContext: readContext, useEffect: mountEffect, useImperativeHandle: function (fe, K, pe) { pe = pe != null ? pe.concat([fe]) : null, mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, K, fe), pe) }, useLayoutEffect: function (fe, K) { return mountEffectImpl(4194308, 4, fe, K) }, useInsertionEffect: function (fe, K) { mountEffectImpl(4, 2, fe, K) }, useMemo: function (fe, K) { var pe = mountWorkInProgressHook(); K = K === void 0 ? null : K; var me = fe(); if (shouldDoubleInvokeUserFnsInHooksDEV) { setIsStrictModeForDevtools(!0); try { fe() } finally { setIsStrictModeForDevtools(!1) } } return pe.memoizedState = [me, K], me }, useReducer: function (fe, K, pe) { var me = mountWorkInProgressHook(); if (pe !== void 0) { var ge = pe(K); if (shouldDoubleInvokeUserFnsInHooksDEV) { setIsStrictModeForDevtools(!0); try { pe(K) } finally { setIsStrictModeForDevtools(!1) } } } else ge = K; return me.memoizedState = me.baseState = ge, fe = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: fe, lastRenderedState: ge }, me.queue = fe, fe = fe.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, fe), [me.memoizedState, fe] }, useRef: function (fe) { var K = mountWorkInProgressHook(); return fe = { current: fe }, K.memoizedState = fe }, useState: function (fe) { fe = mountStateImpl(fe); var K = fe.queue, pe = dispatchSetState.bind(null, currentlyRenderingFiber$1, K); return K.dispatch = pe, [fe.memoizedState, pe] }, useDebugValue: mountDebugValue, useDeferredValue: function (fe, K) { var pe = mountWorkInProgressHook(); return mountDeferredValueImpl(pe, fe, K) }, useTransition: function () { var fe = mountStateImpl(!1); return fe = startTransition.bind(null, currentlyRenderingFiber$1, fe.queue, !0, !1), mountWorkInProgressHook().memoizedState = fe, [!1, fe] }, useSyncExternalStore: function (fe, K, pe) { var me = currentlyRenderingFiber$1, ge = mountWorkInProgressHook(); if (isHydrating) { if (pe === void 0) throw Error(formatProdErrorMessage(407)); pe = pe() } else { if (pe = K(), workInProgressRoot === null) throw Error(formatProdErrorMessage(349)); workInProgressRootRenderLanes & 60 || pushStoreConsistencyCheck(me, K, pe) } ge.memoizedState = pe; var xe = { value: pe, getSnapshot: K }; return ge.queue = xe, mountEffect(subscribeToStore.bind(null, me, xe, fe), [fe]), me.flags |= 2048, pushEffect(9, updateStoreInstance.bind(null, me, xe, pe, K), { destroy: void 0 }, null), pe }, useId: function () { var fe = mountWorkInProgressHook(), K = workInProgressRoot.identifierPrefix; if (isHydrating) { var pe = treeContextOverflow, me = treeContextId; pe = (me & ~(1 << 32 - clz32(me) - 1)).toString(32) + pe, K = ":" + K + "R" + pe, pe = localIdCounter++, 0 < pe && (K += "H" + pe.toString(32)), K += ":" } else pe = globalClientIdCounter++, K = ":" + K + "r" + pe.toString(32) + ":"; return fe.memoizedState = K }, useCacheRefresh: function () { return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1) } }; HooksDispatcherOnMount.useMemoCache = useMemoCache; HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus; HooksDispatcherOnMount.useFormState = mountActionState; HooksDispatcherOnMount.useActionState = mountActionState; HooksDispatcherOnMount.useOptimistic = function (fe) { var K = mountWorkInProgressHook(); K.memoizedState = K.baseState = fe; var pe = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return K.queue = pe, K = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, pe), pe.dispatch = K, [fe, K] }; var HooksDispatcherOnUpdate = { readContext, use, useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useImperativeHandle: updateImperativeHandle, useInsertionEffect: updateInsertionEffect, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: updateReducer, useRef: updateRef$1, useState: function () { return updateReducer(basicStateReducer) }, useDebugValue: mountDebugValue, useDeferredValue: function (fe, K) { var pe = updateWorkInProgressHook(); return updateDeferredValueImpl(pe, currentHook.memoizedState, fe, K) }, useTransition: function () { var fe = updateReducer(basicStateReducer)[0], K = updateWorkInProgressHook().memoizedState; return [typeof fe == "boolean" ? fe : useThenable(fe), K] }, useSyncExternalStore: updateSyncExternalStore, useId: updateId }; HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh; HooksDispatcherOnUpdate.useMemoCache = useMemoCache; HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus; HooksDispatcherOnUpdate.useFormState = updateActionState; HooksDispatcherOnUpdate.useActionState = updateActionState; HooksDispatcherOnUpdate.useOptimistic = function (fe, K) { var pe = updateWorkInProgressHook(); return updateOptimisticImpl(pe, currentHook, fe, K) }; var HooksDispatcherOnRerender = { readContext, use, useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useImperativeHandle: updateImperativeHandle, useInsertionEffect: updateInsertionEffect, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: rerenderReducer, useRef: updateRef$1, useState: function () { return rerenderReducer(basicStateReducer) }, useDebugValue: mountDebugValue, useDeferredValue: function (fe, K) { var pe = updateWorkInProgressHook(); return currentHook === null ? mountDeferredValueImpl(pe, fe, K) : updateDeferredValueImpl(pe, currentHook.memoizedState, fe, K) }, useTransition: function () { var fe = rerenderReducer(basicStateReducer)[0], K = updateWorkInProgressHook().memoizedState; return [typeof fe == "boolean" ? fe : useThenable(fe), K] }, useSyncExternalStore: updateSyncExternalStore, useId: updateId }; HooksDispatcherOnRerender.useCacheRefresh = updateRefresh; HooksDispatcherOnRerender.useMemoCache = useMemoCache; HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus; HooksDispatcherOnRerender.useFormState = rerenderActionState; HooksDispatcherOnRerender.useActionState = rerenderActionState; HooksDispatcherOnRerender.useOptimistic = function (fe, K) { var pe = updateWorkInProgressHook(); return currentHook !== null ? updateOptimisticImpl(pe, currentHook, fe, K) : (pe.baseState = fe, [fe, pe.queue.dispatch]) }; function applyDerivedStateFromProps(fe, K, pe, me) { K = fe.memoizedState, pe = pe(me, K), pe = pe == null ? K : assign$1({}, K, pe), fe.memoizedState = pe, fe.lanes === 0 && (fe.updateQueue.baseState = pe) } var classComponentUpdater = { isMounted: function (fe) { return (fe = fe._reactInternals) ? getNearestMountedFiber(fe) === fe : !1 }, enqueueSetState: function (fe, K, pe) { fe = fe._reactInternals; var me = requestUpdateLane(), ge = createUpdate(me); ge.payload = K, pe != null && (ge.callback = pe), K = enqueueUpdate(fe, ge, me), K !== null && (scheduleUpdateOnFiber(K, fe, me), entangleTransitions(K, fe, me)) }, enqueueReplaceState: function (fe, K, pe) { fe = fe._reactInternals; var me = requestUpdateLane(), ge = createUpdate(me); ge.tag = 1, ge.payload = K, pe != null && (ge.callback = pe), K = enqueueUpdate(fe, ge, me), K !== null && (scheduleUpdateOnFiber(K, fe, me), entangleTransitions(K, fe, me)) }, enqueueForceUpdate: function (fe, K) { fe = fe._reactInternals; var pe = requestUpdateLane(), me = createUpdate(pe); me.tag = 2, K != null && (me.callback = K), K = enqueueUpdate(fe, me, pe), K !== null && (scheduleUpdateOnFiber(K, fe, pe), entangleTransitions(K, fe, pe)) } }; function checkShouldComponentUpdate(fe, K, pe, me, ge, xe, ye) { return fe = fe.stateNode, typeof fe.shouldComponentUpdate == "function" ? fe.shouldComponentUpdate(me, xe, ye) : K.prototype && K.prototype.isPureReactComponent ? !shallowEqual(pe, me) || !shallowEqual(ge, xe) : !0 } function callComponentWillReceiveProps(fe, K, pe, me) { fe = K.state, typeof K.componentWillReceiveProps == "function" && K.componentWillReceiveProps(pe, me), typeof K.UNSAFE_componentWillReceiveProps == "function" && K.UNSAFE_componentWillReceiveProps(pe, me), K.state !== fe && classComponentUpdater.enqueueReplaceState(K, K.state, null) } function resolveClassComponentProps(fe, K) { var pe = K; if ("ref" in K) { pe = {}; for (var me in K) me !== "ref" && (pe[me] = K[me]) } if (fe = fe.defaultProps) { pe === K && (pe = assign$1({}, pe)); for (var ge in fe) pe[ge] === void 0 && (pe[ge] = fe[ge]) } return pe } var reportGlobalError = typeof reportError == "function" ? reportError : function (fe) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var K = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof fe == "object" && fe !== null && typeof fe.message == "string" ? String(fe.message) : String(fe), error: fe }); if (!window.dispatchEvent(K)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", fe); return } console.error(fe) }; function defaultOnUncaughtError(fe) { reportGlobalError(fe) } function defaultOnCaughtError(fe) { console.error(fe) } function defaultOnRecoverableError(fe) { reportGlobalError(fe) } function logUncaughtError(fe, K) { try { var pe = fe.onUncaughtError; pe(K.value, { componentStack: K.stack }) } catch (me) { setTimeout(function () { throw me }) } } function logCaughtError(fe, K, pe) { try { var me = fe.onCaughtError; me(pe.value, { componentStack: pe.stack, errorBoundary: K.tag === 1 ? K.stateNode : null }) } catch (ge) { setTimeout(function () { throw ge }) } } function createRootErrorUpdate(fe, K, pe) { return pe = createUpdate(pe), pe.tag = 3, pe.payload = { element: null }, pe.callback = function () { logUncaughtError(fe, K) }, pe } function createClassErrorUpdate(fe) { return fe = createUpdate(fe), fe.tag = 3, fe } function initializeClassErrorUpdate(fe, K, pe, me) { var ge = pe.type.getDerivedStateFromError; if (typeof ge == "function") { var xe = me.value; fe.payload = function () { return ge(xe) }, fe.callback = function () { logCaughtError(K, pe, me) } } var ye = pe.stateNode; ye !== null && typeof ye.componentDidCatch == "function" && (fe.callback = function () { logCaughtError(K, pe, me), typeof ge != "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this)); var ve = me.stack; this.componentDidCatch(me.value, { componentStack: ve !== null ? ve : "" }) }) } function throwException(fe, K, pe, me, ge) { if (pe.flags |= 32768, me !== null && typeof me == "object" && typeof me.then == "function") { if (K = pe.alternate, K !== null && propagateParentContextChanges(K, pe, ge, !0), pe = suspenseHandlerStackCursor.current, pe !== null) { switch (pe.tag) { case 13: return shellBoundary === null ? renderDidSuspendDelayIfPossible() : pe.alternate === null && workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 3), pe.flags &= -257, pe.flags |= 65536, pe.lanes = ge, me === noopSuspenseyCommitThenable ? pe.flags |= 16384 : (K = pe.updateQueue, K === null ? pe.updateQueue = new Set([me]) : K.add(me), attachPingListener(fe, me, ge)), !1; case 22: return pe.flags |= 65536, me === noopSuspenseyCommitThenable ? pe.flags |= 16384 : (K = pe.updateQueue, K === null ? (K = { transitions: null, markerInstances: null, retryQueue: new Set([me]) }, pe.updateQueue = K) : (pe = K.retryQueue, pe === null ? K.retryQueue = new Set([me]) : pe.add(me)), attachPingListener(fe, me, ge)), !1 }throw Error(formatProdErrorMessage(435, pe.tag)) } return attachPingListener(fe, me, ge), renderDidSuspendDelayIfPossible(), !1 } if (isHydrating) return K = suspenseHandlerStackCursor.current, K !== null ? (!(K.flags & 65536) && (K.flags |= 256), K.flags |= 65536, K.lanes = ge, me !== HydrationMismatchException && (fe = Error(formatProdErrorMessage(422), { cause: me }), queueHydrationError(createCapturedValueAtFiber(fe, pe)))) : (me !== HydrationMismatchException && (K = Error(formatProdErrorMessage(423), { cause: me }), queueHydrationError(createCapturedValueAtFiber(K, pe))), fe = fe.current.alternate, fe.flags |= 65536, ge &= -ge, fe.lanes |= ge, me = createCapturedValueAtFiber(me, pe), ge = createRootErrorUpdate(fe.stateNode, me, ge), enqueueCapturedUpdate(fe, ge), workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2)), !1; var xe = Error(formatProdErrorMessage(520), { cause: me }); if (xe = createCapturedValueAtFiber(xe, pe), workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [xe] : workInProgressRootConcurrentErrors.push(xe), workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2), K === null) return !0; me = createCapturedValueAtFiber(me, pe), pe = K; do { switch (pe.tag) { case 3: return pe.flags |= 65536, fe = ge & -ge, pe.lanes |= fe, fe = createRootErrorUpdate(pe.stateNode, me, fe), enqueueCapturedUpdate(pe, fe), !1; case 1: if (K = pe.type, xe = pe.stateNode, (pe.flags & 128) === 0 && (typeof K.getDerivedStateFromError == "function" || xe !== null && typeof xe.componentDidCatch == "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(xe)))) return pe.flags |= 65536, ge &= -ge, pe.lanes |= ge, ge = createClassErrorUpdate(ge), initializeClassErrorUpdate(ge, fe, pe, me), enqueueCapturedUpdate(pe, ge), !1 }pe = pe.return } while (pe !== null); return !1 } var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = !1; function reconcileChildren(fe, K, pe, me) { K.child = fe === null ? mountChildFibers(K, null, pe, me) : reconcileChildFibers(K, fe.child, pe, me) } function updateForwardRef(fe, K, pe, me, ge) { pe = pe.render; var xe = K.ref; if ("ref" in me) { var ye = {}; for (var ve in me) ve !== "ref" && (ye[ve] = me[ve]) } else ye = me; return prepareToReadContext(K), me = renderWithHooks(fe, K, pe, ye, xe, ge), ve = checkDidRenderIdHook(), fe !== null && !didReceiveUpdate ? (bailoutHooks(fe, K, ge), bailoutOnAlreadyFinishedWork(fe, K, ge)) : (isHydrating && ve && pushMaterializedTreeId(K), K.flags |= 1, reconcileChildren(fe, K, me, ge), K.child) } function updateMemoComponent(fe, K, pe, me, ge) { if (fe === null) { var xe = pe.type; return typeof xe == "function" && !shouldConstruct(xe) && xe.defaultProps === void 0 && pe.compare === null ? (K.tag = 15, K.type = xe, updateSimpleMemoComponent(fe, K, xe, me, ge)) : (fe = createFiberFromTypeAndProps(pe.type, null, me, K, K.mode, ge), fe.ref = K.ref, fe.return = K, K.child = fe) } if (xe = fe.child, !checkScheduledUpdateOrContext(fe, ge)) { var ye = xe.memoizedProps; if (pe = pe.compare, pe = pe !== null ? pe : shallowEqual, pe(ye, me) && fe.ref === K.ref) return bailoutOnAlreadyFinishedWork(fe, K, ge) } return K.flags |= 1, fe = createWorkInProgress(xe, me), fe.ref = K.ref, fe.return = K, K.child = fe } function updateSimpleMemoComponent(fe, K, pe, me, ge) { if (fe !== null) { var xe = fe.memoizedProps; if (shallowEqual(xe, me) && fe.ref === K.ref) if (didReceiveUpdate = !1, K.pendingProps = me = xe, checkScheduledUpdateOrContext(fe, ge)) fe.flags & 131072 && (didReceiveUpdate = !0); else return K.lanes = fe.lanes, bailoutOnAlreadyFinishedWork(fe, K, ge) } return updateFunctionComponent(fe, K, pe, me, ge) } function updateOffscreenComponent(fe, K, pe) { var me = K.pendingProps, ge = me.children, xe = (K.stateNode._pendingVisibility & 2) !== 0, ye = fe !== null ? fe.memoizedState : null; if (markRef(fe, K), me.mode === "hidden" || xe) { if (K.flags & 128) { if (me = ye !== null ? ye.baseLanes | pe : pe, fe !== null) { for (ge = K.child = fe.child, xe = 0; ge !== null;)xe = xe | ge.lanes | ge.childLanes, ge = ge.sibling; K.childLanes = xe & ~me } else K.childLanes = 0, K.child = null; return deferHiddenOffscreenComponent(fe, K, me, pe) } if (pe & 536870912) K.memoizedState = { baseLanes: 0, cachePool: null }, fe !== null && pushTransition(K, ye !== null ? ye.cachePool : null), ye !== null ? pushHiddenContext(K, ye) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(K); else return K.lanes = K.childLanes = 536870912, deferHiddenOffscreenComponent(fe, K, ye !== null ? ye.baseLanes | pe : pe, pe) } else ye !== null ? (pushTransition(K, ye.cachePool), pushHiddenContext(K, ye), reuseSuspenseHandlerOnStack(), K.memoizedState = null) : (fe !== null && pushTransition(K, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack()); return reconcileChildren(fe, K, ge, pe), K.child } function deferHiddenOffscreenComponent(fe, K, pe, me) { var ge = peekCacheFromPool(); return ge = ge === null ? null : { parent: CacheContext._currentValue, pool: ge }, K.memoizedState = { baseLanes: pe, cachePool: ge }, fe !== null && pushTransition(K, null), reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(K), fe !== null && propagateParentContextChanges(fe, K, me, !0), null } function markRef(fe, K) { var pe = K.ref; if (pe === null) fe !== null && fe.ref !== null && (K.flags |= 2097664); else { if (typeof pe != "function" && typeof pe != "object") throw Error(formatProdErrorMessage(284)); (fe === null || fe.ref !== pe) && (K.flags |= 2097664) } } function updateFunctionComponent(fe, K, pe, me, ge) { return prepareToReadContext(K), pe = renderWithHooks(fe, K, pe, me, void 0, ge), me = checkDidRenderIdHook(), fe !== null && !didReceiveUpdate ? (bailoutHooks(fe, K, ge), bailoutOnAlreadyFinishedWork(fe, K, ge)) : (isHydrating && me && pushMaterializedTreeId(K), K.flags |= 1, reconcileChildren(fe, K, pe, ge), K.child) } function replayFunctionComponent(fe, K, pe, me, ge, xe) { return prepareToReadContext(K), K.updateQueue = null, pe = renderWithHooksAgain(K, me, pe, ge), finishRenderingHooks(fe), me = checkDidRenderIdHook(), fe !== null && !didReceiveUpdate ? (bailoutHooks(fe, K, xe), bailoutOnAlreadyFinishedWork(fe, K, xe)) : (isHydrating && me && pushMaterializedTreeId(K), K.flags |= 1, reconcileChildren(fe, K, pe, xe), K.child) } function updateClassComponent(fe, K, pe, me, ge) { if (prepareToReadContext(K), K.stateNode === null) { var xe = emptyContextObject, ye = pe.contextType; typeof ye == "object" && ye !== null && (xe = readContext(ye)), xe = new pe(me, xe), K.memoizedState = xe.state !== null && xe.state !== void 0 ? xe.state : null, xe.updater = classComponentUpdater, K.stateNode = xe, xe._reactInternals = K, xe = K.stateNode, xe.props = me, xe.state = K.memoizedState, xe.refs = {}, initializeUpdateQueue(K), ye = pe.contextType, xe.context = typeof ye == "object" && ye !== null ? readContext(ye) : emptyContextObject, xe.state = K.memoizedState, ye = pe.getDerivedStateFromProps, typeof ye == "function" && (applyDerivedStateFromProps(K, pe, ye, me), xe.state = K.memoizedState), typeof pe.getDerivedStateFromProps == "function" || typeof xe.getSnapshotBeforeUpdate == "function" || typeof xe.UNSAFE_componentWillMount != "function" && typeof xe.componentWillMount != "function" || (ye = xe.state, typeof xe.componentWillMount == "function" && xe.componentWillMount(), typeof xe.UNSAFE_componentWillMount == "function" && xe.UNSAFE_componentWillMount(), ye !== xe.state && classComponentUpdater.enqueueReplaceState(xe, xe.state, null), processUpdateQueue(K, me, xe, ge), suspendIfUpdateReadFromEntangledAsyncAction(), xe.state = K.memoizedState), typeof xe.componentDidMount == "function" && (K.flags |= 4194308), me = !0 } else if (fe === null) { xe = K.stateNode; var ve = K.memoizedProps, _e = resolveClassComponentProps(pe, ve); xe.props = _e; var Ee = xe.context, be = pe.contextType; ye = emptyContextObject, typeof be == "object" && be !== null && (ye = readContext(be)); var Ae = pe.getDerivedStateFromProps; be = typeof Ae == "function" || typeof xe.getSnapshotBeforeUpdate == "function", ve = K.pendingProps !== ve, be || typeof xe.UNSAFE_componentWillReceiveProps != "function" && typeof xe.componentWillReceiveProps != "function" || (ve || Ee !== ye) && callComponentWillReceiveProps(K, xe, me, ye), hasForceUpdate = !1; var Se = K.memoizedState; xe.state = Se, processUpdateQueue(K, me, xe, ge), suspendIfUpdateReadFromEntangledAsyncAction(), Ee = K.memoizedState, ve || Se !== Ee || hasForceUpdate ? (typeof Ae == "function" && (applyDerivedStateFromProps(K, pe, Ae, me), Ee = K.memoizedState), (_e = hasForceUpdate || checkShouldComponentUpdate(K, pe, _e, me, Se, Ee, ye)) ? (be || typeof xe.UNSAFE_componentWillMount != "function" && typeof xe.componentWillMount != "function" || (typeof xe.componentWillMount == "function" && xe.componentWillMount(), typeof xe.UNSAFE_componentWillMount == "function" && xe.UNSAFE_componentWillMount()), typeof xe.componentDidMount == "function" && (K.flags |= 4194308)) : (typeof xe.componentDidMount == "function" && (K.flags |= 4194308), K.memoizedProps = me, K.memoizedState = Ee), xe.props = me, xe.state = Ee, xe.context = ye, me = _e) : (typeof xe.componentDidMount == "function" && (K.flags |= 4194308), me = !1) } else { xe = K.stateNode, cloneUpdateQueue(fe, K), ye = K.memoizedProps, be = resolveClassComponentProps(pe, ye), xe.props = be, Ae = K.pendingProps, Se = xe.context, Ee = pe.contextType, _e = emptyContextObject, typeof Ee == "object" && Ee !== null && (_e = readContext(Ee)), ve = pe.getDerivedStateFromProps, (Ee = typeof ve == "function" || typeof xe.getSnapshotBeforeUpdate == "function") || typeof xe.UNSAFE_componentWillReceiveProps != "function" && typeof xe.componentWillReceiveProps != "function" || (ye !== Ae || Se !== _e) && callComponentWillReceiveProps(K, xe, me, _e), hasForceUpdate = !1, Se = K.memoizedState, xe.state = Se, processUpdateQueue(K, me, xe, ge), suspendIfUpdateReadFromEntangledAsyncAction(); var Ce = K.memoizedState; ye !== Ae || Se !== Ce || hasForceUpdate || fe !== null && fe.dependencies !== null && checkIfContextChanged(fe.dependencies) ? (typeof ve == "function" && (applyDerivedStateFromProps(K, pe, ve, me), Ce = K.memoizedState), (be = hasForceUpdate || checkShouldComponentUpdate(K, pe, be, me, Se, Ce, _e) || fe !== null && fe.dependencies !== null && checkIfContextChanged(fe.dependencies)) ? (Ee || typeof xe.UNSAFE_componentWillUpdate != "function" && typeof xe.componentWillUpdate != "function" || (typeof xe.componentWillUpdate == "function" && xe.componentWillUpdate(me, Ce, _e), typeof xe.UNSAFE_componentWillUpdate == "function" && xe.UNSAFE_componentWillUpdate(me, Ce, _e)), typeof xe.componentDidUpdate == "function" && (K.flags |= 4), typeof xe.getSnapshotBeforeUpdate == "function" && (K.flags |= 1024)) : (typeof xe.componentDidUpdate != "function" || ye === fe.memoizedProps && Se === fe.memoizedState || (K.flags |= 4), typeof xe.getSnapshotBeforeUpdate != "function" || ye === fe.memoizedProps && Se === fe.memoizedState || (K.flags |= 1024), K.memoizedProps = me, K.memoizedState = Ce), xe.props = me, xe.state = Ce, xe.context = _e, me = be) : (typeof xe.componentDidUpdate != "function" || ye === fe.memoizedProps && Se === fe.memoizedState || (K.flags |= 4), typeof xe.getSnapshotBeforeUpdate != "function" || ye === fe.memoizedProps && Se === fe.memoizedState || (K.flags |= 1024), me = !1) } return xe = me, markRef(fe, K), me = (K.flags & 128) !== 0, xe || me ? (xe = K.stateNode, pe = me && typeof pe.getDerivedStateFromError != "function" ? null : xe.render(), K.flags |= 1, fe !== null && me ? (K.child = reconcileChildFibers(K, fe.child, null, ge), K.child = reconcileChildFibers(K, null, pe, ge)) : reconcileChildren(fe, K, pe, ge), K.memoizedState = xe.state, fe = K.child) : fe = bailoutOnAlreadyFinishedWork(fe, K, ge), fe } function mountHostRootWithoutHydrating(fe, K, pe, me) { return resetHydrationState(), K.flags |= 256, reconcileChildren(fe, K, pe, me), K.child } var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 }; function mountSuspenseOffscreenState(fe) { return { baseLanes: fe, cachePool: getSuspendedCache() } } function getRemainingWorkInPrimaryTree(fe, K, pe) { return fe = fe !== null ? fe.childLanes & ~pe : 0, K && (fe |= workInProgressDeferredLane), fe } function updateSuspenseComponent(fe, K, pe) { var me = K.pendingProps, ge = !1, xe = (K.flags & 128) !== 0, ye; if ((ye = xe) || (ye = fe !== null && fe.memoizedState === null ? !1 : (suspenseStackCursor.current & 2) !== 0), ye && (ge = !0, K.flags &= -129), ye = (K.flags & 32) !== 0, K.flags &= -33, fe === null) { if (isHydrating) { if (ge ? pushPrimaryTreeSuspenseHandler(K) : reuseSuspenseHandlerOnStack(), isHydrating) { var ve = nextHydratableInstance, _e; if (_e = ve) { e: { for (_e = ve, ve = rootOrSingletonContext; _e.nodeType !== 8;) { if (!ve) { ve = null; break e } if (_e = getNextHydratable(_e.nextSibling), _e === null) { ve = null; break e } } ve = _e } ve !== null ? (K.memoizedState = { dehydrated: ve, treeContext: treeContextProvider !== null ? { id: treeContextId, overflow: treeContextOverflow } : null, retryLane: 536870912 }, _e = createFiberImplClass(18, null, null, 0), _e.stateNode = ve, _e.return = K, K.child = _e, hydrationParentFiber = K, nextHydratableInstance = null, _e = !0) : _e = !1 } _e || throwOnHydrationMismatch(K) } if (ve = K.memoizedState, ve !== null && (ve = ve.dehydrated, ve !== null)) return ve.data === "$!" ? K.lanes = 16 : K.lanes = 536870912, null; popSuspenseHandler(K) } return ve = me.children, me = me.fallback, ge ? (reuseSuspenseHandlerOnStack(), ge = K.mode, ve = mountWorkInProgressOffscreenFiber({ mode: "hidden", children: ve }, ge), me = createFiberFromFragment(me, ge, pe, null), ve.return = K, me.return = K, ve.sibling = me, K.child = ve, ge = K.child, ge.memoizedState = mountSuspenseOffscreenState(pe), ge.childLanes = getRemainingWorkInPrimaryTree(fe, ye, pe), K.memoizedState = SUSPENDED_MARKER, me) : (pushPrimaryTreeSuspenseHandler(K), mountSuspensePrimaryChildren(K, ve)) } if (_e = fe.memoizedState, _e !== null && (ve = _e.dehydrated, ve !== null)) { if (xe) K.flags & 256 ? (pushPrimaryTreeSuspenseHandler(K), K.flags &= -257, K = retrySuspenseComponentWithoutHydrating(fe, K, pe)) : K.memoizedState !== null ? (reuseSuspenseHandlerOnStack(), K.child = fe.child, K.flags |= 128, K = null) : (reuseSuspenseHandlerOnStack(), ge = me.fallback, ve = K.mode, me = mountWorkInProgressOffscreenFiber({ mode: "visible", children: me.children }, ve), ge = createFiberFromFragment(ge, ve, pe, null), ge.flags |= 2, me.return = K, ge.return = K, me.sibling = ge, K.child = me, reconcileChildFibers(K, fe.child, null, pe), me = K.child, me.memoizedState = mountSuspenseOffscreenState(pe), me.childLanes = getRemainingWorkInPrimaryTree(fe, ye, pe), K.memoizedState = SUSPENDED_MARKER, K = ge); else if (pushPrimaryTreeSuspenseHandler(K), ve.data === "$!") { if (ye = ve.nextSibling && ve.nextSibling.dataset, ye) var Ee = ye.dgst; ye = Ee, me = Error(formatProdErrorMessage(419)), me.stack = "", me.digest = ye, queueHydrationError({ value: me, source: null, stack: null }), K = retrySuspenseComponentWithoutHydrating(fe, K, pe) } else if (didReceiveUpdate || propagateParentContextChanges(fe, K, pe, !1), ye = (pe & fe.childLanes) !== 0, didReceiveUpdate || ye) { if (ye = workInProgressRoot, ye !== null) { if (me = pe & -pe, me & 42) me = 1; else switch (me) { case 2: me = 1; break; case 8: me = 4; break; case 32: me = 16; break; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: me = 64; break; case 268435456: me = 134217728; break; default: me = 0 }if (me = me & (ye.suspendedLanes | pe) ? 0 : me, me !== 0 && me !== _e.retryLane) throw _e.retryLane = me, enqueueConcurrentRenderForLane(fe, me), scheduleUpdateOnFiber(ye, fe, me), SelectiveHydrationException } ve.data === "$?" || renderDidSuspendDelayIfPossible(), K = retrySuspenseComponentWithoutHydrating(fe, K, pe) } else ve.data === "$?" ? (K.flags |= 128, K.child = fe.child, K = retryDehydratedSuspenseBoundary.bind(null, fe), ve._reactRetry = K, K = null) : (fe = _e.treeContext, nextHydratableInstance = getNextHydratable(ve.nextSibling), hydrationParentFiber = K, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !1, fe !== null && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = fe.id, treeContextOverflow = fe.overflow, treeContextProvider = K), K = mountSuspensePrimaryChildren(K, me.children), K.flags |= 4096); return K } return ge ? (reuseSuspenseHandlerOnStack(), ge = me.fallback, ve = K.mode, _e = fe.child, Ee = _e.sibling, me = createWorkInProgress(_e, { mode: "hidden", children: me.children }), me.subtreeFlags = _e.subtreeFlags & 31457280, Ee !== null ? ge = createWorkInProgress(Ee, ge) : (ge = createFiberFromFragment(ge, ve, pe, null), ge.flags |= 2), ge.return = K, me.return = K, me.sibling = ge, K.child = me, me = ge, ge = K.child, ve = fe.child.memoizedState, ve === null ? ve = mountSuspenseOffscreenState(pe) : (_e = ve.cachePool, _e !== null ? (Ee = CacheContext._currentValue, _e = _e.parent !== Ee ? { parent: Ee, pool: Ee } : _e) : _e = getSuspendedCache(), ve = { baseLanes: ve.baseLanes | pe, cachePool: _e }), ge.memoizedState = ve, ge.childLanes = getRemainingWorkInPrimaryTree(fe, ye, pe), K.memoizedState = SUSPENDED_MARKER, me) : (pushPrimaryTreeSuspenseHandler(K), pe = fe.child, fe = pe.sibling, pe = createWorkInProgress(pe, { mode: "visible", children: me.children }), pe.return = K, pe.sibling = null, fe !== null && (ye = K.deletions, ye === null ? (K.deletions = [fe], K.flags |= 16) : ye.push(fe)), K.child = pe, K.memoizedState = null, pe) } function mountSuspensePrimaryChildren(fe, K) { return K = mountWorkInProgressOffscreenFiber({ mode: "visible", children: K }, fe.mode), K.return = fe, fe.child = K } function mountWorkInProgressOffscreenFiber(fe, K) { return createFiberFromOffscreen(fe, K, 0, null) } function retrySuspenseComponentWithoutHydrating(fe, K, pe) { return reconcileChildFibers(K, fe.child, null, pe), fe = mountSuspensePrimaryChildren(K, K.pendingProps.children), fe.flags |= 2, K.memoizedState = null, fe } function scheduleSuspenseWorkOnFiber(fe, K, pe) { fe.lanes |= K; var me = fe.alternate; me !== null && (me.lanes |= K), scheduleContextWorkOnParentPath(fe.return, K, pe) } function initSuspenseListRenderState(fe, K, pe, me, ge) { var xe = fe.memoizedState; xe === null ? fe.memoizedState = { isBackwards: K, rendering: null, renderingStartTime: 0, last: me, tail: pe, tailMode: ge } : (xe.isBackwards = K, xe.rendering = null, xe.renderingStartTime = 0, xe.last = me, xe.tail = pe, xe.tailMode = ge) } function updateSuspenseListComponent(fe, K, pe) { var me = K.pendingProps, ge = me.revealOrder, xe = me.tail; if (reconcileChildren(fe, K, me.children, pe), me = suspenseStackCursor.current, me & 2) me = me & 1 | 2, K.flags |= 128; else { if (fe !== null && fe.flags & 128) e: for (fe = K.child; fe !== null;) { if (fe.tag === 13) fe.memoizedState !== null && scheduleSuspenseWorkOnFiber(fe, pe, K); else if (fe.tag === 19) scheduleSuspenseWorkOnFiber(fe, pe, K); else if (fe.child !== null) { fe.child.return = fe, fe = fe.child; continue } if (fe === K) break e; for (; fe.sibling === null;) { if (fe.return === null || fe.return === K) break e; fe = fe.return } fe.sibling.return = fe.return, fe = fe.sibling } me &= 1 } switch (push$1(suspenseStackCursor, me), ge) { case "forwards": for (pe = K.child, ge = null; pe !== null;)fe = pe.alternate, fe !== null && findFirstSuspended(fe) === null && (ge = pe), pe = pe.sibling; pe = ge, pe === null ? (ge = K.child, K.child = null) : (ge = pe.sibling, pe.sibling = null), initSuspenseListRenderState(K, !1, ge, pe, xe); break; case "backwards": for (pe = null, ge = K.child, K.child = null; ge !== null;) { if (fe = ge.alternate, fe !== null && findFirstSuspended(fe) === null) { K.child = ge; break } fe = ge.sibling, ge.sibling = pe, pe = ge, ge = fe } initSuspenseListRenderState(K, !0, pe, null, xe); break; case "together": initSuspenseListRenderState(K, !1, null, null, void 0); break; default: K.memoizedState = null }return K.child } function bailoutOnAlreadyFinishedWork(fe, K, pe) { if (fe !== null && (K.dependencies = fe.dependencies), workInProgressRootSkippedLanes |= K.lanes, !(pe & K.childLanes)) if (fe !== null) { if (propagateParentContextChanges(fe, K, pe, !1), (pe & K.childLanes) === 0) return null } else return null; if (fe !== null && K.child !== fe.child) throw Error(formatProdErrorMessage(153)); if (K.child !== null) { for (fe = K.child, pe = createWorkInProgress(fe, fe.pendingProps), K.child = pe, pe.return = K; fe.sibling !== null;)fe = fe.sibling, pe = pe.sibling = createWorkInProgress(fe, fe.pendingProps), pe.return = K; pe.sibling = null } return K.child } function checkScheduledUpdateOrContext(fe, K) { return fe.lanes & K ? !0 : (fe = fe.dependencies, !!(fe !== null && checkIfContextChanged(fe))) } function attemptEarlyBailoutIfNoScheduledUpdate(fe, K, pe) { switch (K.tag) { case 3: pushHostContainer(K, K.stateNode.containerInfo), pushProvider(K, CacheContext, fe.memoizedState.cache), resetHydrationState(); break; case 27: case 5: pushHostContext(K); break; case 4: pushHostContainer(K, K.stateNode.containerInfo); break; case 10: pushProvider(K, K.type, K.memoizedProps.value); break; case 13: var me = K.memoizedState; if (me !== null) return me.dehydrated !== null ? (pushPrimaryTreeSuspenseHandler(K), K.flags |= 128, null) : pe & K.child.childLanes ? updateSuspenseComponent(fe, K, pe) : (pushPrimaryTreeSuspenseHandler(K), fe = bailoutOnAlreadyFinishedWork(fe, K, pe), fe !== null ? fe.sibling : null); pushPrimaryTreeSuspenseHandler(K); break; case 19: var ge = (fe.flags & 128) !== 0; if (me = (pe & K.childLanes) !== 0, me || (propagateParentContextChanges(fe, K, pe, !1), me = (pe & K.childLanes) !== 0), ge) { if (me) return updateSuspenseListComponent(fe, K, pe); K.flags |= 128 } if (ge = K.memoizedState, ge !== null && (ge.rendering = null, ge.tail = null, ge.lastEffect = null), push$1(suspenseStackCursor, suspenseStackCursor.current), me) break; return null; case 22: case 23: return K.lanes = 0, updateOffscreenComponent(fe, K, pe); case 24: pushProvider(K, CacheContext, fe.memoizedState.cache) }return bailoutOnAlreadyFinishedWork(fe, K, pe) } function beginWork(fe, K, pe) { if (fe !== null) if (fe.memoizedProps !== K.pendingProps) didReceiveUpdate = !0; else { if (!checkScheduledUpdateOrContext(fe, pe) && !(K.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(fe, K, pe); didReceiveUpdate = !!(fe.flags & 131072) } else didReceiveUpdate = !1, isHydrating && K.flags & 1048576 && pushTreeId(K, treeForkCount, K.index); switch (K.lanes = 0, K.tag) { case 16: e: { fe = K.pendingProps; var me = K.elementType, ge = me._init; if (me = ge(me._payload), K.type = me, typeof me == "function") shouldConstruct(me) ? (fe = resolveClassComponentProps(me, fe), K.tag = 1, K = updateClassComponent(null, K, me, fe, pe)) : (K.tag = 0, K = updateFunctionComponent(null, K, me, fe, pe)); else { if (me != null) { if (ge = me.$$typeof, ge === REACT_FORWARD_REF_TYPE) { K.tag = 11, K = updateForwardRef(null, K, me, fe, pe); break e } else if (ge === REACT_MEMO_TYPE) { K.tag = 14, K = updateMemoComponent(null, K, me, fe, pe); break e } } throw K = getComponentNameFromType(me) || me, Error(formatProdErrorMessage(306, K, "")) } } return K; case 0: return updateFunctionComponent(fe, K, K.type, K.pendingProps, pe); case 1: return me = K.type, ge = resolveClassComponentProps(me, K.pendingProps), updateClassComponent(fe, K, me, ge, pe); case 3: e: { if (pushHostContainer(K, K.stateNode.containerInfo), fe === null) throw Error(formatProdErrorMessage(387)); var xe = K.pendingProps; ge = K.memoizedState, me = ge.element, cloneUpdateQueue(fe, K), processUpdateQueue(K, xe, null, pe); var ye = K.memoizedState; if (xe = ye.cache, pushProvider(K, CacheContext, xe), xe !== ge.cache && propagateContextChanges(K, [CacheContext], pe, !0), suspendIfUpdateReadFromEntangledAsyncAction(), xe = ye.element, ge.isDehydrated) if (ge = { element: xe, isDehydrated: !1, cache: ye.cache }, K.updateQueue.baseState = ge, K.memoizedState = ge, K.flags & 256) { K = mountHostRootWithoutHydrating(fe, K, xe, pe); break e } else if (xe !== me) { me = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), K), queueHydrationError(me), K = mountHostRootWithoutHydrating(fe, K, xe, pe); break e } else for (nextHydratableInstance = getNextHydratable(K.stateNode.containerInfo.firstChild), hydrationParentFiber = K, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !0, pe = mountChildFibers(K, null, xe, pe), K.child = pe; pe;)pe.flags = pe.flags & -3 | 4096, pe = pe.sibling; else { if (resetHydrationState(), xe === me) { K = bailoutOnAlreadyFinishedWork(fe, K, pe); break e } reconcileChildren(fe, K, xe, pe) } K = K.child } return K; case 26: return markRef(fe, K), fe === null ? (pe = getResource(K.type, null, K.pendingProps, null)) ? K.memoizedState = pe : isHydrating || (pe = K.type, fe = K.pendingProps, me = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(pe), me[internalInstanceKey] = K, me[internalPropsKey] = fe, setInitialProperties(me, pe, fe), markNodeAsHoistable(me), K.stateNode = me) : K.memoizedState = getResource(K.type, fe.memoizedProps, K.pendingProps, fe.memoizedState), null; case 27: return pushHostContext(K), fe === null && isHydrating && (me = K.stateNode = resolveSingletonInstance(K.type, K.pendingProps, rootInstanceStackCursor.current), hydrationParentFiber = K, rootOrSingletonContext = !0, nextHydratableInstance = getNextHydratable(me.firstChild)), me = K.pendingProps.children, fe !== null || isHydrating ? reconcileChildren(fe, K, me, pe) : K.child = reconcileChildFibers(K, null, me, pe), markRef(fe, K), K.child; case 5: return fe === null && isHydrating && ((ge = me = nextHydratableInstance) && (me = canHydrateInstance(me, K.type, K.pendingProps, rootOrSingletonContext), me !== null ? (K.stateNode = me, hydrationParentFiber = K, nextHydratableInstance = getNextHydratable(me.firstChild), rootOrSingletonContext = !1, ge = !0) : ge = !1), ge || throwOnHydrationMismatch(K)), pushHostContext(K), ge = K.type, xe = K.pendingProps, ye = fe !== null ? fe.memoizedProps : null, me = xe.children, shouldSetTextContent(ge, xe) ? me = null : ye !== null && shouldSetTextContent(ge, ye) && (K.flags |= 32), K.memoizedState !== null && (ge = renderWithHooks(fe, K, TransitionAwareHostComponent, null, null, pe), HostTransitionContext._currentValue = ge), markRef(fe, K), reconcileChildren(fe, K, me, pe), K.child; case 6: return fe === null && isHydrating && ((fe = pe = nextHydratableInstance) && (pe = canHydrateTextInstance(pe, K.pendingProps, rootOrSingletonContext), pe !== null ? (K.stateNode = pe, hydrationParentFiber = K, nextHydratableInstance = null, fe = !0) : fe = !1), fe || throwOnHydrationMismatch(K)), null; case 13: return updateSuspenseComponent(fe, K, pe); case 4: return pushHostContainer(K, K.stateNode.containerInfo), me = K.pendingProps, fe === null ? K.child = reconcileChildFibers(K, null, me, pe) : reconcileChildren(fe, K, me, pe), K.child; case 11: return updateForwardRef(fe, K, K.type, K.pendingProps, pe); case 7: return reconcileChildren(fe, K, K.pendingProps, pe), K.child; case 8: return reconcileChildren(fe, K, K.pendingProps.children, pe), K.child; case 12: return reconcileChildren(fe, K, K.pendingProps.children, pe), K.child; case 10: return me = K.pendingProps, pushProvider(K, K.type, me.value), reconcileChildren(fe, K, me.children, pe), K.child; case 9: return ge = K.type._context, me = K.pendingProps.children, prepareToReadContext(K), ge = readContext(ge), me = me(ge), K.flags |= 1, reconcileChildren(fe, K, me, pe), K.child; case 14: return updateMemoComponent(fe, K, K.type, K.pendingProps, pe); case 15: return updateSimpleMemoComponent(fe, K, K.type, K.pendingProps, pe); case 19: return updateSuspenseListComponent(fe, K, pe); case 22: return updateOffscreenComponent(fe, K, pe); case 24: return prepareToReadContext(K), me = readContext(CacheContext), fe === null ? (ge = peekCacheFromPool(), ge === null && (ge = workInProgressRoot, xe = createCache(), ge.pooledCache = xe, xe.refCount++, xe !== null && (ge.pooledCacheLanes |= pe), ge = xe), K.memoizedState = { parent: me, cache: ge }, initializeUpdateQueue(K), pushProvider(K, CacheContext, ge)) : (fe.lanes & pe && (cloneUpdateQueue(fe, K), processUpdateQueue(K, null, null, pe), suspendIfUpdateReadFromEntangledAsyncAction()), ge = fe.memoizedState, xe = K.memoizedState, ge.parent !== me ? (ge = { parent: me, cache: me }, K.memoizedState = ge, K.lanes === 0 && (K.memoizedState = K.updateQueue.baseState = ge), pushProvider(K, CacheContext, me)) : (me = xe.cache, pushProvider(K, CacheContext, me), me !== ge.cache && propagateContextChanges(K, [CacheContext], pe, !0))), reconcileChildren(fe, K, K.pendingProps.children, pe), K.child; case 29: throw K.pendingProps }throw Error(formatProdErrorMessage(156, K.tag)) } var valueCursor = createCursor(null), currentlyRenderingFiber = null, lastContextDependency = null; function pushProvider(fe, K, pe) { push$1(valueCursor, K._currentValue), K._currentValue = pe } function popProvider(fe) { fe._currentValue = valueCursor.current, pop(valueCursor) } function scheduleContextWorkOnParentPath(fe, K, pe) { for (; fe !== null;) { var me = fe.alternate; if ((fe.childLanes & K) !== K ? (fe.childLanes |= K, me !== null && (me.childLanes |= K)) : me !== null && (me.childLanes & K) !== K && (me.childLanes |= K), fe === pe) break; fe = fe.return } } function propagateContextChanges(fe, K, pe, me) { var ge = fe.child; for (ge !== null && (ge.return = fe); ge !== null;) { var xe = ge.dependencies; if (xe !== null) { var ye = ge.child; xe = xe.firstContext; e: for (; xe !== null;) { var ve = xe; xe = ge; for (var _e = 0; _e < K.length; _e++)if (ve.context === K[_e]) { xe.lanes |= pe, ve = xe.alternate, ve !== null && (ve.lanes |= pe), scheduleContextWorkOnParentPath(xe.return, pe, fe), me || (ye = null); break e } xe = ve.next } } else if (ge.tag === 18) { if (ye = ge.return, ye === null) throw Error(formatProdErrorMessage(341)); ye.lanes |= pe, xe = ye.alternate, xe !== null && (xe.lanes |= pe), scheduleContextWorkOnParentPath(ye, pe, fe), ye = null } else ye = ge.child; if (ye !== null) ye.return = ge; else for (ye = ge; ye !== null;) { if (ye === fe) { ye = null; break } if (ge = ye.sibling, ge !== null) { ge.return = ye.return, ye = ge; break } ye = ye.return } ge = ye } } function propagateParentContextChanges(fe, K, pe, me) { fe = null; for (var ge = K, xe = !1; ge !== null;) { if (!xe) { if (ge.flags & 524288) xe = !0; else if (ge.flags & 262144) break } if (ge.tag === 10) { var ye = ge.alternate; if (ye === null) throw Error(formatProdErrorMessage(387)); if (ye = ye.memoizedProps, ye !== null) { var ve = ge.type; objectIs$2(ge.pendingProps.value, ye.value) || (fe !== null ? fe.push(ve) : fe = [ve]) } } else if (ge === hostTransitionProviderCursor.current) { if (ye = ge.alternate, ye === null) throw Error(formatProdErrorMessage(387)); ye.memoizedState.memoizedState !== ge.memoizedState.memoizedState && (fe !== null ? fe.push(HostTransitionContext) : fe = [HostTransitionContext]) } ge = ge.return } fe !== null && propagateContextChanges(K, fe, pe, me), K.flags |= 262144 } function checkIfContextChanged(fe) { for (fe = fe.firstContext; fe !== null;) { if (!objectIs$2(fe.context._currentValue, fe.memoizedValue)) return !0; fe = fe.next } return !1 } function prepareToReadContext(fe) { currentlyRenderingFiber = fe, lastContextDependency = null, fe = fe.dependencies, fe !== null && (fe.firstContext = null) } function readContext(fe) { return readContextForConsumer(currentlyRenderingFiber, fe) } function readContextDuringReconciliation(fe, K) { return currentlyRenderingFiber === null && prepareToReadContext(fe), readContextForConsumer(fe, K) } function readContextForConsumer(fe, K) { var pe = K._currentValue; if (K = { context: K, memoizedValue: pe, next: null }, lastContextDependency === null) { if (fe === null) throw Error(formatProdErrorMessage(308)); lastContextDependency = K, fe.dependencies = { lanes: 0, firstContext: K }, fe.flags |= 524288 } else lastContextDependency = lastContextDependency.next = K; return pe } var hasForceUpdate = !1; function initializeUpdateQueue(fe) { fe.updateQueue = { baseState: fe.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function cloneUpdateQueue(fe, K) { fe = fe.updateQueue, K.updateQueue === fe && (K.updateQueue = { baseState: fe.baseState, firstBaseUpdate: fe.firstBaseUpdate, lastBaseUpdate: fe.lastBaseUpdate, shared: fe.shared, callbacks: null }) } function createUpdate(fe) { return { lane: fe, tag: 0, payload: null, callback: null, next: null } } function enqueueUpdate(fe, K, pe) { var me = fe.updateQueue; if (me === null) return null; if (me = me.shared, executionContext & 2) { var ge = me.pending; return ge === null ? K.next = K : (K.next = ge.next, ge.next = K), me.pending = K, K = getRootForUpdatedFiber(fe), markUpdateLaneFromFiberToRoot(fe, null, pe), K } return enqueueUpdate$1(fe, me, K, pe), getRootForUpdatedFiber(fe) } function entangleTransitions(fe, K, pe) { if (K = K.updateQueue, K !== null && (K = K.shared, (pe & 4194176) !== 0)) { var me = K.lanes; me &= fe.pendingLanes, pe |= me, K.lanes = pe, markRootEntangled(fe, pe) } } function enqueueCapturedUpdate(fe, K) { var pe = fe.updateQueue, me = fe.alternate; if (me !== null && (me = me.updateQueue, pe === me)) { var ge = null, xe = null; if (pe = pe.firstBaseUpdate, pe !== null) { do { var ye = { lane: pe.lane, tag: pe.tag, payload: pe.payload, callback: null, next: null }; xe === null ? ge = xe = ye : xe = xe.next = ye, pe = pe.next } while (pe !== null); xe === null ? ge = xe = K : xe = xe.next = K } else ge = xe = K; pe = { baseState: me.baseState, firstBaseUpdate: ge, lastBaseUpdate: xe, shared: me.shared, callbacks: me.callbacks }, fe.updateQueue = pe; return } fe = pe.lastBaseUpdate, fe === null ? pe.firstBaseUpdate = K : fe.next = K, pe.lastBaseUpdate = K } var didReadFromEntangledAsyncAction = !1; function suspendIfUpdateReadFromEntangledAsyncAction() { if (didReadFromEntangledAsyncAction) { var fe = currentEntangledActionThenable; if (fe !== null) throw fe } } function processUpdateQueue(fe, K, pe, me) { didReadFromEntangledAsyncAction = !1; var ge = fe.updateQueue; hasForceUpdate = !1; var xe = ge.firstBaseUpdate, ye = ge.lastBaseUpdate, ve = ge.shared.pending; if (ve !== null) { ge.shared.pending = null; var _e = ve, Ee = _e.next; _e.next = null, ye === null ? xe = Ee : ye.next = Ee, ye = _e; var be = fe.alternate; be !== null && (be = be.updateQueue, ve = be.lastBaseUpdate, ve !== ye && (ve === null ? be.firstBaseUpdate = Ee : ve.next = Ee, be.lastBaseUpdate = _e)) } if (xe !== null) { var Ae = ge.baseState; ye = 0, be = Ee = _e = null, ve = xe; do { var Se = ve.lane & -536870913, Ce = Se !== ve.lane; if (Ce ? (workInProgressRootRenderLanes & Se) === Se : (me & Se) === Se) { Se !== 0 && Se === currentEntangledLane && (didReadFromEntangledAsyncAction = !0), be !== null && (be = be.next = { lane: 0, tag: ve.tag, payload: ve.payload, callback: null, next: null }); e: { var we = fe, Be = ve; Se = K; var De = pe; switch (Be.tag) { case 1: if (we = Be.payload, typeof we == "function") { Ae = we.call(De, Ae, Se); break e } Ae = we; break e; case 3: we.flags = we.flags & -65537 | 128; case 0: if (we = Be.payload, Se = typeof we == "function" ? we.call(De, Ae, Se) : we, Se == null) break e; Ae = assign$1({}, Ae, Se); break e; case 2: hasForceUpdate = !0 } } Se = ve.callback, Se !== null && (fe.flags |= 64, Ce && (fe.flags |= 8192), Ce = ge.callbacks, Ce === null ? ge.callbacks = [Se] : Ce.push(Se)) } else Ce = { lane: Se, tag: ve.tag, payload: ve.payload, callback: ve.callback, next: null }, be === null ? (Ee = be = Ce, _e = Ae) : be = be.next = Ce, ye |= Se; if (ve = ve.next, ve === null) { if (ve = ge.shared.pending, ve === null) break; Ce = ve, ve = Ce.next, Ce.next = null, ge.lastBaseUpdate = Ce, ge.shared.pending = null } } while (!0); be === null && (_e = Ae), ge.baseState = _e, ge.firstBaseUpdate = Ee, ge.lastBaseUpdate = be, xe === null && (ge.shared.lanes = 0), workInProgressRootSkippedLanes |= ye, fe.lanes = ye, fe.memoizedState = Ae } } function callCallback(fe, K) { if (typeof fe != "function") throw Error(formatProdErrorMessage(191, fe)); fe.call(K) } function commitCallbacks(fe, K) { var pe = fe.callbacks; if (pe !== null) for (fe.callbacks = null, fe = 0; fe < pe.length; fe++)callCallback(pe[fe], K) } function commitHookEffectListMount(fe, K) { try { var pe = K.updateQueue, me = pe !== null ? pe.lastEffect : null; if (me !== null) { var ge = me.next; pe = ge; do { if ((pe.tag & fe) === fe) { me = void 0; var xe = pe.create, ye = pe.inst; me = xe(), ye.destroy = me } pe = pe.next } while (pe !== ge) } } catch (ve) { captureCommitPhaseError(K, K.return, ve) } } function commitHookEffectListUnmount(fe, K, pe) { try { var me = K.updateQueue, ge = me !== null ? me.lastEffect : null; if (ge !== null) { var xe = ge.next; me = xe; do { if ((me.tag & fe) === fe) { var ye = me.inst, ve = ye.destroy; if (ve !== void 0) { ye.destroy = void 0, ge = K; var _e = pe; try { ve() } catch (Ee) { captureCommitPhaseError(ge, _e, Ee) } } } me = me.next } while (me !== xe) } } catch (Ee) { captureCommitPhaseError(K, K.return, Ee) } } function commitClassCallbacks(fe) { var K = fe.updateQueue; if (K !== null) { var pe = fe.stateNode; try { commitCallbacks(K, pe) } catch (me) { captureCommitPhaseError(fe, fe.return, me) } } } function safelyCallComponentWillUnmount(fe, K, pe) { pe.props = resolveClassComponentProps(fe.type, fe.memoizedProps), pe.state = fe.memoizedState; try { pe.componentWillUnmount() } catch (me) { captureCommitPhaseError(fe, K, me) } } function safelyAttachRef(fe, K) { try { var pe = fe.ref; if (pe !== null) { var me = fe.stateNode; switch (fe.tag) { case 26: case 27: case 5: var ge = me; break; default: ge = me }typeof pe == "function" ? fe.refCleanup = pe(ge) : pe.current = ge } } catch (xe) { captureCommitPhaseError(fe, K, xe) } } function safelyDetachRef(fe, K) { var pe = fe.ref, me = fe.refCleanup; if (pe !== null) if (typeof me == "function") try { me() } catch (ge) { captureCommitPhaseError(fe, K, ge) } finally { fe.refCleanup = null, fe = fe.alternate, fe != null && (fe.refCleanup = null) } else if (typeof pe == "function") try { pe(null) } catch (ge) { captureCommitPhaseError(fe, K, ge) } else pe.current = null } function commitHostMount(fe) { var K = fe.type, pe = fe.memoizedProps, me = fe.stateNode; try { e: switch (K) { case "button": case "input": case "select": case "textarea": pe.autoFocus && me.focus(); break e; case "img": pe.src ? me.src = pe.src : pe.srcSet && (me.srcset = pe.srcSet) } } catch (ge) { captureCommitPhaseError(fe, fe.return, ge) } } function commitHostUpdate(fe, K, pe) { try { var me = fe.stateNode; updateProperties(me, fe.type, pe, K), me[internalPropsKey] = K } catch (ge) { captureCommitPhaseError(fe, fe.return, ge) } } function isHostParent(fe) { return fe.tag === 5 || fe.tag === 3 || fe.tag === 26 || fe.tag === 27 || fe.tag === 4 } function getHostSibling(fe) { e: for (; ;) { for (; fe.sibling === null;) { if (fe.return === null || isHostParent(fe.return)) return null; fe = fe.return } for (fe.sibling.return = fe.return, fe = fe.sibling; fe.tag !== 5 && fe.tag !== 6 && fe.tag !== 27 && fe.tag !== 18;) { if (fe.flags & 2 || fe.child === null || fe.tag === 4) continue e; fe.child.return = fe, fe = fe.child } if (!(fe.flags & 2)) return fe.stateNode } } function insertOrAppendPlacementNodeIntoContainer(fe, K, pe) { var me = fe.tag; if (me === 5 || me === 6) fe = fe.stateNode, K ? pe.nodeType === 8 ? pe.parentNode.insertBefore(fe, K) : pe.insertBefore(fe, K) : (pe.nodeType === 8 ? (K = pe.parentNode, K.insertBefore(fe, pe)) : (K = pe, K.appendChild(fe)), pe = pe._reactRootContainer, pe != null || K.onclick !== null || (K.onclick = noop$1$1)); else if (me !== 4 && me !== 27 && (fe = fe.child, fe !== null)) for (insertOrAppendPlacementNodeIntoContainer(fe, K, pe), fe = fe.sibling; fe !== null;)insertOrAppendPlacementNodeIntoContainer(fe, K, pe), fe = fe.sibling } function insertOrAppendPlacementNode(fe, K, pe) { var me = fe.tag; if (me === 5 || me === 6) fe = fe.stateNode, K ? pe.insertBefore(fe, K) : pe.appendChild(fe); else if (me !== 4 && me !== 27 && (fe = fe.child, fe !== null)) for (insertOrAppendPlacementNode(fe, K, pe), fe = fe.sibling; fe !== null;)insertOrAppendPlacementNode(fe, K, pe), fe = fe.sibling } var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = typeof WeakSet == "function" ? WeakSet : Set, nextEffect = null, shouldFireAfterActiveInstanceBlur = !1; function commitBeforeMutationEffects(fe, K) { if (fe = fe.containerInfo, eventsEnabled = _enabled, fe = getActiveElementDeep(fe), hasSelectionCapabilities(fe)) { if ("selectionStart" in fe) var pe = { start: fe.selectionStart, end: fe.selectionEnd }; else e: { pe = (pe = fe.ownerDocument) && pe.defaultView || window; var me = pe.getSelection && pe.getSelection(); if (me && me.rangeCount !== 0) { pe = me.anchorNode; var ge = me.anchorOffset, xe = me.focusNode; me = me.focusOffset; try { pe.nodeType, xe.nodeType } catch { pe = null; break e } var ye = 0, ve = -1, _e = -1, Ee = 0, be = 0, Ae = fe, Se = null; t: for (; ;) { for (var Ce; Ae !== pe || ge !== 0 && Ae.nodeType !== 3 || (ve = ye + ge), Ae !== xe || me !== 0 && Ae.nodeType !== 3 || (_e = ye + me), Ae.nodeType === 3 && (ye += Ae.nodeValue.length), (Ce = Ae.firstChild) !== null;)Se = Ae, Ae = Ce; for (; ;) { if (Ae === fe) break t; if (Se === pe && ++Ee === ge && (ve = ye), Se === xe && ++be === me && (_e = ye), (Ce = Ae.nextSibling) !== null) break; Ae = Se, Se = Ae.parentNode } Ae = Ce } pe = ve === -1 || _e === -1 ? null : { start: ve, end: _e } } else pe = null } pe = pe || { start: 0, end: 0 } } else pe = null; for (selectionInformation = { focusedElem: fe, selectionRange: pe }, _enabled = !1, nextEffect = K; nextEffect !== null;)if (K = nextEffect, fe = K.child, (K.subtreeFlags & 1028) !== 0 && fe !== null) fe.return = K, nextEffect = fe; else for (; nextEffect !== null;) { switch (K = nextEffect, xe = K.alternate, fe = K.flags, K.tag) { case 0: break; case 11: case 15: break; case 1: if (fe & 1024 && xe !== null) { fe = void 0, pe = K, ge = xe.memoizedProps, xe = xe.memoizedState, me = pe.stateNode; try { var we = resolveClassComponentProps(pe.type, ge, pe.elementType === pe.type); fe = me.getSnapshotBeforeUpdate(we, xe), me.__reactInternalSnapshotBeforeUpdate = fe } catch (Be) { captureCommitPhaseError(pe, pe.return, Be) } } break; case 3: if (fe & 1024) { if (fe = K.stateNode.containerInfo, pe = fe.nodeType, pe === 9) clearContainerSparingly(fe); else if (pe === 1) switch (fe.nodeName) { case "HEAD": case "HTML": case "BODY": clearContainerSparingly(fe); break; default: fe.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if (fe & 1024) throw Error(formatProdErrorMessage(163)) }if (fe = K.sibling, fe !== null) { fe.return = K.return, nextEffect = fe; break } nextEffect = K.return } return we = shouldFireAfterActiveInstanceBlur, shouldFireAfterActiveInstanceBlur = !1, we } function commitLayoutEffectOnFiber(fe, K, pe) { var me = pe.flags; switch (pe.tag) { case 0: case 11: case 15: recursivelyTraverseLayoutEffects(fe, pe), me & 4 && commitHookEffectListMount(5, pe); break; case 1: if (recursivelyTraverseLayoutEffects(fe, pe), me & 4) if (fe = pe.stateNode, K === null) try { fe.componentDidMount() } catch (ve) { captureCommitPhaseError(pe, pe.return, ve) } else { var ge = resolveClassComponentProps(pe.type, K.memoizedProps); K = K.memoizedState; try { fe.componentDidUpdate(ge, K, fe.__reactInternalSnapshotBeforeUpdate) } catch (ve) { captureCommitPhaseError(pe, pe.return, ve) } } me & 64 && commitClassCallbacks(pe), me & 512 && safelyAttachRef(pe, pe.return); break; case 3: if (recursivelyTraverseLayoutEffects(fe, pe), me & 64 && (me = pe.updateQueue, me !== null)) { if (fe = null, pe.child !== null) switch (pe.child.tag) { case 27: case 5: fe = pe.child.stateNode; break; case 1: fe = pe.child.stateNode }try { commitCallbacks(me, fe) } catch (ve) { captureCommitPhaseError(pe, pe.return, ve) } } break; case 26: recursivelyTraverseLayoutEffects(fe, pe), me & 512 && safelyAttachRef(pe, pe.return); break; case 27: case 5: recursivelyTraverseLayoutEffects(fe, pe), K === null && me & 4 && commitHostMount(pe), me & 512 && safelyAttachRef(pe, pe.return); break; case 12: recursivelyTraverseLayoutEffects(fe, pe); break; case 13: recursivelyTraverseLayoutEffects(fe, pe), me & 4 && commitSuspenseHydrationCallbacks(fe, pe); break; case 22: if (ge = pe.memoizedState !== null || offscreenSubtreeIsHidden, !ge) { K = K !== null && K.memoizedState !== null || offscreenSubtreeWasHidden; var xe = offscreenSubtreeIsHidden, ye = offscreenSubtreeWasHidden; offscreenSubtreeIsHidden = ge, (offscreenSubtreeWasHidden = K) && !ye ? recursivelyTraverseReappearLayoutEffects(fe, pe, (pe.subtreeFlags & 8772) !== 0) : recursivelyTraverseLayoutEffects(fe, pe), offscreenSubtreeIsHidden = xe, offscreenSubtreeWasHidden = ye } me & 512 && (pe.memoizedProps.mode === "manual" ? safelyAttachRef(pe, pe.return) : safelyDetachRef(pe, pe.return)); break; default: recursivelyTraverseLayoutEffects(fe, pe) } } function detachFiberAfterEffects(fe) { var K = fe.alternate; K !== null && (fe.alternate = null, detachFiberAfterEffects(K)), fe.child = null, fe.deletions = null, fe.sibling = null, fe.tag === 5 && (K = fe.stateNode, K !== null && detachDeletedInstance(K)), fe.stateNode = null, fe.return = null, fe.dependencies = null, fe.memoizedProps = null, fe.memoizedState = null, fe.pendingProps = null, fe.stateNode = null, fe.updateQueue = null } var hostParent = null, hostParentIsContainer = !1; function recursivelyTraverseDeletionEffects(fe, K, pe) { for (pe = pe.child; pe !== null;)commitDeletionEffectsOnFiber(fe, K, pe), pe = pe.sibling } function commitDeletionEffectsOnFiber(fe, K, pe) { if (injectedHook && typeof injectedHook.onCommitFiberUnmount == "function") try { injectedHook.onCommitFiberUnmount(rendererID, pe) } catch { } switch (pe.tag) { case 26: offscreenSubtreeWasHidden || safelyDetachRef(pe, K), recursivelyTraverseDeletionEffects(fe, K, pe), pe.memoizedState ? pe.memoizedState.count-- : pe.stateNode && (pe = pe.stateNode, pe.parentNode.removeChild(pe)); break; case 27: offscreenSubtreeWasHidden || safelyDetachRef(pe, K); var me = hostParent, ge = hostParentIsContainer; for (hostParent = pe.stateNode, recursivelyTraverseDeletionEffects(fe, K, pe), pe = pe.stateNode, K = pe.attributes; K.length;)pe.removeAttributeNode(K[0]); detachDeletedInstance(pe), hostParent = me, hostParentIsContainer = ge; break; case 5: offscreenSubtreeWasHidden || safelyDetachRef(pe, K); case 6: ge = hostParent; var xe = hostParentIsContainer; if (hostParent = null, recursivelyTraverseDeletionEffects(fe, K, pe), hostParent = ge, hostParentIsContainer = xe, hostParent !== null) if (hostParentIsContainer) try { fe = hostParent, me = pe.stateNode, fe.nodeType === 8 ? fe.parentNode.removeChild(me) : fe.removeChild(me) } catch (ye) { captureCommitPhaseError(pe, K, ye) } else try { hostParent.removeChild(pe.stateNode) } catch (ye) { captureCommitPhaseError(pe, K, ye) } break; case 18: hostParent !== null && (hostParentIsContainer ? (K = hostParent, pe = pe.stateNode, K.nodeType === 8 ? clearSuspenseBoundary(K.parentNode, pe) : K.nodeType === 1 && clearSuspenseBoundary(K, pe), retryIfBlockedOn(K)) : clearSuspenseBoundary(hostParent, pe.stateNode)); break; case 4: me = hostParent, ge = hostParentIsContainer, hostParent = pe.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(fe, K, pe), hostParent = me, hostParentIsContainer = ge; break; case 0: case 11: case 14: case 15: offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, pe, K), offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, pe, K), recursivelyTraverseDeletionEffects(fe, K, pe); break; case 1: offscreenSubtreeWasHidden || (safelyDetachRef(pe, K), me = pe.stateNode, typeof me.componentWillUnmount == "function" && safelyCallComponentWillUnmount(pe, K, me)), recursivelyTraverseDeletionEffects(fe, K, pe); break; case 21: recursivelyTraverseDeletionEffects(fe, K, pe); break; case 22: offscreenSubtreeWasHidden || safelyDetachRef(pe, K), offscreenSubtreeWasHidden = (me = offscreenSubtreeWasHidden) || pe.memoizedState !== null, recursivelyTraverseDeletionEffects(fe, K, pe), offscreenSubtreeWasHidden = me; break; default: recursivelyTraverseDeletionEffects(fe, K, pe) } } function commitSuspenseHydrationCallbacks(fe, K) { if (K.memoizedState === null && (fe = K.alternate, fe !== null && (fe = fe.memoizedState, fe !== null && (fe = fe.dehydrated, fe !== null)))) try { retryIfBlockedOn(fe) } catch (pe) { captureCommitPhaseError(K, K.return, pe) } } function getRetryCache(fe) { switch (fe.tag) { case 13: case 19: var K = fe.stateNode; return K === null && (K = fe.stateNode = new PossiblyWeakSet), K; case 22: return fe = fe.stateNode, K = fe._retryCache, K === null && (K = fe._retryCache = new PossiblyWeakSet), K; default: throw Error(formatProdErrorMessage(435, fe.tag)) } } function attachSuspenseRetryListeners(fe, K) { var pe = getRetryCache(fe); K.forEach(function (me) { var ge = resolveRetryWakeable.bind(null, fe, me); pe.has(me) || (pe.add(me), me.then(ge, ge)) }) } function recursivelyTraverseMutationEffects(fe, K) { var pe = K.deletions; if (pe !== null) for (var me = 0; me < pe.length; me++) { var ge = pe[me], xe = fe, ye = K, ve = ye; e: for (; ve !== null;) { switch (ve.tag) { case 27: case 5: hostParent = ve.stateNode, hostParentIsContainer = !1; break e; case 3: hostParent = ve.stateNode.containerInfo, hostParentIsContainer = !0; break e; case 4: hostParent = ve.stateNode.containerInfo, hostParentIsContainer = !0; break e }ve = ve.return } if (hostParent === null) throw Error(formatProdErrorMessage(160)); commitDeletionEffectsOnFiber(xe, ye, ge), hostParent = null, hostParentIsContainer = !1, xe = ge.alternate, xe !== null && (xe.return = null), ge.return = null } if (K.subtreeFlags & 13878) for (K = K.child; K !== null;)commitMutationEffectsOnFiber(K, fe), K = K.sibling } var currentHoistableRoot = null; function commitMutationEffectsOnFiber(fe, K) { var pe = fe.alternate, me = fe.flags; switch (fe.tag) { case 0: case 11: case 14: case 15: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 4 && (commitHookEffectListUnmount(3, fe, fe.return), commitHookEffectListMount(3, fe), commitHookEffectListUnmount(5, fe, fe.return)); break; case 1: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 512 && (offscreenSubtreeWasHidden || pe === null || safelyDetachRef(pe, pe.return)), me & 64 && offscreenSubtreeIsHidden && (fe = fe.updateQueue, fe !== null && (me = fe.callbacks, me !== null && (pe = fe.shared.hiddenCallbacks, fe.shared.hiddenCallbacks = pe === null ? me : pe.concat(me)))); break; case 26: var ge = currentHoistableRoot; if (recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 512 && (offscreenSubtreeWasHidden || pe === null || safelyDetachRef(pe, pe.return)), me & 4) { var xe = pe !== null ? pe.memoizedState : null; if (me = fe.memoizedState, pe === null) if (me === null) if (fe.stateNode === null) { e: { me = fe.type, pe = fe.memoizedProps, ge = ge.ownerDocument || ge; t: switch (me) { case "title": xe = ge.getElementsByTagName("title")[0], (!xe || xe[internalHoistableMarker] || xe[internalInstanceKey] || xe.namespaceURI === "http://www.w3.org/2000/svg" || xe.hasAttribute("itemprop")) && (xe = ge.createElement(me), ge.head.insertBefore(xe, ge.querySelector("head > title"))), setInitialProperties(xe, me, pe), xe[internalInstanceKey] = fe, markNodeAsHoistable(xe), me = xe; break e; case "link": var ye = getHydratableHoistableCache("link", "href", ge).get(me + (pe.href || "")); if (ye) { for (var ve = 0; ve < ye.length; ve++)if (xe = ye[ve], xe.getAttribute("href") === (pe.href == null ? null : pe.href) && xe.getAttribute("rel") === (pe.rel == null ? null : pe.rel) && xe.getAttribute("title") === (pe.title == null ? null : pe.title) && xe.getAttribute("crossorigin") === (pe.crossOrigin == null ? null : pe.crossOrigin)) { ye.splice(ve, 1); break t } } xe = ge.createElement(me), setInitialProperties(xe, me, pe), ge.head.appendChild(xe); break; case "meta": if (ye = getHydratableHoistableCache("meta", "content", ge).get(me + (pe.content || ""))) { for (ve = 0; ve < ye.length; ve++)if (xe = ye[ve], xe.getAttribute("content") === (pe.content == null ? null : "" + pe.content) && xe.getAttribute("name") === (pe.name == null ? null : pe.name) && xe.getAttribute("property") === (pe.property == null ? null : pe.property) && xe.getAttribute("http-equiv") === (pe.httpEquiv == null ? null : pe.httpEquiv) && xe.getAttribute("charset") === (pe.charSet == null ? null : pe.charSet)) { ye.splice(ve, 1); break t } } xe = ge.createElement(me), setInitialProperties(xe, me, pe), ge.head.appendChild(xe); break; default: throw Error(formatProdErrorMessage(468, me)) }xe[internalInstanceKey] = fe, markNodeAsHoistable(xe), me = xe } fe.stateNode = me } else mountHoistable(ge, fe.type, fe.stateNode); else fe.stateNode = acquireResource(ge, me, fe.memoizedProps); else xe !== me ? (xe === null ? pe.stateNode !== null && (pe = pe.stateNode, pe.parentNode.removeChild(pe)) : xe.count--, me === null ? mountHoistable(ge, fe.type, fe.stateNode) : acquireResource(ge, me, fe.memoizedProps)) : me === null && fe.stateNode !== null && commitHostUpdate(fe, fe.memoizedProps, pe.memoizedProps) } break; case 27: if (me & 4 && fe.alternate === null) { ge = fe.stateNode, xe = fe.memoizedProps; try { for (var _e = ge.firstChild; _e;) { var Ee = _e.nextSibling, be = _e.nodeName; _e[internalHoistableMarker] || be === "HEAD" || be === "BODY" || be === "SCRIPT" || be === "STYLE" || be === "LINK" && _e.rel.toLowerCase() === "stylesheet" || ge.removeChild(_e), _e = Ee } for (var Ae = fe.type, Se = ge.attributes; Se.length;)ge.removeAttributeNode(Se[0]); setInitialProperties(ge, Ae, xe), ge[internalInstanceKey] = fe, ge[internalPropsKey] = xe } catch (we) { captureCommitPhaseError(fe, fe.return, we) } } case 5: if (recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 512 && (offscreenSubtreeWasHidden || pe === null || safelyDetachRef(pe, pe.return)), fe.flags & 32) { ge = fe.stateNode; try { setTextContent(ge, "") } catch (we) { captureCommitPhaseError(fe, fe.return, we) } } me & 4 && fe.stateNode != null && (ge = fe.memoizedProps, commitHostUpdate(fe, ge, pe !== null ? pe.memoizedProps : ge)), me & 1024 && (needsFormReset = !0); break; case 6: if (recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 4) { if (fe.stateNode === null) throw Error(formatProdErrorMessage(162)); me = fe.memoizedProps, pe = fe.stateNode; try { pe.nodeValue = me } catch (we) { captureCommitPhaseError(fe, fe.return, we) } } break; case 3: if (tagCaches = null, ge = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(K.containerInfo), recursivelyTraverseMutationEffects(K, fe), currentHoistableRoot = ge, commitReconciliationEffects(fe), me & 4 && pe !== null && pe.memoizedState.isDehydrated) try { retryIfBlockedOn(K.containerInfo) } catch (we) { captureCommitPhaseError(fe, fe.return, we) } needsFormReset && (needsFormReset = !1, recursivelyResetForms(fe)); break; case 4: me = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(fe.stateNode.containerInfo), recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), currentHoistableRoot = me; break; case 12: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe); break; case 13: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), fe.child.flags & 8192 && fe.memoizedState !== null != (pe !== null && pe.memoizedState !== null) && (globalMostRecentFallbackTime = now$1()), me & 4 && (me = fe.updateQueue, me !== null && (fe.updateQueue = null, attachSuspenseRetryListeners(fe, me))); break; case 22: if (me & 512 && (offscreenSubtreeWasHidden || pe === null || safelyDetachRef(pe, pe.return)), _e = fe.memoizedState !== null, Ee = pe !== null && pe.memoizedState !== null, be = offscreenSubtreeIsHidden, Ae = offscreenSubtreeWasHidden, offscreenSubtreeIsHidden = be || _e, offscreenSubtreeWasHidden = Ae || Ee, recursivelyTraverseMutationEffects(K, fe), offscreenSubtreeWasHidden = Ae, offscreenSubtreeIsHidden = be, commitReconciliationEffects(fe), K = fe.stateNode, K._current = fe, K._visibility &= -3, K._visibility |= K._pendingVisibility & 2, me & 8192 && (K._visibility = _e ? K._visibility & -2 : K._visibility | 1, _e && (K = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, pe === null || Ee || K || recursivelyTraverseDisappearLayoutEffects(fe)), fe.memoizedProps === null || fe.memoizedProps.mode !== "manual")) e: for (pe = null, K = fe; ;) { if (K.tag === 5 || K.tag === 26 || K.tag === 27) { if (pe === null) { Ee = pe = K; try { if (ge = Ee.stateNode, _e) xe = ge.style, typeof xe.setProperty == "function" ? xe.setProperty("display", "none", "important") : xe.display = "none"; else { ye = Ee.stateNode, ve = Ee.memoizedProps.style; var Ce = ve != null && ve.hasOwnProperty("display") ? ve.display : null; ye.style.display = Ce == null || typeof Ce == "boolean" ? "" : ("" + Ce).trim() } } catch (we) { captureCommitPhaseError(Ee, Ee.return, we) } } } else if (K.tag === 6) { if (pe === null) { Ee = K; try { Ee.stateNode.nodeValue = _e ? "" : Ee.memoizedProps } catch (we) { captureCommitPhaseError(Ee, Ee.return, we) } } } else if ((K.tag !== 22 && K.tag !== 23 || K.memoizedState === null || K === fe) && K.child !== null) { K.child.return = K, K = K.child; continue } if (K === fe) break e; for (; K.sibling === null;) { if (K.return === null || K.return === fe) break e; pe === K && (pe = null), K = K.return } pe === K && (pe = null), K.sibling.return = K.return, K = K.sibling } me & 4 && (me = fe.updateQueue, me !== null && (pe = me.retryQueue, pe !== null && (me.retryQueue = null, attachSuspenseRetryListeners(fe, pe)))); break; case 19: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe), me & 4 && (me = fe.updateQueue, me !== null && (fe.updateQueue = null, attachSuspenseRetryListeners(fe, me))); break; case 21: break; default: recursivelyTraverseMutationEffects(K, fe), commitReconciliationEffects(fe) } } function commitReconciliationEffects(fe) { var K = fe.flags; if (K & 2) { try { if (fe.tag !== 27) { e: { for (var pe = fe.return; pe !== null;) { if (isHostParent(pe)) { var me = pe; break e } pe = pe.return } throw Error(formatProdErrorMessage(160)) } switch (me.tag) { case 27: var ge = me.stateNode, xe = getHostSibling(fe); insertOrAppendPlacementNode(fe, xe, ge); break; case 5: var ye = me.stateNode; me.flags & 32 && (setTextContent(ye, ""), me.flags &= -33); var ve = getHostSibling(fe); insertOrAppendPlacementNode(fe, ve, ye); break; case 3: case 4: var _e = me.stateNode.containerInfo, Ee = getHostSibling(fe); insertOrAppendPlacementNodeIntoContainer(fe, Ee, _e); break; default: throw Error(formatProdErrorMessage(161)) } } } catch (be) { captureCommitPhaseError(fe, fe.return, be) } fe.flags &= -3 } K & 4096 && (fe.flags &= -4097) } function recursivelyResetForms(fe) { if (fe.subtreeFlags & 1024) for (fe = fe.child; fe !== null;) { var K = fe; recursivelyResetForms(K), K.tag === 5 && K.flags & 1024 && K.stateNode.reset(), fe = fe.sibling } } function recursivelyTraverseLayoutEffects(fe, K) { if (K.subtreeFlags & 8772) for (K = K.child; K !== null;)commitLayoutEffectOnFiber(fe, K.alternate, K), K = K.sibling } function recursivelyTraverseDisappearLayoutEffects(fe) { for (fe = fe.child; fe !== null;) { var K = fe; switch (K.tag) { case 0: case 11: case 14: case 15: commitHookEffectListUnmount(4, K, K.return), recursivelyTraverseDisappearLayoutEffects(K); break; case 1: safelyDetachRef(K, K.return); var pe = K.stateNode; typeof pe.componentWillUnmount == "function" && safelyCallComponentWillUnmount(K, K.return, pe), recursivelyTraverseDisappearLayoutEffects(K); break; case 26: case 27: case 5: safelyDetachRef(K, K.return), recursivelyTraverseDisappearLayoutEffects(K); break; case 22: safelyDetachRef(K, K.return), K.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(K); break; default: recursivelyTraverseDisappearLayoutEffects(K) }fe = fe.sibling } } function recursivelyTraverseReappearLayoutEffects(fe, K, pe) { for (pe = pe && (K.subtreeFlags & 8772) !== 0, K = K.child; K !== null;) { var me = K.alternate, ge = fe, xe = K, ye = xe.flags; switch (xe.tag) { case 0: case 11: case 15: recursivelyTraverseReappearLayoutEffects(ge, xe, pe), commitHookEffectListMount(4, xe); break; case 1: if (recursivelyTraverseReappearLayoutEffects(ge, xe, pe), me = xe, ge = me.stateNode, typeof ge.componentDidMount == "function") try { ge.componentDidMount() } catch (Ee) { captureCommitPhaseError(me, me.return, Ee) } if (me = xe, ge = me.updateQueue, ge !== null) { var ve = me.stateNode; try { var _e = ge.shared.hiddenCallbacks; if (_e !== null) for (ge.shared.hiddenCallbacks = null, ge = 0; ge < _e.length; ge++)callCallback(_e[ge], ve) } catch (Ee) { captureCommitPhaseError(me, me.return, Ee) } } pe && ye & 64 && commitClassCallbacks(xe), safelyAttachRef(xe, xe.return); break; case 26: case 27: case 5: recursivelyTraverseReappearLayoutEffects(ge, xe, pe), pe && me === null && ye & 4 && commitHostMount(xe), safelyAttachRef(xe, xe.return); break; case 12: recursivelyTraverseReappearLayoutEffects(ge, xe, pe); break; case 13: recursivelyTraverseReappearLayoutEffects(ge, xe, pe), pe && ye & 4 && commitSuspenseHydrationCallbacks(ge, xe); break; case 22: xe.memoizedState === null && recursivelyTraverseReappearLayoutEffects(ge, xe, pe), safelyAttachRef(xe, xe.return); break; default: recursivelyTraverseReappearLayoutEffects(ge, xe, pe) }K = K.sibling } } function commitOffscreenPassiveMountEffects(fe, K) { var pe = null; fe !== null && fe.memoizedState !== null && fe.memoizedState.cachePool !== null && (pe = fe.memoizedState.cachePool.pool), fe = null, K.memoizedState !== null && K.memoizedState.cachePool !== null && (fe = K.memoizedState.cachePool.pool), fe !== pe && (fe != null && fe.refCount++, pe != null && releaseCache(pe)) } function commitCachePassiveMountEffect(fe, K) { fe = null, K.alternate !== null && (fe = K.alternate.memoizedState.cache), K = K.memoizedState.cache, K !== fe && (K.refCount++, fe != null && releaseCache(fe)) } function recursivelyTraversePassiveMountEffects(fe, K, pe, me) { if (K.subtreeFlags & 10256) for (K = K.child; K !== null;)commitPassiveMountOnFiber(fe, K, pe, me), K = K.sibling } function commitPassiveMountOnFiber(fe, K, pe, me) { var ge = K.flags; switch (K.tag) { case 0: case 11: case 15: recursivelyTraversePassiveMountEffects(fe, K, pe, me), ge & 2048 && commitHookEffectListMount(9, K); break; case 3: recursivelyTraversePassiveMountEffects(fe, K, pe, me), ge & 2048 && (fe = null, K.alternate !== null && (fe = K.alternate.memoizedState.cache), K = K.memoizedState.cache, K !== fe && (K.refCount++, fe != null && releaseCache(fe))); break; case 12: if (ge & 2048) { recursivelyTraversePassiveMountEffects(fe, K, pe, me), fe = K.stateNode; try { var xe = K.memoizedProps, ye = xe.id, ve = xe.onPostCommit; typeof ve == "function" && ve(ye, K.alternate === null ? "mount" : "update", fe.passiveEffectDuration, -0) } catch (_e) { captureCommitPhaseError(K, K.return, _e) } } else recursivelyTraversePassiveMountEffects(fe, K, pe, me); break; case 23: break; case 22: xe = K.stateNode, K.memoizedState !== null ? xe._visibility & 4 ? recursivelyTraversePassiveMountEffects(fe, K, pe, me) : recursivelyTraverseAtomicPassiveEffects(fe, K) : xe._visibility & 4 ? recursivelyTraversePassiveMountEffects(fe, K, pe, me) : (xe._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(fe, K, pe, me, (K.subtreeFlags & 10256) !== 0)), ge & 2048 && commitOffscreenPassiveMountEffects(K.alternate, K); break; case 24: recursivelyTraversePassiveMountEffects(fe, K, pe, me), ge & 2048 && commitCachePassiveMountEffect(K.alternate, K); break; default: recursivelyTraversePassiveMountEffects(fe, K, pe, me) } } function recursivelyTraverseReconnectPassiveEffects(fe, K, pe, me, ge) { for (ge = ge && (K.subtreeFlags & 10256) !== 0, K = K.child; K !== null;) { var xe = fe, ye = K, ve = pe, _e = me, Ee = ye.flags; switch (ye.tag) { case 0: case 11: case 15: recursivelyTraverseReconnectPassiveEffects(xe, ye, ve, _e, ge), commitHookEffectListMount(8, ye); break; case 23: break; case 22: var be = ye.stateNode; ye.memoizedState !== null ? be._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(xe, ye, ve, _e, ge) : recursivelyTraverseAtomicPassiveEffects(xe, ye) : (be._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(xe, ye, ve, _e, ge)), ge && Ee & 2048 && commitOffscreenPassiveMountEffects(ye.alternate, ye); break; case 24: recursivelyTraverseReconnectPassiveEffects(xe, ye, ve, _e, ge), ge && Ee & 2048 && commitCachePassiveMountEffect(ye.alternate, ye); break; default: recursivelyTraverseReconnectPassiveEffects(xe, ye, ve, _e, ge) }K = K.sibling } } function recursivelyTraverseAtomicPassiveEffects(fe, K) { if (K.subtreeFlags & 10256) for (K = K.child; K !== null;) { var pe = fe, me = K, ge = me.flags; switch (me.tag) { case 22: recursivelyTraverseAtomicPassiveEffects(pe, me), ge & 2048 && commitOffscreenPassiveMountEffects(me.alternate, me); break; case 24: recursivelyTraverseAtomicPassiveEffects(pe, me), ge & 2048 && commitCachePassiveMountEffect(me.alternate, me); break; default: recursivelyTraverseAtomicPassiveEffects(pe, me) }K = K.sibling } } var suspenseyCommitFlag = 8192; function recursivelyAccumulateSuspenseyCommit(fe) { if (fe.subtreeFlags & suspenseyCommitFlag) for (fe = fe.child; fe !== null;)accumulateSuspenseyCommitOnFiber(fe), fe = fe.sibling } function accumulateSuspenseyCommitOnFiber(fe) { switch (fe.tag) { case 26: recursivelyAccumulateSuspenseyCommit(fe), fe.flags & suspenseyCommitFlag && fe.memoizedState !== null && suspendResource(currentHoistableRoot, fe.memoizedState, fe.memoizedProps); break; case 5: recursivelyAccumulateSuspenseyCommit(fe); break; case 3: case 4: var K = currentHoistableRoot; currentHoistableRoot = getHoistableRoot(fe.stateNode.containerInfo), recursivelyAccumulateSuspenseyCommit(fe), currentHoistableRoot = K; break; case 22: fe.memoizedState === null && (K = fe.alternate, K !== null && K.memoizedState !== null ? (K = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fe), suspenseyCommitFlag = K) : recursivelyAccumulateSuspenseyCommit(fe)); break; default: recursivelyAccumulateSuspenseyCommit(fe) } } function detachAlternateSiblings(fe) { var K = fe.alternate; if (K !== null && (fe = K.child, fe !== null)) { K.child = null; do K = fe.sibling, fe.sibling = null, fe = K; while (fe !== null) } } function recursivelyTraversePassiveUnmountEffects(fe) { var K = fe.deletions; if (fe.flags & 16) { if (K !== null) for (var pe = 0; pe < K.length; pe++) { var me = K[pe]; nextEffect = me, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(me, fe) } detachAlternateSiblings(fe) } if (fe.subtreeFlags & 10256) for (fe = fe.child; fe !== null;)commitPassiveUnmountOnFiber(fe), fe = fe.sibling } function commitPassiveUnmountOnFiber(fe) { switch (fe.tag) { case 0: case 11: case 15: recursivelyTraversePassiveUnmountEffects(fe), fe.flags & 2048 && commitHookEffectListUnmount(9, fe, fe.return); break; case 3: recursivelyTraversePassiveUnmountEffects(fe); break; case 12: recursivelyTraversePassiveUnmountEffects(fe); break; case 22: var K = fe.stateNode; fe.memoizedState !== null && K._visibility & 4 && (fe.return === null || fe.return.tag !== 13) ? (K._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(fe)) : recursivelyTraversePassiveUnmountEffects(fe); break; default: recursivelyTraversePassiveUnmountEffects(fe) } } function recursivelyTraverseDisconnectPassiveEffects(fe) { var K = fe.deletions; if (fe.flags & 16) { if (K !== null) for (var pe = 0; pe < K.length; pe++) { var me = K[pe]; nextEffect = me, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(me, fe) } detachAlternateSiblings(fe) } for (fe = fe.child; fe !== null;) { switch (K = fe, K.tag) { case 0: case 11: case 15: commitHookEffectListUnmount(8, K, K.return), recursivelyTraverseDisconnectPassiveEffects(K); break; case 22: pe = K.stateNode, pe._visibility & 4 && (pe._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(K)); break; default: recursivelyTraverseDisconnectPassiveEffects(K) }fe = fe.sibling } } function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fe, K) { for (; nextEffect !== null;) { var pe = nextEffect; switch (pe.tag) { case 0: case 11: case 15: commitHookEffectListUnmount(8, pe, K); break; case 23: case 22: if (pe.memoizedState !== null && pe.memoizedState.cachePool !== null) { var me = pe.memoizedState.cachePool.pool; me != null && me.refCount++ } break; case 24: releaseCache(pe.memoizedState.cache) }if (me = pe.child, me !== null) me.return = pe, nextEffect = me; else e: for (pe = fe; nextEffect !== null;) { me = nextEffect; var ge = me.sibling, xe = me.return; if (detachFiberAfterEffects(me), me === pe) { nextEffect = null; break e } if (ge !== null) { ge.return = xe, nextEffect = ge; break e } nextEffect = xe } } } function FiberNode(fe, K, pe, me) { this.tag = fe, this.key = pe, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = K, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = me, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function createFiberImplClass(fe, K, pe, me) { return new FiberNode(fe, K, pe, me) } function shouldConstruct(fe) { return fe = fe.prototype, !(!fe || !fe.isReactComponent) } function createWorkInProgress(fe, K) { var pe = fe.alternate; return pe === null ? (pe = createFiberImplClass(fe.tag, K, fe.key, fe.mode), pe.elementType = fe.elementType, pe.type = fe.type, pe.stateNode = fe.stateNode, pe.alternate = fe, fe.alternate = pe) : (pe.pendingProps = K, pe.type = fe.type, pe.flags = 0, pe.subtreeFlags = 0, pe.deletions = null), pe.flags = fe.flags & 31457280, pe.childLanes = fe.childLanes, pe.lanes = fe.lanes, pe.child = fe.child, pe.memoizedProps = fe.memoizedProps, pe.memoizedState = fe.memoizedState, pe.updateQueue = fe.updateQueue, K = fe.dependencies, pe.dependencies = K === null ? null : { lanes: K.lanes, firstContext: K.firstContext }, pe.sibling = fe.sibling, pe.index = fe.index, pe.ref = fe.ref, pe.refCleanup = fe.refCleanup, pe } function resetWorkInProgress(fe, K) { fe.flags &= 31457282; var pe = fe.alternate; return pe === null ? (fe.childLanes = 0, fe.lanes = K, fe.child = null, fe.subtreeFlags = 0, fe.memoizedProps = null, fe.memoizedState = null, fe.updateQueue = null, fe.dependencies = null, fe.stateNode = null) : (fe.childLanes = pe.childLanes, fe.lanes = pe.lanes, fe.child = pe.child, fe.subtreeFlags = 0, fe.deletions = null, fe.memoizedProps = pe.memoizedProps, fe.memoizedState = pe.memoizedState, fe.updateQueue = pe.updateQueue, fe.type = pe.type, K = pe.dependencies, fe.dependencies = K === null ? null : { lanes: K.lanes, firstContext: K.firstContext }), fe } function createFiberFromTypeAndProps(fe, K, pe, me, ge, xe) { var ye = 0; if (me = fe, typeof fe == "function") shouldConstruct(fe) && (ye = 1); else if (typeof fe == "string") ye = isHostHoistableType(fe, pe, contextStackCursor.current) ? 26 : fe === "html" || fe === "head" || fe === "body" ? 27 : 5; else e: switch (fe) { case REACT_FRAGMENT_TYPE: return createFiberFromFragment(pe.children, ge, xe, K); case REACT_STRICT_MODE_TYPE: ye = 8, ge |= 24; break; case REACT_PROFILER_TYPE: return fe = createFiberImplClass(12, pe, K, ge | 2), fe.elementType = REACT_PROFILER_TYPE, fe.lanes = xe, fe; case REACT_SUSPENSE_TYPE: return fe = createFiberImplClass(13, pe, K, ge), fe.elementType = REACT_SUSPENSE_TYPE, fe.lanes = xe, fe; case REACT_SUSPENSE_LIST_TYPE: return fe = createFiberImplClass(19, pe, K, ge), fe.elementType = REACT_SUSPENSE_LIST_TYPE, fe.lanes = xe, fe; case REACT_OFFSCREEN_TYPE: return createFiberFromOffscreen(pe, ge, xe, K); default: if (typeof fe == "object" && fe !== null) switch (fe.$$typeof) { case REACT_PROVIDER_TYPE: case REACT_CONTEXT_TYPE: ye = 10; break e; case REACT_CONSUMER_TYPE: ye = 9; break e; case REACT_FORWARD_REF_TYPE: ye = 11; break e; case REACT_MEMO_TYPE: ye = 14; break e; case REACT_LAZY_TYPE: ye = 16, me = null; break e }ye = 29, pe = Error(formatProdErrorMessage(130, fe === null ? "null" : typeof fe, "")), me = null }return K = createFiberImplClass(ye, pe, K, ge), K.elementType = fe, K.type = me, K.lanes = xe, K } function createFiberFromFragment(fe, K, pe, me) { return fe = createFiberImplClass(7, fe, me, K), fe.lanes = pe, fe } function createFiberFromOffscreen(fe, K, pe, me) { fe = createFiberImplClass(22, fe, me, K), fe.elementType = REACT_OFFSCREEN_TYPE, fe.lanes = pe; var ge = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function () { var xe = ge._current; if (xe === null) throw Error(formatProdErrorMessage(456)); if (!(ge._pendingVisibility & 2)) { var ye = enqueueConcurrentRenderForLane(xe, 2); ye !== null && (ge._pendingVisibility |= 2, scheduleUpdateOnFiber(ye, xe, 2)) } }, attach: function () { var xe = ge._current; if (xe === null) throw Error(formatProdErrorMessage(456)); if (ge._pendingVisibility & 2) { var ye = enqueueConcurrentRenderForLane(xe, 2); ye !== null && (ge._pendingVisibility &= -3, scheduleUpdateOnFiber(ye, xe, 2)) } } }; return fe.stateNode = ge, fe } function createFiberFromText(fe, K, pe) { return fe = createFiberImplClass(6, fe, null, K), fe.lanes = pe, fe } function createFiberFromPortal(fe, K, pe) { return K = createFiberImplClass(4, fe.children !== null ? fe.children : [], fe.key, K), K.lanes = pe, K.stateNode = { containerInfo: fe.containerInfo, pendingChildren: null, implementation: fe.implementation }, K } function markUpdate(fe) { fe.flags |= 4 } function preloadResourceAndSuspendIfNeeded(fe, K) { if (K.type !== "stylesheet" || K.state.loading & 4) fe.flags &= -16777217; else if (fe.flags |= 16777216, !preloadResource(K)) { if (K = suspenseHandlerStackCursor.current, K !== null && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? shellBoundary !== null : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && !(workInProgressRootRenderLanes & 536870912) || K !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException; fe.flags |= 8192 } } function scheduleRetryEffect(fe, K) { K !== null && (fe.flags |= 4), fe.flags & 16384 && (K = fe.tag !== 22 ? claimNextRetryLane() : 536870912, fe.lanes |= K, workInProgressSuspendedRetryLanes |= K) } function cutOffTailIfNeeded(fe, K) { if (!isHydrating) switch (fe.tailMode) { case "hidden": K = fe.tail; for (var pe = null; K !== null;)K.alternate !== null && (pe = K), K = K.sibling; pe === null ? fe.tail = null : pe.sibling = null; break; case "collapsed": pe = fe.tail; for (var me = null; pe !== null;)pe.alternate !== null && (me = pe), pe = pe.sibling; me === null ? K || fe.tail === null ? fe.tail = null : fe.tail.sibling = null : me.sibling = null } } function bubbleProperties(fe) { var K = fe.alternate !== null && fe.alternate.child === fe.child, pe = 0, me = 0; if (K) for (var ge = fe.child; ge !== null;)pe |= ge.lanes | ge.childLanes, me |= ge.subtreeFlags & 31457280, me |= ge.flags & 31457280, ge.return = fe, ge = ge.sibling; else for (ge = fe.child; ge !== null;)pe |= ge.lanes | ge.childLanes, me |= ge.subtreeFlags, me |= ge.flags, ge.return = fe, ge = ge.sibling; return fe.subtreeFlags |= me, fe.childLanes = pe, K } function completeWork(fe, K, pe) { var me = K.pendingProps; switch (popTreeContext(K), K.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return bubbleProperties(K), null; case 1: return bubbleProperties(K), null; case 3: return pe = K.stateNode, me = null, fe !== null && (me = fe.memoizedState.cache), K.memoizedState.cache !== me && (K.flags |= 2048), popProvider(CacheContext), popHostContainer(), pe.pendingContext && (pe.context = pe.pendingContext, pe.pendingContext = null), (fe === null || fe.child === null) && (popHydrationState(K) ? markUpdate(K) : fe === null || fe.memoizedState.isDehydrated && !(K.flags & 256) || (K.flags |= 1024, hydrationErrors !== null && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null))), bubbleProperties(K), null; case 26: return pe = K.memoizedState, fe === null ? (markUpdate(K), pe !== null ? (bubbleProperties(K), preloadResourceAndSuspendIfNeeded(K, pe)) : (bubbleProperties(K), K.flags &= -16777217)) : pe ? pe !== fe.memoizedState ? (markUpdate(K), bubbleProperties(K), preloadResourceAndSuspendIfNeeded(K, pe)) : (bubbleProperties(K), K.flags &= -16777217) : (fe.memoizedProps !== me && markUpdate(K), bubbleProperties(K), K.flags &= -16777217), null; case 27: popHostContext(K), pe = rootInstanceStackCursor.current; var ge = K.type; if (fe !== null && K.stateNode != null) fe.memoizedProps !== me && markUpdate(K); else { if (!me) { if (K.stateNode === null) throw Error(formatProdErrorMessage(166)); return bubbleProperties(K), null } fe = contextStackCursor.current, popHydrationState(K) ? prepareToHydrateHostInstance(K) : (fe = resolveSingletonInstance(ge, me, pe), K.stateNode = fe, markUpdate(K)) } return bubbleProperties(K), null; case 5: if (popHostContext(K), pe = K.type, fe !== null && K.stateNode != null) fe.memoizedProps !== me && markUpdate(K); else { if (!me) { if (K.stateNode === null) throw Error(formatProdErrorMessage(166)); return bubbleProperties(K), null } if (fe = contextStackCursor.current, popHydrationState(K)) prepareToHydrateHostInstance(K); else { switch (ge = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current), fe) { case 1: fe = ge.createElementNS("http://www.w3.org/2000/svg", pe); break; case 2: fe = ge.createElementNS("http://www.w3.org/1998/Math/MathML", pe); break; default: switch (pe) { case "svg": fe = ge.createElementNS("http://www.w3.org/2000/svg", pe); break; case "math": fe = ge.createElementNS("http://www.w3.org/1998/Math/MathML", pe); break; case "script": fe = ge.createElement("div"), fe.innerHTML = "<script><\/script>", fe = fe.removeChild(fe.firstChild); break; case "select": fe = typeof me.is == "string" ? ge.createElement("select", { is: me.is }) : ge.createElement("select"), me.multiple ? fe.multiple = !0 : me.size && (fe.size = me.size); break; default: fe = typeof me.is == "string" ? ge.createElement(pe, { is: me.is }) : ge.createElement(pe) } }fe[internalInstanceKey] = K, fe[internalPropsKey] = me; e: for (ge = K.child; ge !== null;) { if (ge.tag === 5 || ge.tag === 6) fe.appendChild(ge.stateNode); else if (ge.tag !== 4 && ge.tag !== 27 && ge.child !== null) { ge.child.return = ge, ge = ge.child; continue } if (ge === K) break e; for (; ge.sibling === null;) { if (ge.return === null || ge.return === K) break e; ge = ge.return } ge.sibling.return = ge.return, ge = ge.sibling } K.stateNode = fe; e: switch (setInitialProperties(fe, pe, me), pe) { case "button": case "input": case "select": case "textarea": fe = !!me.autoFocus; break e; case "img": fe = !0; break e; default: fe = !1 }fe && markUpdate(K) } } return bubbleProperties(K), K.flags &= -16777217, null; case 6: if (fe && K.stateNode != null) fe.memoizedProps !== me && markUpdate(K); else { if (typeof me != "string" && K.stateNode === null) throw Error(formatProdErrorMessage(166)); if (fe = rootInstanceStackCursor.current, popHydrationState(K)) { if (fe = K.stateNode, pe = K.memoizedProps, me = null, ge = hydrationParentFiber, ge !== null) switch (ge.tag) { case 27: case 5: me = ge.memoizedProps }fe[internalInstanceKey] = K, fe = !!(fe.nodeValue === pe || me !== null && me.suppressHydrationWarning === !0 || checkForUnmatchedText(fe.nodeValue, pe)), fe || throwOnHydrationMismatch(K) } else fe = getOwnerDocumentFromRootContainer(fe).createTextNode(me), fe[internalInstanceKey] = K, K.stateNode = fe } return bubbleProperties(K), null; case 13: if (me = K.memoizedState, fe === null || fe.memoizedState !== null && fe.memoizedState.dehydrated !== null) { if (ge = popHydrationState(K), me !== null && me.dehydrated !== null) { if (fe === null) { if (!ge) throw Error(formatProdErrorMessage(318)); if (ge = K.memoizedState, ge = ge !== null ? ge.dehydrated : null, !ge) throw Error(formatProdErrorMessage(317)); ge[internalInstanceKey] = K } else resetHydrationState(), !(K.flags & 128) && (K.memoizedState = null), K.flags |= 4; bubbleProperties(K), ge = !1 } else hydrationErrors !== null && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), ge = !0; if (!ge) return K.flags & 256 ? (popSuspenseHandler(K), K) : (popSuspenseHandler(K), null) } if (popSuspenseHandler(K), K.flags & 128) return K.lanes = pe, K; if (pe = me !== null, fe = fe !== null && fe.memoizedState !== null, pe) { me = K.child, ge = null, me.alternate !== null && me.alternate.memoizedState !== null && me.alternate.memoizedState.cachePool !== null && (ge = me.alternate.memoizedState.cachePool.pool); var xe = null; me.memoizedState !== null && me.memoizedState.cachePool !== null && (xe = me.memoizedState.cachePool.pool), xe !== ge && (me.flags |= 2048) } return pe !== fe && pe && (K.child.flags |= 8192), scheduleRetryEffect(K, K.updateQueue), bubbleProperties(K), null; case 4: return popHostContainer(), fe === null && listenToAllSupportedEvents(K.stateNode.containerInfo), bubbleProperties(K), null; case 10: return popProvider(K.type), bubbleProperties(K), null; case 19: if (pop(suspenseStackCursor), ge = K.memoizedState, ge === null) return bubbleProperties(K), null; if (me = (K.flags & 128) !== 0, xe = ge.rendering, xe === null) if (me) cutOffTailIfNeeded(ge, !1); else { if (workInProgressRootExitStatus !== 0 || fe !== null && fe.flags & 128) for (fe = K.child; fe !== null;) { if (xe = findFirstSuspended(fe), xe !== null) { for (K.flags |= 128, cutOffTailIfNeeded(ge, !1), fe = xe.updateQueue, K.updateQueue = fe, scheduleRetryEffect(K, fe), K.subtreeFlags = 0, fe = pe, pe = K.child; pe !== null;)resetWorkInProgress(pe, fe), pe = pe.sibling; return push$1(suspenseStackCursor, suspenseStackCursor.current & 1 | 2), K.child } fe = fe.sibling } ge.tail !== null && now$1() > workInProgressRootRenderTargetTime && (K.flags |= 128, me = !0, cutOffTailIfNeeded(ge, !1), K.lanes = 4194304) } else { if (!me) if (fe = findFirstSuspended(xe), fe !== null) { if (K.flags |= 128, me = !0, fe = fe.updateQueue, K.updateQueue = fe, scheduleRetryEffect(K, fe), cutOffTailIfNeeded(ge, !0), ge.tail === null && ge.tailMode === "hidden" && !xe.alternate && !isHydrating) return bubbleProperties(K), null } else 2 * now$1() - ge.renderingStartTime > workInProgressRootRenderTargetTime && pe !== 536870912 && (K.flags |= 128, me = !0, cutOffTailIfNeeded(ge, !1), K.lanes = 4194304); ge.isBackwards ? (xe.sibling = K.child, K.child = xe) : (fe = ge.last, fe !== null ? fe.sibling = xe : K.child = xe, ge.last = xe) } return ge.tail !== null ? (K = ge.tail, ge.rendering = K, ge.tail = K.sibling, ge.renderingStartTime = now$1(), K.sibling = null, fe = suspenseStackCursor.current, push$1(suspenseStackCursor, me ? fe & 1 | 2 : fe & 1), K) : (bubbleProperties(K), null); case 22: case 23: return popSuspenseHandler(K), popHiddenContext(), me = K.memoizedState !== null, fe !== null ? fe.memoizedState !== null !== me && (K.flags |= 8192) : me && (K.flags |= 8192), me ? pe & 536870912 && !(K.flags & 128) && (bubbleProperties(K), K.subtreeFlags & 6 && (K.flags |= 8192)) : bubbleProperties(K), pe = K.updateQueue, pe !== null && scheduleRetryEffect(K, pe.retryQueue), pe = null, fe !== null && fe.memoizedState !== null && fe.memoizedState.cachePool !== null && (pe = fe.memoizedState.cachePool.pool), me = null, K.memoizedState !== null && K.memoizedState.cachePool !== null && (me = K.memoizedState.cachePool.pool), me !== pe && (K.flags |= 2048), fe !== null && pop(resumedCache), null; case 24: return pe = null, fe !== null && (pe = fe.memoizedState.cache), K.memoizedState.cache !== pe && (K.flags |= 2048), popProvider(CacheContext), bubbleProperties(K), null; case 25: return null }throw Error(formatProdErrorMessage(156, K.tag)) } function unwindWork(fe, K) { switch (popTreeContext(K), K.tag) { case 1: return fe = K.flags, fe & 65536 ? (K.flags = fe & -65537 | 128, K) : null; case 3: return popProvider(CacheContext), popHostContainer(), fe = K.flags, fe & 65536 && !(fe & 128) ? (K.flags = fe & -65537 | 128, K) : null; case 26: case 27: case 5: return popHostContext(K), null; case 13: if (popSuspenseHandler(K), fe = K.memoizedState, fe !== null && fe.dehydrated !== null) { if (K.alternate === null) throw Error(formatProdErrorMessage(340)); resetHydrationState() } return fe = K.flags, fe & 65536 ? (K.flags = fe & -65537 | 128, K) : null; case 19: return pop(suspenseStackCursor), null; case 4: return popHostContainer(), null; case 10: return popProvider(K.type), null; case 22: case 23: return popSuspenseHandler(K), popHiddenContext(), fe !== null && pop(resumedCache), fe = K.flags, fe & 65536 ? (K.flags = fe & -65537 | 128, K) : null; case 24: return popProvider(CacheContext), null; case 25: return null; default: return null } } function unwindInterruptedWork(fe, K) { switch (popTreeContext(K), K.tag) { case 3: popProvider(CacheContext), popHostContainer(); break; case 26: case 27: case 5: popHostContext(K); break; case 4: popHostContainer(); break; case 13: popSuspenseHandler(K); break; case 19: pop(suspenseStackCursor); break; case 10: popProvider(K.type); break; case 22: case 23: popSuspenseHandler(K), popHiddenContext(), fe !== null && pop(resumedCache); break; case 24: popProvider(CacheContext) } } var DefaultAsyncDispatcher = { getCacheForType: function (fe) { var K = readContext(CacheContext), pe = K.data.get(fe); return pe === void 0 && (pe = fe(), K.data.set(fe, pe)), pe } }, PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = 1 / 0, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, nestedUpdateCount = 0, rootWithNestedUpdates = null; function requestUpdateLane() { if (executionContext & 2 && workInProgressRootRenderLanes !== 0) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes; if (ReactSharedInternals.T !== null) { var fe = currentEntangledLane; return fe !== 0 ? fe : requestTransitionLane() } return resolveUpdatePriority() } function requestDeferredLane() { workInProgressDeferredLane === 0 && (workInProgressDeferredLane = !(workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912); var fe = suspenseHandlerStackCursor.current; return fe !== null && (fe.flags |= 32), workInProgressDeferredLane } function scheduleUpdateOnFiber(fe, K, pe) { (fe === workInProgressRoot && workInProgressSuspendedReason === 2 || fe.cancelPendingCommit !== null) && (prepareFreshStack(fe, 0), markRootSuspended(fe, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), markRootUpdated$1(fe, pe), (!(executionContext & 2) || fe !== workInProgressRoot) && (fe === workInProgressRoot && (!(executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= pe), workInProgressRootExitStatus === 4 && markRootSuspended(fe, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(fe)) } function performWorkOnRoot(fe, K, pe) { if (executionContext & 6) throw Error(formatProdErrorMessage(327)); var me = !pe && (K & 60) === 0 && (K & fe.expiredLanes) === 0 || checkIfRootIsPrerendering(fe, K), ge = me ? renderRootConcurrent(fe, K) : renderRootSync(fe, K, !0), xe = me; do { if (ge === 0) { workInProgressRootIsPrerendering && !me && markRootSuspended(fe, K, 0, !1); break } else if (ge === 6) markRootSuspended(fe, K, 0, !workInProgressRootDidSkipSuspendedSiblings); else { if (pe = fe.current.alternate, xe && !isRenderConsistentWithExternalStores(pe)) { ge = renderRootSync(fe, K, !1), xe = !1; continue } if (ge === 2) { if (xe = K, fe.errorRecoveryDisabledLanes & xe) var ye = 0; else ye = fe.pendingLanes & -536870913, ye = ye !== 0 ? ye : ye & 536870912 ? 536870912 : 0; if (ye !== 0) { K = ye; e: { var ve = fe; ge = workInProgressRootConcurrentErrors; var _e = ve.current.memoizedState.isDehydrated; if (_e && (prepareFreshStack(ve, ye).flags |= 256), ye = renderRootSync(ve, ye, !1), ye !== 2) { if (workInProgressRootDidAttachPingListener && !_e) { ve.errorRecoveryDisabledLanes |= xe, workInProgressRootInterleavedUpdatedLanes |= xe, ge = 4; break e } xe = workInProgressRootRecoverableErrors, workInProgressRootRecoverableErrors = ge, xe !== null && queueRecoverableErrors(xe) } ge = ye } if (xe = !1, ge !== 2) continue } } if (ge === 1) { prepareFreshStack(fe, 0), markRootSuspended(fe, K, 0, !0); break } e: { switch (me = fe, ge) { case 0: case 1: throw Error(formatProdErrorMessage(345)); case 4: if ((K & 4194176) === K) { markRootSuspended(me, K, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings); break e } break; case 2: workInProgressRootRecoverableErrors = null; break; case 3: case 5: break; default: throw Error(formatProdErrorMessage(329)) }if (me.finishedWork = pe, me.finishedLanes = K, (K & 62914560) === K && (xe = globalMostRecentFallbackTime + 300 - now$1(), 10 < xe)) { if (markRootSuspended(me, K, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings), getNextLanes(me, 0) !== 0) break e; me.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, me, pe, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, K, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, 2, -0, 0), xe); break e } commitRootWhenReady(me, pe, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, K, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, 0, -0, 0) } } break } while (!0); ensureRootIsScheduled(fe) } function queueRecoverableErrors(fe) { workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = fe : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, fe) } function commitRootWhenReady(fe, K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se) { var Ce = K.subtreeFlags; if ((Ce & 8192 || (Ce & 16785408) === 16785408) && (suspendedState = { stylesheets: null, count: 0, unsuspend: noop$5 }, accumulateSuspenseyCommitOnFiber(K), K = waitForCommitToBeReady(), K !== null)) { fe.cancelPendingCommit = K(commitRoot.bind(null, fe, pe, me, ge, ye, ve, _e, 1, Ae, Se)), markRootSuspended(fe, xe, ye, !Ee); return } commitRoot(fe, pe, me, ge, ye, ve, _e, be, Ae, Se) } function isRenderConsistentWithExternalStores(fe) { for (var K = fe; ;) { var pe = K.tag; if ((pe === 0 || pe === 11 || pe === 15) && K.flags & 16384 && (pe = K.updateQueue, pe !== null && (pe = pe.stores, pe !== null))) for (var me = 0; me < pe.length; me++) { var ge = pe[me], xe = ge.getSnapshot; ge = ge.value; try { if (!objectIs$2(xe(), ge)) return !1 } catch { return !1 } } if (pe = K.child, K.subtreeFlags & 16384 && pe !== null) pe.return = K, K = pe; else { if (K === fe) break; for (; K.sibling === null;) { if (K.return === null || K.return === fe) return !0; K = K.return } K.sibling.return = K.return, K = K.sibling } } return !0 } function markRootSuspended(fe, K, pe, me) { K &= ~workInProgressRootPingedLanes, K &= ~workInProgressRootInterleavedUpdatedLanes, fe.suspendedLanes |= K, fe.pingedLanes &= ~K, me && (fe.warmLanes |= K), me = fe.expirationTimes; for (var ge = K; 0 < ge;) { var xe = 31 - clz32(ge), ye = 1 << xe; me[xe] = -1, ge &= ~ye } pe !== 0 && markSpawnedDeferredLane(fe, pe, K) } function flushSyncWork$1() { return executionContext & 6 ? !0 : (flushSyncWorkAcrossRoots_impl(0), !1) } function resetWorkInProgressStack() { if (workInProgress !== null) { if (workInProgressSuspendedReason === 0) var fe = workInProgress.return; else fe = workInProgress, lastContextDependency = currentlyRenderingFiber = null, resetHooksOnUnwind(fe), thenableState$1 = null, thenableIndexCounter$1 = 0, fe = workInProgress; for (; fe !== null;)unwindInterruptedWork(fe.alternate, fe), fe = fe.return; workInProgress = null } } function prepareFreshStack(fe, K) { fe.finishedWork = null, fe.finishedLanes = 0; var pe = fe.timeoutHandle; pe !== -1 && (fe.timeoutHandle = -1, cancelTimeout(pe)), pe = fe.cancelPendingCommit, pe !== null && (fe.cancelPendingCommit = null, pe()), resetWorkInProgressStack(), workInProgressRoot = fe, workInProgress = pe = createWorkInProgress(fe.current, null), workInProgressRootRenderLanes = K, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = checkIfRootIsPrerendering(fe, K), workInProgressRootDidAttachPingListener = !1, workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0, workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, K & 8 && (K |= K & 32); var me = fe.entangledLanes; if (me !== 0) for (fe = fe.entanglements, me &= K; 0 < me;) { var ge = 31 - clz32(me), xe = 1 << ge; K |= fe[ge], me &= ~xe } return entangledRenderLanes = K, finishQueueingConcurrentUpdates(), pe } function handleThrow(fe, K) { currentlyRenderingFiber$1 = null, ReactSharedInternals.H = ContextOnlyDispatcher, K === SuspenseException ? (K = getSuspendedThenable(), workInProgressSuspendedReason = 3) : K === SuspenseyCommitException ? (K = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = K === SelectiveHydrationException ? 8 : K !== null && typeof K == "object" && typeof K.then == "function" ? 6 : 1, workInProgressThrownValue = K, workInProgress === null && (workInProgressRootExitStatus = 1, logUncaughtError(fe, createCapturedValueAtFiber(K, fe.current))) } function pushDispatcher() { var fe = ReactSharedInternals.H; return ReactSharedInternals.H = ContextOnlyDispatcher, fe === null ? ContextOnlyDispatcher : fe } function pushAsyncDispatcher() { var fe = ReactSharedInternals.A; return ReactSharedInternals.A = DefaultAsyncDispatcher, fe } function renderDidSuspendDelayIfPossible() { workInProgressRootExitStatus = 4, workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = !0), !(workInProgressRootSkippedLanes & 134217727) && !(workInProgressRootInterleavedUpdatedLanes & 134217727) || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1) } function renderRootSync(fe, K, pe) { var me = executionContext; executionContext |= 2; var ge = pushDispatcher(), xe = pushAsyncDispatcher(); (workInProgressRoot !== fe || workInProgressRootRenderLanes !== K) && (workInProgressTransitions = null, prepareFreshStack(fe, K)), K = !1; var ye = workInProgressRootExitStatus; e: do try { if (workInProgressSuspendedReason !== 0 && workInProgress !== null) { var ve = workInProgress, _e = workInProgressThrownValue; switch (workInProgressSuspendedReason) { case 8: resetWorkInProgressStack(), ye = 6; break e; case 3: case 2: case 6: suspenseHandlerStackCursor.current === null && (K = !0); var Ee = workInProgressSuspendedReason; if (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, ve, _e, Ee), pe && workInProgressRootIsPrerendering) { ye = 0; break e } break; default: Ee = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, ve, _e, Ee) } } workLoopSync(), ye = workInProgressRootExitStatus; break } catch (be) { handleThrow(fe, be) } while (!0); return K && fe.shellSuspendCounter++, lastContextDependency = currentlyRenderingFiber = null, executionContext = me, ReactSharedInternals.H = ge, ReactSharedInternals.A = xe, workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates()), ye } function workLoopSync() { for (; workInProgress !== null;)performUnitOfWork(workInProgress) } function renderRootConcurrent(fe, K) { var pe = executionContext; executionContext |= 2; var me = pushDispatcher(), ge = pushAsyncDispatcher(); workInProgressRoot !== fe || workInProgressRootRenderLanes !== K ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now$1() + 500, prepareFreshStack(fe, K)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(fe, K); e: do try { if (workInProgressSuspendedReason !== 0 && workInProgress !== null) { K = workInProgress; var xe = workInProgressThrownValue; t: switch (workInProgressSuspendedReason) { case 1: workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, K, xe, 1); break; case 2: if (isThenableResolved(xe)) { workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(K); break } K = function () { workInProgressSuspendedReason === 2 && workInProgressRoot === fe && (workInProgressSuspendedReason = 7), ensureRootIsScheduled(fe) }, xe.then(K, K); break e; case 3: workInProgressSuspendedReason = 7; break e; case 4: workInProgressSuspendedReason = 5; break e; case 7: isThenableResolved(xe) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(K)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, K, xe, 7)); break; case 5: var ye = null; switch (workInProgress.tag) { case 26: ye = workInProgress.memoizedState; case 5: case 27: var ve = workInProgress; if (!ye || preloadResource(ye)) { workInProgressSuspendedReason = 0, workInProgressThrownValue = null; var _e = ve.sibling; if (_e !== null) workInProgress = _e; else { var Ee = ve.return; Ee !== null ? (workInProgress = Ee, completeUnitOfWork(Ee)) : workInProgress = null } break t } }workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, K, xe, 5); break; case 6: workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(fe, K, xe, 6); break; case 8: resetWorkInProgressStack(), workInProgressRootExitStatus = 6; break e; default: throw Error(formatProdErrorMessage(462)) } } workLoopConcurrent(); break } catch (be) { handleThrow(fe, be) } while (!0); return lastContextDependency = currentlyRenderingFiber = null, ReactSharedInternals.H = me, ReactSharedInternals.A = ge, executionContext = pe, workInProgress !== null ? 0 : (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates(), workInProgressRootExitStatus) } function workLoopConcurrent() { for (; workInProgress !== null && !shouldYield();)performUnitOfWork(workInProgress) } function performUnitOfWork(fe) { var K = beginWork(fe.alternate, fe, entangledRenderLanes); fe.memoizedProps = fe.pendingProps, K === null ? completeUnitOfWork(fe) : workInProgress = K } function replaySuspendedUnitOfWork(fe) { var K = fe, pe = K.alternate; switch (K.tag) { case 15: case 0: K = replayFunctionComponent(pe, K, K.pendingProps, K.type, void 0, workInProgressRootRenderLanes); break; case 11: K = replayFunctionComponent(pe, K, K.pendingProps, K.type.render, K.ref, workInProgressRootRenderLanes); break; case 5: resetHooksOnUnwind(K); default: unwindInterruptedWork(pe, K), K = workInProgress = resetWorkInProgress(K, entangledRenderLanes), K = beginWork(pe, K, entangledRenderLanes) }fe.memoizedProps = fe.pendingProps, K === null ? completeUnitOfWork(fe) : workInProgress = K } function throwAndUnwindWorkLoop(fe, K, pe, me) { lastContextDependency = currentlyRenderingFiber = null, resetHooksOnUnwind(K), thenableState$1 = null, thenableIndexCounter$1 = 0; var ge = K.return; try { if (throwException(fe, ge, K, pe, workInProgressRootRenderLanes)) { workInProgressRootExitStatus = 1, logUncaughtError(fe, createCapturedValueAtFiber(pe, fe.current)), workInProgress = null; return } } catch (xe) { if (ge !== null) throw workInProgress = ge, xe; workInProgressRootExitStatus = 1, logUncaughtError(fe, createCapturedValueAtFiber(pe, fe.current)), workInProgress = null; return } K.flags & 32768 ? (isHydrating || me === 1 ? fe = !0 : workInProgressRootIsPrerendering || workInProgressRootRenderLanes & 536870912 ? fe = !1 : (workInProgressRootDidSkipSuspendedSiblings = fe = !0, (me === 2 || me === 3 || me === 6) && (me = suspenseHandlerStackCursor.current, me !== null && me.tag === 13 && (me.flags |= 16384))), unwindUnitOfWork(K, fe)) : completeUnitOfWork(K) } function completeUnitOfWork(fe) { var K = fe; do { if (K.flags & 32768) { unwindUnitOfWork(K, workInProgressRootDidSkipSuspendedSiblings); return } fe = K.return; var pe = completeWork(K.alternate, K, entangledRenderLanes); if (pe !== null) { workInProgress = pe; return } if (K = K.sibling, K !== null) { workInProgress = K; return } workInProgress = K = fe } while (K !== null); workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 5) } function unwindUnitOfWork(fe, K) { do { var pe = unwindWork(fe.alternate, fe); if (pe !== null) { pe.flags &= 32767, workInProgress = pe; return } if (pe = fe.return, pe !== null && (pe.flags |= 32768, pe.subtreeFlags = 0, pe.deletions = null), !K && (fe = fe.sibling, fe !== null)) { workInProgress = fe; return } workInProgress = fe = pe } while (fe !== null); workInProgressRootExitStatus = 6, workInProgress = null } function commitRoot(fe, K, pe, me, ge, xe, ye, ve, _e, Ee) { var be = ReactSharedInternals.T, Ae = ReactDOMSharedInternals.p; try { ReactDOMSharedInternals.p = 2, ReactSharedInternals.T = null, commitRootImpl(fe, K, pe, me, Ae, ge, xe, ye, ve, _e, Ee) } finally { ReactSharedInternals.T = be, ReactDOMSharedInternals.p = Ae } } function commitRootImpl(fe, K, pe, me, ge, xe, ye, ve) { do flushPassiveEffects(); while (rootWithPendingPassiveEffects !== null); if (executionContext & 6) throw Error(formatProdErrorMessage(327)); var _e = fe.finishedWork; if (me = fe.finishedLanes, _e === null) return null; if (fe.finishedWork = null, fe.finishedLanes = 0, _e === fe.current) throw Error(formatProdErrorMessage(177)); fe.callbackNode = null, fe.callbackPriority = 0, fe.cancelPendingCommit = null; var Ee = _e.lanes | _e.childLanes; if (Ee |= concurrentlyUpdatedLanes, markRootFinished(fe, me, Ee, xe, ye, ve), fe === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0), !(_e.subtreeFlags & 10256) && !(_e.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = Ee, pendingPassiveTransitions = pe, scheduleCallback$1(NormalPriority$1, function () { return flushPassiveEffects(), null })), pe = (_e.flags & 15990) !== 0, _e.subtreeFlags & 15990 || pe ? (pe = ReactSharedInternals.T, ReactSharedInternals.T = null, xe = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = 2, ye = executionContext, executionContext |= 4, commitBeforeMutationEffects(fe, _e), commitMutationEffectsOnFiber(_e, fe), restoreSelection(selectionInformation, fe.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, fe.current = _e, commitLayoutEffectOnFiber(fe, _e.alternate, _e), requestPaint(), executionContext = ye, ReactDOMSharedInternals.p = xe, ReactSharedInternals.T = pe) : fe.current = _e, rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = fe, pendingPassiveEffectsLanes = me) : releaseRootPooledCache(fe, Ee), Ee = fe.pendingLanes, Ee === 0 && (legacyErrorBoundariesThatAlreadyFailed = null), onCommitRoot(_e.stateNode), ensureRootIsScheduled(fe), K !== null) for (ge = fe.onRecoverableError, _e = 0; _e < K.length; _e++)Ee = K[_e], ge(Ee.value, { componentStack: Ee.stack }); return pendingPassiveEffectsLanes & 3 && flushPassiveEffects(), Ee = fe.pendingLanes, me & 4194218 && Ee & 42 ? fe === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = fe) : nestedUpdateCount = 0, flushSyncWorkAcrossRoots_impl(0), null } function releaseRootPooledCache(fe, K) { (fe.pooledCacheLanes &= K) === 0 && (K = fe.pooledCache, K != null && (fe.pooledCache = null, releaseCache(K))) } function flushPassiveEffects() { if (rootWithPendingPassiveEffects !== null) { var fe = rootWithPendingPassiveEffects, K = pendingPassiveEffectsRemainingLanes; pendingPassiveEffectsRemainingLanes = 0; var pe = lanesToEventPriority(pendingPassiveEffectsLanes), me = ReactSharedInternals.T, ge = ReactDOMSharedInternals.p; try { if (ReactDOMSharedInternals.p = 32 > pe ? 32 : pe, ReactSharedInternals.T = null, rootWithPendingPassiveEffects === null) var xe = !1; else { pe = pendingPassiveTransitions, pendingPassiveTransitions = null; var ye = rootWithPendingPassiveEffects, ve = pendingPassiveEffectsLanes; if (rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, executionContext & 6) throw Error(formatProdErrorMessage(331)); var _e = executionContext; if (executionContext |= 4, commitPassiveUnmountOnFiber(ye.current), commitPassiveMountOnFiber(ye, ye.current, ve, pe), executionContext = _e, flushSyncWorkAcrossRoots_impl(0, !1), injectedHook && typeof injectedHook.onPostCommitFiberRoot == "function") try { injectedHook.onPostCommitFiberRoot(rendererID, ye) } catch { } xe = !0 } return xe } finally { ReactDOMSharedInternals.p = ge, ReactSharedInternals.T = me, releaseRootPooledCache(fe, K) } } return !1 } function captureCommitPhaseErrorOnRoot(fe, K, pe) { K = createCapturedValueAtFiber(pe, K), K = createRootErrorUpdate(fe.stateNode, K, 2), fe = enqueueUpdate(fe, K, 2), fe !== null && (markRootUpdated$1(fe, 2), ensureRootIsScheduled(fe)) } function captureCommitPhaseError(fe, K, pe) { if (fe.tag === 3) captureCommitPhaseErrorOnRoot(fe, fe, pe); else for (; K !== null;) { if (K.tag === 3) { captureCommitPhaseErrorOnRoot(K, fe, pe); break } else if (K.tag === 1) { var me = K.stateNode; if (typeof K.type.getDerivedStateFromError == "function" || typeof me.componentDidCatch == "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(me))) { fe = createCapturedValueAtFiber(pe, fe), pe = createClassErrorUpdate(2), me = enqueueUpdate(K, pe, 2), me !== null && (initializeClassErrorUpdate(pe, me, K, fe), markRootUpdated$1(me, 2), ensureRootIsScheduled(me)); break } } K = K.return } } function attachPingListener(fe, K, pe) { var me = fe.pingCache; if (me === null) { me = fe.pingCache = new PossiblyWeakMap; var ge = new Set; me.set(K, ge) } else ge = me.get(K), ge === void 0 && (ge = new Set, me.set(K, ge)); ge.has(pe) || (workInProgressRootDidAttachPingListener = !0, ge.add(pe), fe = pingSuspendedRoot.bind(null, fe, K, pe), K.then(fe, fe)) } function pingSuspendedRoot(fe, K, pe) { var me = fe.pingCache; me !== null && me.delete(K), fe.pingedLanes |= fe.suspendedLanes & pe, fe.warmLanes &= ~pe, workInProgressRoot === fe && (workInProgressRootRenderLanes & pe) === pe && (workInProgressRootExitStatus === 4 || workInProgressRootExitStatus === 3 && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now$1() - globalMostRecentFallbackTime ? !(executionContext & 2) && prepareFreshStack(fe, 0) : workInProgressRootPingedLanes |= pe, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0)), ensureRootIsScheduled(fe) } function retryTimedOutBoundary(fe, K) { K === 0 && (K = claimNextRetryLane()), fe = enqueueConcurrentRenderForLane(fe, K), fe !== null && (markRootUpdated$1(fe, K), ensureRootIsScheduled(fe)) } function retryDehydratedSuspenseBoundary(fe) { var K = fe.memoizedState, pe = 0; K !== null && (pe = K.retryLane), retryTimedOutBoundary(fe, pe) } function resolveRetryWakeable(fe, K) { var pe = 0; switch (fe.tag) { case 13: var me = fe.stateNode, ge = fe.memoizedState; ge !== null && (pe = ge.retryLane); break; case 19: me = fe.stateNode; break; case 22: me = fe.stateNode._retryCache; break; default: throw Error(formatProdErrorMessage(314)) }me !== null && me.delete(K), retryTimedOutBoundary(fe, pe) } function scheduleCallback$1(fe, K) { return scheduleCallback$3(fe, K) } var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0; function ensureRootIsScheduled(fe) { fe !== lastScheduledRoot && fe.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = fe : lastScheduledRoot = lastScheduledRoot.next = fe), mightHavePendingSyncWork = !0, didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) } function flushSyncWorkAcrossRoots_impl(fe, K) { if (!isFlushingWork && mightHavePendingSyncWork) { isFlushingWork = !0; do for (var pe = !1, me = firstScheduledRoot; me !== null;) { if (fe !== 0) { var ge = me.pendingLanes; if (ge === 0) var xe = 0; else { var ye = me.suspendedLanes, ve = me.pingedLanes; xe = (1 << 31 - clz32(42 | fe) + 1) - 1, xe &= ge & ~(ye & ~ve), xe = xe & 201326677 ? xe & 201326677 | 1 : xe ? xe | 2 : 0 } xe !== 0 && (pe = !0, performSyncWorkOnRoot(me, xe)) } else xe = workInProgressRootRenderLanes, xe = getNextLanes(me, me === workInProgressRoot ? xe : 0), !(xe & 3) || checkIfRootIsPrerendering(me, xe) || (pe = !0, performSyncWorkOnRoot(me, xe)); me = me.next } while (pe); isFlushingWork = !1 } } function processRootScheduleInMicrotask() { mightHavePendingSyncWork = didScheduleMicrotask = !1; var fe = 0; currentEventTransitionLane !== 0 && (shouldAttemptEagerTransition() && (fe = currentEventTransitionLane), currentEventTransitionLane = 0); for (var K = now$1(), pe = null, me = firstScheduledRoot; me !== null;) { var ge = me.next, xe = scheduleTaskForRootDuringMicrotask(me, K); xe === 0 ? (me.next = null, pe === null ? firstScheduledRoot = ge : pe.next = ge, ge === null && (lastScheduledRoot = pe)) : (pe = me, (fe !== 0 || xe & 3) && (mightHavePendingSyncWork = !0)), me = ge } flushSyncWorkAcrossRoots_impl(fe) } function scheduleTaskForRootDuringMicrotask(fe, K) { for (var pe = fe.suspendedLanes, me = fe.pingedLanes, ge = fe.expirationTimes, xe = fe.pendingLanes & -62914561; 0 < xe;) { var ye = 31 - clz32(xe), ve = 1 << ye, _e = ge[ye]; _e === -1 ? (!(ve & pe) || ve & me) && (ge[ye] = computeExpirationTime(ve, K)) : _e <= K && (fe.expiredLanes |= ve), xe &= ~ve } if (K = workInProgressRoot, pe = workInProgressRootRenderLanes, pe = getNextLanes(fe, fe === K ? pe : 0), me = fe.callbackNode, pe === 0 || fe === K && workInProgressSuspendedReason === 2 || fe.cancelPendingCommit !== null) return me !== null && me !== null && cancelCallback$1(me), fe.callbackNode = null, fe.callbackPriority = 0; if (!(pe & 3) || checkIfRootIsPrerendering(fe, pe)) { if (K = pe & -pe, K === fe.callbackPriority) return K; switch (me !== null && cancelCallback$1(me), lanesToEventPriority(pe)) { case 2: case 8: pe = UserBlockingPriority; break; case 32: pe = NormalPriority$1; break; case 268435456: pe = IdlePriority; break; default: pe = NormalPriority$1 }return me = performWorkOnRootViaSchedulerTask.bind(null, fe), pe = scheduleCallback$3(pe, me), fe.callbackPriority = K, fe.callbackNode = pe, K } return me !== null && me !== null && cancelCallback$1(me), fe.callbackPriority = 2, fe.callbackNode = null, 2 } function performWorkOnRootViaSchedulerTask(fe, K) { var pe = fe.callbackNode; if (flushPassiveEffects() && fe.callbackNode !== pe) return null; var me = workInProgressRootRenderLanes; return me = getNextLanes(fe, fe === workInProgressRoot ? me : 0), me === 0 ? null : (performWorkOnRoot(fe, me, K), scheduleTaskForRootDuringMicrotask(fe, now$1()), fe.callbackNode != null && fe.callbackNode === pe ? performWorkOnRootViaSchedulerTask.bind(null, fe) : null) } function performSyncWorkOnRoot(fe, K) { if (flushPassiveEffects()) return null; performWorkOnRoot(fe, K, !0) } function scheduleImmediateTask(fe) { scheduleMicrotask(function () { executionContext & 6 ? scheduleCallback$3(ImmediatePriority, fe) : fe() }) } function requestTransitionLane() { return currentEventTransitionLane === 0 && (currentEventTransitionLane = claimNextTransitionLane()), currentEventTransitionLane } function coerceFormActionProp(fe) { return fe == null || typeof fe == "symbol" || typeof fe == "boolean" ? null : typeof fe == "function" ? fe : sanitizeURL("" + fe) } function createFormDataWithSubmitter(fe, K) { var pe = K.ownerDocument.createElement("input"); return pe.name = K.name, pe.value = K.value, fe.id && pe.setAttribute("form", fe.id), K.parentNode.insertBefore(pe, K), fe = new FormData(fe), pe.parentNode.removeChild(pe), fe } function extractEvents$1(fe, K, pe, me, ge) { if (K === "submit" && pe && pe.stateNode === ge) { var xe = coerceFormActionProp((ge[internalPropsKey] || null).action), ye = me.submitter; ye && (K = (K = ye[internalPropsKey] || null) ? coerceFormActionProp(K.formAction) : ye.getAttribute("formAction"), K !== null && (xe = K, ye = null)); var ve = new SyntheticEvent("action", "action", null, me, ge); fe.push({ event: ve, listeners: [{ instance: null, listener: function () { if (me.defaultPrevented) { if (currentEventTransitionLane !== 0) { var _e = ye ? createFormDataWithSubmitter(ge, ye) : new FormData(ge); startHostTransition(pe, { pending: !0, data: _e, method: ge.method, action: xe }, null, _e) } } else typeof xe == "function" && (ve.preventDefault(), _e = ye ? createFormDataWithSubmitter(ge, ye) : new FormData(ge), startHostTransition(pe, { pending: !0, data: _e, method: ge.method, action: xe }, xe, _e)) }, currentTarget: ge }] }) } } for (var i$jscomp$inline_1439 = 0; i$jscomp$inline_1439 < simpleEventPluginEvents.length; i$jscomp$inline_1439++) { var eventName$jscomp$inline_1440 = simpleEventPluginEvents[i$jscomp$inline_1439], domEventName$jscomp$inline_1441 = eventName$jscomp$inline_1440.toLowerCase(), capitalizedEvent$jscomp$inline_1442 = eventName$jscomp$inline_1440[0].toUpperCase() + eventName$jscomp$inline_1440.slice(1); registerSimpleEvent(domEventName$jscomp$inline_1441, "on" + capitalizedEvent$jscomp$inline_1442) } registerSimpleEvent(ANIMATION_END, "onAnimationEnd"); registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration"); registerSimpleEvent(ANIMATION_START, "onAnimationStart"); registerSimpleEvent("dblclick", "onDoubleClick"); registerSimpleEvent("focusin", "onFocus"); registerSimpleEvent("focusout", "onBlur"); registerSimpleEvent(TRANSITION_RUN, "onTransitionRun"); registerSimpleEvent(TRANSITION_START, "onTransitionStart"); registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel"); registerSimpleEvent(TRANSITION_END, "onTransitionEnd"); registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]); registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]); registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]); registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]); registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)); function processDispatchQueue(fe, K) { K = (K & 4) !== 0; for (var pe = 0; pe < fe.length; pe++) { var me = fe[pe], ge = me.event; me = me.listeners; e: { var xe = void 0; if (K) for (var ye = me.length - 1; 0 <= ye; ye--) { var ve = me[ye], _e = ve.instance, Ee = ve.currentTarget; if (ve = ve.listener, _e !== xe && ge.isPropagationStopped()) break e; xe = ve, ge.currentTarget = Ee; try { xe(ge) } catch (be) { reportGlobalError(be) } ge.currentTarget = null, xe = _e } else for (ye = 0; ye < me.length; ye++) { if (ve = me[ye], _e = ve.instance, Ee = ve.currentTarget, ve = ve.listener, _e !== xe && ge.isPropagationStopped()) break e; xe = ve, ge.currentTarget = Ee; try { xe(ge) } catch (be) { reportGlobalError(be) } ge.currentTarget = null, xe = _e } } } } function listenToNonDelegatedEvent(fe, K) { var pe = K[internalEventHandlersKey]; pe === void 0 && (pe = K[internalEventHandlersKey] = new Set); var me = fe + "__bubble"; pe.has(me) || (addTrappedEventListener(K, fe, 2, !1), pe.add(me)) } function listenToNativeEvent(fe, K, pe) { var me = 0; K && (me |= 4), addTrappedEventListener(pe, fe, me, K) } var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2); function listenToAllSupportedEvents(fe) { if (!fe[listeningMarker]) { fe[listeningMarker] = !0, allNativeEvents.forEach(function (pe) { pe !== "selectionchange" && (nonDelegatedEvents.has(pe) || listenToNativeEvent(pe, !1, fe), listenToNativeEvent(pe, !0, fe)) }); var K = fe.nodeType === 9 ? fe : fe.ownerDocument; K === null || K[listeningMarker] || (K[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, K)) } } function addTrappedEventListener(fe, K, pe, me) { switch (getEventPriority(K)) { case 2: var ge = dispatchDiscreteEvent; break; case 8: ge = dispatchContinuousEvent; break; default: ge = dispatchEvent }pe = ge.bind(null, K, pe, fe), ge = void 0, !passiveBrowserEventsSupported || K !== "touchstart" && K !== "touchmove" && K !== "wheel" || (ge = !0), me ? ge !== void 0 ? fe.addEventListener(K, pe, { capture: !0, passive: ge }) : fe.addEventListener(K, pe, !0) : ge !== void 0 ? fe.addEventListener(K, pe, { passive: ge }) : fe.addEventListener(K, pe, !1) } function dispatchEventForPluginEventSystem(fe, K, pe, me, ge) { var xe = me; if (!(K & 1) && !(K & 2) && me !== null) e: for (; ;) { if (me === null) return; var ye = me.tag; if (ye === 3 || ye === 4) { var ve = me.stateNode.containerInfo; if (ve === ge || ve.nodeType === 8 && ve.parentNode === ge) break; if (ye === 4) for (ye = me.return; ye !== null;) { var _e = ye.tag; if ((_e === 3 || _e === 4) && (_e = ye.stateNode.containerInfo, _e === ge || _e.nodeType === 8 && _e.parentNode === ge)) return; ye = ye.return } for (; ve !== null;) { if (ye = getClosestInstanceFromNode(ve), ye === null) return; if (_e = ye.tag, _e === 5 || _e === 6 || _e === 26 || _e === 27) { me = xe = ye; continue e } ve = ve.parentNode } } me = me.return } batchedUpdates$1(function () { var Ee = xe, be = getEventTarget(pe), Ae = []; e: { var Se = topLevelEventsToReactNames.get(fe); if (Se !== void 0) { var Ce = SyntheticEvent, we = fe; switch (fe) { case "keypress": if (getEventCharCode(pe) === 0) break e; case "keydown": case "keyup": Ce = SyntheticKeyboardEvent; break; case "focusin": we = "focus", Ce = SyntheticFocusEvent; break; case "focusout": we = "blur", Ce = SyntheticFocusEvent; break; case "beforeblur": case "afterblur": Ce = SyntheticFocusEvent; break; case "click": if (pe.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Ce = SyntheticMouseEvent; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Ce = SyntheticDragEvent; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Ce = SyntheticTouchEvent; break; case ANIMATION_END: case ANIMATION_ITERATION: case ANIMATION_START: Ce = SyntheticAnimationEvent; break; case TRANSITION_END: Ce = SyntheticTransitionEvent; break; case "scroll": case "scrollend": Ce = SyntheticUIEvent; break; case "wheel": Ce = SyntheticWheelEvent; break; case "copy": case "cut": case "paste": Ce = SyntheticClipboardEvent; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Ce = SyntheticPointerEvent; break; case "toggle": case "beforetoggle": Ce = SyntheticToggleEvent }var Be = (K & 4) !== 0, De = !Be && (fe === "scroll" || fe === "scrollend"), Re = Be ? Se !== null ? Se + "Capture" : null : Se; Be = []; for (var Ie = Ee, Pe; Ie !== null;) { var Ne = Ie; if (Pe = Ne.stateNode, Ne = Ne.tag, Ne !== 5 && Ne !== 26 && Ne !== 27 || Pe === null || Re === null || (Ne = getListener(Ie, Re), Ne != null && Be.push(createDispatchListener(Ie, Ne, Pe))), De) break; Ie = Ie.return } 0 < Be.length && (Se = new Ce(Se, we, null, pe, be), Ae.push({ event: Se, listeners: Be })) } } if (!(K & 7)) { e: { if (Se = fe === "mouseover" || fe === "pointerover", Ce = fe === "mouseout" || fe === "pointerout", Se && pe !== currentReplayingEvent && (we = pe.relatedTarget || pe.fromElement) && (getClosestInstanceFromNode(we) || we[internalContainerInstanceKey])) break e; if ((Ce || Se) && (Se = be.window === be ? be : (Se = be.ownerDocument) ? Se.defaultView || Se.parentWindow : window, Ce ? (we = pe.relatedTarget || pe.toElement, Ce = Ee, we = we ? getClosestInstanceFromNode(we) : null, we !== null && (De = getNearestMountedFiber(we), Be = we.tag, we !== De || Be !== 5 && Be !== 27 && Be !== 6) && (we = null)) : (Ce = null, we = Ee), Ce !== we)) { if (Be = SyntheticMouseEvent, Ne = "onMouseLeave", Re = "onMouseEnter", Ie = "mouse", (fe === "pointerout" || fe === "pointerover") && (Be = SyntheticPointerEvent, Ne = "onPointerLeave", Re = "onPointerEnter", Ie = "pointer"), De = Ce == null ? Se : getNodeFromInstance(Ce), Pe = we == null ? Se : getNodeFromInstance(we), Se = new Be(Ne, Ie + "leave", Ce, pe, be), Se.target = De, Se.relatedTarget = Pe, Ne = null, getClosestInstanceFromNode(be) === Ee && (Be = new Be(Re, Ie + "enter", we, pe, be), Be.target = Pe, Be.relatedTarget = De, Ne = Be), De = Ne, Ce && we) t: { for (Be = Ce, Re = we, Ie = 0, Pe = Be; Pe; Pe = getParent(Pe))Ie++; for (Pe = 0, Ne = Re; Ne; Ne = getParent(Ne))Pe++; for (; 0 < Ie - Pe;)Be = getParent(Be), Ie--; for (; 0 < Pe - Ie;)Re = getParent(Re), Pe--; for (; Ie--;) { if (Be === Re || Re !== null && Be === Re.alternate) break t; Be = getParent(Be), Re = getParent(Re) } Be = null } else Be = null; Ce !== null && accumulateEnterLeaveListenersForEvent(Ae, Se, Ce, Be, !1), we !== null && De !== null && accumulateEnterLeaveListenersForEvent(Ae, De, we, Be, !0) } } e: { if (Se = Ee ? getNodeFromInstance(Ee) : window, Ce = Se.nodeName && Se.nodeName.toLowerCase(), Ce === "select" || Ce === "input" && Se.type === "file") var ke = getTargetInstForChangeEvent; else if (isTextInputElement(Se)) if (isInputEventSupported) ke = getTargetInstForInputOrChangeEvent; else { ke = getTargetInstForInputEventPolyfill; var Oe = handleEventsForInputEventPolyfill } else Ce = Se.nodeName, !Ce || Ce.toLowerCase() !== "input" || Se.type !== "checkbox" && Se.type !== "radio" ? Ee && isCustomElement(Ee.elementType) && (ke = getTargetInstForChangeEvent) : ke = getTargetInstForClickEvent; if (ke && (ke = ke(fe, Ee))) { createAndAccumulateChangeEvent(Ae, ke, pe, be); break e } Oe && Oe(fe, Se, Ee), fe === "focusout" && Ee && Se.type === "number" && Ee.memoizedProps.value != null && setDefaultValue(Se, "number", Se.value) } switch (Oe = Ee ? getNodeFromInstance(Ee) : window, fe) { case "focusin": (isTextInputElement(Oe) || Oe.contentEditable === "true") && (activeElement$2 = Oe, activeElementInst = Ee, lastSelection = null); break; case "focusout": lastSelection = activeElementInst = activeElement$2 = null; break; case "mousedown": mouseDown = !0; break; case "contextmenu": case "mouseup": case "dragend": mouseDown = !1, constructSelectEvent(Ae, pe, be); break; case "selectionchange": if (skipSelectionChangeEvent) break; case "keydown": case "keyup": constructSelectEvent(Ae, pe, be) }var Ue; if (canUseCompositionEvent) e: { switch (fe) { case "compositionstart": var He = "onCompositionStart"; break e; case "compositionend": He = "onCompositionEnd"; break e; case "compositionupdate": He = "onCompositionUpdate"; break e }He = void 0 } else isComposing ? isFallbackCompositionEnd(fe, pe) && (He = "onCompositionEnd") : fe === "keydown" && pe.keyCode === 229 && (He = "onCompositionStart"); He && (useFallbackCompositionData && pe.locale !== "ko" && (isComposing || He !== "onCompositionStart" ? He === "onCompositionEnd" && isComposing && (Ue = getData()) : (root$3 = be, startText = "value" in root$3 ? root$3.value : root$3.textContent, isComposing = !0)), Oe = accumulateTwoPhaseListeners(Ee, He), 0 < Oe.length && (He = new SyntheticCompositionEvent(He, fe, null, pe, be), Ae.push({ event: He, listeners: Oe }), Ue ? He.data = Ue : (Ue = getDataFromCustomEvent(pe), Ue !== null && (He.data = Ue)))), (Ue = canUseTextInputEvent ? getNativeBeforeInputChars(fe, pe) : getFallbackBeforeInputChars(fe, pe)) && (He = accumulateTwoPhaseListeners(Ee, "onBeforeInput"), 0 < He.length && (Oe = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, pe, be), Ae.push({ event: Oe, listeners: He }), Oe.data = Ue)), extractEvents$1(Ae, fe, Ee, pe, be) } processDispatchQueue(Ae, K) }) } function createDispatchListener(fe, K, pe) { return { instance: fe, listener: K, currentTarget: pe } } function accumulateTwoPhaseListeners(fe, K) { for (var pe = K + "Capture", me = []; fe !== null;) { var ge = fe, xe = ge.stateNode; ge = ge.tag, ge !== 5 && ge !== 26 && ge !== 27 || xe === null || (ge = getListener(fe, pe), ge != null && me.unshift(createDispatchListener(fe, ge, xe)), ge = getListener(fe, K), ge != null && me.push(createDispatchListener(fe, ge, xe))), fe = fe.return } return me } function getParent(fe) { if (fe === null) return null; do fe = fe.return; while (fe && fe.tag !== 5 && fe.tag !== 27); return fe || null } function accumulateEnterLeaveListenersForEvent(fe, K, pe, me, ge) { for (var xe = K._reactName, ye = []; pe !== null && pe !== me;) { var ve = pe, _e = ve.alternate, Ee = ve.stateNode; if (ve = ve.tag, _e !== null && _e === me) break; ve !== 5 && ve !== 26 && ve !== 27 || Ee === null || (_e = Ee, ge ? (Ee = getListener(pe, xe), Ee != null && ye.unshift(createDispatchListener(pe, Ee, _e))) : ge || (Ee = getListener(pe, xe), Ee != null && ye.push(createDispatchListener(pe, Ee, _e)))), pe = pe.return } ye.length !== 0 && fe.push({ event: K, listeners: ye }) } var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g; function normalizeMarkupForTextOrAttribute(fe) {
	return (typeof fe == "string" ? fe : "" + fe).replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "")
} function checkForUnmatchedText(fe, K) { return K = normalizeMarkupForTextOrAttribute(K), normalizeMarkupForTextOrAttribute(fe) === K } function noop$1$1() { } function setProp(fe, K, pe, me, ge, xe) { switch (pe) { case "children": typeof me == "string" ? K === "body" || K === "textarea" && me === "" || setTextContent(fe, me) : (typeof me == "number" || typeof me == "bigint") && K !== "body" && setTextContent(fe, "" + me); break; case "className": setValueForKnownAttribute(fe, "class", me); break; case "tabIndex": setValueForKnownAttribute(fe, "tabindex", me); break; case "dir": case "role": case "viewBox": case "width": case "height": setValueForKnownAttribute(fe, pe, me); break; case "style": setValueForStyles(fe, me, xe); break; case "data": if (K !== "object") { setValueForKnownAttribute(fe, "data", me); break } case "src": case "href": if (me === "" && (K !== "a" || pe !== "href")) { fe.removeAttribute(pe); break } if (me == null || typeof me == "function" || typeof me == "symbol" || typeof me == "boolean") { fe.removeAttribute(pe); break } me = sanitizeURL("" + me), fe.setAttribute(pe, me); break; case "action": case "formAction": if (typeof me == "function") { fe.setAttribute(pe, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof xe == "function" && (pe === "formAction" ? (K !== "input" && setProp(fe, K, "name", ge.name, ge, null), setProp(fe, K, "formEncType", ge.formEncType, ge, null), setProp(fe, K, "formMethod", ge.formMethod, ge, null), setProp(fe, K, "formTarget", ge.formTarget, ge, null)) : (setProp(fe, K, "encType", ge.encType, ge, null), setProp(fe, K, "method", ge.method, ge, null), setProp(fe, K, "target", ge.target, ge, null))); if (me == null || typeof me == "symbol" || typeof me == "boolean") { fe.removeAttribute(pe); break } me = sanitizeURL("" + me), fe.setAttribute(pe, me); break; case "onClick": me != null && (fe.onclick = noop$1$1); break; case "onScroll": me != null && listenToNonDelegatedEvent("scroll", fe); break; case "onScrollEnd": me != null && listenToNonDelegatedEvent("scrollend", fe); break; case "dangerouslySetInnerHTML": if (me != null) { if (typeof me != "object" || !("__html" in me)) throw Error(formatProdErrorMessage(61)); if (pe = me.__html, pe != null) { if (ge.children != null) throw Error(formatProdErrorMessage(60)); fe.innerHTML = pe } } break; case "multiple": fe.multiple = me && typeof me != "function" && typeof me != "symbol"; break; case "muted": fe.muted = me && typeof me != "function" && typeof me != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (me == null || typeof me == "function" || typeof me == "boolean" || typeof me == "symbol") { fe.removeAttribute("xlink:href"); break } pe = sanitizeURL("" + me), fe.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", pe); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": me != null && typeof me != "function" && typeof me != "symbol" ? fe.setAttribute(pe, "" + me) : fe.removeAttribute(pe); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": me && typeof me != "function" && typeof me != "symbol" ? fe.setAttribute(pe, "") : fe.removeAttribute(pe); break; case "capture": case "download": me === !0 ? fe.setAttribute(pe, "") : me !== !1 && me != null && typeof me != "function" && typeof me != "symbol" ? fe.setAttribute(pe, me) : fe.removeAttribute(pe); break; case "cols": case "rows": case "size": case "span": me != null && typeof me != "function" && typeof me != "symbol" && !isNaN(me) && 1 <= me ? fe.setAttribute(pe, me) : fe.removeAttribute(pe); break; case "rowSpan": case "start": me == null || typeof me == "function" || typeof me == "symbol" || isNaN(me) ? fe.removeAttribute(pe) : fe.setAttribute(pe, me); break; case "popover": listenToNonDelegatedEvent("beforetoggle", fe), listenToNonDelegatedEvent("toggle", fe), setValueForAttribute(fe, "popover", me); break; case "xlinkActuate": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:actuate", me); break; case "xlinkArcrole": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:arcrole", me); break; case "xlinkRole": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:role", me); break; case "xlinkShow": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:show", me); break; case "xlinkTitle": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:title", me); break; case "xlinkType": setValueForNamespacedAttribute(fe, "http://www.w3.org/1999/xlink", "xlink:type", me); break; case "xmlBase": setValueForNamespacedAttribute(fe, "http://www.w3.org/XML/1998/namespace", "xml:base", me); break; case "xmlLang": setValueForNamespacedAttribute(fe, "http://www.w3.org/XML/1998/namespace", "xml:lang", me); break; case "xmlSpace": setValueForNamespacedAttribute(fe, "http://www.w3.org/XML/1998/namespace", "xml:space", me); break; case "is": setValueForAttribute(fe, "is", me); break; case "innerText": case "textContent": break; default: (!(2 < pe.length) || pe[0] !== "o" && pe[0] !== "O" || pe[1] !== "n" && pe[1] !== "N") && (pe = aliases.get(pe) || pe, setValueForAttribute(fe, pe, me)) } } function setPropOnCustomElement(fe, K, pe, me, ge, xe) { switch (pe) { case "style": setValueForStyles(fe, me, xe); break; case "dangerouslySetInnerHTML": if (me != null) { if (typeof me != "object" || !("__html" in me)) throw Error(formatProdErrorMessage(61)); if (pe = me.__html, pe != null) { if (ge.children != null) throw Error(formatProdErrorMessage(60)); fe.innerHTML = pe } } break; case "children": typeof me == "string" ? setTextContent(fe, me) : (typeof me == "number" || typeof me == "bigint") && setTextContent(fe, "" + me); break; case "onScroll": me != null && listenToNonDelegatedEvent("scroll", fe); break; case "onScrollEnd": me != null && listenToNonDelegatedEvent("scrollend", fe); break; case "onClick": me != null && (fe.onclick = noop$1$1); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!registrationNameDependencies.hasOwnProperty(pe)) e: { if (pe[0] === "o" && pe[1] === "n" && (ge = pe.endsWith("Capture"), K = pe.slice(2, ge ? pe.length - 7 : void 0), xe = fe[internalPropsKey] || null, xe = xe != null ? xe[pe] : null, typeof xe == "function" && fe.removeEventListener(K, xe, ge), typeof me == "function")) { typeof xe != "function" && xe !== null && (pe in fe ? fe[pe] = null : fe.hasAttribute(pe) && fe.removeAttribute(pe)), fe.addEventListener(K, me, ge); break e } pe in fe ? fe[pe] = me : me === !0 ? fe.setAttribute(pe, "") : setValueForAttribute(fe, pe, me) } } } function setInitialProperties(fe, K, pe) { switch (K) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": listenToNonDelegatedEvent("error", fe), listenToNonDelegatedEvent("load", fe); var me = !1, ge = !1, xe; for (xe in pe) if (pe.hasOwnProperty(xe)) { var ye = pe[xe]; if (ye != null) switch (xe) { case "src": me = !0; break; case "srcSet": ge = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, K)); default: setProp(fe, K, xe, ye, pe, null) } } ge && setProp(fe, K, "srcSet", pe.srcSet, pe, null), me && setProp(fe, K, "src", pe.src, pe, null); return; case "input": listenToNonDelegatedEvent("invalid", fe); var ve = xe = ye = ge = null, _e = null, Ee = null; for (me in pe) if (pe.hasOwnProperty(me)) { var be = pe[me]; if (be != null) switch (me) { case "name": ge = be; break; case "type": ye = be; break; case "checked": _e = be; break; case "defaultChecked": Ee = be; break; case "value": xe = be; break; case "defaultValue": ve = be; break; case "children": case "dangerouslySetInnerHTML": if (be != null) throw Error(formatProdErrorMessage(137, K)); break; default: setProp(fe, K, me, be, pe, null) } } initInput(fe, xe, ve, _e, Ee, ye, ge, !1), track(fe); return; case "select": listenToNonDelegatedEvent("invalid", fe), me = ye = xe = null; for (ge in pe) if (pe.hasOwnProperty(ge) && (ve = pe[ge], ve != null)) switch (ge) { case "value": xe = ve; break; case "defaultValue": ye = ve; break; case "multiple": me = ve; default: setProp(fe, K, ge, ve, pe, null) }K = xe, pe = ye, fe.multiple = !!me, K != null ? updateOptions(fe, !!me, K, !1) : pe != null && updateOptions(fe, !!me, pe, !0); return; case "textarea": listenToNonDelegatedEvent("invalid", fe), xe = ge = me = null; for (ye in pe) if (pe.hasOwnProperty(ye) && (ve = pe[ye], ve != null)) switch (ye) { case "value": me = ve; break; case "defaultValue": ge = ve; break; case "children": xe = ve; break; case "dangerouslySetInnerHTML": if (ve != null) throw Error(formatProdErrorMessage(91)); break; default: setProp(fe, K, ye, ve, pe, null) }initTextarea(fe, me, ge, xe), track(fe); return; case "option": for (_e in pe) if (pe.hasOwnProperty(_e) && (me = pe[_e], me != null)) switch (_e) { case "selected": fe.selected = me && typeof me != "function" && typeof me != "symbol"; break; default: setProp(fe, K, _e, me, pe, null) }return; case "dialog": listenToNonDelegatedEvent("cancel", fe), listenToNonDelegatedEvent("close", fe); break; case "iframe": case "object": listenToNonDelegatedEvent("load", fe); break; case "video": case "audio": for (me = 0; me < mediaEventTypes.length; me++)listenToNonDelegatedEvent(mediaEventTypes[me], fe); break; case "image": listenToNonDelegatedEvent("error", fe), listenToNonDelegatedEvent("load", fe); break; case "details": listenToNonDelegatedEvent("toggle", fe); break; case "embed": case "source": case "link": listenToNonDelegatedEvent("error", fe), listenToNonDelegatedEvent("load", fe); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (Ee in pe) if (pe.hasOwnProperty(Ee) && (me = pe[Ee], me != null)) switch (Ee) { case "children": case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, K)); default: setProp(fe, K, Ee, me, pe, null) }return; default: if (isCustomElement(K)) { for (be in pe) pe.hasOwnProperty(be) && (me = pe[be], me !== void 0 && setPropOnCustomElement(fe, K, be, me, pe, void 0)); return } }for (ve in pe) pe.hasOwnProperty(ve) && (me = pe[ve], me != null && setProp(fe, K, ve, me, pe, null)) } function updateProperties(fe, K, pe, me) { switch (K) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var ge = null, xe = null, ye = null, ve = null, _e = null, Ee = null, be = null; for (Ce in pe) { var Ae = pe[Ce]; if (pe.hasOwnProperty(Ce) && Ae != null) switch (Ce) { case "checked": break; case "value": break; case "defaultValue": _e = Ae; default: me.hasOwnProperty(Ce) || setProp(fe, K, Ce, null, me, Ae) } } for (var Se in me) { var Ce = me[Se]; if (Ae = pe[Se], me.hasOwnProperty(Se) && (Ce != null || Ae != null)) switch (Se) { case "type": xe = Ce; break; case "name": ge = Ce; break; case "checked": Ee = Ce; break; case "defaultChecked": be = Ce; break; case "value": ye = Ce; break; case "defaultValue": ve = Ce; break; case "children": case "dangerouslySetInnerHTML": if (Ce != null) throw Error(formatProdErrorMessage(137, K)); break; default: Ce !== Ae && setProp(fe, K, Se, Ce, me, Ae) } } updateInput(fe, ye, ve, _e, Ee, be, xe, ge); return; case "select": Ce = ye = ve = Se = null; for (xe in pe) if (_e = pe[xe], pe.hasOwnProperty(xe) && _e != null) switch (xe) { case "value": break; case "multiple": Ce = _e; default: me.hasOwnProperty(xe) || setProp(fe, K, xe, null, me, _e) }for (ge in me) if (xe = me[ge], _e = pe[ge], me.hasOwnProperty(ge) && (xe != null || _e != null)) switch (ge) { case "value": Se = xe; break; case "defaultValue": ve = xe; break; case "multiple": ye = xe; default: xe !== _e && setProp(fe, K, ge, xe, me, _e) }K = ve, pe = ye, me = Ce, Se != null ? updateOptions(fe, !!pe, Se, !1) : !!me != !!pe && (K != null ? updateOptions(fe, !!pe, K, !0) : updateOptions(fe, !!pe, pe ? [] : "", !1)); return; case "textarea": Ce = Se = null; for (ve in pe) if (ge = pe[ve], pe.hasOwnProperty(ve) && ge != null && !me.hasOwnProperty(ve)) switch (ve) { case "value": break; case "children": break; default: setProp(fe, K, ve, null, me, ge) }for (ye in me) if (ge = me[ye], xe = pe[ye], me.hasOwnProperty(ye) && (ge != null || xe != null)) switch (ye) { case "value": Se = ge; break; case "defaultValue": Ce = ge; break; case "children": break; case "dangerouslySetInnerHTML": if (ge != null) throw Error(formatProdErrorMessage(91)); break; default: ge !== xe && setProp(fe, K, ye, ge, me, xe) }updateTextarea(fe, Se, Ce); return; case "option": for (var we in pe) if (Se = pe[we], pe.hasOwnProperty(we) && Se != null && !me.hasOwnProperty(we)) switch (we) { case "selected": fe.selected = !1; break; default: setProp(fe, K, we, null, me, Se) }for (_e in me) if (Se = me[_e], Ce = pe[_e], me.hasOwnProperty(_e) && Se !== Ce && (Se != null || Ce != null)) switch (_e) { case "selected": fe.selected = Se && typeof Se != "function" && typeof Se != "symbol"; break; default: setProp(fe, K, _e, Se, me, Ce) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var Be in pe) Se = pe[Be], pe.hasOwnProperty(Be) && Se != null && !me.hasOwnProperty(Be) && setProp(fe, K, Be, null, me, Se); for (Ee in me) if (Se = me[Ee], Ce = pe[Ee], me.hasOwnProperty(Ee) && Se !== Ce && (Se != null || Ce != null)) switch (Ee) { case "children": case "dangerouslySetInnerHTML": if (Se != null) throw Error(formatProdErrorMessage(137, K)); break; default: setProp(fe, K, Ee, Se, me, Ce) }return; default: if (isCustomElement(K)) { for (var De in pe) Se = pe[De], pe.hasOwnProperty(De) && Se !== void 0 && !me.hasOwnProperty(De) && setPropOnCustomElement(fe, K, De, void 0, me, Se); for (be in me) Se = me[be], Ce = pe[be], !me.hasOwnProperty(be) || Se === Ce || Se === void 0 && Ce === void 0 || setPropOnCustomElement(fe, K, be, Se, me, Ce); return } }for (var Re in pe) Se = pe[Re], pe.hasOwnProperty(Re) && Se != null && !me.hasOwnProperty(Re) && setProp(fe, K, Re, null, me, Se); for (Ae in me) Se = me[Ae], Ce = pe[Ae], !me.hasOwnProperty(Ae) || Se === Ce || Se == null && Ce == null || setProp(fe, K, Ae, Se, me, Ce) } var eventsEnabled = null, selectionInformation = null; function getOwnerDocumentFromRootContainer(fe) { return fe.nodeType === 9 ? fe : fe.ownerDocument } function getOwnHostContext(fe) { switch (fe) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function getChildHostContextProd(fe, K) { if (fe === 0) switch (K) { case "svg": return 1; case "math": return 2; default: return 0 }return fe === 1 && K === "foreignObject" ? 0 : fe } function shouldSetTextContent(fe, K) { return fe === "textarea" || fe === "noscript" || typeof K.children == "string" || typeof K.children == "number" || typeof K.children == "bigint" || typeof K.dangerouslySetInnerHTML == "object" && K.dangerouslySetInnerHTML !== null && K.dangerouslySetInnerHTML.__html != null } var currentPopstateTransitionEvent = null; function shouldAttemptEagerTransition() { var fe = window.event; return fe && fe.type === "popstate" ? fe === currentPopstateTransitionEvent ? !1 : (currentPopstateTransitionEvent = fe, !0) : (currentPopstateTransitionEvent = null, !1) } var scheduleTimeout = typeof setTimeout == "function" ? setTimeout : void 0, cancelTimeout = typeof clearTimeout == "function" ? clearTimeout : void 0, localPromise = typeof Promise == "function" ? Promise : void 0, scheduleMicrotask = typeof queueMicrotask == "function" ? queueMicrotask : typeof localPromise < "u" ? function (fe) { return localPromise.resolve(null).then(fe).catch(handleErrorInNextTick) } : scheduleTimeout; function handleErrorInNextTick(fe) { setTimeout(function () { throw fe }) } function clearSuspenseBoundary(fe, K) { var pe = K, me = 0; do { var ge = pe.nextSibling; if (fe.removeChild(pe), ge && ge.nodeType === 8) if (pe = ge.data, pe === "/$") { if (me === 0) { fe.removeChild(ge), retryIfBlockedOn(K); return } me-- } else pe !== "$" && pe !== "$?" && pe !== "$!" || me++; pe = ge } while (pe); retryIfBlockedOn(K) } function clearContainerSparingly(fe) { var K = fe.firstChild; for (K && K.nodeType === 10 && (K = K.nextSibling); K;) { var pe = K; switch (K = K.nextSibling, pe.nodeName) { case "HTML": case "HEAD": case "BODY": clearContainerSparingly(pe), detachDeletedInstance(pe); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (pe.rel.toLowerCase() === "stylesheet") continue }fe.removeChild(pe) } } function canHydrateInstance(fe, K, pe, me) { for (; fe.nodeType === 1;) { var ge = pe; if (fe.nodeName.toLowerCase() !== K.toLowerCase()) { if (!me && (fe.nodeName !== "INPUT" || fe.type !== "hidden")) break } else if (me) { if (!fe[internalHoistableMarker]) switch (K) { case "meta": if (!fe.hasAttribute("itemprop")) break; return fe; case "link": if (xe = fe.getAttribute("rel"), xe === "stylesheet" && fe.hasAttribute("data-precedence")) break; if (xe !== ge.rel || fe.getAttribute("href") !== (ge.href == null ? null : ge.href) || fe.getAttribute("crossorigin") !== (ge.crossOrigin == null ? null : ge.crossOrigin) || fe.getAttribute("title") !== (ge.title == null ? null : ge.title)) break; return fe; case "style": if (fe.hasAttribute("data-precedence")) break; return fe; case "script": if (xe = fe.getAttribute("src"), (xe !== (ge.src == null ? null : ge.src) || fe.getAttribute("type") !== (ge.type == null ? null : ge.type) || fe.getAttribute("crossorigin") !== (ge.crossOrigin == null ? null : ge.crossOrigin)) && xe && fe.hasAttribute("async") && !fe.hasAttribute("itemprop")) break; return fe; default: return fe } } else if (K === "input" && fe.type === "hidden") { var xe = ge.name == null ? null : "" + ge.name; if (ge.type === "hidden" && fe.getAttribute("name") === xe) return fe } else return fe; if (fe = getNextHydratable(fe.nextSibling), fe === null) break } return null } function canHydrateTextInstance(fe, K, pe) { if (K === "") return null; for (; fe.nodeType !== 3;)if ((fe.nodeType !== 1 || fe.nodeName !== "INPUT" || fe.type !== "hidden") && !pe || (fe = getNextHydratable(fe.nextSibling), fe === null)) return null; return fe } function getNextHydratable(fe) { for (; fe != null; fe = fe.nextSibling) { var K = fe.nodeType; if (K === 1 || K === 3) break; if (K === 8) { if (K = fe.data, K === "$" || K === "$!" || K === "$?" || K === "F!" || K === "F") break; if (K === "/$") return null } } return fe } function getParentSuspenseInstance(fe) { fe = fe.previousSibling; for (var K = 0; fe;) { if (fe.nodeType === 8) { var pe = fe.data; if (pe === "$" || pe === "$!" || pe === "$?") { if (K === 0) return fe; K-- } else pe === "/$" && K++ } fe = fe.previousSibling } return null } function resolveSingletonInstance(fe, K, pe) { switch (K = getOwnerDocumentFromRootContainer(pe), fe) { case "html": if (fe = K.documentElement, !fe) throw Error(formatProdErrorMessage(452)); return fe; case "head": if (fe = K.head, !fe) throw Error(formatProdErrorMessage(453)); return fe; case "body": if (fe = K.body, !fe) throw Error(formatProdErrorMessage(454)); return fe; default: throw Error(formatProdErrorMessage(451)) } } var preloadPropsMap = new Map, preconnectsSet = new Set; function getHoistableRoot(fe) { return typeof fe.getRootNode == "function" ? fe.getRootNode() : fe.ownerDocument } var previousDispatcher = ReactDOMSharedInternals.d; ReactDOMSharedInternals.d = { f: flushSyncWork, r: requestFormReset, D: prefetchDNS, C: preconnect, L: preload$1, m: preloadModule, X: preinitScript, S: preinitStyle, M: preinitModuleScript }; function flushSyncWork() { var fe = previousDispatcher.f(), K = flushSyncWork$1(); return fe || K } function requestFormReset(fe) { var K = getInstanceFromNode(fe); K !== null && K.tag === 5 && K.type === "form" ? requestFormReset$1(K) : previousDispatcher.r(fe) } var globalDocument = typeof document > "u" ? null : document; function preconnectAs(fe, K, pe) { var me = globalDocument; if (me && typeof K == "string" && K) { var ge = escapeSelectorAttributeValueInsideDoubleQuotes(K); ge = 'link[rel="' + fe + '"][href="' + ge + '"]', typeof pe == "string" && (ge += '[crossorigin="' + pe + '"]'), preconnectsSet.has(ge) || (preconnectsSet.add(ge), fe = { rel: fe, crossOrigin: pe, href: K }, me.querySelector(ge) === null && (K = me.createElement("link"), setInitialProperties(K, "link", fe), markNodeAsHoistable(K), me.head.appendChild(K))) } } function prefetchDNS(fe) { previousDispatcher.D(fe), preconnectAs("dns-prefetch", fe, null) } function preconnect(fe, K) { previousDispatcher.C(fe, K), preconnectAs("preconnect", fe, K) } function preload$1(fe, K, pe) { previousDispatcher.L(fe, K, pe); var me = globalDocument; if (me && fe && K) { var ge = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(K) + '"]'; K === "image" && pe && pe.imageSrcSet ? (ge += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(pe.imageSrcSet) + '"]', typeof pe.imageSizes == "string" && (ge += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(pe.imageSizes) + '"]')) : ge += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(fe) + '"]'; var xe = ge; switch (K) { case "style": xe = getStyleKey(fe); break; case "script": xe = getScriptKey(fe) }preloadPropsMap.has(xe) || (fe = assign$1({ rel: "preload", href: K === "image" && pe && pe.imageSrcSet ? void 0 : fe, as: K }, pe), preloadPropsMap.set(xe, fe), me.querySelector(ge) !== null || K === "style" && me.querySelector(getStylesheetSelectorFromKey(xe)) || K === "script" && me.querySelector(getScriptSelectorFromKey(xe)) || (K = me.createElement("link"), setInitialProperties(K, "link", fe), markNodeAsHoistable(K), me.head.appendChild(K))) } } function preloadModule(fe, K) { previousDispatcher.m(fe, K); var pe = globalDocument; if (pe && fe) { var me = K && typeof K.as == "string" ? K.as : "script", ge = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(me) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(fe) + '"]', xe = ge; switch (me) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": xe = getScriptKey(fe) }if (!preloadPropsMap.has(xe) && (fe = assign$1({ rel: "modulepreload", href: fe }, K), preloadPropsMap.set(xe, fe), pe.querySelector(ge) === null)) { switch (me) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (pe.querySelector(getScriptSelectorFromKey(xe))) return }me = pe.createElement("link"), setInitialProperties(me, "link", fe), markNodeAsHoistable(me), pe.head.appendChild(me) } } } function preinitStyle(fe, K, pe) { previousDispatcher.S(fe, K, pe); var me = globalDocument; if (me && fe) { var ge = getResourcesFromRoot(me).hoistableStyles, xe = getStyleKey(fe); K = K || "default"; var ye = ge.get(xe); if (!ye) { var ve = { loading: 0, preload: null }; if (ye = me.querySelector(getStylesheetSelectorFromKey(xe))) ve.loading = 5; else { fe = assign$1({ rel: "stylesheet", href: fe, "data-precedence": K }, pe), (pe = preloadPropsMap.get(xe)) && adoptPreloadPropsForStylesheet(fe, pe); var _e = ye = me.createElement("link"); markNodeAsHoistable(_e), setInitialProperties(_e, "link", fe), _e._p = new Promise(function (Ee, be) { _e.onload = Ee, _e.onerror = be }), _e.addEventListener("load", function () { ve.loading |= 1 }), _e.addEventListener("error", function () { ve.loading |= 2 }), ve.loading |= 4, insertStylesheet(ye, K, me) } ye = { type: "stylesheet", instance: ye, count: 1, state: ve }, ge.set(xe, ye) } } } function preinitScript(fe, K) { previousDispatcher.X(fe, K); var pe = globalDocument; if (pe && fe) { var me = getResourcesFromRoot(pe).hoistableScripts, ge = getScriptKey(fe), xe = me.get(ge); xe || (xe = pe.querySelector(getScriptSelectorFromKey(ge)), xe || (fe = assign$1({ src: fe, async: !0 }, K), (K = preloadPropsMap.get(ge)) && adoptPreloadPropsForScript(fe, K), xe = pe.createElement("script"), markNodeAsHoistable(xe), setInitialProperties(xe, "link", fe), pe.head.appendChild(xe)), xe = { type: "script", instance: xe, count: 1, state: null }, me.set(ge, xe)) } } function preinitModuleScript(fe, K) { previousDispatcher.M(fe, K); var pe = globalDocument; if (pe && fe) { var me = getResourcesFromRoot(pe).hoistableScripts, ge = getScriptKey(fe), xe = me.get(ge); xe || (xe = pe.querySelector(getScriptSelectorFromKey(ge)), xe || (fe = assign$1({ src: fe, async: !0, type: "module" }, K), (K = preloadPropsMap.get(ge)) && adoptPreloadPropsForScript(fe, K), xe = pe.createElement("script"), markNodeAsHoistable(xe), setInitialProperties(xe, "link", fe), pe.head.appendChild(xe)), xe = { type: "script", instance: xe, count: 1, state: null }, me.set(ge, xe)) } } function getResource(fe, K, pe, me) { var ge = (ge = rootInstanceStackCursor.current) ? getHoistableRoot(ge) : null; if (!ge) throw Error(formatProdErrorMessage(446)); switch (fe) { case "meta": case "title": return null; case "style": return typeof pe.precedence == "string" && typeof pe.href == "string" ? (K = getStyleKey(pe.href), pe = getResourcesFromRoot(ge).hoistableStyles, me = pe.get(K), me || (me = { type: "style", instance: null, count: 0, state: null }, pe.set(K, me)), me) : { type: "void", instance: null, count: 0, state: null }; case "link": if (pe.rel === "stylesheet" && typeof pe.href == "string" && typeof pe.precedence == "string") { fe = getStyleKey(pe.href); var xe = getResourcesFromRoot(ge).hoistableStyles, ye = xe.get(fe); if (ye || (ge = ge.ownerDocument || ge, ye = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, xe.set(fe, ye), (xe = ge.querySelector(getStylesheetSelectorFromKey(fe))) && !xe._p && (ye.instance = xe, ye.state.loading = 5), preloadPropsMap.has(fe) || (pe = { rel: "preload", as: "style", href: pe.href, crossOrigin: pe.crossOrigin, integrity: pe.integrity, media: pe.media, hrefLang: pe.hrefLang, referrerPolicy: pe.referrerPolicy }, preloadPropsMap.set(fe, pe), xe || preloadStylesheet(ge, fe, pe, ye.state))), K && me === null) throw Error(formatProdErrorMessage(528, "")); return ye } if (K && me !== null) throw Error(formatProdErrorMessage(529, "")); return null; case "script": return K = pe.async, pe = pe.src, typeof pe == "string" && K && typeof K != "function" && typeof K != "symbol" ? (K = getScriptKey(pe), pe = getResourcesFromRoot(ge).hoistableScripts, me = pe.get(K), me || (me = { type: "script", instance: null, count: 0, state: null }, pe.set(K, me)), me) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(formatProdErrorMessage(444, fe)) } } function getStyleKey(fe) { return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(fe) + '"' } function getStylesheetSelectorFromKey(fe) { return 'link[rel="stylesheet"][' + fe + "]" } function stylesheetPropsFromRawProps(fe) { return assign$1({}, fe, { "data-precedence": fe.precedence, precedence: null }) } function preloadStylesheet(fe, K, pe, me) { fe.querySelector('link[rel="preload"][as="style"][' + K + "]") ? me.loading = 1 : (K = fe.createElement("link"), me.preload = K, K.addEventListener("load", function () { return me.loading |= 1 }), K.addEventListener("error", function () { return me.loading |= 2 }), setInitialProperties(K, "link", pe), markNodeAsHoistable(K), fe.head.appendChild(K)) } function getScriptKey(fe) { return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(fe) + '"]' } function getScriptSelectorFromKey(fe) { return "script[async]" + fe } function acquireResource(fe, K, pe) { if (K.count++, K.instance === null) switch (K.type) { case "style": var me = fe.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(pe.href) + '"]'); if (me) return K.instance = me, markNodeAsHoistable(me), me; var ge = assign$1({}, pe, { "data-href": pe.href, "data-precedence": pe.precedence, href: null, precedence: null }); return me = (fe.ownerDocument || fe).createElement("style"), markNodeAsHoistable(me), setInitialProperties(me, "style", ge), insertStylesheet(me, pe.precedence, fe), K.instance = me; case "stylesheet": ge = getStyleKey(pe.href); var xe = fe.querySelector(getStylesheetSelectorFromKey(ge)); if (xe) return K.state.loading |= 4, K.instance = xe, markNodeAsHoistable(xe), xe; me = stylesheetPropsFromRawProps(pe), (ge = preloadPropsMap.get(ge)) && adoptPreloadPropsForStylesheet(me, ge), xe = (fe.ownerDocument || fe).createElement("link"), markNodeAsHoistable(xe); var ye = xe; return ye._p = new Promise(function (ve, _e) { ye.onload = ve, ye.onerror = _e }), setInitialProperties(xe, "link", me), K.state.loading |= 4, insertStylesheet(xe, pe.precedence, fe), K.instance = xe; case "script": return xe = getScriptKey(pe.src), (ge = fe.querySelector(getScriptSelectorFromKey(xe))) ? (K.instance = ge, markNodeAsHoistable(ge), ge) : (me = pe, (ge = preloadPropsMap.get(xe)) && (me = assign$1({}, pe), adoptPreloadPropsForScript(me, ge)), fe = fe.ownerDocument || fe, ge = fe.createElement("script"), markNodeAsHoistable(ge), setInitialProperties(ge, "link", me), fe.head.appendChild(ge), K.instance = ge); case "void": return null; default: throw Error(formatProdErrorMessage(443, K.type)) } else K.type === "stylesheet" && !(K.state.loading & 4) && (me = K.instance, K.state.loading |= 4, insertStylesheet(me, pe.precedence, fe)); return K.instance } function insertStylesheet(fe, K, pe) { for (var me = pe.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), ge = me.length ? me[me.length - 1] : null, xe = ge, ye = 0; ye < me.length; ye++) { var ve = me[ye]; if (ve.dataset.precedence === K) xe = ve; else if (xe !== ge) break } xe ? xe.parentNode.insertBefore(fe, xe.nextSibling) : (K = pe.nodeType === 9 ? pe.head : pe, K.insertBefore(fe, K.firstChild)) } function adoptPreloadPropsForStylesheet(fe, K) { fe.crossOrigin == null && (fe.crossOrigin = K.crossOrigin), fe.referrerPolicy == null && (fe.referrerPolicy = K.referrerPolicy), fe.title == null && (fe.title = K.title) } function adoptPreloadPropsForScript(fe, K) { fe.crossOrigin == null && (fe.crossOrigin = K.crossOrigin), fe.referrerPolicy == null && (fe.referrerPolicy = K.referrerPolicy), fe.integrity == null && (fe.integrity = K.integrity) } var tagCaches = null; function getHydratableHoistableCache(fe, K, pe) { if (tagCaches === null) { var me = new Map, ge = tagCaches = new Map; ge.set(pe, me) } else ge = tagCaches, me = ge.get(pe), me || (me = new Map, ge.set(pe, me)); if (me.has(fe)) return me; for (me.set(fe, null), pe = pe.getElementsByTagName(fe), ge = 0; ge < pe.length; ge++) { var xe = pe[ge]; if (!(xe[internalHoistableMarker] || xe[internalInstanceKey] || fe === "link" && xe.getAttribute("rel") === "stylesheet") && xe.namespaceURI !== "http://www.w3.org/2000/svg") { var ye = xe.getAttribute(K) || ""; ye = fe + ye; var ve = me.get(ye); ve ? ve.push(xe) : me.set(ye, [xe]) } } return me } function mountHoistable(fe, K, pe) { fe = fe.ownerDocument || fe, fe.head.insertBefore(pe, K === "title" ? fe.querySelector("head > title") : null) } function isHostHoistableType(fe, K, pe) { if (pe === 1 || K.itemProp != null) return !1; switch (fe) { case "meta": case "title": return !0; case "style": if (typeof K.precedence != "string" || typeof K.href != "string" || K.href === "") break; return !0; case "link": if (typeof K.rel != "string" || typeof K.href != "string" || K.href === "" || K.onLoad || K.onError) break; switch (K.rel) { case "stylesheet": return fe = K.disabled, typeof K.precedence == "string" && fe == null; default: return !0 }case "script": if (K.async && typeof K.async != "function" && typeof K.async != "symbol" && !K.onLoad && !K.onError && K.src && typeof K.src == "string") return !0 }return !1 } function preloadResource(fe) { return !(fe.type === "stylesheet" && !(fe.state.loading & 3)) } var suspendedState = null; function noop$5() { } function suspendResource(fe, K, pe) { if (suspendedState === null) throw Error(formatProdErrorMessage(475)); var me = suspendedState; if (K.type === "stylesheet" && (typeof pe.media != "string" || matchMedia(pe.media).matches !== !1) && !(K.state.loading & 4)) { if (K.instance === null) { var ge = getStyleKey(pe.href), xe = fe.querySelector(getStylesheetSelectorFromKey(ge)); if (xe) { fe = xe._p, fe !== null && typeof fe == "object" && typeof fe.then == "function" && (me.count++, me = onUnsuspend.bind(me), fe.then(me, me)), K.state.loading |= 4, K.instance = xe, markNodeAsHoistable(xe); return } xe = fe.ownerDocument || fe, pe = stylesheetPropsFromRawProps(pe), (ge = preloadPropsMap.get(ge)) && adoptPreloadPropsForStylesheet(pe, ge), xe = xe.createElement("link"), markNodeAsHoistable(xe); var ye = xe; ye._p = new Promise(function (ve, _e) { ye.onload = ve, ye.onerror = _e }), setInitialProperties(xe, "link", pe), K.instance = xe } me.stylesheets === null && (me.stylesheets = new Map), me.stylesheets.set(K, fe), (fe = K.state.preload) && !(K.state.loading & 3) && (me.count++, K = onUnsuspend.bind(me), fe.addEventListener("load", K), fe.addEventListener("error", K)) } } function waitForCommitToBeReady() { if (suspendedState === null) throw Error(formatProdErrorMessage(475)); var fe = suspendedState; return fe.stylesheets && fe.count === 0 && insertSuspendedStylesheets(fe, fe.stylesheets), 0 < fe.count ? function (K) { var pe = setTimeout(function () { if (fe.stylesheets && insertSuspendedStylesheets(fe, fe.stylesheets), fe.unsuspend) { var me = fe.unsuspend; fe.unsuspend = null, me() } }, 6e4); return fe.unsuspend = K, function () { fe.unsuspend = null, clearTimeout(pe) } } : null } function onUnsuspend() { if (this.count--, this.count === 0) { if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets); else if (this.unsuspend) { var fe = this.unsuspend; this.unsuspend = null, fe() } } } var precedencesByRoot = null; function insertSuspendedStylesheets(fe, K) { fe.stylesheets = null, fe.unsuspend !== null && (fe.count++, precedencesByRoot = new Map, K.forEach(insertStylesheetIntoRoot, fe), precedencesByRoot = null, onUnsuspend.call(fe)) } function insertStylesheetIntoRoot(fe, K) { if (!(K.state.loading & 4)) { var pe = precedencesByRoot.get(fe); if (pe) var me = pe.get(null); else { pe = new Map, precedencesByRoot.set(fe, pe); for (var ge = fe.querySelectorAll("link[data-precedence],style[data-precedence]"), xe = 0; xe < ge.length; xe++) { var ye = ge[xe]; (ye.nodeName === "LINK" || ye.getAttribute("media") !== "not all") && (pe.set(ye.dataset.precedence, ye), me = ye) } me && pe.set(null, me) } ge = K.instance, ye = ge.getAttribute("data-precedence"), xe = pe.get(ye) || me, xe === me && pe.set(null, ge), pe.set(ye, ge), this.count++, me = onUnsuspend.bind(this), ge.addEventListener("load", me), ge.addEventListener("error", me), xe ? xe.parentNode.insertBefore(ge, xe.nextSibling) : (fe = fe.nodeType === 9 ? fe.head : fe, fe.insertBefore(ge, fe.firstChild)), K.state.loading |= 4 } } var HostTransitionContext = { $$typeof: REACT_CONTEXT_TYPE, Provider: null, Consumer: null, _currentValue: sharedNotPendingObject, _currentValue2: sharedNotPendingObject, _threadCount: 0 }; function FiberRootNode(fe, K, pe, me, ge, xe, ye, ve) { this.tag = 1, this.containerInfo = fe, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = createLaneMap(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = createLaneMap(0), this.hiddenUpdates = createLaneMap(null), this.identifierPrefix = me, this.onUncaughtError = ge, this.onCaughtError = xe, this.onRecoverableError = ye, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = ve, this.incompleteTransitions = new Map } function createFiberRoot(fe, K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae) { return fe = new FiberRootNode(fe, K, pe, ye, ve, _e, Ee, Ae), K = 1, xe === !0 && (K |= 24), xe = createFiberImplClass(3, null, null, K), fe.current = xe, xe.stateNode = fe, K = createCache(), K.refCount++, fe.pooledCache = K, K.refCount++, xe.memoizedState = { element: me, isDehydrated: pe, cache: K }, initializeUpdateQueue(xe), fe } function getContextForSubtree(fe) { return fe ? (fe = emptyContextObject, fe) : emptyContextObject } function updateContainerImpl(fe, K, pe, me, ge, xe) { ge = getContextForSubtree(ge), me.context === null ? me.context = ge : me.pendingContext = ge, me = createUpdate(K), me.payload = { element: pe }, xe = xe === void 0 ? null : xe, xe !== null && (me.callback = xe), pe = enqueueUpdate(fe, me, K), pe !== null && (scheduleUpdateOnFiber(pe, fe, K), entangleTransitions(pe, fe, K)) } function markRetryLaneImpl(fe, K) { if (fe = fe.memoizedState, fe !== null && fe.dehydrated !== null) { var pe = fe.retryLane; fe.retryLane = pe !== 0 && pe < K ? pe : K } } function markRetryLaneIfNotHydrated(fe, K) { markRetryLaneImpl(fe, K), (fe = fe.alternate) && markRetryLaneImpl(fe, K) } function attemptContinuousHydration(fe) { if (fe.tag === 13) { var K = enqueueConcurrentRenderForLane(fe, 67108864); K !== null && scheduleUpdateOnFiber(K, fe, 67108864), markRetryLaneIfNotHydrated(fe, 67108864) } } var _enabled = !0; function dispatchDiscreteEvent(fe, K, pe, me) { var ge = ReactSharedInternals.T; ReactSharedInternals.T = null; var xe = ReactDOMSharedInternals.p; try { ReactDOMSharedInternals.p = 2, dispatchEvent(fe, K, pe, me) } finally { ReactDOMSharedInternals.p = xe, ReactSharedInternals.T = ge } } function dispatchContinuousEvent(fe, K, pe, me) { var ge = ReactSharedInternals.T; ReactSharedInternals.T = null; var xe = ReactDOMSharedInternals.p; try { ReactDOMSharedInternals.p = 8, dispatchEvent(fe, K, pe, me) } finally { ReactDOMSharedInternals.p = xe, ReactSharedInternals.T = ge } } function dispatchEvent(fe, K, pe, me) { if (_enabled) { var ge = findInstanceBlockingEvent(me); if (ge === null) dispatchEventForPluginEventSystem(fe, K, me, return_targetInst, pe), clearIfContinuousEvent(fe, me); else if (queueIfContinuousEvent(ge, fe, K, pe, me)) me.stopPropagation(); else if (clearIfContinuousEvent(fe, me), K & 4 && -1 < discreteReplayableEvents.indexOf(fe)) { for (; ge !== null;) { var xe = getInstanceFromNode(ge); if (xe !== null) switch (xe.tag) { case 3: if (xe = xe.stateNode, xe.current.memoizedState.isDehydrated) { var ye = getHighestPriorityLanes(xe.pendingLanes); if (ye !== 0) { var ve = xe; for (ve.pendingLanes |= 2, ve.entangledLanes |= 2; ye;) { var _e = 1 << 31 - clz32(ye); ve.entanglements[1] |= _e, ye &= ~_e } ensureRootIsScheduled(xe), !(executionContext & 6) && (workInProgressRootRenderTargetTime = now$1() + 500, flushSyncWorkAcrossRoots_impl(0)) } } break; case 13: ve = enqueueConcurrentRenderForLane(xe, 2), ve !== null && scheduleUpdateOnFiber(ve, xe, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(xe, 2) }if (xe = findInstanceBlockingEvent(me), xe === null && dispatchEventForPluginEventSystem(fe, K, me, return_targetInst, pe), xe === ge) break; ge = xe } ge !== null && me.stopPropagation() } else dispatchEventForPluginEventSystem(fe, K, me, null, pe) } } function findInstanceBlockingEvent(fe) { return fe = getEventTarget(fe), findInstanceBlockingTarget(fe) } var return_targetInst = null; function findInstanceBlockingTarget(fe) { if (return_targetInst = null, fe = getClosestInstanceFromNode(fe), fe !== null) { var K = getNearestMountedFiber(fe); if (K === null) fe = null; else { var pe = K.tag; if (pe === 13) { if (fe = getSuspenseInstanceFromFiber(K), fe !== null) return fe; fe = null } else if (pe === 3) { if (K.stateNode.current.memoizedState.isDehydrated) return K.tag === 3 ? K.stateNode.containerInfo : null; fe = null } else K !== fe && (fe = null) } } return return_targetInst = fe, null } function getEventPriority(fe) { switch (fe) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (getCurrentPriorityLevel()) { case ImmediatePriority: return 2; case UserBlockingPriority: return 8; case NormalPriority$1: case LowPriority: return 32; case IdlePriority: return 268435456; default: return 32 }default: return 32 } } var hasScheduledReplayAttempt = !1, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map, queuedPointerCaptures = new Map, queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function clearIfContinuousEvent(fe, K) { switch (fe) { case "focusin": case "focusout": queuedFocus = null; break; case "dragenter": case "dragleave": queuedDrag = null; break; case "mouseover": case "mouseout": queuedMouse = null; break; case "pointerover": case "pointerout": queuedPointers.delete(K.pointerId); break; case "gotpointercapture": case "lostpointercapture": queuedPointerCaptures.delete(K.pointerId) } } function accumulateOrCreateContinuousQueuedReplayableEvent(fe, K, pe, me, ge, xe) { return fe === null || fe.nativeEvent !== xe ? (fe = { blockedOn: K, domEventName: pe, eventSystemFlags: me, nativeEvent: xe, targetContainers: [ge] }, K !== null && (K = getInstanceFromNode(K), K !== null && attemptContinuousHydration(K)), fe) : (fe.eventSystemFlags |= me, K = fe.targetContainers, ge !== null && K.indexOf(ge) === -1 && K.push(ge), fe) } function queueIfContinuousEvent(fe, K, pe, me, ge) { switch (K) { case "focusin": return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, fe, K, pe, me, ge), !0; case "dragenter": return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, fe, K, pe, me, ge), !0; case "mouseover": return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, fe, K, pe, me, ge), !0; case "pointerover": var xe = ge.pointerId; return queuedPointers.set(xe, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(xe) || null, fe, K, pe, me, ge)), !0; case "gotpointercapture": return xe = ge.pointerId, queuedPointerCaptures.set(xe, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(xe) || null, fe, K, pe, me, ge)), !0 }return !1 } function attemptExplicitHydrationTarget(fe) { var K = getClosestInstanceFromNode(fe.target); if (K !== null) { var pe = getNearestMountedFiber(K); if (pe !== null) { if (K = pe.tag, K === 13) { if (K = getSuspenseInstanceFromFiber(pe), K !== null) { fe.blockedOn = K, runWithPriority(fe.priority, function () { if (pe.tag === 13) { var me = requestUpdateLane(), ge = enqueueConcurrentRenderForLane(pe, me); ge !== null && scheduleUpdateOnFiber(ge, pe, me), markRetryLaneIfNotHydrated(pe, me) } }); return } } else if (K === 3 && pe.stateNode.current.memoizedState.isDehydrated) { fe.blockedOn = pe.tag === 3 ? pe.stateNode.containerInfo : null; return } } } fe.blockedOn = null } function attemptReplayContinuousQueuedEvent(fe) { if (fe.blockedOn !== null) return !1; for (var K = fe.targetContainers; 0 < K.length;) { var pe = findInstanceBlockingEvent(fe.nativeEvent); if (pe === null) { pe = fe.nativeEvent; var me = new pe.constructor(pe.type, pe); currentReplayingEvent = me, pe.target.dispatchEvent(me), currentReplayingEvent = null } else return K = getInstanceFromNode(pe), K !== null && attemptContinuousHydration(K), fe.blockedOn = pe, !1; K.shift() } return !0 } function attemptReplayContinuousQueuedEventInMap(fe, K, pe) { attemptReplayContinuousQueuedEvent(fe) && pe.delete(K) } function replayUnblockedEvents() { hasScheduledReplayAttempt = !1, queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null), queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null), queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null), queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap), queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap) } function scheduleCallbackIfUnblocked(fe, K) { fe.blockedOn === K && (fe.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents))) } var lastScheduledReplayQueue = null; function scheduleReplayQueueIfNeeded(fe) { lastScheduledReplayQueue !== fe && (lastScheduledReplayQueue = fe, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () { lastScheduledReplayQueue === fe && (lastScheduledReplayQueue = null); for (var K = 0; K < fe.length; K += 3) { var pe = fe[K], me = fe[K + 1], ge = fe[K + 2]; if (typeof me != "function") { if (findInstanceBlockingTarget(me || pe) === null) continue; break } var xe = getInstanceFromNode(pe); xe !== null && (fe.splice(K, 3), K -= 3, startHostTransition(xe, { pending: !0, data: ge, method: pe.method, action: me }, me, ge)) } })) } function retryIfBlockedOn(fe) { function K(_e) { return scheduleCallbackIfUnblocked(_e, fe) } queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, fe), queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, fe), queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, fe), queuedPointers.forEach(K), queuedPointerCaptures.forEach(K); for (var pe = 0; pe < queuedExplicitHydrationTargets.length; pe++) { var me = queuedExplicitHydrationTargets[pe]; me.blockedOn === fe && (me.blockedOn = null) } for (; 0 < queuedExplicitHydrationTargets.length && (pe = queuedExplicitHydrationTargets[0], pe.blockedOn === null);)attemptExplicitHydrationTarget(pe), pe.blockedOn === null && queuedExplicitHydrationTargets.shift(); if (pe = (fe.ownerDocument || fe).$$reactFormReplay, pe != null) for (me = 0; me < pe.length; me += 3) { var ge = pe[me], xe = pe[me + 1], ye = ge[internalPropsKey] || null; if (typeof xe == "function") ye || scheduleReplayQueueIfNeeded(pe); else if (ye) { var ve = null; if (xe && xe.hasAttribute("formAction")) { if (ge = xe, ye = xe[internalPropsKey] || null) ve = ye.formAction; else if (findInstanceBlockingTarget(ge) !== null) continue } else ve = ye.action; typeof ve == "function" ? pe[me + 1] = ve : (pe.splice(me, 3), me -= 3), scheduleReplayQueueIfNeeded(pe) } } } function ReactDOMRoot(fe) { this._internalRoot = fe } ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (fe) { var K = this._internalRoot; if (K === null) throw Error(formatProdErrorMessage(409)); var pe = K.current, me = requestUpdateLane(); updateContainerImpl(pe, me, fe, K, null, null) }; ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () { var fe = this._internalRoot; if (fe !== null) { this._internalRoot = null; var K = fe.containerInfo; fe.tag === 0 && flushPassiveEffects(), updateContainerImpl(fe.current, 2, null, fe, null, null), flushSyncWork$1(), K[internalContainerInstanceKey] = null } }; function ReactDOMHydrationRoot(fe) { this._internalRoot = fe } ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (fe) { if (fe) { var K = resolveUpdatePriority(); fe = { blockedOn: null, target: fe, priority: K }; for (var pe = 0; pe < queuedExplicitHydrationTargets.length && K !== 0 && K < queuedExplicitHydrationTargets[pe].priority; pe++); queuedExplicitHydrationTargets.splice(pe, 0, fe), pe === 0 && attemptExplicitHydrationTarget(fe) } }; var isomorphicReactPackageVersion$jscomp$inline_1686 = React$2.version; if (isomorphicReactPackageVersion$jscomp$inline_1686 !== "19.0.0") throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1686, "19.0.0")); ReactDOMSharedInternals.findDOMNode = function (fe) { var K = fe._reactInternals; if (K === void 0) throw typeof fe.render == "function" ? Error(formatProdErrorMessage(188)) : (fe = Object.keys(fe).join(","), Error(formatProdErrorMessage(268, fe))); return fe = findCurrentFiberUsingSlowPath(K), fe = fe !== null ? findCurrentHostFiberImpl(fe) : null, fe = fe === null ? null : fe.stateNode, fe }; var internals$jscomp$inline_2165 = { bundleType: 0, version: "19.0.0", rendererPackageName: "react-dom", currentDispatcherRef: ReactSharedInternals, findFiberByHostInstance: getClosestInstanceFromNode, reconcilerVersion: "19.0.0" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!hook$jscomp$inline_2166.isDisabled && hook$jscomp$inline_2166.supportsFiber) try { rendererID = hook$jscomp$inline_2166.inject(internals$jscomp$inline_2165), injectedHook = hook$jscomp$inline_2166 } catch { } } reactDomClient_production.createRoot = function (fe, K) { if (!isValidContainer(fe)) throw Error(formatProdErrorMessage(299)); var pe = !1, me = "", ge = defaultOnUncaughtError, xe = defaultOnCaughtError, ye = defaultOnRecoverableError, ve = null; return K != null && (K.unstable_strictMode === !0 && (pe = !0), K.identifierPrefix !== void 0 && (me = K.identifierPrefix), K.onUncaughtError !== void 0 && (ge = K.onUncaughtError), K.onCaughtError !== void 0 && (xe = K.onCaughtError), K.onRecoverableError !== void 0 && (ye = K.onRecoverableError), K.unstable_transitionCallbacks !== void 0 && (ve = K.unstable_transitionCallbacks)), K = createFiberRoot(fe, 1, !1, null, null, pe, me, ge, xe, ye, ve, null), fe[internalContainerInstanceKey] = K.current, listenToAllSupportedEvents(fe.nodeType === 8 ? fe.parentNode : fe), new ReactDOMRoot(K) }; reactDomClient_production.hydrateRoot = function (fe, K, pe) { if (!isValidContainer(fe)) throw Error(formatProdErrorMessage(299)); var me = !1, ge = "", xe = defaultOnUncaughtError, ye = defaultOnCaughtError, ve = defaultOnRecoverableError, _e = null, Ee = null; return pe != null && (pe.unstable_strictMode === !0 && (me = !0), pe.identifierPrefix !== void 0 && (ge = pe.identifierPrefix), pe.onUncaughtError !== void 0 && (xe = pe.onUncaughtError), pe.onCaughtError !== void 0 && (ye = pe.onCaughtError), pe.onRecoverableError !== void 0 && (ve = pe.onRecoverableError), pe.unstable_transitionCallbacks !== void 0 && (_e = pe.unstable_transitionCallbacks), pe.formState !== void 0 && (Ee = pe.formState)), K = createFiberRoot(fe, 1, !0, K, pe ?? null, me, ge, xe, ye, ve, _e, Ee), K.context = getContextForSubtree(null), pe = K.current, me = requestUpdateLane(), ge = createUpdate(me), ge.callback = null, enqueueUpdate(pe, ge, me), K.current.lanes = me, markRootUpdated$1(K, me), ensureRootIsScheduled(K), fe[internalContainerInstanceKey] = K.current, listenToAllSupportedEvents(fe), new ReactDOMHydrationRoot(K) }; reactDomClient_production.version = "19.0.0"; function checkDCE() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE) } catch (fe) { console.error(fe) } } checkDCE(), client.exports = reactDomClient_production; var clientExports = client.exports; const ReactDOM = getDefaultExportFromCjs(clientExports); var observerMap = new Map, RootIds = new WeakMap, rootId = 0, unsupportedValue = void 0; function getRootId(fe) { return fe ? (RootIds.has(fe) || (rootId += 1, RootIds.set(fe, rootId.toString())), RootIds.get(fe)) : "0" } function optionsToId(fe) { return Object.keys(fe).sort().filter(K => fe[K] !== void 0).map(K => `${K}_${K === "root" ? getRootId(fe.root) : fe[K]}`).toString() } function createObserver(fe) { const K = optionsToId(fe); let pe = observerMap.get(K); if (!pe) { const me = new Map; let ge; const xe = new IntersectionObserver(ye => { ye.forEach(ve => { var _e; const Ee = ve.isIntersecting && ge.some(be => ve.intersectionRatio >= be); fe.trackVisibility && typeof ve.isVisible > "u" && (ve.isVisible = Ee), (_e = me.get(ve.target)) == null || _e.forEach(be => { be(Ee, ve) }) }) }, fe); ge = xe.thresholds || (Array.isArray(fe.threshold) ? fe.threshold : [fe.threshold || 0]), pe = { id: K, observer: xe, elements: me }, observerMap.set(K, pe) } return pe } function observe(fe, K, pe = {}, me = unsupportedValue) { if (typeof window.IntersectionObserver > "u" && me !== void 0) { const _e = fe.getBoundingClientRect(); return K(me, { isIntersecting: me, target: fe, intersectionRatio: typeof pe.threshold == "number" ? pe.threshold : 0, time: 0, boundingClientRect: _e, intersectionRect: _e, rootBounds: _e }), () => { } } const { id: ge, observer: xe, elements: ye } = createObserver(pe), ve = ye.get(fe) || []; return ye.has(fe) || ye.set(fe, ve), ve.push(K), xe.observe(fe), function () { ve.splice(ve.indexOf(K), 1), ve.length === 0 && (ye.delete(fe), xe.unobserve(fe)), ye.size === 0 && (xe.disconnect(), observerMap.delete(ge)) } } function useInView({ threshold: fe, delay: K, trackVisibility: pe, rootMargin: me, root: ge, triggerOnce: xe, skip: ye, initialInView: ve, fallbackInView: _e, onChange: Ee } = {}) { var be; const [Ae, Se] = reactExports.useState(null), Ce = reactExports.useRef(Ee), [we, Be] = reactExports.useState({ inView: !!ve, entry: void 0 }); Ce.current = Ee, reactExports.useEffect(() => { if (ye || !Ae) return; let Pe; return Pe = observe(Ae, (Ne, ke) => { Be({ inView: Ne, entry: ke }), Ce.current && Ce.current(Ne, ke), ke.isIntersecting && xe && Pe && (Pe(), Pe = void 0) }, { root: ge, rootMargin: me, threshold: fe, trackVisibility: pe, delay: K }, _e), () => { Pe && Pe() } }, [Array.isArray(fe) ? fe.toString() : fe, Ae, ge, me, xe, ye, pe, _e, K]); const De = (be = we.entry) == null ? void 0 : be.target, Re = reactExports.useRef(void 0); !Ae && De && !xe && !ye && Re.current !== De && (Re.current = De, Be({ inView: !!ve, entry: void 0 })); const Ie = [Se, we.inView, we.entry]; return Ie.ref = Ie[0], Ie.inView = Ie[1], Ie.entry = Ie[2], Ie } function clamp$7(fe, K, pe) { return K === void 0 && pe === void 0 ? fe : K !== void 0 && pe === void 0 ? Math.max(fe, K) : Math.min(K === void 0 && pe !== void 0 ? fe : Math.max(fe, K), pe) } function randomId(fe = "mantine-") { return `${fe}${Math.random().toString(36).slice(2, 11)}` } function useCallbackRef$1(fe) { const K = reactExports.useRef(fe); return reactExports.useEffect(() => { K.current = fe }), reactExports.useMemo(() => (...pe) => K.current?.(...pe), []) } function useDebouncedCallback(fe, K) { const pe = typeof K == "number" ? K : K.delay, me = typeof K == "number" ? !1 : K.flushOnUnmount, ge = typeof K == "number" ? !1 : K.leading, xe = useCallbackRef$1(fe), ye = reactExports.useRef(0), ve = reactExports.useRef(() => { }), _e = reactExports.useRef(ge), Ee = Object.assign(reactExports.useCallback((...be) => { if (window.clearTimeout(ye.current), ge && _e.current) { _e.current = !1, xe(...be); return } const Ae = () => { ye.current !== 0 && (ye.current = 0, _e.current = !0, xe(...be)) }; ve.current = Ae, Ee.flush = Ae, ye.current = window.setTimeout(Ae, pe), _e.current = !1 }, [xe, pe, ge]), { flush: ve.current }); return reactExports.useEffect(() => () => { window.clearTimeout(ye.current), me && Ee.flush() }, [Ee, me]), Ee } const DEFAULT_EVENTS = ["mousedown", "touchstart"]; function useClickOutside(fe, K, pe) { const me = reactExports.useRef(null); return reactExports.useEffect(() => { const ge = xe => { const { target: ye } = xe ?? {}; if (Array.isArray(pe)) { const ve = ye?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(ye) && ye.tagName !== "HTML"; pe.every(Ee => !!Ee && !xe.composedPath().includes(Ee)) && !ve && fe() } else me.current && !me.current.contains(ye) && fe() }; return (K || DEFAULT_EVENTS).forEach(xe => document.addEventListener(xe, ge)), () => { (K || DEFAULT_EVENTS).forEach(xe => document.removeEventListener(xe, ge)) } }, [me, fe, pe]), me } function useClipboard({ timeout: fe = 2e3 } = {}) { const [K, pe] = reactExports.useState(null), [me, ge] = reactExports.useState(!1), [xe, ye] = reactExports.useState(null), ve = be => { window.clearTimeout(xe), ye(window.setTimeout(() => ge(!1), fe)), ge(be) }; return { copy: be => { "clipboard" in navigator ? navigator.clipboard.writeText(be).then(() => ve(!0)).catch(Ae => pe(Ae)) : pe(new Error("useClipboard: navigator.clipboard is not supported")) }, reset: () => { ge(!1), pe(null), window.clearTimeout(xe) }, error: K, copied: me } } function attachMediaListener(fe, K) { try { return fe.addEventListener("change", K), () => fe.removeEventListener("change", K) } catch { return fe.addListener(K), () => fe.removeListener(K) } } function getInitialValue(fe, K) { return typeof window < "u" && "matchMedia" in window ? window.matchMedia(fe).matches : !1 } function useMediaQuery(fe, K, { getInitialValueInEffect: pe } = { getInitialValueInEffect: !0 }) { const [me, ge] = reactExports.useState(pe ? K : getInitialValue(fe)), xe = reactExports.useRef(null); return reactExports.useEffect(() => { if ("matchMedia" in window) return xe.current = window.matchMedia(fe), ge(xe.current.matches), attachMediaListener(xe.current, ye => ge(ye.matches)) }, [fe]), me } function useColorScheme(fe, K) { return useMediaQuery("(prefers-color-scheme: dark)", fe === "dark", K) ? "dark" : "light" } const useIsomorphicEffect$1 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect; function useDidUpdate(fe, K) { const pe = reactExports.useRef(!1); reactExports.useEffect(() => () => { pe.current = !1 }, []), reactExports.useEffect(() => { if (pe.current) return fe(); pe.current = !0 }, K) } function useFocusReturn({ opened: fe, shouldReturnFocus: K = !0 }) { const pe = reactExports.useRef(null), me = () => { pe.current && "focus" in pe.current && typeof pe.current.focus == "function" && pe.current?.focus({ preventScroll: !0 }) }; return useDidUpdate(() => { let ge = -1; const xe = ye => { ye.key === "Tab" && window.clearTimeout(ge) }; return document.addEventListener("keydown", xe), fe ? pe.current = document.activeElement : K && (ge = window.setTimeout(me, 10)), () => { window.clearTimeout(ge), document.removeEventListener("keydown", xe) } }, [fe, K]), me } const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]"; function hidden(fe) { return fe.style.display === "none" } function visible(fe) { if (fe.getAttribute("aria-hidden") || fe.getAttribute("hidden") || fe.getAttribute("type") === "hidden") return !1; let pe = fe; for (; pe && !(pe === document.body || pe.nodeType === 11);) { if (hidden(pe)) return !1; pe = pe.parentNode } return !0 } function getElementTabIndex(fe) { let K = fe.getAttribute("tabindex"); return K === null && (K = void 0), parseInt(K, 10) } function focusable(fe) { const K = fe.nodeName.toLowerCase(), pe = !Number.isNaN(getElementTabIndex(fe)); return (TABBABLE_NODES.test(K) && !fe.disabled || fe instanceof HTMLAnchorElement && fe.href || pe) && visible(fe) } function tabbable(fe) { const K = getElementTabIndex(fe); return (Number.isNaN(K) || K >= 0) && focusable(fe) } function findTabbableDescendants(fe) { return Array.from(fe.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable) } function scopeTab(fe, K) { const pe = findTabbableDescendants(fe); if (!pe.length) { K.preventDefault(); return } const me = pe[K.shiftKey ? 0 : pe.length - 1], ge = fe.getRootNode(); let xe = me === ge.activeElement || fe === ge.activeElement; const ye = ge.activeElement; if (ye.tagName === "INPUT" && ye.getAttribute("type") === "radio" && (xe = pe.filter(be => be.getAttribute("type") === "radio" && be.getAttribute("name") === ye.getAttribute("name")).includes(me)), !xe) return; K.preventDefault(); const _e = pe[K.shiftKey ? pe.length - 1 : 0]; _e && _e.focus() } function useFocusTrap(fe = !0) { const K = reactExports.useRef(null), pe = ge => { let xe = ge.querySelector("[data-autofocus]"); if (!xe) { const ye = Array.from(ge.querySelectorAll(FOCUS_SELECTOR)); xe = ye.find(tabbable) || ye.find(focusable) || null, !xe && focusable(ge) && (xe = ge) } xe && xe.focus({ preventScroll: !0 }) }, me = reactExports.useCallback(ge => { fe && ge !== null && K.current !== ge && (ge ? (setTimeout(() => { ge.getRootNode() && pe(ge) }), K.current = ge) : K.current = null) }, [fe]); return reactExports.useEffect(() => { if (!fe) return; K.current && setTimeout(() => pe(K.current)); const ge = xe => { xe.key === "Tab" && K.current && scopeTab(K.current, xe) }; return document.addEventListener("keydown", ge), () => document.removeEventListener("keydown", ge) }, [fe]), me } const reducer = fe => (fe + 1) % 1e6; function useForceUpdate() { const [, fe] = reactExports.useReducer(reducer, 0); return fe } const __useId = React$4.useId || (() => { }); function useReactId$1() { const fe = __useId(); return fe ? `mantine-${fe.replace(/:/g, "")}` : "" } function useId$1(fe) { const K = useReactId$1(), [pe, me] = reactExports.useState(K); return useIsomorphicEffect$1(() => { me(randomId()) }, []), typeof fe == "string" ? fe : typeof window > "u" ? K : pe } function useWindowEvent(fe, K, pe) { reactExports.useEffect(() => (window.addEventListener(fe, K, pe), () => window.removeEventListener(fe, K, pe)), [fe, K]) } function assignRef$1(fe, K) { if (typeof fe == "function") return fe(K); typeof fe == "object" && fe !== null && "current" in fe && (fe.current = K) } function mergeRefs(...fe) { const K = new Map; return pe => { if (fe.forEach(me => { const ge = assignRef$1(me, pe); ge && K.set(me, ge) }), K.size > 0) return () => { fe.forEach(me => { const ge = K.get(me); ge ? ge() : assignRef$1(me, null) }), K.clear() } } } function useMergedRef(...fe) { return reactExports.useCallback(mergeRefs(...fe), fe) } function clampUseMovePosition(fe) { return { x: clamp$7(fe.x, 0, 1), y: clamp$7(fe.y, 0, 1) } } function useMove(fe, K, pe = "ltr") { const me = reactExports.useRef(null), ge = reactExports.useRef(!1), xe = reactExports.useRef(!1), ye = reactExports.useRef(0), [ve, _e] = reactExports.useState(!1); return reactExports.useEffect(() => { ge.current = !0 }, []), reactExports.useEffect(() => { const Ee = me.current, be = ({ x: Pe, y: Ne }) => { cancelAnimationFrame(ye.current), ye.current = requestAnimationFrame(() => { if (ge.current && Ee) { Ee.style.userSelect = "none"; const ke = Ee.getBoundingClientRect(); if (ke.width && ke.height) { const Oe = clamp$7((Pe - ke.left) / ke.width, 0, 1); fe({ x: pe === "ltr" ? Oe : 1 - Oe, y: clamp$7((Ne - ke.top) / ke.height, 0, 1) }) } } }) }, Ae = () => { document.addEventListener("mousemove", De), document.addEventListener("mouseup", we), document.addEventListener("touchmove", Ie), document.addEventListener("touchend", we) }, Se = () => { document.removeEventListener("mousemove", De), document.removeEventListener("mouseup", we), document.removeEventListener("touchmove", Ie), document.removeEventListener("touchend", we) }, Ce = () => { !xe.current && ge.current && (xe.current = !0, typeof K?.onScrubStart == "function" && K.onScrubStart(), _e(!0), Ae()) }, we = () => { xe.current && ge.current && (xe.current = !1, _e(!1), Se(), setTimeout(() => { typeof K?.onScrubEnd == "function" && K.onScrubEnd() }, 0)) }, Be = Pe => { Ce(), Pe.preventDefault(), De(Pe) }, De = Pe => be({ x: Pe.clientX, y: Pe.clientY }), Re = Pe => { Pe.cancelable && Pe.preventDefault(), Ce(), Ie(Pe) }, Ie = Pe => { Pe.cancelable && Pe.preventDefault(), be({ x: Pe.changedTouches[0].clientX, y: Pe.changedTouches[0].clientY }) }; return Ee?.addEventListener("mousedown", Be), Ee?.addEventListener("touchstart", Re, { passive: !1 }), () => { Ee && (Ee.removeEventListener("mousedown", Be), Ee.removeEventListener("touchstart", Re)) } }, [pe, fe]), { ref: me, active: ve } } function useUncontrolled({ value: fe, defaultValue: K, finalValue: pe, onChange: me = () => { } }) { const [ge, xe] = reactExports.useState(K !== void 0 ? K : pe), ye = (ve, ..._e) => { xe(ve), me?.(ve, ..._e) }; return fe !== void 0 ? [fe, me, !0] : [ge, ye, !1] } function useReducedMotion(fe, K) { return useMediaQuery("(prefers-reduced-motion: reduce)", fe, K) } const defaultState = { x: 0, y: 0, width: 0, height: 0, top: 0, left: 0, bottom: 0, right: 0 }; function useResizeObserver$1(fe) { const K = reactExports.useRef(0), pe = reactExports.useRef(null), [me, ge] = reactExports.useState(defaultState), xe = reactExports.useMemo(() => typeof window < "u" ? new ResizeObserver(ye => { const ve = ye[0]; ve && (cancelAnimationFrame(K.current), K.current = requestAnimationFrame(() => { if (pe.current) { const _e = ve.borderBoxSize?.[0] || ve.contentBoxSize?.[0]; if (_e) { const Ee = _e.inlineSize, be = _e.blockSize; ge({ width: Ee, height: be, x: ve.contentRect.x, y: ve.contentRect.y, top: ve.contentRect.top, left: ve.contentRect.left, bottom: ve.contentRect.bottom, right: ve.contentRect.right }) } else ge(ve.contentRect) } })) }) : null, []); return reactExports.useEffect(() => (pe.current && xe?.observe(pe.current, fe), () => { xe?.disconnect(), K.current && cancelAnimationFrame(K.current) }), [pe.current]), [pe, me] } function useElementSize(fe) { const [K, { width: pe, height: me }] = useResizeObserver$1(fe); return { ref: K, width: pe, height: me } } function useDisclosure(fe = !1, K) { const { onOpen: pe, onClose: me } = {}, [ge, xe] = reactExports.useState(fe), ye = reactExports.useCallback(() => { xe(Ee => Ee || (pe?.(), !0)) }, [pe]), ve = reactExports.useCallback(() => { xe(Ee => Ee && (me?.(), !1)) }, [me]), _e = reactExports.useCallback(() => { ge ? ve() : ye() }, [ve, ye, ge]); return [ge, { open: ye, close: ve, toggle: _e }] } function usePrevious(fe) { const K = reactExports.useRef(void 0); return reactExports.useEffect(() => { K.current = fe }, [fe]), K.current } function isOpera() { return navigator.userAgent.includes("OPR") } function useEyeDropper() { const [fe, K] = reactExports.useState(!1); useIsomorphicEffect$1(() => { K(typeof window < "u" && !isOpera() && "EyeDropper" in window) }, []); const pe = reactExports.useCallback((me = {}) => fe ? new window.EyeDropper().open(me) : Promise.resolve(void 0), [fe]); return { supported: fe, open: pe } } function createStore$3(fe) { let K = fe, pe = !1; const me = new Set; return { getState() { return K }, updateState(ge) { K = typeof ge == "function" ? ge(K) : ge }, setState(ge) { this.updateState(ge), me.forEach(xe => xe(K)) }, initialize(ge) { pe || (K = ge, pe = !0) }, subscribe(ge) { return me.add(ge), () => me.delete(ge) } } } function useStore$2(fe) { return reactExports.useSyncExternalStore(fe.subscribe, () => fe.getState(), () => fe.getState()) } function getDistributedNotifications(fe, K, pe) { const me = [], ge = [], xe = {}; for (const ye of fe) { const ve = ye.position || K; xe[ve] = xe[ve] || 0, xe[ve] += 1, xe[ve] <= pe ? ge.push(ye) : me.push(ye) } return { notifications: ge, queue: me } } const createNotificationsStore = () => createStore$3({ notifications: [], queue: [], defaultPosition: "bottom-right", limit: 5 }), notificationsStore = createNotificationsStore(), useNotifications = (fe = notificationsStore) => useStore$2(fe); function updateNotificationsState(fe, K) { const pe = fe.getState(), me = K([...pe.notifications, ...pe.queue]), ge = getDistributedNotifications(me, pe.defaultPosition, pe.limit); fe.setState({ notifications: ge.notifications, queue: ge.queue, limit: pe.limit, defaultPosition: pe.defaultPosition }) } function showNotification(fe, K = notificationsStore) { const pe = fe.id || randomId(); return updateNotificationsState(K, me => fe.id && me.some(ge => ge.id === fe.id) ? me : [...me, { ...fe, id: pe }]), pe } function hideNotification(fe, K = notificationsStore) { return updateNotificationsState(K, pe => pe.filter(me => me.id === fe ? (me.onClose?.(me), !1) : !0)), fe } function updateNotification(fe, K = notificationsStore) { return updateNotificationsState(K, pe => pe.map(me => me.id === fe.id ? { ...me, ...fe } : me)), fe.id } function cleanNotifications(fe = notificationsStore) { updateNotificationsState(fe, () => []) } function cleanNotificationsQueue(fe = notificationsStore) { updateNotificationsState(fe, K => K.slice(0, fe.getState().limit)) } const notifications = { show: showNotification, hide: hideNotification, update: updateNotification, clean: cleanNotifications, cleanQueue: cleanNotificationsQueue, updateState: updateNotificationsState }; function _extends$2() { return _extends$2 = Object.assign ? Object.assign.bind() : function (fe) { for (var K = 1; K < arguments.length; K++) { var pe = arguments[K]; for (var me in pe) ({}).hasOwnProperty.call(pe, me) && (fe[me] = pe[me]) } return fe }, _extends$2.apply(null, arguments) } function _objectWithoutPropertiesLoose(fe, K) { if (fe == null) return {}; var pe = {}; for (var me in fe) if ({}.hasOwnProperty.call(fe, me)) { if (K.indexOf(me) !== -1) continue; pe[me] = fe[me] } return pe } function _setPrototypeOf(fe, K) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (pe, me) { return pe.__proto__ = me, pe }, _setPrototypeOf(fe, K) } function _inheritsLoose(fe, K) { fe.prototype = Object.create(K.prototype), fe.prototype.constructor = fe, _setPrototypeOf(fe, K) } var propTypes$2 = { exports: {} }, ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", ReactPropTypesSecret_1 = ReactPropTypesSecret$1, ReactPropTypesSecret = ReactPropTypesSecret_1; function emptyFunction() { } function emptyFunctionWithReset() { } emptyFunctionWithReset.resetWarningCache = emptyFunction; var factoryWithThrowingShims = function () { function fe(me, ge, xe, ye, ve, _e) { if (_e !== ReactPropTypesSecret) { var Ee = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw Ee.name = "Invariant Violation", Ee } } fe.isRequired = fe; function K() { return fe } var pe = { array: fe, bigint: fe, bool: fe, func: fe, number: fe, object: fe, string: fe, symbol: fe, any: fe, arrayOf: K, element: fe, elementType: fe, instanceOf: K, node: fe, objectOf: K, oneOf: K, oneOfType: K, shape: K, exact: K, checkPropTypes: emptyFunctionWithReset, resetWarningCache: emptyFunction }; return pe.PropTypes = pe, pe }; propTypes$2.exports = factoryWithThrowingShims(); var propTypesExports = propTypes$2.exports; const config = { disabled: !1 }, TransitionGroupContext = React$4.createContext(null); var forceReflow = function (K) { return K.scrollTop }, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition$2 = function (fe) { _inheritsLoose(K, fe); function K(me, ge) { var xe; xe = fe.call(this, me, ge) || this; var ye = ge, ve = ye && !ye.isMounting ? me.enter : me.appear, _e; return xe.appearStatus = null, me.in ? ve ? (_e = EXITED, xe.appearStatus = ENTERING) : _e = ENTERED : me.unmountOnExit || me.mountOnEnter ? _e = UNMOUNTED : _e = EXITED, xe.state = { status: _e }, xe.nextCallback = null, xe } K.getDerivedStateFromProps = function (ge, xe) { var ye = ge.in; return ye && xe.status === UNMOUNTED ? { status: EXITED } : null }; var pe = K.prototype; return pe.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, pe.componentDidUpdate = function (ge) { var xe = null; if (ge !== this.props) { var ye = this.state.status; this.props.in ? ye !== ENTERING && ye !== ENTERED && (xe = ENTERING) : (ye === ENTERING || ye === ENTERED) && (xe = EXITING) } this.updateStatus(!1, xe) }, pe.componentWillUnmount = function () { this.cancelNextCallback() }, pe.getTimeouts = function () { var ge = this.props.timeout, xe, ye, ve; return xe = ye = ve = ge, ge != null && typeof ge != "number" && (xe = ge.exit, ye = ge.enter, ve = ge.appear !== void 0 ? ge.appear : ye), { exit: xe, enter: ye, appear: ve } }, pe.updateStatus = function (ge, xe) { if (ge === void 0 && (ge = !1), xe !== null) if (this.cancelNextCallback(), xe === ENTERING) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var ye = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM$2.findDOMNode(this); ye && forceReflow(ye) } this.performEnter(ge) } else this.performExit(); else this.props.unmountOnExit && this.state.status === EXITED && this.setState({ status: UNMOUNTED }) }, pe.performEnter = function (ge) { var xe = this, ye = this.props.enter, ve = this.context ? this.context.isMounting : ge, _e = this.props.nodeRef ? [ve] : [ReactDOM$2.findDOMNode(this), ve], Ee = _e[0], be = _e[1], Ae = this.getTimeouts(), Se = ve ? Ae.appear : Ae.enter; if (!ge && !ye || config.disabled) { this.safeSetState({ status: ENTERED }, function () { xe.props.onEntered(Ee) }); return } this.props.onEnter(Ee, be), this.safeSetState({ status: ENTERING }, function () { xe.props.onEntering(Ee, be), xe.onTransitionEnd(Se, function () { xe.safeSetState({ status: ENTERED }, function () { xe.props.onEntered(Ee, be) }) }) }) }, pe.performExit = function () { var ge = this, xe = this.props.exit, ye = this.getTimeouts(), ve = this.props.nodeRef ? void 0 : ReactDOM$2.findDOMNode(this); if (!xe || config.disabled) { this.safeSetState({ status: EXITED }, function () { ge.props.onExited(ve) }); return } this.props.onExit(ve), this.safeSetState({ status: EXITING }, function () { ge.props.onExiting(ve), ge.onTransitionEnd(ye.exit, function () { ge.safeSetState({ status: EXITED }, function () { ge.props.onExited(ve) }) }) }) }, pe.cancelNextCallback = function () { this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null) }, pe.safeSetState = function (ge, xe) { xe = this.setNextCallback(xe), this.setState(ge, xe) }, pe.setNextCallback = function (ge) { var xe = this, ye = !0; return this.nextCallback = function (ve) { ye && (ye = !1, xe.nextCallback = null, ge(ve)) }, this.nextCallback.cancel = function () { ye = !1 }, this.nextCallback }, pe.onTransitionEnd = function (ge, xe) { this.setNextCallback(xe); var ye = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM$2.findDOMNode(this), ve = ge == null && !this.props.addEndListener; if (!ye || ve) { setTimeout(this.nextCallback, 0); return } if (this.props.addEndListener) { var _e = this.props.nodeRef ? [this.nextCallback] : [ye, this.nextCallback], Ee = _e[0], be = _e[1]; this.props.addEndListener(Ee, be) } ge != null && setTimeout(this.nextCallback, ge) }, pe.render = function () { var ge = this.state.status; if (ge === UNMOUNTED) return null; var xe = this.props, ye = xe.children; xe.in, xe.mountOnEnter, xe.unmountOnExit, xe.appear, xe.enter, xe.exit, xe.timeout, xe.addEndListener, xe.onEnter, xe.onEntering, xe.onEntered, xe.onExit, xe.onExiting, xe.onExited, xe.nodeRef; var ve = _objectWithoutPropertiesLoose(xe, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]); return React$4.createElement(TransitionGroupContext.Provider, { value: null }, typeof ye == "function" ? ye(ge, ve) : React$4.cloneElement(React$4.Children.only(ye), ve)) }, K }(React$4.Component); Transition$2.contextType = TransitionGroupContext; Transition$2.propTypes = {}; function noop$4() { } Transition$2.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: noop$4, onEntering: noop$4, onEntered: noop$4, onExit: noop$4, onExiting: noop$4, onExited: noop$4 }; Transition$2.UNMOUNTED = UNMOUNTED; Transition$2.EXITED = EXITED; Transition$2.ENTERING = ENTERING; Transition$2.ENTERED = ENTERED; Transition$2.EXITING = EXITING; function _assertThisInitialized(fe) { if (fe === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return fe } function getChildMapping(fe, K) { var pe = function (xe) { return K && reactExports.isValidElement(xe) ? K(xe) : xe }, me = Object.create(null); return fe && reactExports.Children.map(fe, function (ge) { return ge }).forEach(function (ge) { me[ge.key] = pe(ge) }), me } function mergeChildMappings(fe, K) { fe = fe || {}, K = K || {}; function pe(be) { return be in K ? K[be] : fe[be] } var me = Object.create(null), ge = []; for (var xe in fe) xe in K ? ge.length && (me[xe] = ge, ge = []) : ge.push(xe); var ye, ve = {}; for (var _e in K) { if (me[_e]) for (ye = 0; ye < me[_e].length; ye++) { var Ee = me[_e][ye]; ve[me[_e][ye]] = pe(Ee) } ve[_e] = pe(_e) } for (ye = 0; ye < ge.length; ye++)ve[ge[ye]] = pe(ge[ye]); return ve } function getProp(fe, K, pe) { return pe[K] != null ? pe[K] : fe.props[K] } function getInitialChildMapping(fe, K) { return getChildMapping(fe.children, function (pe) { return reactExports.cloneElement(pe, { onExited: K.bind(null, pe), in: !0, appear: getProp(pe, "appear", fe), enter: getProp(pe, "enter", fe), exit: getProp(pe, "exit", fe) }) }) } function getNextChildMapping(fe, K, pe) { var me = getChildMapping(fe.children), ge = mergeChildMappings(K, me); return Object.keys(ge).forEach(function (xe) { var ye = ge[xe]; if (reactExports.isValidElement(ye)) { var ve = xe in K, _e = xe in me, Ee = K[xe], be = reactExports.isValidElement(Ee) && !Ee.props.in; _e && (!ve || be) ? ge[xe] = reactExports.cloneElement(ye, { onExited: pe.bind(null, ye), in: !0, exit: getProp(ye, "exit", fe), enter: getProp(ye, "enter", fe) }) : !_e && ve && !be ? ge[xe] = reactExports.cloneElement(ye, { in: !1 }) : _e && ve && reactExports.isValidElement(Ee) && (ge[xe] = reactExports.cloneElement(ye, { onExited: pe.bind(null, ye), in: Ee.props.in, exit: getProp(ye, "exit", fe), enter: getProp(ye, "enter", fe) })) } }), ge } var values$1 = Object.values || function (fe) { return Object.keys(fe).map(function (K) { return fe[K] }) }, defaultProps$1s = { component: "div", childFactory: function (K) { return K } }, TransitionGroup = function (fe) { _inheritsLoose(K, fe); function K(me, ge) { var xe; xe = fe.call(this, me, ge) || this; var ye = xe.handleExited.bind(_assertThisInitialized(xe)); return xe.state = { contextValue: { isMounting: !0 }, handleExited: ye, firstRender: !0 }, xe } var pe = K.prototype; return pe.componentDidMount = function () { this.mounted = !0, this.setState({ contextValue: { isMounting: !1 } }) }, pe.componentWillUnmount = function () { this.mounted = !1 }, K.getDerivedStateFromProps = function (ge, xe) { var ye = xe.children, ve = xe.handleExited, _e = xe.firstRender; return { children: _e ? getInitialChildMapping(ge, ve) : getNextChildMapping(ge, ye, ve), firstRender: !1 } }, pe.handleExited = function (ge, xe) { var ye = getChildMapping(this.props.children); ge.key in ye || (ge.props.onExited && ge.props.onExited(xe), this.mounted && this.setState(function (ve) { var _e = _extends$2({}, ve.children); return delete _e[ge.key], { children: _e } })) }, pe.render = function () { var ge = this.props, xe = ge.component, ye = ge.childFactory, ve = _objectWithoutPropertiesLoose(ge, ["component", "childFactory"]), _e = this.state.contextValue, Ee = values$1(this.state.children).map(ye); return delete ve.appear, delete ve.enter, delete ve.exit, xe === null ? React$4.createElement(TransitionGroupContext.Provider, { value: _e }, Ee) : React$4.createElement(TransitionGroupContext.Provider, { value: _e }, React$4.createElement(xe, ve, Ee)) }, K }(React$4.Component); TransitionGroup.propTypes = {}; TransitionGroup.defaultProps = defaultProps$1s; var __assign = function () { return __assign = Object.assign || function (K) { for (var pe, me = 1, ge = arguments.length; me < ge; me++) { pe = arguments[me]; for (var xe in pe) Object.prototype.hasOwnProperty.call(pe, xe) && (K[xe] = pe[xe]) } return K }, __assign.apply(this, arguments) }; function __rest$1(fe, K) { var pe = {}; for (var me in fe) Object.prototype.hasOwnProperty.call(fe, me) && K.indexOf(me) < 0 && (pe[me] = fe[me]); if (fe != null && typeof Object.getOwnPropertySymbols == "function") for (var ge = 0, me = Object.getOwnPropertySymbols(fe); ge < me.length; ge++)K.indexOf(me[ge]) < 0 && Object.prototype.propertyIsEnumerable.call(fe, me[ge]) && (pe[me[ge]] = fe[me[ge]]); return pe } function __spreadArray$1(fe, K, pe) { if (pe || arguments.length === 2) for (var me = 0, ge = K.length, xe; me < ge; me++)(xe || !(me in K)) && (xe || (xe = Array.prototype.slice.call(K, 0, me)), xe[me] = K[me]); return fe.concat(xe || Array.prototype.slice.call(K)) } typeof SuppressedError == "function" && SuppressedError; var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size"; function assignRef(fe, K) { return typeof fe == "function" ? fe(K) : fe && (fe.current = K), fe } function useCallbackRef(fe, K) { var pe = reactExports.useState(function () { return { value: fe, callback: K, facade: { get current() { return pe.value }, set current(me) { var ge = pe.value; ge !== me && (pe.value = me, pe.callback(me, ge)) } } } })[0]; return pe.callback = K, pe.facade } var useIsomorphicLayoutEffect$1 = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, currentValues = new WeakMap; function useMergeRefs$1(fe, K) { var pe = useCallbackRef(null, function (me) { return fe.forEach(function (ge) { return assignRef(ge, me) }) }); return useIsomorphicLayoutEffect$1(function () { var me = currentValues.get(pe); if (me) { var ge = new Set(me), xe = new Set(fe), ye = pe.current; ge.forEach(function (ve) { xe.has(ve) || assignRef(ve, null) }), xe.forEach(function (ve) { ge.has(ve) || assignRef(ve, ye) }) } currentValues.set(pe, fe) }, [fe]), pe } function ItoI(fe) { return fe } function innerCreateMedium(fe, K) { K === void 0 && (K = ItoI); var pe = [], me = !1, ge = { read: function () { if (me) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return pe.length ? pe[pe.length - 1] : fe }, useMedium: function (xe) { var ye = K(xe, me); return pe.push(ye), function () { pe = pe.filter(function (ve) { return ve !== ye }) } }, assignSyncMedium: function (xe) { for (me = !0; pe.length;) { var ye = pe; pe = [], ye.forEach(xe) } pe = { push: function (ve) { return xe(ve) }, filter: function () { return pe } } }, assignMedium: function (xe) { me = !0; var ye = []; if (pe.length) { var ve = pe; pe = [], ve.forEach(xe), ye = pe } var _e = function () { var be = ye; ye = [], be.forEach(xe) }, Ee = function () { return Promise.resolve().then(_e) }; Ee(), pe = { push: function (be) { ye.push(be), Ee() }, filter: function (be) { return ye = ye.filter(be), pe } } } }; return ge } function createSidecarMedium(fe) { fe === void 0 && (fe = {}); var K = innerCreateMedium(null); return K.options = __assign({ async: !0, ssr: !1 }, fe), K } var SideCar$1 = function (fe) { var K = fe.sideCar, pe = __rest$1(fe, ["sideCar"]); if (!K) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var me = K.read(); if (!me) throw new Error("Sidecar medium not found"); return reactExports.createElement(me, __assign({}, pe)) }; SideCar$1.isSideCarExport = !0; function exportSidecar(fe, K) { return fe.useMedium(K), SideCar$1 } var effectCar = createSidecarMedium(), nothing = function () { }, RemoveScroll = reactExports.forwardRef(function (fe, K) { var pe = reactExports.useRef(null), me = reactExports.useState({ onScrollCapture: nothing, onWheelCapture: nothing, onTouchMoveCapture: nothing }), ge = me[0], xe = me[1], ye = fe.forwardProps, ve = fe.children, _e = fe.className, Ee = fe.removeScrollBar, be = fe.enabled, Ae = fe.shards, Se = fe.sideCar, Ce = fe.noIsolation, we = fe.inert, Be = fe.allowPinchZoom, De = fe.as, Re = De === void 0 ? "div" : De, Ie = fe.gapMode, Pe = __rest$1(fe, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), Ne = Se, ke = useMergeRefs$1([pe, K]), Oe = __assign(__assign({}, Pe), ge); return reactExports.createElement(reactExports.Fragment, null, be && reactExports.createElement(Ne, { sideCar: effectCar, removeScrollBar: Ee, shards: Ae, noIsolation: Ce, inert: we, setCallbacks: xe, allowPinchZoom: !!Be, lockRef: pe, gapMode: Ie }), ye ? reactExports.cloneElement(reactExports.Children.only(ve), __assign(__assign({}, Oe), { ref: ke })) : reactExports.createElement(Re, __assign({}, Oe, { className: _e, ref: ke }), ve)) }); RemoveScroll.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; RemoveScroll.classNames = { fullWidth: fullWidthClassName, zeroRight: zeroRightClassName }; var getNonce = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function makeStyleTag() { if (!document) return null; var fe = document.createElement("style"); fe.type = "text/css"; var K = getNonce(); return K && fe.setAttribute("nonce", K), fe } function injectStyles(fe, K) { fe.styleSheet ? fe.styleSheet.cssText = K : fe.appendChild(document.createTextNode(K)) } function insertStyleTag(fe) { var K = document.head || document.getElementsByTagName("head")[0]; K.appendChild(fe) } var stylesheetSingleton = function () { var fe = 0, K = null; return { add: function (pe) { fe == 0 && (K = makeStyleTag()) && (injectStyles(K, pe), insertStyleTag(K)), fe++ }, remove: function () { fe--, !fe && K && (K.parentNode && K.parentNode.removeChild(K), K = null) } } }, styleHookSingleton = function () { var fe = stylesheetSingleton(); return function (K, pe) { reactExports.useEffect(function () { return fe.add(K), function () { fe.remove() } }, [K && pe]) } }, styleSingleton = function () { var fe = styleHookSingleton(), K = function (pe) { var me = pe.styles, ge = pe.dynamic; return fe(me, ge), null }; return K }, zeroGap = { left: 0, top: 0, right: 0, gap: 0 }, parse$1 = function (fe) { return parseInt(fe || "", 10) || 0 }, getOffset = function (fe) { var K = window.getComputedStyle(document.body), pe = K[fe === "padding" ? "paddingLeft" : "marginLeft"], me = K[fe === "padding" ? "paddingTop" : "marginTop"], ge = K[fe === "padding" ? "paddingRight" : "marginRight"]; return [parse$1(pe), parse$1(me), parse$1(ge)] }, getGapWidth = function (fe) { if (fe === void 0 && (fe = "margin"), typeof window > "u") return zeroGap; var K = getOffset(fe), pe = document.documentElement.clientWidth, me = window.innerWidth; return { left: K[0], top: K[1], right: K[2], gap: Math.max(0, me - pe + K[2] - K[0]) } }, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function (fe, K, pe, me) {
	var ge = fe.left, xe = fe.top, ye = fe.right, ve = fe.gap; return pe === void 0 && (pe = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(me, `;
   padding-right: `).concat(ve, "px ").concat(me, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(me, `;
    overscroll-behavior: contain;
    `).concat([K && "position: relative ".concat(me, ";"), pe === "margin" && `
    padding-left: `.concat(ge, `px;
    padding-top: `).concat(xe, `px;
    padding-right: `).concat(ye, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(ve, "px ").concat(me, `;
    `), pe === "padding" && "padding-right: ".concat(ve, "px ").concat(me, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(ve, "px ").concat(me, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(ve, "px ").concat(me, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(me, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(me, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(ve, `px;
  }
`)
}, getCurrentUseCounter = function () { var fe = parseInt(document.body.getAttribute(lockAttribute) || "0", 10); return isFinite(fe) ? fe : 0 }, useLockAttribute = function () { reactExports.useEffect(function () { return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function () { var fe = getCurrentUseCounter() - 1; fe <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, fe.toString()) } }, []) }, RemoveScrollBar = function (fe) { var K = fe.noRelative, pe = fe.noImportant, me = fe.gapMode, ge = me === void 0 ? "margin" : me; useLockAttribute(); var xe = reactExports.useMemo(function () { return getGapWidth(ge) }, [ge]); return reactExports.createElement(Style, { styles: getStyles(xe, !K, ge, pe ? "" : "!important") }) }, passiveSupported = !1; if (typeof window < "u") try { var options = Object.defineProperty({}, "passive", { get: function () { return passiveSupported = !0, !0 } }); window.addEventListener("test", options, options), window.removeEventListener("test", options, options) } catch { passiveSupported = !1 } var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function (fe) { return fe.tagName === "TEXTAREA" }, elementCanBeScrolled = function (fe, K) { if (!(fe instanceof Element)) return !1; var pe = window.getComputedStyle(fe); return pe[K] !== "hidden" && !(pe.overflowY === pe.overflowX && !alwaysContainsScroll(fe) && pe[K] === "visible") }, elementCouldBeVScrolled = function (fe) { return elementCanBeScrolled(fe, "overflowY") }, elementCouldBeHScrolled = function (fe) { return elementCanBeScrolled(fe, "overflowX") }, locationCouldBeScrolled = function (fe, K) { var pe = K.ownerDocument, me = K; do { typeof ShadowRoot < "u" && me instanceof ShadowRoot && (me = me.host); var ge = elementCouldBeScrolled(fe, me); if (ge) { var xe = getScrollVariables(fe, me), ye = xe[1], ve = xe[2]; if (ye > ve) return !0 } me = me.parentNode } while (me && me !== pe.body); return !1 }, getVScrollVariables = function (fe) { var K = fe.scrollTop, pe = fe.scrollHeight, me = fe.clientHeight; return [K, pe, me] }, getHScrollVariables = function (fe) { var K = fe.scrollLeft, pe = fe.scrollWidth, me = fe.clientWidth; return [K, pe, me] }, elementCouldBeScrolled = function (fe, K) { return fe === "v" ? elementCouldBeVScrolled(K) : elementCouldBeHScrolled(K) }, getScrollVariables = function (fe, K) { return fe === "v" ? getVScrollVariables(K) : getHScrollVariables(K) }, getDirectionFactor = function (fe, K) { return fe === "h" && K === "rtl" ? -1 : 1 }, handleScroll = function (fe, K, pe, me, ge) { var xe = getDirectionFactor(fe, window.getComputedStyle(K).direction), ye = xe * me, ve = pe.target, _e = K.contains(ve), Ee = !1, be = ye > 0, Ae = 0, Se = 0; do { var Ce = getScrollVariables(fe, ve), we = Ce[0], Be = Ce[1], De = Ce[2], Re = Be - De - xe * we; (we || Re) && elementCouldBeScrolled(fe, ve) && (Ae += Re, Se += we), ve instanceof ShadowRoot ? ve = ve.host : ve = ve.parentNode } while (!_e && ve !== document.body || _e && (K.contains(ve) || K === ve)); return (be && Math.abs(Ae) < 1 || !be && Math.abs(Se) < 1) && (Ee = !0), Ee }, getTouchXY = function (fe) { return "changedTouches" in fe ? [fe.changedTouches[0].clientX, fe.changedTouches[0].clientY] : [0, 0] }, getDeltaXY = function (fe) { return [fe.deltaX, fe.deltaY] }, extractRef = function (fe) { return fe && "current" in fe ? fe.current : fe }, deltaCompare = function (fe, K) { return fe[0] === K[0] && fe[1] === K[1] }, generateStyle = function (fe) {
	return `
  .block-interactivity-`.concat(fe, ` {pointer-events: none;}
  .allow-interactivity-`).concat(fe, ` {pointer-events: all;}
`)
}, idCounter = 0, lockStack = []; function RemoveScrollSideCar(fe) { var K = reactExports.useRef([]), pe = reactExports.useRef([0, 0]), me = reactExports.useRef(), ge = reactExports.useState(idCounter++)[0], xe = reactExports.useState(styleSingleton)[0], ye = reactExports.useRef(fe); reactExports.useEffect(function () { ye.current = fe }, [fe]), reactExports.useEffect(function () { if (fe.inert) { document.body.classList.add("block-interactivity-".concat(ge)); var Be = __spreadArray$1([fe.lockRef.current], (fe.shards || []).map(extractRef), !0).filter(Boolean); return Be.forEach(function (De) { return De.classList.add("allow-interactivity-".concat(ge)) }), function () { document.body.classList.remove("block-interactivity-".concat(ge)), Be.forEach(function (De) { return De.classList.remove("allow-interactivity-".concat(ge)) }) } } }, [fe.inert, fe.lockRef.current, fe.shards]); var ve = reactExports.useCallback(function (Be, De) { if ("touches" in Be && Be.touches.length === 2 || Be.type === "wheel" && Be.ctrlKey) return !ye.current.allowPinchZoom; var Re = getTouchXY(Be), Ie = pe.current, Pe = "deltaX" in Be ? Be.deltaX : Ie[0] - Re[0], Ne = "deltaY" in Be ? Be.deltaY : Ie[1] - Re[1], ke, Oe = Be.target, Ue = Math.abs(Pe) > Math.abs(Ne) ? "h" : "v"; if ("touches" in Be && Ue === "h" && Oe.type === "range") return !1; var He = locationCouldBeScrolled(Ue, Oe); if (!He) return !0; if (He ? ke = Ue : (ke = Ue === "v" ? "h" : "v", He = locationCouldBeScrolled(Ue, Oe)), !He) return !1; if (!me.current && "changedTouches" in Be && (Pe || Ne) && (me.current = ke), !ke) return !0; var Ge = me.current || ke; return handleScroll(Ge, De, Be, Ge === "h" ? Pe : Ne) }, []), _e = reactExports.useCallback(function (Be) { var De = Be; if (!(!lockStack.length || lockStack[lockStack.length - 1] !== xe)) { var Re = "deltaY" in De ? getDeltaXY(De) : getTouchXY(De), Ie = K.current.filter(function (ke) { return ke.name === De.type && (ke.target === De.target || De.target === ke.shadowParent) && deltaCompare(ke.delta, Re) })[0]; if (Ie && Ie.should) { De.cancelable && De.preventDefault(); return } if (!Ie) { var Pe = (ye.current.shards || []).map(extractRef).filter(Boolean).filter(function (ke) { return ke.contains(De.target) }), Ne = Pe.length > 0 ? ve(De, Pe[0]) : !ye.current.noIsolation; Ne && De.cancelable && De.preventDefault() } } }, []), Ee = reactExports.useCallback(function (Be, De, Re, Ie) { var Pe = { name: Be, delta: De, target: Re, should: Ie, shadowParent: getOutermostShadowParent(Re) }; K.current.push(Pe), setTimeout(function () { K.current = K.current.filter(function (Ne) { return Ne !== Pe }) }, 1) }, []), be = reactExports.useCallback(function (Be) { pe.current = getTouchXY(Be), me.current = void 0 }, []), Ae = reactExports.useCallback(function (Be) { Ee(Be.type, getDeltaXY(Be), Be.target, ve(Be, fe.lockRef.current)) }, []), Se = reactExports.useCallback(function (Be) { Ee(Be.type, getTouchXY(Be), Be.target, ve(Be, fe.lockRef.current)) }, []); reactExports.useEffect(function () { return lockStack.push(xe), fe.setCallbacks({ onScrollCapture: Ae, onWheelCapture: Ae, onTouchMoveCapture: Se }), document.addEventListener("wheel", _e, nonPassive), document.addEventListener("touchmove", _e, nonPassive), document.addEventListener("touchstart", be, nonPassive), function () { lockStack = lockStack.filter(function (Be) { return Be !== xe }), document.removeEventListener("wheel", _e, nonPassive), document.removeEventListener("touchmove", _e, nonPassive), document.removeEventListener("touchstart", be, nonPassive) } }, []); var Ce = fe.removeScrollBar, we = fe.inert; return reactExports.createElement(reactExports.Fragment, null, we ? reactExports.createElement(xe, { styles: generateStyle(ge) }) : null, Ce ? reactExports.createElement(RemoveScrollBar, { gapMode: fe.gapMode }) : null) } function getOutermostShadowParent(fe) { for (var K = null; fe !== null;)fe instanceof ShadowRoot && (K = fe.host, fe = fe.host), fe = fe.parentNode; return K } const SideCar = exportSidecar(effectCar, RemoveScrollSideCar); var ReactRemoveScroll = reactExports.forwardRef(function (fe, K) { return reactExports.createElement(RemoveScroll, __assign({}, fe, { ref: K, sideCar: SideCar })) }); ReactRemoveScroll.classNames = RemoveScroll.classNames; function keys$1(fe) { return Object.keys(fe) } function isObject(fe) { return fe && typeof fe == "object" && !Array.isArray(fe) } function deepMerge(fe, K) { const pe = { ...fe }, me = K; return isObject(fe) && isObject(K) && Object.keys(K).forEach(ge => { isObject(me[ge]) && ge in fe ? pe[ge] = deepMerge(pe[ge], me[ge]) : pe[ge] = me[ge] }), pe } function camelToKebabCase(fe) { return fe.replace(/[A-Z]/g, K => `-${K.toLowerCase()}`) } function getTransformedScaledValue(fe) { return typeof fe != "string" || !fe.includes("var(--mantine-scale)") ? fe : fe.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim() } function px$1(fe) { const K = getTransformedScaledValue(fe); return typeof K == "number" ? K : typeof K == "string" ? K.includes("calc") || K.includes("var") ? K : K.includes("px") ? Number(K.replace("px", "")) : K.includes("rem") ? Number(K.replace("rem", "")) * 16 : K.includes("em") ? Number(K.replace("em", "")) * 16 : Number(K) : NaN } function scaleRem(fe) { return fe === "0rem" ? "0rem" : `calc(${fe} * var(--mantine-scale))` } function createConverter(fe, { shouldScale: K = !1 } = {}) { function pe(me) { if (me === 0 || me === "0") return `0${fe}`; if (typeof me == "number") { const ge = `${me / 16}${fe}`; return K ? scaleRem(ge) : ge } if (typeof me == "string") { if (me === "" || me.startsWith("calc(") || me.startsWith("clamp(") || me.includes("rgba(")) return me; if (me.includes(",")) return me.split(",").map(xe => pe(xe)).join(","); if (me.includes(" ")) return me.split(" ").map(xe => pe(xe)).join(" "); const ge = me.replace("px", ""); if (!Number.isNaN(Number(ge))) { const xe = `${Number(ge) / 16}${fe}`; return K ? scaleRem(xe) : xe } } return me } return pe } const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em"); function filterProps(fe) { return Object.keys(fe).reduce((K, pe) => (fe[pe] !== void 0 && (K[pe] = fe[pe]), K), {}) } function isNumberLike(fe) { if (typeof fe == "number") return !0; if (typeof fe == "string") { if (fe.startsWith("calc(") || fe.startsWith("var(") || fe.includes(" ") && fe.trim() !== "") return !0; const K = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/; return fe.trim().split(/\s+/).every(me => K.test(me)) } return !1 } function isElement$1(fe) { return Array.isArray(fe) || fe === null ? !1 : typeof fe == "object" ? fe.type !== reactExports.Fragment : !1 } function createSafeContext(fe) { const K = reactExports.createContext(null); return [({ children: ge, value: xe }) => jsxRuntimeExports.jsx(K.Provider, { value: xe, children: ge }), () => { const ge = reactExports.useContext(K); if (ge === null) throw new Error(fe); return ge }] } function createOptionalContext(fe = null) { const K = reactExports.createContext(fe); return [({ children: ge, value: xe }) => jsxRuntimeExports.jsx(K.Provider, { value: xe, children: ge }), () => reactExports.useContext(K)] } function getSafeId(fe, K) { return pe => { if (typeof pe != "string" || pe.trim().length === 0) throw new Error(K); return `${fe}-${pe}` } } function findElementAncestor(fe, K) { let pe = fe; for (; (pe = pe.parentElement) && !pe.matches(K);); return pe } function getPreviousIndex$1(fe, K, pe) { for (let me = fe - 1; me >= 0; me -= 1)if (!K[me].disabled) return me; if (pe) { for (let me = K.length - 1; me > -1; me -= 1)if (!K[me].disabled) return me } return fe } function getNextIndex$1(fe, K, pe) { for (let me = fe + 1; me < K.length; me += 1)if (!K[me].disabled) return me; if (pe) { for (let me = 0; me < K.length; me += 1)if (!K[me].disabled) return me } return fe } function onSameLevel(fe, K, pe) { return findElementAncestor(fe, pe) === findElementAncestor(K, pe) } function createScopedKeydownHandler({ parentSelector: fe, siblingSelector: K, onKeyDown: pe, loop: me = !0, activateOnFocus: ge = !1, dir: xe = "rtl", orientation: ye }) { return ve => { pe?.(ve); const _e = Array.from(findElementAncestor(ve.currentTarget, fe)?.querySelectorAll(K) || []).filter(we => onSameLevel(ve.currentTarget, we, fe)), Ee = _e.findIndex(we => ve.currentTarget === we), be = getNextIndex$1(Ee, _e, me), Ae = getPreviousIndex$1(Ee, _e, me), Se = xe === "rtl" ? Ae : be, Ce = xe === "rtl" ? be : Ae; switch (ve.key) { case "ArrowRight": { ye === "horizontal" && (ve.stopPropagation(), ve.preventDefault(), _e[Se].focus(), ge && _e[Se].click()); break } case "ArrowLeft": { ye === "horizontal" && (ve.stopPropagation(), ve.preventDefault(), _e[Ce].focus(), ge && _e[Ce].click()); break } case "ArrowUp": { ye === "vertical" && (ve.stopPropagation(), ve.preventDefault(), _e[Ae].focus(), ge && _e[Ae].click()); break } case "ArrowDown": { ye === "vertical" && (ve.stopPropagation(), ve.preventDefault(), _e[be].focus(), ge && _e[be].click()); break } case "Home": { ve.stopPropagation(), ve.preventDefault(), !_e[0].disabled && _e[0].focus(); break } case "End": { ve.stopPropagation(), ve.preventDefault(); const we = _e.length - 1; !_e[we].disabled && _e[we].focus(); break } } } } const elevations = { app: 100, modal: 200, popover: 300, overlay: 400, max: 9999 }; function getDefaultZIndex(fe) { return elevations[fe] } const noop$3 = () => { }; function closeOnEscape(fe, K = { active: !0 }) { return typeof fe != "function" || !K.active ? K.onKeyDown || noop$3 : pe => { pe.key === "Escape" && (fe(pe), K.onTrigger?.()) } } function getSize(fe, K = "size", pe = !0) { if (fe !== void 0) return isNumberLike(fe) ? pe ? rem(fe) : fe : `var(--${K}-${fe})` } function getSpacing(fe) { return getSize(fe, "mantine-spacing") } function getRadius(fe) { return fe === void 0 ? "var(--mantine-radius-default)" : getSize(fe, "mantine-radius") } function getFontSize(fe) { return getSize(fe, "mantine-font-size") } function getLineHeight(fe) { return getSize(fe, "mantine-line-height", !1) } function getShadow(fe) { if (fe) return getSize(fe, "mantine-shadow", !1) } var define_process_env_default = {}; function getEnv() { return typeof process < "u" && define_process_env_default ? "production" : "development" } function findClosestNumber(fe, K) { return K.length === 0 ? fe : K.reduce((pe, me) => Math.abs(me - fe) < Math.abs(pe - fe) ? me : pe) } function getRefProp(fe) { const K = React$4.version; return typeof React$4.version != "string" || K.startsWith("18.") ? fe?.ref : fe?.props?.ref } function createVarsResolver(fe) { return fe } function r$1(fe) { var K, pe, me = ""; if (typeof fe == "string" || typeof fe == "number") me += fe; else if (typeof fe == "object") if (Array.isArray(fe)) { var ge = fe.length; for (K = 0; K < ge; K++)fe[K] && (pe = r$1(fe[K])) && (me && (me += " "), me += pe) } else for (pe in fe) fe[pe] && (me && (me += " "), me += pe); return me } function clsx() { for (var fe, K, pe = 0, me = "", ge = arguments.length; pe < ge; pe++)(fe = arguments[pe]) && (K = r$1(fe)) && (me && (me += " "), me += K); return me } const EMPTY_CLASS_NAMES = {}; function mergeClassNames(fe) { const K = {}; return fe.forEach(pe => { Object.entries(pe).forEach(([me, ge]) => { K[me] ? K[me] = clsx(K[me], ge) : K[me] = ge }) }), K } function resolveClassNames({ theme: fe, classNames: K, props: pe, stylesCtx: me }) { const xe = (Array.isArray(K) ? K : [K]).map(ye => typeof ye == "function" ? ye(fe, pe, me) : ye || EMPTY_CLASS_NAMES); return mergeClassNames(xe) } function resolveStyles({ theme: fe, styles: K, props: pe, stylesCtx: me }) { return (Array.isArray(K) ? K : [K]).reduce((xe, ye) => typeof ye == "function" ? { ...xe, ...ye(fe, pe, me) } : { ...xe, ...ye }, {}) } const MantineContext = reactExports.createContext(null); function useMantineContext() { const fe = reactExports.useContext(MantineContext); if (!fe) throw new Error("[@mantine/core] MantineProvider was not found in tree"); return fe } function useMantineCssVariablesResolver() { return useMantineContext().cssVariablesResolver } function useMantineClassNamesPrefix() { return useMantineContext().classNamesPrefix } function useMantineStyleNonce() { return useMantineContext().getStyleNonce } function useMantineWithStaticClasses() { return useMantineContext().withStaticClasses } function useMantineIsHeadless() { return useMantineContext().headless } function useMantineSxTransform() { return useMantineContext().stylesTransform?.sx } function useMantineStylesTransform() { return useMantineContext().stylesTransform?.styles } function useMantineEnv() { return useMantineContext().env || "default" } function isHexColor(fe) { return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(fe) } function hexToRgba(fe) { let K = fe.replace("#", ""); if (K.length === 3) { const ye = K.split(""); K = [ye[0], ye[0], ye[1], ye[1], ye[2], ye[2]].join("") } if (K.length === 8) { const ye = parseInt(K.slice(6, 8), 16) / 255; return { r: parseInt(K.slice(0, 2), 16), g: parseInt(K.slice(2, 4), 16), b: parseInt(K.slice(4, 6), 16), a: ye } } const pe = parseInt(K, 16), me = pe >> 16 & 255, ge = pe >> 8 & 255, xe = pe & 255; return { r: me, g: ge, b: xe, a: 1 } } function rgbStringToRgba(fe) { const [K, pe, me, ge] = fe.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number); return { r: K, g: pe, b: me, a: ge || 1 } } function hslStringToRgba(fe) { const K = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, pe = fe.match(K); if (!pe) return { r: 0, g: 0, b: 0, a: 1 }; const me = parseInt(pe[1], 10), ge = parseInt(pe[2], 10) / 100, xe = parseInt(pe[3], 10) / 100, ye = pe[5] ? parseFloat(pe[5]) : void 0, ve = (1 - Math.abs(2 * xe - 1)) * ge, _e = me / 60, Ee = ve * (1 - Math.abs(_e % 2 - 1)), be = xe - ve / 2; let Ae, Se, Ce; return _e >= 0 && _e < 1 ? (Ae = ve, Se = Ee, Ce = 0) : _e >= 1 && _e < 2 ? (Ae = Ee, Se = ve, Ce = 0) : _e >= 2 && _e < 3 ? (Ae = 0, Se = ve, Ce = Ee) : _e >= 3 && _e < 4 ? (Ae = 0, Se = Ee, Ce = ve) : _e >= 4 && _e < 5 ? (Ae = Ee, Se = 0, Ce = ve) : (Ae = ve, Se = 0, Ce = Ee), { r: Math.round((Ae + be) * 255), g: Math.round((Se + be) * 255), b: Math.round((Ce + be) * 255), a: ye || 1 } } function toRgba(fe) { return isHexColor(fe) ? hexToRgba(fe) : fe.startsWith("rgb") ? rgbStringToRgba(fe) : fe.startsWith("hsl") ? hslStringToRgba(fe) : { r: 0, g: 0, b: 0, a: 1 } } function darken(fe, K) { if (fe.startsWith("var(")) return `color-mix(in srgb, ${fe}, black ${K * 100}%)`; const { r: pe, g: me, b: ge, a: xe } = toRgba(fe), ye = 1 - K, ve = _e => Math.round(_e * ye); return `rgba(${ve(pe)}, ${ve(me)}, ${ve(ge)}, ${xe})` } function getPrimaryShade(fe, K) { return typeof fe.primaryShade == "number" ? fe.primaryShade : K === "dark" ? fe.primaryShade.dark : fe.primaryShade.light } function gammaCorrect(fe) { return fe <= .03928 ? fe / 12.92 : ((fe + .055) / 1.055) ** 2.4 } function getLightnessFromOklch(fe) { const K = fe.match(/oklch\((.*?)%\s/); return K ? parseFloat(K[1]) : null } function luminance(fe) { if (fe.startsWith("oklch(")) return (getLightnessFromOklch(fe) || 0) / 100; const { r: K, g: pe, b: me } = toRgba(fe), ge = K / 255, xe = pe / 255, ye = me / 255, ve = gammaCorrect(ge), _e = gammaCorrect(xe), Ee = gammaCorrect(ye); return .2126 * ve + .7152 * _e + .0722 * Ee } function isLightColor(fe, K = .179) { return fe.startsWith("var(") ? !1 : luminance(fe) > K } function parseThemeColor({ color: fe, theme: K, colorScheme: pe }) { if (typeof fe != "string") throw new Error(`[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof fe}`); if (fe === "bright") return { color: fe, value: pe === "dark" ? K.white : K.black, shade: void 0, isThemeColor: !1, isLight: isLightColor(pe === "dark" ? K.white : K.black, K.luminanceThreshold), variable: "--mantine-color-bright" }; if (fe === "dimmed") return { color: fe, value: pe === "dark" ? K.colors.dark[2] : K.colors.gray[7], shade: void 0, isThemeColor: !1, isLight: isLightColor(pe === "dark" ? K.colors.dark[2] : K.colors.gray[6], K.luminanceThreshold), variable: "--mantine-color-dimmed" }; if (fe === "white" || fe === "black") return { color: fe, value: fe === "white" ? K.white : K.black, shade: void 0, isThemeColor: !1, isLight: isLightColor(fe === "white" ? K.white : K.black, K.luminanceThreshold), variable: `--mantine-color-${fe}` }; const [me, ge] = fe.split("."), xe = ge ? Number(ge) : void 0, ye = me in K.colors; if (ye) { const ve = xe !== void 0 ? K.colors[me][xe] : K.colors[me][getPrimaryShade(K, pe || "light")]; return { color: me, value: ve, shade: xe, isThemeColor: ye, isLight: isLightColor(ve, K.luminanceThreshold), variable: ge ? `--mantine-color-${me}-${xe}` : `--mantine-color-${me}-filled` } } return { color: fe, value: fe, isThemeColor: ye, isLight: isLightColor(fe, K.luminanceThreshold), shade: xe, variable: void 0 } } function getThemeColor(fe, K) { const pe = parseThemeColor({ color: fe || K.primaryColor, theme: K }); return pe.variable ? `var(${pe.variable})` : fe } function getGradient(fe, K) { const pe = { from: fe?.from || K.defaultGradient.from, to: fe?.to || K.defaultGradient.to, deg: fe?.deg ?? K.defaultGradient.deg ?? 0 }, me = getThemeColor(pe.from, K), ge = getThemeColor(pe.to, K); return `linear-gradient(${pe.deg}deg, ${me} 0%, ${ge} 100%)` } function rgba$1(fe, K) { if (typeof fe != "string" || K > 1 || K < 0) return "rgba(0, 0, 0, 1)"; if (fe.startsWith("var(")) { const xe = (1 - K) * 100; return `color-mix(in srgb, ${fe}, transparent ${xe}%)` } if (fe.startsWith("oklch")) return fe.includes("/") ? fe.replace(/\/\s*[\d.]+\s*\)/, `/ ${K})`) : fe.replace(")", ` / ${K})`); const { r: pe, g: me, b: ge } = toRgba(fe); return `rgba(${pe}, ${me}, ${ge}, ${K})` } const alpha = rgba$1, defaultVariantColorsResolver = ({ color: fe, theme: K, variant: pe, gradient: me, autoContrast: ge }) => { const xe = parseThemeColor({ color: fe, theme: K }), ye = typeof ge == "boolean" ? ge : K.autoContrast; if (pe === "none") return { background: "transparent", hover: "transparent", color: "inherit", border: "none" }; if (pe === "filled") { const ve = ye && xe.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)"; return xe.isThemeColor ? xe.shade === void 0 ? { background: `var(--mantine-color-${fe}-filled)`, hover: `var(--mantine-color-${fe}-filled-hover)`, color: ve, border: `${rem(1)} solid transparent` } : { background: `var(--mantine-color-${xe.color}-${xe.shade})`, hover: `var(--mantine-color-${xe.color}-${xe.shade === 9 ? 8 : xe.shade + 1})`, color: ve, border: `${rem(1)} solid transparent` } : { background: fe, hover: darken(fe, .1), color: ve, border: `${rem(1)} solid transparent` } } if (pe === "light") { if (xe.isThemeColor) { if (xe.shade === void 0) return { background: `var(--mantine-color-${fe}-light)`, hover: `var(--mantine-color-${fe}-light-hover)`, color: `var(--mantine-color-${fe}-light-color)`, border: `${rem(1)} solid transparent` }; const ve = K.colors[xe.color][xe.shade]; return { background: rgba$1(ve, .1), hover: rgba$1(ve, .12), color: `var(--mantine-color-${xe.color}-${Math.min(xe.shade, 6)})`, border: `${rem(1)} solid transparent` } } return { background: rgba$1(fe, .1), hover: rgba$1(fe, .12), color: fe, border: `${rem(1)} solid transparent` } } if (pe === "outline") return xe.isThemeColor ? xe.shade === void 0 ? { background: "transparent", hover: `var(--mantine-color-${fe}-outline-hover)`, color: `var(--mantine-color-${fe}-outline)`, border: `${rem(1)} solid var(--mantine-color-${fe}-outline)` } : { background: "transparent", hover: rgba$1(K.colors[xe.color][xe.shade], .05), color: `var(--mantine-color-${xe.color}-${xe.shade})`, border: `${rem(1)} solid var(--mantine-color-${xe.color}-${xe.shade})` } : { background: "transparent", hover: rgba$1(fe, .05), color: fe, border: `${rem(1)} solid ${fe}` }; if (pe === "subtle") { if (xe.isThemeColor) { if (xe.shade === void 0) return { background: "transparent", hover: `var(--mantine-color-${fe}-light-hover)`, color: `var(--mantine-color-${fe}-light-color)`, border: `${rem(1)} solid transparent` }; const ve = K.colors[xe.color][xe.shade]; return { background: "transparent", hover: rgba$1(ve, .12), color: `var(--mantine-color-${xe.color}-${Math.min(xe.shade, 6)})`, border: `${rem(1)} solid transparent` } } return { background: "transparent", hover: rgba$1(fe, .12), color: fe, border: `${rem(1)} solid transparent` } } return pe === "transparent" ? xe.isThemeColor ? xe.shade === void 0 ? { background: "transparent", hover: "transparent", color: `var(--mantine-color-${fe}-light-color)`, border: `${rem(1)} solid transparent` } : { background: "transparent", hover: "transparent", color: `var(--mantine-color-${xe.color}-${Math.min(xe.shade, 6)})`, border: `${rem(1)} solid transparent` } : { background: "transparent", hover: "transparent", color: fe, border: `${rem(1)} solid transparent` } : pe === "white" ? xe.isThemeColor ? xe.shade === void 0 ? { background: "var(--mantine-color-white)", hover: darken(K.white, .01), color: `var(--mantine-color-${fe}-filled)`, border: `${rem(1)} solid transparent` } : { background: "var(--mantine-color-white)", hover: darken(K.white, .01), color: `var(--mantine-color-${xe.color}-${xe.shade})`, border: `${rem(1)} solid transparent` } : { background: "var(--mantine-color-white)", hover: darken(K.white, .01), color: fe, border: `${rem(1)} solid transparent` } : pe === "gradient" ? { background: getGradient(me, K), hover: getGradient(me, K), color: "var(--mantine-color-white)", border: "none" } : pe === "default" ? { background: "var(--mantine-color-default)", hover: "var(--mantine-color-default-hover)", color: "var(--mantine-color-default-color)", border: `${rem(1)} solid var(--mantine-color-default-border)` } : {} }, DEFAULT_COLORS = { dark: ["#C9C9C9", "#b8b8b8", "#828282", "#696969", "#424242", "#3b3b3b", "#2e2e2e", "#242424", "#1f1f1f", "#141414"], gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"], red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"], pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"], grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"], violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"], indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"], blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"], cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"], teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"], green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"], lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"], yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"], orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"] }, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = { scale: 1, fontSmoothing: !0, focusRing: "auto", white: "#fff", black: "#000", colors: DEFAULT_COLORS, primaryShade: { light: 6, dark: 8 }, primaryColor: "blue", variantColorResolver: defaultVariantColorsResolver, autoContrast: !1, luminanceThreshold: .3, fontFamily: DEFAULT_FONT_FAMILY, fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace", respectReducedMotion: !1, cursorType: "default", defaultGradient: { from: "blue", to: "cyan", deg: 45 }, defaultRadius: "sm", activeClassName: "mantine-active", focusClassName: "", headings: { fontFamily: DEFAULT_FONT_FAMILY, fontWeight: "700", textWrap: "wrap", sizes: { h1: { fontSize: rem(34), lineHeight: "1.3" }, h2: { fontSize: rem(26), lineHeight: "1.35" }, h3: { fontSize: rem(22), lineHeight: "1.4" }, h4: { fontSize: rem(18), lineHeight: "1.45" }, h5: { fontSize: rem(16), lineHeight: "1.5" }, h6: { fontSize: rem(14), lineHeight: "1.5" } } }, fontSizes: { xs: rem(12), sm: rem(14), md: rem(16), lg: rem(18), xl: rem(20) }, lineHeights: { xs: "1.4", sm: "1.45", md: "1.55", lg: "1.6", xl: "1.65" }, radius: { xs: rem(2), sm: rem(4), md: rem(8), lg: rem(16), xl: rem(32) }, spacing: { xs: rem(10), sm: rem(12), md: rem(16), lg: rem(20), xl: rem(32) }, breakpoints: { xs: "36em", sm: "48em", md: "62em", lg: "75em", xl: "88em" }, shadows: { xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`, sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(15)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`, md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(25)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`, lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(23)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`, xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(28)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}` }, other: {}, components: {} }; function isMantineColorScheme(fe) { return fe === "auto" || fe === "dark" || fe === "light" } function localStorageColorSchemeManager({ key: fe = "mantine-color-scheme-value" } = {}) { let K; return { get: pe => { if (typeof window > "u") return pe; try { const me = window.localStorage.getItem(fe); return isMantineColorScheme(me) ? me : pe } catch { return pe } }, set: pe => { try { window.localStorage.setItem(fe, pe) } catch (me) { console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", me) } }, subscribe: pe => { K = me => { me.storageArea === window.localStorage && me.key === fe && isMantineColorScheme(me.newValue) && pe(me.newValue) }, window.addEventListener("storage", K) }, unsubscribe: () => { window.removeEventListener("storage", K) }, clear: () => { window.localStorage.removeItem(fe) } } } const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }"; function isValidPrimaryShade(fe) { return fe < 0 || fe > 9 ? !1 : parseInt(fe.toString(), 10) === fe } function validateMantineTheme(fe) { if (!(fe.primaryColor in fe.colors)) throw new Error(INVALID_PRIMARY_COLOR_ERROR); if (typeof fe.primaryShade == "object" && (!isValidPrimaryShade(fe.primaryShade.dark) || !isValidPrimaryShade(fe.primaryShade.light))) throw new Error(INVALID_PRIMARY_SHADE_ERROR); if (typeof fe.primaryShade == "number" && !isValidPrimaryShade(fe.primaryShade)) throw new Error(INVALID_PRIMARY_SHADE_ERROR) } function mergeMantineTheme(fe, K) { if (!K) return validateMantineTheme(fe), fe; const pe = deepMerge(fe, K); return K.fontFamily && !K.headings?.fontFamily && (pe.headings.fontFamily = K.fontFamily), validateMantineTheme(pe), pe } const MantineThemeContext = reactExports.createContext(null), useSafeMantineTheme = () => reactExports.useContext(MantineThemeContext) || DEFAULT_THEME; function useMantineTheme() { const fe = reactExports.useContext(MantineThemeContext); if (!fe) throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"); return fe } function MantineThemeProvider({ theme: fe, children: K, inherit: pe = !0 }) { const me = useSafeMantineTheme(), ge = reactExports.useMemo(() => mergeMantineTheme(pe ? me : DEFAULT_THEME, fe), [fe, me, pe]); return jsxRuntimeExports.jsx(MantineThemeContext.Provider, { value: ge, children: K }) } MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider"; function MantineClasses() { const fe = useMantineTheme(), K = useMantineStyleNonce(), pe = keys$1(fe.breakpoints).reduce((me, ge) => { const xe = fe.breakpoints[ge].includes("px"), ye = px$1(fe.breakpoints[ge]), ve = xe ? `${ye - .1}px` : em(ye - .1), _e = xe ? `${ye}px` : em(ye); return `${me}@media (max-width: ${ve}) {.mantine-visible-from-${ge} {display: none !important;}}@media (min-width: ${_e}) {.mantine-hidden-from-${ge} {display: none !important;}}` }, ""); return jsxRuntimeExports.jsx("style", { "data-mantine-styles": "classes", nonce: K?.(), dangerouslySetInnerHTML: { __html: pe } }) } function cssVariablesObjectToString(fe) { return Object.entries(fe).map(([K, pe]) => `${K}: ${pe};`).join("") } function wrapWithSelector(fe, K) { return (Array.isArray(fe) ? fe : [fe]).reduce((me, ge) => `${ge}{${me}}`, K) } function convertCssVariables(fe, K) { const pe = cssVariablesObjectToString(fe.variables), me = pe ? wrapWithSelector(K, pe) : "", ge = cssVariablesObjectToString(fe.dark), xe = cssVariablesObjectToString(fe.light), ye = ge ? wrapWithSelector(K === ":host" ? `${K}([data-mantine-color-scheme="dark"])` : `${K}[data-mantine-color-scheme="dark"]`, ge) : "", ve = xe ? wrapWithSelector(K === ":host" ? `${K}([data-mantine-color-scheme="light"])` : `${K}[data-mantine-color-scheme="light"]`, xe) : ""; return `${me}${ye}${ve}` } function getContrastColor({ color: fe, theme: K, autoContrast: pe }) { return (typeof pe == "boolean" ? pe : K.autoContrast) && parseThemeColor({ color: fe || K.primaryColor, theme: K }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" } function getPrimaryContrastColor(fe, K) { return getContrastColor({ color: fe.colors[fe.primaryColor][getPrimaryShade(fe, K)], theme: fe, autoContrast: null }) } function getCSSColorVariables({ theme: fe, color: K, colorScheme: pe, name: me = K, withColorValues: ge = !0 }) { if (!fe.colors[K]) return {}; if (pe === "light") { const ve = getPrimaryShade(fe, "light"), _e = { [`--mantine-color-${me}-text`]: `var(--mantine-color-${me}-filled)`, [`--mantine-color-${me}-filled`]: `var(--mantine-color-${me}-${ve})`, [`--mantine-color-${me}-filled-hover`]: `var(--mantine-color-${me}-${ve === 9 ? 8 : ve + 1})`, [`--mantine-color-${me}-light`]: alpha(fe.colors[K][ve], .1), [`--mantine-color-${me}-light-hover`]: alpha(fe.colors[K][ve], .12), [`--mantine-color-${me}-light-color`]: `var(--mantine-color-${me}-${ve})`, [`--mantine-color-${me}-outline`]: `var(--mantine-color-${me}-${ve})`, [`--mantine-color-${me}-outline-hover`]: alpha(fe.colors[K][ve], .05) }; return ge ? { [`--mantine-color-${me}-0`]: fe.colors[K][0], [`--mantine-color-${me}-1`]: fe.colors[K][1], [`--mantine-color-${me}-2`]: fe.colors[K][2], [`--mantine-color-${me}-3`]: fe.colors[K][3], [`--mantine-color-${me}-4`]: fe.colors[K][4], [`--mantine-color-${me}-5`]: fe.colors[K][5], [`--mantine-color-${me}-6`]: fe.colors[K][6], [`--mantine-color-${me}-7`]: fe.colors[K][7], [`--mantine-color-${me}-8`]: fe.colors[K][8], [`--mantine-color-${me}-9`]: fe.colors[K][9], ..._e } : _e } const xe = getPrimaryShade(fe, "dark"), ye = { [`--mantine-color-${me}-text`]: `var(--mantine-color-${me}-4)`, [`--mantine-color-${me}-filled`]: `var(--mantine-color-${me}-${xe})`, [`--mantine-color-${me}-filled-hover`]: `var(--mantine-color-${me}-${xe === 9 ? 8 : xe + 1})`, [`--mantine-color-${me}-light`]: alpha(fe.colors[K][Math.max(0, xe - 2)], .15), [`--mantine-color-${me}-light-hover`]: alpha(fe.colors[K][Math.max(0, xe - 2)], .2), [`--mantine-color-${me}-light-color`]: `var(--mantine-color-${me}-${Math.max(xe - 5, 0)})`, [`--mantine-color-${me}-outline`]: `var(--mantine-color-${me}-${Math.max(xe - 4, 0)})`, [`--mantine-color-${me}-outline-hover`]: alpha(fe.colors[K][Math.max(xe - 4, 0)], .05) }; return ge ? { [`--mantine-color-${me}-0`]: fe.colors[K][0], [`--mantine-color-${me}-1`]: fe.colors[K][1], [`--mantine-color-${me}-2`]: fe.colors[K][2], [`--mantine-color-${me}-3`]: fe.colors[K][3], [`--mantine-color-${me}-4`]: fe.colors[K][4], [`--mantine-color-${me}-5`]: fe.colors[K][5], [`--mantine-color-${me}-6`]: fe.colors[K][6], [`--mantine-color-${me}-7`]: fe.colors[K][7], [`--mantine-color-${me}-8`]: fe.colors[K][8], [`--mantine-color-${me}-9`]: fe.colors[K][9], ...ye } : ye } function isVirtualColor(fe) { return !!fe && typeof fe == "object" && "mantine-virtual-color" in fe } function assignSizeVariables(fe, K, pe) { keys$1(K).forEach(me => Object.assign(fe, { [`--mantine-${pe}-${me}`]: K[me] })) } const defaultCssVariablesResolver = fe => { const K = getPrimaryShade(fe, "light"), pe = fe.defaultRadius in fe.radius ? fe.radius[fe.defaultRadius] : rem(fe.defaultRadius), me = { variables: { "--mantine-scale": fe.scale.toString(), "--mantine-cursor-type": fe.cursorType, "--mantine-color-scheme": "light dark", "--mantine-webkit-font-smoothing": fe.fontSmoothing ? "antialiased" : "unset", "--mantine-moz-font-smoothing": fe.fontSmoothing ? "grayscale" : "unset", "--mantine-color-white": fe.white, "--mantine-color-black": fe.black, "--mantine-line-height": fe.lineHeights.md, "--mantine-font-family": fe.fontFamily, "--mantine-font-family-monospace": fe.fontFamilyMonospace, "--mantine-font-family-headings": fe.headings.fontFamily, "--mantine-heading-font-weight": fe.headings.fontWeight, "--mantine-heading-text-wrap": fe.headings.textWrap, "--mantine-radius-default": pe, "--mantine-primary-color-filled": `var(--mantine-color-${fe.primaryColor}-filled)`, "--mantine-primary-color-filled-hover": `var(--mantine-color-${fe.primaryColor}-filled-hover)`, "--mantine-primary-color-light": `var(--mantine-color-${fe.primaryColor}-light)`, "--mantine-primary-color-light-hover": `var(--mantine-color-${fe.primaryColor}-light-hover)`, "--mantine-primary-color-light-color": `var(--mantine-color-${fe.primaryColor}-light-color)` }, light: { "--mantine-primary-color-contrast": getPrimaryContrastColor(fe, "light"), "--mantine-color-bright": "var(--mantine-color-black)", "--mantine-color-text": fe.black, "--mantine-color-body": fe.white, "--mantine-color-error": "var(--mantine-color-red-6)", "--mantine-color-placeholder": "var(--mantine-color-gray-5)", "--mantine-color-anchor": `var(--mantine-color-${fe.primaryColor}-${K})`, "--mantine-color-default": "var(--mantine-color-white)", "--mantine-color-default-hover": "var(--mantine-color-gray-0)", "--mantine-color-default-color": "var(--mantine-color-black)", "--mantine-color-default-border": "var(--mantine-color-gray-4)", "--mantine-color-dimmed": "var(--mantine-color-gray-6)", "--mantine-color-disabled": "var(--mantine-color-gray-2)", "--mantine-color-disabled-color": "var(--mantine-color-gray-5)", "--mantine-color-disabled-border": "var(--mantine-color-gray-3)" }, dark: { "--mantine-primary-color-contrast": getPrimaryContrastColor(fe, "dark"), "--mantine-color-bright": "var(--mantine-color-white)", "--mantine-color-text": "var(--mantine-color-dark-0)", "--mantine-color-body": "var(--mantine-color-dark-7)", "--mantine-color-error": "var(--mantine-color-red-8)", "--mantine-color-placeholder": "var(--mantine-color-dark-3)", "--mantine-color-anchor": `var(--mantine-color-${fe.primaryColor}-4)`, "--mantine-color-default": "var(--mantine-color-dark-6)", "--mantine-color-default-hover": "var(--mantine-color-dark-5)", "--mantine-color-default-color": "var(--mantine-color-white)", "--mantine-color-default-border": "var(--mantine-color-dark-4)", "--mantine-color-dimmed": "var(--mantine-color-dark-2)", "--mantine-color-disabled": "var(--mantine-color-dark-6)", "--mantine-color-disabled-color": "var(--mantine-color-dark-3)", "--mantine-color-disabled-border": "var(--mantine-color-gray-6)" } }; assignSizeVariables(me.variables, fe.breakpoints, "breakpoint"), assignSizeVariables(me.variables, fe.spacing, "spacing"), assignSizeVariables(me.variables, fe.fontSizes, "font-size"), assignSizeVariables(me.variables, fe.lineHeights, "line-height"), assignSizeVariables(me.variables, fe.shadows, "shadow"), assignSizeVariables(me.variables, fe.radius, "radius"), fe.colors[fe.primaryColor].forEach((xe, ye) => { me.variables[`--mantine-primary-color-${ye}`] = `var(--mantine-color-${fe.primaryColor}-${ye})` }), keys$1(fe.colors).forEach(xe => { const ye = fe.colors[xe]; if (isVirtualColor(ye)) { Object.assign(me.light, getCSSColorVariables({ theme: fe, name: ye.name, color: ye.light, colorScheme: "light", withColorValues: !0 })), Object.assign(me.dark, getCSSColorVariables({ theme: fe, name: ye.name, color: ye.dark, colorScheme: "dark", withColorValues: !0 })); return } ye.forEach((ve, _e) => { me.variables[`--mantine-color-${xe}-${_e}`] = ve }), Object.assign(me.light, getCSSColorVariables({ theme: fe, color: xe, colorScheme: "light", withColorValues: !1 })), Object.assign(me.dark, getCSSColorVariables({ theme: fe, color: xe, colorScheme: "dark", withColorValues: !1 })) }); const ge = fe.headings.sizes; return keys$1(ge).forEach(xe => { me.variables[`--mantine-${xe}-font-size`] = ge[xe].fontSize, me.variables[`--mantine-${xe}-line-height`] = ge[xe].lineHeight, me.variables[`--mantine-${xe}-font-weight`] = ge[xe].fontWeight || fe.headings.fontWeight }), me }; function getMergedVariables({ theme: fe, generator: K }) { const pe = defaultCssVariablesResolver(fe), me = K?.(fe); return me ? deepMerge(pe, me) : pe } const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME); function removeDefaultVariables(fe) { const K = { variables: {}, light: {}, dark: {} }; return keys$1(fe.variables).forEach(pe => { defaultCssVariables.variables[pe] !== fe.variables[pe] && (K.variables[pe] = fe.variables[pe]) }), keys$1(fe.light).forEach(pe => { defaultCssVariables.light[pe] !== fe.light[pe] && (K.light[pe] = fe.light[pe]) }), keys$1(fe.dark).forEach(pe => { defaultCssVariables.dark[pe] !== fe.dark[pe] && (K.dark[pe] = fe.dark[pe]) }), K } function getColorSchemeCssVariables(fe) {
	return `
  ${fe}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${fe}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`} function MantineCssVariables({ cssVariablesSelector: fe, deduplicateCssVariables: K }) { const pe = useMantineTheme(), me = useMantineStyleNonce(), ge = useMantineCssVariablesResolver(), xe = getMergedVariables({ theme: pe, generator: ge }), ye = fe === ":root" && K, ve = ye ? removeDefaultVariables(xe) : xe, _e = convertCssVariables(ve, fe); return _e ? jsxRuntimeExports.jsx("style", { "data-mantine-styles": !0, nonce: me?.(), dangerouslySetInnerHTML: { __html: `${_e}${ye ? "" : getColorSchemeCssVariables(fe)}` } }) : null } MantineCssVariables.displayName = "@mantine/CssVariables"; function setColorSchemeAttribute(fe, K) { const pe = typeof window < "u" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches, me = fe !== "auto" ? fe : pe ? "dark" : "light"; K()?.setAttribute("data-mantine-color-scheme", me) } function useProviderColorScheme({ manager: fe, defaultColorScheme: K, getRootElement: pe, forceColorScheme: me }) { const ge = reactExports.useRef(null), [xe, ye] = reactExports.useState(() => fe.get(K)), ve = me || xe, _e = reactExports.useCallback(be => { me || (setColorSchemeAttribute(be, pe), ye(be), fe.set(be)) }, [fe.set, ve, me]), Ee = reactExports.useCallback(() => { ye(K), setColorSchemeAttribute(K, pe), fe.clear() }, [fe.clear, K]); return reactExports.useEffect(() => (fe.subscribe(_e), fe.unsubscribe), [fe.subscribe, fe.unsubscribe]), useIsomorphicEffect$1(() => { setColorSchemeAttribute(fe.get(K), pe) }, []), reactExports.useEffect(() => { if (me) return setColorSchemeAttribute(me, pe), () => { }; me === void 0 && setColorSchemeAttribute(xe, pe), typeof window < "u" && "matchMedia" in window && (ge.current = window.matchMedia("(prefers-color-scheme: dark)")); const be = Ae => { xe === "auto" && setColorSchemeAttribute(Ae.matches ? "dark" : "light", pe) }; return ge.current?.addEventListener("change", be), () => ge.current?.removeEventListener("change", be) }, [xe, me]), { colorScheme: ve, setColorScheme: _e, clearColorScheme: Ee } } function useRespectReduceMotion({ respectReducedMotion: fe, getRootElement: K }) { useIsomorphicEffect$1(() => { fe && K()?.setAttribute("data-respect-reduced-motion", "true") }, [fe]) } function MantineProvider({ theme: fe, children: K, getStyleNonce: pe, withStaticClasses: me = !0, withGlobalClasses: ge = !0, deduplicateCssVariables: xe = !0, withCssVariables: ye = !0, cssVariablesSelector: ve = ":root", classNamesPrefix: _e = "mantine", colorSchemeManager: Ee = localStorageColorSchemeManager(), defaultColorScheme: be = "light", getRootElement: Ae = () => document.documentElement, cssVariablesResolver: Se, forceColorScheme: Ce, stylesTransform: we, env: Be }) { const { colorScheme: De, setColorScheme: Re, clearColorScheme: Ie } = useProviderColorScheme({ defaultColorScheme: be, forceColorScheme: Ce, manager: Ee, getRootElement: Ae }); return useRespectReduceMotion({ respectReducedMotion: fe?.respectReducedMotion || !1, getRootElement: Ae }), jsxRuntimeExports.jsx(MantineContext.Provider, { value: { colorScheme: De, setColorScheme: Re, clearColorScheme: Ie, getRootElement: Ae, classNamesPrefix: _e, getStyleNonce: pe, cssVariablesResolver: Se, cssVariablesSelector: ve, withStaticClasses: me, stylesTransform: we, env: Be }, children: jsxRuntimeExports.jsxs(MantineThemeProvider, { theme: fe, children: [ye && jsxRuntimeExports.jsx(MantineCssVariables, { cssVariablesSelector: ve, deduplicateCssVariables: xe }), ge && jsxRuntimeExports.jsx(MantineClasses, {}), K] }) }) } MantineProvider.displayName = "@mantine/core/MantineProvider"; function useResolvedStylesApi({ classNames: fe, styles: K, props: pe, stylesCtx: me }) { const ge = useMantineTheme(); return { resolvedClassNames: resolveClassNames({ theme: ge, classNames: fe, props: pe, stylesCtx: me || void 0 }), resolvedStyles: resolveStyles({ theme: ge, styles: K, props: pe, stylesCtx: me || void 0 }) } } const FOCUS_CLASS_NAMES = { always: "mantine-focus-always", auto: "mantine-focus-auto", never: "mantine-focus-never" }; function getGlobalClassNames({ theme: fe, options: K, unstyled: pe }) { return clsx(K?.focusable && !pe && (fe.focusClassName || FOCUS_CLASS_NAMES[fe.focusRing]), K?.active && !pe && fe.activeClassName) } function getOptionsClassNames({ selector: fe, stylesCtx: K, options: pe, props: me, theme: ge }) { return resolveClassNames({ theme: ge, classNames: pe?.classNames, props: pe?.props || me, stylesCtx: K })[fe] } function getResolvedClassNames({ selector: fe, stylesCtx: K, theme: pe, classNames: me, props: ge }) { return resolveClassNames({ theme: pe, classNames: me, props: ge, stylesCtx: K })[fe] } function getRootClassName({ rootSelector: fe, selector: K, className: pe }) { return fe === K ? pe : void 0 } function getSelectorClassName({ selector: fe, classes: K, unstyled: pe }) { return pe ? void 0 : K[fe] } function getStaticClassNames({ themeName: fe, classNamesPrefix: K, selector: pe, withStaticClass: me }) { return me === !1 ? [] : fe.map(ge => `${K}-${ge}-${pe}`) } function getThemeClassNames({ themeName: fe, theme: K, selector: pe, props: me, stylesCtx: ge }) { return fe.map(xe => resolveClassNames({ theme: K, classNames: K.components[xe]?.classNames, props: me, stylesCtx: ge })?.[pe]) } function getVariantClassName({ options: fe, classes: K, selector: pe, unstyled: me }) { return fe?.variant && !me ? K[`${pe}--${fe.variant}`] : void 0 } function getClassName({ theme: fe, options: K, themeName: pe, selector: me, classNamesPrefix: ge, classNames: xe, classes: ye, unstyled: ve, className: _e, rootSelector: Ee, props: be, stylesCtx: Ae, withStaticClasses: Se, headless: Ce, transformedStyles: we }) { return clsx(getGlobalClassNames({ theme: fe, options: K, unstyled: ve || Ce }), getThemeClassNames({ theme: fe, themeName: pe, selector: me, props: be, stylesCtx: Ae }), getVariantClassName({ options: K, classes: ye, selector: me, unstyled: ve }), getResolvedClassNames({ selector: me, stylesCtx: Ae, theme: fe, classNames: xe, props: be }), getResolvedClassNames({ selector: me, stylesCtx: Ae, theme: fe, classNames: we, props: be }), getOptionsClassNames({ selector: me, stylesCtx: Ae, options: K, props: be, theme: fe }), getRootClassName({ rootSelector: Ee, selector: me, className: _e }), getSelectorClassName({ selector: me, classes: ye, unstyled: ve || Ce }), Se && !Ce && getStaticClassNames({ themeName: pe, classNamesPrefix: ge, selector: me, withStaticClass: K?.withStaticClass }), K?.className) } function getThemeStyles({ theme: fe, themeName: K, props: pe, stylesCtx: me, selector: ge }) { return K.map(xe => resolveStyles({ theme: fe, styles: fe.components[xe]?.styles, props: pe, stylesCtx: me })[ge]).reduce((xe, ye) => ({ ...xe, ...ye }), {}) } function resolveStyle({ style: fe, theme: K }) { return Array.isArray(fe) ? [...fe].reduce((pe, me) => ({ ...pe, ...resolveStyle({ style: me, theme: K }) }), {}) : typeof fe == "function" ? fe(K) : fe ?? {} } function mergeVars(fe) { return fe.reduce((K, pe) => (pe && Object.keys(pe).forEach(me => { K[me] = { ...K[me], ...filterProps(pe[me]) } }), K), {}) } function resolveVars({ vars: fe, varsResolver: K, theme: pe, props: me, stylesCtx: ge, selector: xe, themeName: ye, headless: ve }) { return mergeVars([ve ? {} : K?.(pe, me, ge), ...ye.map(_e => pe.components?.[_e]?.vars?.(pe, me, ge)), fe?.(pe, me, ge)])?.[xe] } function getStyle({ theme: fe, themeName: K, selector: pe, options: me, props: ge, stylesCtx: xe, rootSelector: ye, styles: ve, style: _e, vars: Ee, varsResolver: be, headless: Ae, withStylesTransform: Se }) { return { ...!Se && getThemeStyles({ theme: fe, themeName: K, props: ge, stylesCtx: xe, selector: pe }), ...!Se && resolveStyles({ theme: fe, styles: ve, props: ge, stylesCtx: xe })[pe], ...!Se && resolveStyles({ theme: fe, styles: me?.styles, props: me?.props || ge, stylesCtx: xe })[pe], ...resolveVars({ theme: fe, props: ge, stylesCtx: xe, vars: Ee, varsResolver: be, selector: pe, themeName: K, headless: Ae }), ...ye === pe ? resolveStyle({ style: _e, theme: fe }) : null, ...resolveStyle({ style: me?.style, theme: fe }) } } function useStylesTransform({ props: fe, stylesCtx: K, themeName: pe }) { const me = useMantineTheme(), ge = useMantineStylesTransform()?.(); return { getTransformedStyles: ye => ge ? [...ye.map(_e => ge(_e, { props: fe, theme: me, ctx: K })), ...pe.map(_e => ge(me.components[_e]?.styles, { props: fe, theme: me, ctx: K }))].filter(Boolean) : [], withStylesTransform: !!ge } } function useStyles({ name: fe, classes: K, props: pe, stylesCtx: me, className: ge, style: xe, rootSelector: ye = "root", unstyled: ve, classNames: _e, styles: Ee, vars: be, varsResolver: Ae }) { const Se = useMantineTheme(), Ce = useMantineClassNamesPrefix(), we = useMantineWithStaticClasses(), Be = useMantineIsHeadless(), De = (Array.isArray(fe) ? fe : [fe]).filter(Pe => Pe), { withStylesTransform: Re, getTransformedStyles: Ie } = useStylesTransform({ props: pe, stylesCtx: me, themeName: De }); return (Pe, Ne) => ({ className: getClassName({ theme: Se, options: Ne, themeName: De, selector: Pe, classNamesPrefix: Ce, classNames: _e, classes: K, unstyled: ve, className: ge, rootSelector: ye, props: pe, stylesCtx: me, withStaticClasses: we, headless: Be, transformedStyles: Ie([Ne?.styles, Ee]) }), style: getStyle({ theme: Se, themeName: De, selector: Pe, options: Ne, props: pe, stylesCtx: me, rootSelector: ye, styles: Ee, style: xe, vars: be, varsResolver: Ae, headless: Be, withStylesTransform: Re }) }) } function getAutoContrastValue(fe, K) { return typeof fe == "boolean" ? fe : K.autoContrast } function disableTransition(fe) { const K = document.createElement("style"); return K.setAttribute("data-mantine-styles", "inline"), K.innerHTML = "*, *::before, *::after {transition: none !important;}", K.setAttribute("data-mantine-disable-transition", "true"), fe && K.setAttribute("nonce", fe), document.head.appendChild(K), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach(me => me.remove()) } function useMantineColorScheme({ keepTransitions: fe } = {}) { const K = reactExports.useRef(noop$3), pe = reactExports.useRef(-1), me = reactExports.useContext(MantineContext), ge = useMantineStyleNonce(), xe = reactExports.useRef(ge?.()); if (!me) throw new Error("[@mantine/core] MantineProvider was not found in tree"); const ye = Ae => { me.setColorScheme(Ae), K.current = fe ? () => { } : disableTransition(xe.current), window.clearTimeout(pe.current), pe.current = window.setTimeout(() => { K.current?.() }, 10) }, ve = () => { me.clearColorScheme(), K.current = fe ? () => { } : disableTransition(xe.current), window.clearTimeout(pe.current), pe.current = window.setTimeout(() => { K.current?.() }, 10) }, _e = useColorScheme("light", { getInitialValueInEffect: !1 }), Ee = me.colorScheme === "auto" ? _e : me.colorScheme, be = reactExports.useCallback(() => ye(Ee === "light" ? "dark" : "light"), [ye, Ee]); return reactExports.useEffect(() => () => { K.current?.(), window.clearTimeout(pe.current) }, []), { colorScheme: me.colorScheme, setColorScheme: ye, clearColorScheme: ve, toggleColorScheme: be } } function useProps(fe, K, pe) { const me = useMantineTheme(), ge = me.components[fe]?.defaultProps, xe = typeof ge == "function" ? ge(me) : ge; return { ...K, ...xe, ...filterProps(pe) } } function createTheme(fe) { return fe } function cssObjectToString(fe) { return keys$1(fe).reduce((K, pe) => fe[pe] !== void 0 ? `${K}${camelToKebabCase(pe)}:${fe[pe]};` : K, "").trim() } function stylesToString({ selector: fe, styles: K, media: pe, container: me }) { const ge = K ? cssObjectToString(K) : "", xe = Array.isArray(pe) ? pe.map(ve => `@media${ve.query}{${fe}{${cssObjectToString(ve.styles)}}}`) : [], ye = Array.isArray(me) ? me.map(ve => `@container ${ve.query}{${fe}{${cssObjectToString(ve.styles)}}}`) : []; return `${ge ? `${fe}{${ge}}` : ""}${xe.join("")}${ye.join("")}`.trim() } function InlineStyles(fe) { const K = useMantineStyleNonce(); return jsxRuntimeExports.jsx("style", { "data-mantine-styles": "inline", nonce: K?.(), dangerouslySetInnerHTML: { __html: stylesToString(fe) } }) } function extractStyleProps(fe) { const { m: K, mx: pe, my: me, mt: ge, mb: xe, ml: ye, mr: ve, me: _e, ms: Ee, p: be, px: Ae, py: Se, pt: Ce, pb: we, pl: Be, pr: De, pe: Re, ps: Ie, bd: Pe, bg: Ne, c: ke, opacity: Oe, ff: Ue, fz: He, fw: Ge, lts: ze, ta: We, lh: Xe, fs: Ye, tt: Ze, td: ot, w: qe, miw: Qe, maw: st, h: Nt, mih: Je, mah: jt, bgsz: Xt, bgp: ct, bgr: nn, bga: $t, pos: an, top: gn, left: Mn, bottom: Xn, right: Ln, inset: Gn, display: wn, flex: Bn, hiddenFrom: Gt, visibleFrom: nr, lightHidden: Kn, darkHidden: vn, sx: yn, ...Hn } = fe; return { styleProps: filterProps({ m: K, mx: pe, my: me, mt: ge, mb: xe, ml: ye, mr: ve, me: _e, ms: Ee, p: be, px: Ae, py: Se, pt: Ce, pb: we, pl: Be, pr: De, pe: Re, ps: Ie, bd: Pe, bg: Ne, c: ke, opacity: Oe, ff: Ue, fz: He, fw: Ge, lts: ze, ta: We, lh: Xe, fs: Ye, tt: Ze, td: ot, w: qe, miw: Qe, maw: st, h: Nt, mih: Je, mah: jt, bgsz: Xt, bgp: ct, bgr: nn, bga: $t, pos: an, top: gn, left: Mn, bottom: Xn, right: Ln, inset: Gn, display: wn, flex: Bn, hiddenFrom: Gt, visibleFrom: nr, lightHidden: Kn, darkHidden: vn, sx: yn }), rest: Hn } } const STYlE_PROPS_DATA = { m: { type: "spacing", property: "margin" }, mt: { type: "spacing", property: "marginTop" }, mb: { type: "spacing", property: "marginBottom" }, ml: { type: "spacing", property: "marginLeft" }, mr: { type: "spacing", property: "marginRight" }, ms: { type: "spacing", property: "marginInlineStart" }, me: { type: "spacing", property: "marginInlineEnd" }, mx: { type: "spacing", property: "marginInline" }, my: { type: "spacing", property: "marginBlock" }, p: { type: "spacing", property: "padding" }, pt: { type: "spacing", property: "paddingTop" }, pb: { type: "spacing", property: "paddingBottom" }, pl: { type: "spacing", property: "paddingLeft" }, pr: { type: "spacing", property: "paddingRight" }, ps: { type: "spacing", property: "paddingInlineStart" }, pe: { type: "spacing", property: "paddingInlineEnd" }, px: { type: "spacing", property: "paddingInline" }, py: { type: "spacing", property: "paddingBlock" }, bd: { type: "border", property: "border" }, bg: { type: "color", property: "background" }, c: { type: "textColor", property: "color" }, opacity: { type: "identity", property: "opacity" }, ff: { type: "fontFamily", property: "fontFamily" }, fz: { type: "fontSize", property: "fontSize" }, fw: { type: "identity", property: "fontWeight" }, lts: { type: "size", property: "letterSpacing" }, ta: { type: "identity", property: "textAlign" }, lh: { type: "lineHeight", property: "lineHeight" }, fs: { type: "identity", property: "fontStyle" }, tt: { type: "identity", property: "textTransform" }, td: { type: "identity", property: "textDecoration" }, w: { type: "spacing", property: "width" }, miw: { type: "spacing", property: "minWidth" }, maw: { type: "spacing", property: "maxWidth" }, h: { type: "spacing", property: "height" }, mih: { type: "spacing", property: "minHeight" }, mah: { type: "spacing", property: "maxHeight" }, bgsz: { type: "size", property: "backgroundSize" }, bgp: { type: "identity", property: "backgroundPosition" }, bgr: { type: "identity", property: "backgroundRepeat" }, bga: { type: "identity", property: "backgroundAttachment" }, pos: { type: "identity", property: "position" }, top: { type: "size", property: "top" }, left: { type: "size", property: "left" }, bottom: { type: "size", property: "bottom" }, right: { type: "size", property: "right" }, inset: { type: "size", property: "inset" }, display: { type: "identity", property: "display" }, flex: { type: "identity", property: "flex" } }; function colorResolver(fe, K) { const pe = parseThemeColor({ color: fe, theme: K }); return pe.color === "dimmed" ? "var(--mantine-color-dimmed)" : pe.color === "bright" ? "var(--mantine-color-bright)" : pe.variable ? `var(${pe.variable})` : pe.color } function textColorResolver(fe, K) { const pe = parseThemeColor({ color: fe, theme: K }); return pe.isThemeColor && pe.shade === void 0 ? `var(--mantine-color-${pe.color}-text)` : colorResolver(fe, K) } function borderResolver(fe, K) { if (typeof fe == "number") return rem(fe); if (typeof fe == "string") { const [pe, me, ...ge] = fe.split(" ").filter(ye => ye.trim() !== ""); let xe = `${rem(pe)}`; return me && (xe += ` ${me}`), ge.length > 0 && (xe += ` ${colorResolver(ge.join(" "), K)}`), xe.trim() } return fe } const values = { text: "var(--mantine-font-family)", mono: "var(--mantine-font-family-monospace)", monospace: "var(--mantine-font-family-monospace)", heading: "var(--mantine-font-family-headings)", headings: "var(--mantine-font-family-headings)" }; function fontFamilyResolver(fe) { return typeof fe == "string" && fe in values ? values[fe] : fe } const headings$2 = ["h1", "h2", "h3", "h4", "h5", "h6"]; function fontSizeResolver(fe, K) { return typeof fe == "string" && fe in K.fontSizes ? `var(--mantine-font-size-${fe})` : typeof fe == "string" && headings$2.includes(fe) ? `var(--mantine-${fe}-font-size)` : typeof fe == "number" || typeof fe == "string" ? rem(fe) : fe } function identityResolver(fe) { return fe } const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"]; function lineHeightResolver(fe, K) { return typeof fe == "string" && fe in K.lineHeights ? `var(--mantine-line-height-${fe})` : typeof fe == "string" && headings$1.includes(fe) ? `var(--mantine-${fe}-line-height)` : fe } function sizeResolver(fe) { return typeof fe == "number" ? rem(fe) : fe } function spacingResolver(fe, K) { if (typeof fe == "number") return rem(fe); if (typeof fe == "string") { const pe = fe.replace("-", ""); if (!(pe in K.spacing)) return rem(fe); const me = `--mantine-spacing-${pe}`; return fe.startsWith("-") ? `calc(var(${me}) * -1)` : `var(${me})` } return fe } const resolvers = { color: colorResolver, textColor: textColorResolver, fontSize: fontSizeResolver, spacing: spacingResolver, identity: identityResolver, size: sizeResolver, lineHeight: lineHeightResolver, fontFamily: fontFamilyResolver, border: borderResolver }; function replaceMediaQuery(fe) { return fe.replace("(min-width: ", "").replace("em)", "") } function sortMediaQueries({ media: fe, ...K }) { const me = Object.keys(fe).sort((ge, xe) => Number(replaceMediaQuery(ge)) - Number(replaceMediaQuery(xe))).map(ge => ({ query: ge, styles: fe[ge] })); return { ...K, media: me } } function hasResponsiveStyles(fe) { if (typeof fe != "object" || fe === null) return !1; const K = Object.keys(fe); return !(K.length === 1 && K[0] === "base") } function getBaseValue(fe) { return typeof fe == "object" && fe !== null ? "base" in fe ? fe.base : void 0 : fe } function getBreakpointKeys(fe) { return typeof fe == "object" && fe !== null ? keys$1(fe).filter(K => K !== "base") : [] } function getBreakpointValue$1(fe, K) { return typeof fe == "object" && fe !== null && K in fe ? fe[K] : fe } function parseStyleProps({ styleProps: fe, data: K, theme: pe }) { return sortMediaQueries(keys$1(fe).reduce((me, ge) => { if (ge === "hiddenFrom" || ge === "visibleFrom" || ge === "sx") return me; const xe = K[ge], ye = Array.isArray(xe.property) ? xe.property : [xe.property], ve = getBaseValue(fe[ge]); if (!hasResponsiveStyles(fe[ge])) return ye.forEach(Ee => { me.inlineStyles[Ee] = resolvers[xe.type](ve, pe) }), me; me.hasResponsiveStyles = !0; const _e = getBreakpointKeys(fe[ge]); return ye.forEach(Ee => { ve && (me.styles[Ee] = resolvers[xe.type](ve, pe)), _e.forEach(be => { const Ae = `(min-width: ${pe.breakpoints[be]})`; me.media[Ae] = { ...me.media[Ae], [Ee]: resolvers[xe.type](getBreakpointValue$1(fe[ge], be), pe) } }) }), me }, { hasResponsiveStyles: !1, styles: {}, inlineStyles: {}, media: {} })) } function useRandomClassName() { return `__m__-${reactExports.useId().replace(/:/g, "")}` } function getStyleObject(fe, K) { return Array.isArray(fe) ? [...fe].reduce((pe, me) => ({ ...pe, ...getStyleObject(me, K) }), {}) : typeof fe == "function" ? fe(K) : fe ?? {} } function createPolymorphicComponent(fe) { return fe } function transformModKey(fe) { return fe.startsWith("data-") ? fe : `data-${fe}` } function getMod(fe) { return Object.keys(fe).reduce((K, pe) => { const me = fe[pe]; return me === void 0 || me === "" || me === !1 || me === null || (K[transformModKey(pe)] = fe[pe]), K }, {}) } function getBoxMod(fe) { return fe ? typeof fe == "string" ? { [transformModKey(fe)]: !0 } : Array.isArray(fe) ? [...fe].reduce((K, pe) => ({ ...K, ...getBoxMod(pe) }), {}) : getMod(fe) : null } function mergeStyles(fe, K) { return Array.isArray(fe) ? [...fe].reduce((pe, me) => ({ ...pe, ...mergeStyles(me, K) }), {}) : typeof fe == "function" ? fe(K) : fe ?? {} } function getBoxStyle({ theme: fe, style: K, vars: pe, styleProps: me }) { const ge = mergeStyles(K, fe), xe = mergeStyles(pe, fe); return { ...ge, ...xe, ...me } } const _Box = reactExports.forwardRef(({ component: fe, style: K, __vars: pe, className: me, variant: ge, mod: xe, size: ye, hiddenFrom: ve, visibleFrom: _e, lightHidden: Ee, darkHidden: be, renderRoot: Ae, __size: Se, ...Ce }, we) => { const Be = useMantineTheme(), De = fe || "div", { styleProps: Re, rest: Ie } = extractStyleProps(Ce), Ne = useMantineSxTransform()?.()?.(Re.sx), ke = useRandomClassName(), Oe = parseStyleProps({ styleProps: Re, theme: Be, data: STYlE_PROPS_DATA }), Ue = { ref: we, style: getBoxStyle({ theme: Be, style: K, vars: pe, styleProps: Oe.inlineStyles }), className: clsx(me, Ne, { [ke]: Oe.hasResponsiveStyles, "mantine-light-hidden": Ee, "mantine-dark-hidden": be, [`mantine-hidden-from-${ve}`]: ve, [`mantine-visible-from-${_e}`]: _e }), "data-variant": ge, "data-size": isNumberLike(ye) ? void 0 : ye || void 0, size: Se, ...getBoxMod(xe), ...Ie }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [Oe.hasResponsiveStyles && jsxRuntimeExports.jsx(InlineStyles, { selector: `.${ke}`, styles: Oe.styles, media: Oe.media }), typeof Ae == "function" ? Ae(Ue) : jsxRuntimeExports.jsx(De, { ...Ue })] }) }); _Box.displayName = "@mantine/core/Box"; const Box = _Box; function identity$2(fe) { return fe } function factory(fe) { const K = reactExports.forwardRef(fe); return K.extend = identity$2, K.withProps = pe => { const me = reactExports.forwardRef((ge, xe) => jsxRuntimeExports.jsx(K, { ...pe, ...ge, ref: xe })); return me.extend = K.extend, me.displayName = `WithProps(${K.displayName})`, me }, K } function polymorphicFactory(fe) { const K = reactExports.forwardRef(fe); return K.withProps = pe => { const me = reactExports.forwardRef((ge, xe) => jsxRuntimeExports.jsx(K, { ...pe, ...ge, ref: xe })); return me.extend = K.extend, me.displayName = `WithProps(${K.displayName})`, me }, K.extend = identity$2, K } const DirectionContext = reactExports.createContext({ dir: "ltr", toggleDirection: () => { }, setDirection: () => { } }); function useDirection() { return reactExports.useContext(DirectionContext) } function getAutoHeightDuration(fe) { if (!fe || typeof fe == "string") return 0; const K = fe / 36; return Math.round((4 + 15 * K ** .25 + K / 5) * 10) } function getElementHeight(fe) { return fe?.current ? fe.current.scrollHeight : "auto" } const raf = typeof window < "u" && window.requestAnimationFrame; function useCollapse({ transitionDuration: fe, transitionTimingFunction: K = "ease", onTransitionEnd: pe = () => { }, opened: me }) { const ge = reactExports.useRef(null), xe = 0, ye = { height: 0, overflow: "hidden" }, [ve, _e] = reactExports.useState(me ? {} : ye), Ee = we => { reactDomExports.flushSync(() => _e(we)) }, be = we => { Ee(Be => ({ ...Be, ...we })) }; function Ae(we) { const Be = fe || getAutoHeightDuration(we); return { transition: `height ${Be}ms ${K}, opacity ${Be}ms ${K}` } } useDidUpdate(() => { typeof raf == "function" && raf(me ? () => { be({ willChange: "height", display: "block", overflow: "hidden" }), raf(() => { const we = getElementHeight(ge); be({ ...Ae(we), height: we }) }) } : () => { const we = getElementHeight(ge); be({ ...Ae(we), willChange: "height", height: we }), raf(() => be({ height: xe, overflow: "hidden" })) }) }, [me]); const Se = we => { if (!(we.target !== ge.current || we.propertyName !== "height")) if (me) { const Be = getElementHeight(ge); Be === ve.height ? Ee({}) : be({ height: Be }), pe() } else ve.height === xe && (Ee(ye), pe()) }; function Ce({ style: we = {}, refKey: Be = "ref", ...De } = {}) { const Re = De[Be], Ie = { "aria-hidden": !me, inert: !me, ...De, [Be]: mergeRefs(ge, Re), onTransitionEnd: Se, style: { boxSizing: "border-box", ...we, ...ve } }; return React$4.version.startsWith("18") || (Ie.inert = !me), Ie } return Ce } const defaultProps$1r = { transitionDuration: 200, transitionTimingFunction: "ease", animateOpacity: !0 }, Collapse = factory((fe, K) => { const { children: pe, in: me, transitionDuration: ge, transitionTimingFunction: xe, style: ye, onTransitionEnd: ve, animateOpacity: _e, ...Ee } = useProps("Collapse", defaultProps$1r, fe), be = useMantineTheme(), Ae = useReducedMotion(), Ce = (be.respectReducedMotion ? Ae : !1) ? 0 : ge, we = useCollapse({ opened: me, transitionDuration: Ce, transitionTimingFunction: xe, onTransitionEnd: ve }); return Ce === 0 ? me ? jsxRuntimeExports.jsx(Box, { ...Ee, children: pe }) : null : jsxRuntimeExports.jsx(Box, { ...we({ style: { opacity: me || !_e ? 1 : 0, transition: _e ? `opacity ${Ce}ms ${xe}` : "none", ...getStyleObject(ye, be) }, ref: K, ...Ee }), children: pe }) }); Collapse.displayName = "@mantine/core/Collapse"; function hasWindow() { return typeof window < "u" } function getNodeName(fe) { return isNode$2(fe) ? (fe.nodeName || "").toLowerCase() : "#document" } function getWindow(fe) { var K; return (fe == null || (K = fe.ownerDocument) == null ? void 0 : K.defaultView) || window } function getDocumentElement(fe) { var K; return (K = (isNode$2(fe) ? fe.ownerDocument : fe.document) || window.document) == null ? void 0 : K.documentElement } function isNode$2(fe) { return hasWindow() ? fe instanceof Node || fe instanceof getWindow(fe).Node : !1 } function isElement(fe) { return hasWindow() ? fe instanceof Element || fe instanceof getWindow(fe).Element : !1 } function isHTMLElement(fe) { return hasWindow() ? fe instanceof HTMLElement || fe instanceof getWindow(fe).HTMLElement : !1 } function isShadowRoot(fe) { return !hasWindow() || typeof ShadowRoot > "u" ? !1 : fe instanceof ShadowRoot || fe instanceof getWindow(fe).ShadowRoot } function isOverflowElement(fe) { const { overflow: K, overflowX: pe, overflowY: me, display: ge } = getComputedStyle$1(fe); return /auto|scroll|overlay|hidden|clip/.test(K + me + pe) && !["inline", "contents"].includes(ge) } function isTableElement(fe) { return ["table", "td", "th"].includes(getNodeName(fe)) } function isTopLayer(fe) { return [":popover-open", ":modal"].some(K => { try { return fe.matches(K) } catch { return !1 } }) } function isContainingBlock(fe) { const K = isWebKit(), pe = isElement(fe) ? getComputedStyle$1(fe) : fe; return ["transform", "translate", "scale", "rotate", "perspective"].some(me => pe[me] ? pe[me] !== "none" : !1) || (pe.containerType ? pe.containerType !== "normal" : !1) || !K && (pe.backdropFilter ? pe.backdropFilter !== "none" : !1) || !K && (pe.filter ? pe.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(me => (pe.willChange || "").includes(me)) || ["paint", "layout", "strict", "content"].some(me => (pe.contain || "").includes(me)) } function getContainingBlock(fe) { let K = getParentNode(fe); for (; isHTMLElement(K) && !isLastTraversableNode(K);) { if (isContainingBlock(K)) return K; if (isTopLayer(K)) return null; K = getParentNode(K) } return null } function isWebKit() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function isLastTraversableNode(fe) { return ["html", "body", "#document"].includes(getNodeName(fe)) } function getComputedStyle$1(fe) { return getWindow(fe).getComputedStyle(fe) } function getNodeScroll(fe) { return isElement(fe) ? { scrollLeft: fe.scrollLeft, scrollTop: fe.scrollTop } : { scrollLeft: fe.scrollX, scrollTop: fe.scrollY } } function getParentNode(fe) { if (getNodeName(fe) === "html") return fe; const K = fe.assignedSlot || fe.parentNode || isShadowRoot(fe) && fe.host || getDocumentElement(fe); return isShadowRoot(K) ? K.host : K } function getNearestOverflowAncestor(fe) { const K = getParentNode(fe); return isLastTraversableNode(K) ? fe.ownerDocument ? fe.ownerDocument.body : fe.body : isHTMLElement(K) && isOverflowElement(K) ? K : getNearestOverflowAncestor(K) } function getOverflowAncestors(fe, K, pe) { var me; K === void 0 && (K = []), pe === void 0 && (pe = !0); const ge = getNearestOverflowAncestor(fe), xe = ge === ((me = fe.ownerDocument) == null ? void 0 : me.body), ye = getWindow(ge); if (xe) { const ve = getFrameElement(ye); return K.concat(ye, ye.visualViewport || [], isOverflowElement(ge) ? ge : [], ve && pe ? getOverflowAncestors(ve) : []) } return K.concat(ge, getOverflowAncestors(ge, [], pe)) } function getFrameElement(fe) { return fe.parent && Object.getPrototypeOf(fe.parent) ? fe.frameElement : null } function activeElement(fe) { let K = fe.activeElement; for (; ((pe = K) == null || (pe = pe.shadowRoot) == null ? void 0 : pe.activeElement) != null;) { var pe; K = K.shadowRoot.activeElement } return K } function contains(fe, K) { if (!fe || !K) return !1; const pe = K.getRootNode == null ? void 0 : K.getRootNode(); if (fe.contains(K)) return !0; if (pe && isShadowRoot(pe)) { let me = K; for (; me;) { if (fe === me) return !0; me = me.parentNode || me.host } } return !1 } function getPlatform() { const fe = navigator.userAgentData; return fe != null && fe.platform ? fe.platform : navigator.platform } function getUserAgent() { const fe = navigator.userAgentData; return fe && Array.isArray(fe.brands) ? fe.brands.map(K => { let { brand: pe, version: me } = K; return pe + "/" + me }).join(" ") : navigator.userAgent } function isVirtualPointerEvent(fe) { return isJSDOM() ? !1 : !isAndroid() && fe.width === 0 && fe.height === 0 || isAndroid() && fe.width === 1 && fe.height === 1 && fe.pressure === 0 && fe.detail === 0 && fe.pointerType === "mouse" || fe.width < 1 && fe.height < 1 && fe.pressure === 0 && fe.detail === 0 && fe.pointerType === "touch" } function isSafari() { return /apple/i.test(navigator.vendor) } function isAndroid() { const fe = /android/i; return fe.test(getPlatform()) || fe.test(getUserAgent()) } function isMac$1() { return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints } function isJSDOM() { return getUserAgent().includes("jsdom/") } function isMouseLikePointerType(fe, K) { const pe = ["mouse", "pen"]; return pe.push("", void 0), pe.includes(fe) } function isReactEvent(fe) { return "nativeEvent" in fe } function isRootElement(fe) { return fe.matches("html,body") } function getDocument(fe) { return fe?.ownerDocument || document } function isEventTargetWithin(fe, K) { if (K == null) return !1; if ("composedPath" in fe) return fe.composedPath().includes(K); const pe = fe; return pe.target != null && K.contains(pe.target) } function getTarget(fe) { return "composedPath" in fe ? fe.composedPath()[0] : fe.target } const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])"; function isTypeableElement(fe) { return isHTMLElement(fe) && fe.matches(TYPEABLE_SELECTOR) } const sides = ["top", "right", "bottom", "left"], min$1 = Math.min, max$3 = Math.max, round$2 = Math.round, floor$1 = Math.floor, createCoords = fe => ({ x: fe, y: fe }), oppositeSideMap = { left: "right", right: "left", bottom: "top", top: "bottom" }, oppositeAlignmentMap = { start: "end", end: "start" }; function clamp$6(fe, K, pe) { return max$3(fe, min$1(K, pe)) } function evaluate$1(fe, K) { return typeof fe == "function" ? fe(K) : fe } function getSide(fe) { return fe.split("-")[0] } function getAlignment(fe) { return fe.split("-")[1] } function getOppositeAxis(fe) { return fe === "x" ? "y" : "x" } function getAxisLength(fe) { return fe === "y" ? "height" : "width" } function getSideAxis(fe) { return ["top", "bottom"].includes(getSide(fe)) ? "y" : "x" } function getAlignmentAxis(fe) { return getOppositeAxis(getSideAxis(fe)) } function getAlignmentSides(fe, K, pe) { pe === void 0 && (pe = !1); const me = getAlignment(fe), ge = getAlignmentAxis(fe), xe = getAxisLength(ge); let ye = ge === "x" ? me === (pe ? "end" : "start") ? "right" : "left" : me === "start" ? "bottom" : "top"; return K.reference[xe] > K.floating[xe] && (ye = getOppositePlacement(ye)), [ye, getOppositePlacement(ye)] } function getExpandedPlacements(fe) { const K = getOppositePlacement(fe); return [getOppositeAlignmentPlacement(fe), K, getOppositeAlignmentPlacement(K)] } function getOppositeAlignmentPlacement(fe) { return fe.replace(/start|end/g, K => oppositeAlignmentMap[K]) } function getSideList(fe, K, pe) { const me = ["left", "right"], ge = ["right", "left"], xe = ["top", "bottom"], ye = ["bottom", "top"]; switch (fe) { case "top": case "bottom": return pe ? K ? ge : me : K ? me : ge; case "left": case "right": return K ? xe : ye; default: return [] } } function getOppositeAxisPlacements(fe, K, pe, me) { const ge = getAlignment(fe); let xe = getSideList(getSide(fe), pe === "start", me); return ge && (xe = xe.map(ye => ye + "-" + ge), K && (xe = xe.concat(xe.map(getOppositeAlignmentPlacement)))), xe } function getOppositePlacement(fe) { return fe.replace(/left|right|bottom|top/g, K => oppositeSideMap[K]) } function expandPaddingObject(fe) { return { top: 0, right: 0, bottom: 0, left: 0, ...fe } } function getPaddingObject(fe) { return typeof fe != "number" ? expandPaddingObject(fe) : { top: fe, right: fe, bottom: fe, left: fe } } function rectToClientRect(fe) { const { x: K, y: pe, width: me, height: ge } = fe; return { width: me, height: ge, top: pe, left: K, right: K + me, bottom: pe + ge, x: K, y: pe } } function computeCoordsFromPlacement(fe, K, pe) { let { reference: me, floating: ge } = fe; const xe = getSideAxis(K), ye = getAlignmentAxis(K), ve = getAxisLength(ye), _e = getSide(K), Ee = xe === "y", be = me.x + me.width / 2 - ge.width / 2, Ae = me.y + me.height / 2 - ge.height / 2, Se = me[ve] / 2 - ge[ve] / 2; let Ce; switch (_e) { case "top": Ce = { x: be, y: me.y - ge.height }; break; case "bottom": Ce = { x: be, y: me.y + me.height }; break; case "right": Ce = { x: me.x + me.width, y: Ae }; break; case "left": Ce = { x: me.x - ge.width, y: Ae }; break; default: Ce = { x: me.x, y: me.y } }switch (getAlignment(K)) { case "start": Ce[ye] -= Se * (pe && Ee ? -1 : 1); break; case "end": Ce[ye] += Se * (pe && Ee ? -1 : 1); break }return Ce } const computePosition$1 = async (fe, K, pe) => { const { placement: me = "bottom", strategy: ge = "absolute", middleware: xe = [], platform: ye } = pe, ve = xe.filter(Boolean), _e = await (ye.isRTL == null ? void 0 : ye.isRTL(K)); let Ee = await ye.getElementRects({ reference: fe, floating: K, strategy: ge }), { x: be, y: Ae } = computeCoordsFromPlacement(Ee, me, _e), Se = me, Ce = {}, we = 0; for (let Be = 0; Be < ve.length; Be++) { const { name: De, fn: Re } = ve[Be], { x: Ie, y: Pe, data: Ne, reset: ke } = await Re({ x: be, y: Ae, initialPlacement: me, placement: Se, strategy: ge, middlewareData: Ce, rects: Ee, platform: ye, elements: { reference: fe, floating: K } }); be = Ie ?? be, Ae = Pe ?? Ae, Ce = { ...Ce, [De]: { ...Ce[De], ...Ne } }, ke && we <= 50 && (we++, typeof ke == "object" && (ke.placement && (Se = ke.placement), ke.rects && (Ee = ke.rects === !0 ? await ye.getElementRects({ reference: fe, floating: K, strategy: ge }) : ke.rects), { x: be, y: Ae } = computeCoordsFromPlacement(Ee, Se, _e)), Be = -1) } return { x: be, y: Ae, placement: Se, strategy: ge, middlewareData: Ce } }; async function detectOverflow(fe, K) { var pe; K === void 0 && (K = {}); const { x: me, y: ge, platform: xe, rects: ye, elements: ve, strategy: _e } = fe, { boundary: Ee = "clippingAncestors", rootBoundary: be = "viewport", elementContext: Ae = "floating", altBoundary: Se = !1, padding: Ce = 0 } = evaluate$1(K, fe), we = getPaddingObject(Ce), De = ve[Se ? Ae === "floating" ? "reference" : "floating" : Ae], Re = rectToClientRect(await xe.getClippingRect({ element: (pe = await (xe.isElement == null ? void 0 : xe.isElement(De))) == null || pe ? De : De.contextElement || await (xe.getDocumentElement == null ? void 0 : xe.getDocumentElement(ve.floating)), boundary: Ee, rootBoundary: be, strategy: _e })), Ie = Ae === "floating" ? { x: me, y: ge, width: ye.floating.width, height: ye.floating.height } : ye.reference, Pe = await (xe.getOffsetParent == null ? void 0 : xe.getOffsetParent(ve.floating)), Ne = await (xe.isElement == null ? void 0 : xe.isElement(Pe)) ? await (xe.getScale == null ? void 0 : xe.getScale(Pe)) || { x: 1, y: 1 } : { x: 1, y: 1 }, ke = rectToClientRect(xe.convertOffsetParentRelativeRectToViewportRelativeRect ? await xe.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: ve, rect: Ie, offsetParent: Pe, strategy: _e }) : Ie); return { top: (Re.top - ke.top + we.top) / Ne.y, bottom: (ke.bottom - Re.bottom + we.bottom) / Ne.y, left: (Re.left - ke.left + we.left) / Ne.x, right: (ke.right - Re.right + we.right) / Ne.x } } const arrow$3 = fe => ({ name: "arrow", options: fe, async fn(K) { const { x: pe, y: me, placement: ge, rects: xe, platform: ye, elements: ve, middlewareData: _e } = K, { element: Ee, padding: be = 0 } = evaluate$1(fe, K) || {}; if (Ee == null) return {}; const Ae = getPaddingObject(be), Se = { x: pe, y: me }, Ce = getAlignmentAxis(ge), we = getAxisLength(Ce), Be = await ye.getDimensions(Ee), De = Ce === "y", Re = De ? "top" : "left", Ie = De ? "bottom" : "right", Pe = De ? "clientHeight" : "clientWidth", Ne = xe.reference[we] + xe.reference[Ce] - Se[Ce] - xe.floating[we], ke = Se[Ce] - xe.reference[Ce], Oe = await (ye.getOffsetParent == null ? void 0 : ye.getOffsetParent(Ee)); let Ue = Oe ? Oe[Pe] : 0; (!Ue || !await (ye.isElement == null ? void 0 : ye.isElement(Oe))) && (Ue = ve.floating[Pe] || xe.floating[we]); const He = Ne / 2 - ke / 2, Ge = Ue / 2 - Be[we] / 2 - 1, ze = min$1(Ae[Re], Ge), We = min$1(Ae[Ie], Ge), Xe = ze, Ye = Ue - Be[we] - We, Ze = Ue / 2 - Be[we] / 2 + He, ot = clamp$6(Xe, Ze, Ye), qe = !_e.arrow && getAlignment(ge) != null && Ze !== ot && xe.reference[we] / 2 - (Ze < Xe ? ze : We) - Be[we] / 2 < 0, Qe = qe ? Ze < Xe ? Ze - Xe : Ze - Ye : 0; return { [Ce]: Se[Ce] + Qe, data: { [Ce]: ot, centerOffset: Ze - ot - Qe, ...qe && { alignmentOffset: Qe } }, reset: qe } } }), flip$2 = function (fe) { return fe === void 0 && (fe = {}), { name: "flip", options: fe, async fn(K) { var pe, me; const { placement: ge, middlewareData: xe, rects: ye, initialPlacement: ve, platform: _e, elements: Ee } = K, { mainAxis: be = !0, crossAxis: Ae = !0, fallbackPlacements: Se, fallbackStrategy: Ce = "bestFit", fallbackAxisSideDirection: we = "none", flipAlignment: Be = !0, ...De } = evaluate$1(fe, K); if ((pe = xe.arrow) != null && pe.alignmentOffset) return {}; const Re = getSide(ge), Ie = getSideAxis(ve), Pe = getSide(ve) === ve, Ne = await (_e.isRTL == null ? void 0 : _e.isRTL(Ee.floating)), ke = Se || (Pe || !Be ? [getOppositePlacement(ve)] : getExpandedPlacements(ve)), Oe = we !== "none"; !Se && Oe && ke.push(...getOppositeAxisPlacements(ve, Be, we, Ne)); const Ue = [ve, ...ke], He = await detectOverflow(K, De), Ge = []; let ze = ((me = xe.flip) == null ? void 0 : me.overflows) || []; if (be && Ge.push(He[Re]), Ae) { const Ze = getAlignmentSides(ge, ye, Ne); Ge.push(He[Ze[0]], He[Ze[1]]) } if (ze = [...ze, { placement: ge, overflows: Ge }], !Ge.every(Ze => Ze <= 0)) { var We, Xe; const Ze = (((We = xe.flip) == null ? void 0 : We.index) || 0) + 1, ot = Ue[Ze]; if (ot) return { data: { index: Ze, overflows: ze }, reset: { placement: ot } }; let qe = (Xe = ze.filter(Qe => Qe.overflows[0] <= 0).sort((Qe, st) => Qe.overflows[1] - st.overflows[1])[0]) == null ? void 0 : Xe.placement; if (!qe) switch (Ce) { case "bestFit": { var Ye; const Qe = (Ye = ze.filter(st => { if (Oe) { const Nt = getSideAxis(st.placement); return Nt === Ie || Nt === "y" } return !0 }).map(st => [st.placement, st.overflows.filter(Nt => Nt > 0).reduce((Nt, Je) => Nt + Je, 0)]).sort((st, Nt) => st[1] - Nt[1])[0]) == null ? void 0 : Ye[0]; Qe && (qe = Qe); break } case "initialPlacement": qe = ve; break }if (ge !== qe) return { reset: { placement: qe } } } return {} } } }; function getSideOffsets(fe, K) { return { top: fe.top - K.height, right: fe.right - K.width, bottom: fe.bottom - K.height, left: fe.left - K.width } } function isAnySideFullyClipped(fe) { return sides.some(K => fe[K] >= 0) } const hide$2 = function (fe) { return fe === void 0 && (fe = {}), { name: "hide", options: fe, async fn(K) { const { rects: pe } = K, { strategy: me = "referenceHidden", ...ge } = evaluate$1(fe, K); switch (me) { case "referenceHidden": { const xe = await detectOverflow(K, { ...ge, elementContext: "reference" }), ye = getSideOffsets(xe, pe.reference); return { data: { referenceHiddenOffsets: ye, referenceHidden: isAnySideFullyClipped(ye) } } } case "escaped": { const xe = await detectOverflow(K, { ...ge, altBoundary: !0 }), ye = getSideOffsets(xe, pe.floating); return { data: { escapedOffsets: ye, escaped: isAnySideFullyClipped(ye) } } } default: return {} } } } }; function getBoundingRect(fe) { const K = min$1(...fe.map(xe => xe.left)), pe = min$1(...fe.map(xe => xe.top)), me = max$3(...fe.map(xe => xe.right)), ge = max$3(...fe.map(xe => xe.bottom)); return { x: K, y: pe, width: me - K, height: ge - pe } } function getRectsByLine(fe) { const K = fe.slice().sort((ge, xe) => ge.y - xe.y), pe = []; let me = null; for (let ge = 0; ge < K.length; ge++) { const xe = K[ge]; !me || xe.y - me.y > me.height / 2 ? pe.push([xe]) : pe[pe.length - 1].push(xe), me = xe } return pe.map(ge => rectToClientRect(getBoundingRect(ge))) } const inline$2 = function (fe) { return fe === void 0 && (fe = {}), { name: "inline", options: fe, async fn(K) { const { placement: pe, elements: me, rects: ge, platform: xe, strategy: ye } = K, { padding: ve = 2, x: _e, y: Ee } = evaluate$1(fe, K), be = Array.from(await (xe.getClientRects == null ? void 0 : xe.getClientRects(me.reference)) || []), Ae = getRectsByLine(be), Se = rectToClientRect(getBoundingRect(be)), Ce = getPaddingObject(ve); function we() { if (Ae.length === 2 && Ae[0].left > Ae[1].right && _e != null && Ee != null) return Ae.find(De => _e > De.left - Ce.left && _e < De.right + Ce.right && Ee > De.top - Ce.top && Ee < De.bottom + Ce.bottom) || Se; if (Ae.length >= 2) { if (getSideAxis(pe) === "y") { const ze = Ae[0], We = Ae[Ae.length - 1], Xe = getSide(pe) === "top", Ye = ze.top, Ze = We.bottom, ot = Xe ? ze.left : We.left, qe = Xe ? ze.right : We.right, Qe = qe - ot, st = Ze - Ye; return { top: Ye, bottom: Ze, left: ot, right: qe, width: Qe, height: st, x: ot, y: Ye } } const De = getSide(pe) === "left", Re = max$3(...Ae.map(ze => ze.right)), Ie = min$1(...Ae.map(ze => ze.left)), Pe = Ae.filter(ze => De ? ze.left === Ie : ze.right === Re), Ne = Pe[0].top, ke = Pe[Pe.length - 1].bottom, Oe = Ie, Ue = Re, He = Ue - Oe, Ge = ke - Ne; return { top: Ne, bottom: ke, left: Oe, right: Ue, width: He, height: Ge, x: Oe, y: Ne } } return Se } const Be = await xe.getElementRects({ reference: { getBoundingClientRect: we }, floating: me.floating, strategy: ye }); return ge.reference.x !== Be.reference.x || ge.reference.y !== Be.reference.y || ge.reference.width !== Be.reference.width || ge.reference.height !== Be.reference.height ? { reset: { rects: Be } } : {} } } }; async function convertValueToCoords(fe, K) { const { placement: pe, platform: me, elements: ge } = fe, xe = await (me.isRTL == null ? void 0 : me.isRTL(ge.floating)), ye = getSide(pe), ve = getAlignment(pe), _e = getSideAxis(pe) === "y", Ee = ["left", "top"].includes(ye) ? -1 : 1, be = xe && _e ? -1 : 1, Ae = evaluate$1(K, fe); let { mainAxis: Se, crossAxis: Ce, alignmentAxis: we } = typeof Ae == "number" ? { mainAxis: Ae, crossAxis: 0, alignmentAxis: null } : { mainAxis: Ae.mainAxis || 0, crossAxis: Ae.crossAxis || 0, alignmentAxis: Ae.alignmentAxis }; return ve && typeof we == "number" && (Ce = ve === "end" ? we * -1 : we), _e ? { x: Ce * be, y: Se * Ee } : { x: Se * Ee, y: Ce * be } } const offset$2 = function (fe) { return fe === void 0 && (fe = 0), { name: "offset", options: fe, async fn(K) { var pe, me; const { x: ge, y: xe, placement: ye, middlewareData: ve } = K, _e = await convertValueToCoords(K, fe); return ye === ((pe = ve.offset) == null ? void 0 : pe.placement) && (me = ve.arrow) != null && me.alignmentOffset ? {} : { x: ge + _e.x, y: xe + _e.y, data: { ..._e, placement: ye } } } } }, shift$2 = function (fe) { return fe === void 0 && (fe = {}), { name: "shift", options: fe, async fn(K) { const { x: pe, y: me, placement: ge } = K, { mainAxis: xe = !0, crossAxis: ye = !1, limiter: ve = { fn: De => { let { x: Re, y: Ie } = De; return { x: Re, y: Ie } } }, ..._e } = evaluate$1(fe, K), Ee = { x: pe, y: me }, be = await detectOverflow(K, _e), Ae = getSideAxis(getSide(ge)), Se = getOppositeAxis(Ae); let Ce = Ee[Se], we = Ee[Ae]; if (xe) { const De = Se === "y" ? "top" : "left", Re = Se === "y" ? "bottom" : "right", Ie = Ce + be[De], Pe = Ce - be[Re]; Ce = clamp$6(Ie, Ce, Pe) } if (ye) { const De = Ae === "y" ? "top" : "left", Re = Ae === "y" ? "bottom" : "right", Ie = we + be[De], Pe = we - be[Re]; we = clamp$6(Ie, we, Pe) } const Be = ve.fn({ ...K, [Se]: Ce, [Ae]: we }); return { ...Be, data: { x: Be.x - pe, y: Be.y - me, enabled: { [Se]: xe, [Ae]: ye } } } } } }, limitShift$2 = function (fe) { return fe === void 0 && (fe = {}), { options: fe, fn(K) { const { x: pe, y: me, placement: ge, rects: xe, middlewareData: ye } = K, { offset: ve = 0, mainAxis: _e = !0, crossAxis: Ee = !0 } = evaluate$1(fe, K), be = { x: pe, y: me }, Ae = getSideAxis(ge), Se = getOppositeAxis(Ae); let Ce = be[Se], we = be[Ae]; const Be = evaluate$1(ve, K), De = typeof Be == "number" ? { mainAxis: Be, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...Be }; if (_e) { const Pe = Se === "y" ? "height" : "width", Ne = xe.reference[Se] - xe.floating[Pe] + De.mainAxis, ke = xe.reference[Se] + xe.reference[Pe] - De.mainAxis; Ce < Ne ? Ce = Ne : Ce > ke && (Ce = ke) } if (Ee) { var Re, Ie; const Pe = Se === "y" ? "width" : "height", Ne = ["top", "left"].includes(getSide(ge)), ke = xe.reference[Ae] - xe.floating[Pe] + (Ne && ((Re = ye.offset) == null ? void 0 : Re[Ae]) || 0) + (Ne ? 0 : De.crossAxis), Oe = xe.reference[Ae] + xe.reference[Pe] + (Ne ? 0 : ((Ie = ye.offset) == null ? void 0 : Ie[Ae]) || 0) - (Ne ? De.crossAxis : 0); we < ke ? we = ke : we > Oe && (we = Oe) } return { [Se]: Ce, [Ae]: we } } } }, size$2 = function (fe) { return fe === void 0 && (fe = {}), { name: "size", options: fe, async fn(K) { var pe, me; const { placement: ge, rects: xe, platform: ye, elements: ve } = K, { apply: _e = () => { }, ...Ee } = evaluate$1(fe, K), be = await detectOverflow(K, Ee), Ae = getSide(ge), Se = getAlignment(ge), Ce = getSideAxis(ge) === "y", { width: we, height: Be } = xe.floating; let De, Re; Ae === "top" || Ae === "bottom" ? (De = Ae, Re = Se === (await (ye.isRTL == null ? void 0 : ye.isRTL(ve.floating)) ? "start" : "end") ? "left" : "right") : (Re = Ae, De = Se === "end" ? "top" : "bottom"); const Ie = Be - be.top - be.bottom, Pe = we - be.left - be.right, Ne = min$1(Be - be[De], Ie), ke = min$1(we - be[Re], Pe), Oe = !K.middlewareData.shift; let Ue = Ne, He = ke; if ((pe = K.middlewareData.shift) != null && pe.enabled.x && (He = Pe), (me = K.middlewareData.shift) != null && me.enabled.y && (Ue = Ie), Oe && !Se) { const ze = max$3(be.left, 0), We = max$3(be.right, 0), Xe = max$3(be.top, 0), Ye = max$3(be.bottom, 0); Ce ? He = we - 2 * (ze !== 0 || We !== 0 ? ze + We : max$3(be.left, be.right)) : Ue = Be - 2 * (Xe !== 0 || Ye !== 0 ? Xe + Ye : max$3(be.top, be.bottom)) } await _e({ ...K, availableWidth: He, availableHeight: Ue }); const Ge = await ye.getDimensions(ve.floating); return we !== Ge.width || Be !== Ge.height ? { reset: { rects: !0 } } : {} } } }; function getCssDimensions(fe) { const K = getComputedStyle$1(fe); let pe = parseFloat(K.width) || 0, me = parseFloat(K.height) || 0; const ge = isHTMLElement(fe), xe = ge ? fe.offsetWidth : pe, ye = ge ? fe.offsetHeight : me, ve = round$2(pe) !== xe || round$2(me) !== ye; return ve && (pe = xe, me = ye), { width: pe, height: me, $: ve } } function unwrapElement(fe) { return isElement(fe) ? fe : fe.contextElement } function getScale(fe) { const K = unwrapElement(fe); if (!isHTMLElement(K)) return createCoords(1); const pe = K.getBoundingClientRect(), { width: me, height: ge, $: xe } = getCssDimensions(K); let ye = (xe ? round$2(pe.width) : pe.width) / me, ve = (xe ? round$2(pe.height) : pe.height) / ge; return (!ye || !Number.isFinite(ye)) && (ye = 1), (!ve || !Number.isFinite(ve)) && (ve = 1), { x: ye, y: ve } } const noOffsets = createCoords(0); function getVisualOffsets(fe) { const K = getWindow(fe); return !isWebKit() || !K.visualViewport ? noOffsets : { x: K.visualViewport.offsetLeft, y: K.visualViewport.offsetTop } } function shouldAddVisualOffsets(fe, K, pe) { return K === void 0 && (K = !1), !pe || K && pe !== getWindow(fe) ? !1 : K } function getBoundingClientRect(fe, K, pe, me) { K === void 0 && (K = !1), pe === void 0 && (pe = !1); const ge = fe.getBoundingClientRect(), xe = unwrapElement(fe); let ye = createCoords(1); K && (me ? isElement(me) && (ye = getScale(me)) : ye = getScale(fe)); const ve = shouldAddVisualOffsets(xe, pe, me) ? getVisualOffsets(xe) : createCoords(0); let _e = (ge.left + ve.x) / ye.x, Ee = (ge.top + ve.y) / ye.y, be = ge.width / ye.x, Ae = ge.height / ye.y; if (xe) { const Se = getWindow(xe), Ce = me && isElement(me) ? getWindow(me) : me; let we = Se, Be = getFrameElement(we); for (; Be && me && Ce !== we;) { const De = getScale(Be), Re = Be.getBoundingClientRect(), Ie = getComputedStyle$1(Be), Pe = Re.left + (Be.clientLeft + parseFloat(Ie.paddingLeft)) * De.x, Ne = Re.top + (Be.clientTop + parseFloat(Ie.paddingTop)) * De.y; _e *= De.x, Ee *= De.y, be *= De.x, Ae *= De.y, _e += Pe, Ee += Ne, we = getWindow(Be), Be = getFrameElement(we) } } return rectToClientRect({ width: be, height: Ae, x: _e, y: Ee }) } function getWindowScrollBarX(fe, K) { const pe = getNodeScroll(fe).scrollLeft; return K ? K.left + pe : getBoundingClientRect(getDocumentElement(fe)).left + pe } function getHTMLOffset(fe, K, pe) { pe === void 0 && (pe = !1); const me = fe.getBoundingClientRect(), ge = me.left + K.scrollLeft - (pe ? 0 : getWindowScrollBarX(fe, me)), xe = me.top + K.scrollTop; return { x: ge, y: xe } } function convertOffsetParentRelativeRectToViewportRelativeRect(fe) { let { elements: K, rect: pe, offsetParent: me, strategy: ge } = fe; const xe = ge === "fixed", ye = getDocumentElement(me), ve = K ? isTopLayer(K.floating) : !1; if (me === ye || ve && xe) return pe; let _e = { scrollLeft: 0, scrollTop: 0 }, Ee = createCoords(1); const be = createCoords(0), Ae = isHTMLElement(me); if ((Ae || !Ae && !xe) && ((getNodeName(me) !== "body" || isOverflowElement(ye)) && (_e = getNodeScroll(me)), isHTMLElement(me))) { const Ce = getBoundingClientRect(me); Ee = getScale(me), be.x = Ce.x + me.clientLeft, be.y = Ce.y + me.clientTop } const Se = ye && !Ae && !xe ? getHTMLOffset(ye, _e, !0) : createCoords(0); return { width: pe.width * Ee.x, height: pe.height * Ee.y, x: pe.x * Ee.x - _e.scrollLeft * Ee.x + be.x + Se.x, y: pe.y * Ee.y - _e.scrollTop * Ee.y + be.y + Se.y } } function getClientRects(fe) { return Array.from(fe.getClientRects()) } function getDocumentRect(fe) { const K = getDocumentElement(fe), pe = getNodeScroll(fe), me = fe.ownerDocument.body, ge = max$3(K.scrollWidth, K.clientWidth, me.scrollWidth, me.clientWidth), xe = max$3(K.scrollHeight, K.clientHeight, me.scrollHeight, me.clientHeight); let ye = -pe.scrollLeft + getWindowScrollBarX(fe); const ve = -pe.scrollTop; return getComputedStyle$1(me).direction === "rtl" && (ye += max$3(K.clientWidth, me.clientWidth) - ge), { width: ge, height: xe, x: ye, y: ve } } function getViewportRect(fe, K) { const pe = getWindow(fe), me = getDocumentElement(fe), ge = pe.visualViewport; let xe = me.clientWidth, ye = me.clientHeight, ve = 0, _e = 0; if (ge) { xe = ge.width, ye = ge.height; const Ee = isWebKit(); (!Ee || Ee && K === "fixed") && (ve = ge.offsetLeft, _e = ge.offsetTop) } return { width: xe, height: ye, x: ve, y: _e } } function getInnerBoundingClientRect(fe, K) { const pe = getBoundingClientRect(fe, !0, K === "fixed"), me = pe.top + fe.clientTop, ge = pe.left + fe.clientLeft, xe = isHTMLElement(fe) ? getScale(fe) : createCoords(1), ye = fe.clientWidth * xe.x, ve = fe.clientHeight * xe.y, _e = ge * xe.x, Ee = me * xe.y; return { width: ye, height: ve, x: _e, y: Ee } } function getClientRectFromClippingAncestor(fe, K, pe) { let me; if (K === "viewport") me = getViewportRect(fe, pe); else if (K === "document") me = getDocumentRect(getDocumentElement(fe)); else if (isElement(K)) me = getInnerBoundingClientRect(K, pe); else { const ge = getVisualOffsets(fe); me = { x: K.x - ge.x, y: K.y - ge.y, width: K.width, height: K.height } } return rectToClientRect(me) } function hasFixedPositionAncestor(fe, K) { const pe = getParentNode(fe); return pe === K || !isElement(pe) || isLastTraversableNode(pe) ? !1 : getComputedStyle$1(pe).position === "fixed" || hasFixedPositionAncestor(pe, K) } function getClippingElementAncestors(fe, K) { const pe = K.get(fe); if (pe) return pe; let me = getOverflowAncestors(fe, [], !1).filter(ve => isElement(ve) && getNodeName(ve) !== "body"), ge = null; const xe = getComputedStyle$1(fe).position === "fixed"; let ye = xe ? getParentNode(fe) : fe; for (; isElement(ye) && !isLastTraversableNode(ye);) { const ve = getComputedStyle$1(ye), _e = isContainingBlock(ye); !_e && ve.position === "fixed" && (ge = null), (xe ? !_e && !ge : !_e && ve.position === "static" && !!ge && ["absolute", "fixed"].includes(ge.position) || isOverflowElement(ye) && !_e && hasFixedPositionAncestor(fe, ye)) ? me = me.filter(be => be !== ye) : ge = ve, ye = getParentNode(ye) } return K.set(fe, me), me } function getClippingRect(fe) { let { element: K, boundary: pe, rootBoundary: me, strategy: ge } = fe; const ye = [...pe === "clippingAncestors" ? isTopLayer(K) ? [] : getClippingElementAncestors(K, this._c) : [].concat(pe), me], ve = ye[0], _e = ye.reduce((Ee, be) => { const Ae = getClientRectFromClippingAncestor(K, be, ge); return Ee.top = max$3(Ae.top, Ee.top), Ee.right = min$1(Ae.right, Ee.right), Ee.bottom = min$1(Ae.bottom, Ee.bottom), Ee.left = max$3(Ae.left, Ee.left), Ee }, getClientRectFromClippingAncestor(K, ve, ge)); return { width: _e.right - _e.left, height: _e.bottom - _e.top, x: _e.left, y: _e.top } } function getDimensions(fe) { const { width: K, height: pe } = getCssDimensions(fe); return { width: K, height: pe } } function getRectRelativeToOffsetParent(fe, K, pe) { const me = isHTMLElement(K), ge = getDocumentElement(K), xe = pe === "fixed", ye = getBoundingClientRect(fe, !0, xe, K); let ve = { scrollLeft: 0, scrollTop: 0 }; const _e = createCoords(0); if (me || !me && !xe) if ((getNodeName(K) !== "body" || isOverflowElement(ge)) && (ve = getNodeScroll(K)), me) { const Se = getBoundingClientRect(K, !0, xe, K); _e.x = Se.x + K.clientLeft, _e.y = Se.y + K.clientTop } else ge && (_e.x = getWindowScrollBarX(ge)); const Ee = ge && !me && !xe ? getHTMLOffset(ge, ve) : createCoords(0), be = ye.left + ve.scrollLeft - _e.x - Ee.x, Ae = ye.top + ve.scrollTop - _e.y - Ee.y; return { x: be, y: Ae, width: ye.width, height: ye.height } } function isStaticPositioned(fe) { return getComputedStyle$1(fe).position === "static" } function getTrueOffsetParent(fe, K) { if (!isHTMLElement(fe) || getComputedStyle$1(fe).position === "fixed") return null; if (K) return K(fe); let pe = fe.offsetParent; return getDocumentElement(fe) === pe && (pe = pe.ownerDocument.body), pe } function getOffsetParent(fe, K) { const pe = getWindow(fe); if (isTopLayer(fe)) return pe; if (!isHTMLElement(fe)) { let ge = getParentNode(fe); for (; ge && !isLastTraversableNode(ge);) { if (isElement(ge) && !isStaticPositioned(ge)) return ge; ge = getParentNode(ge) } return pe } let me = getTrueOffsetParent(fe, K); for (; me && isTableElement(me) && isStaticPositioned(me);)me = getTrueOffsetParent(me, K); return me && isLastTraversableNode(me) && isStaticPositioned(me) && !isContainingBlock(me) ? pe : me || getContainingBlock(fe) || pe } const getElementRects = async function (fe) { const K = this.getOffsetParent || getOffsetParent, pe = this.getDimensions, me = await pe(fe.floating); return { reference: getRectRelativeToOffsetParent(fe.reference, await K(fe.floating), fe.strategy), floating: { x: 0, y: 0, width: me.width, height: me.height } } }; function isRTL(fe) { return getComputedStyle$1(fe).direction === "rtl" } const platform = { convertOffsetParentRelativeRectToViewportRelativeRect, getDocumentElement, getClippingRect, getOffsetParent, getElementRects, getClientRects, getDimensions, getScale, isElement, isRTL }; function rectsAreEqual(fe, K) { return fe.x === K.x && fe.y === K.y && fe.width === K.width && fe.height === K.height } function observeMove(fe, K) { let pe = null, me; const ge = getDocumentElement(fe); function xe() { var ve; clearTimeout(me), (ve = pe) == null || ve.disconnect(), pe = null } function ye(ve, _e) { ve === void 0 && (ve = !1), _e === void 0 && (_e = 1), xe(); const Ee = fe.getBoundingClientRect(), { left: be, top: Ae, width: Se, height: Ce } = Ee; if (ve || K(), !Se || !Ce) return; const we = floor$1(Ae), Be = floor$1(ge.clientWidth - (be + Se)), De = floor$1(ge.clientHeight - (Ae + Ce)), Re = floor$1(be), Pe = { rootMargin: -we + "px " + -Be + "px " + -De + "px " + -Re + "px", threshold: max$3(0, min$1(1, _e)) || 1 }; let Ne = !0; function ke(Oe) { const Ue = Oe[0].intersectionRatio; if (Ue !== _e) { if (!Ne) return ye(); Ue ? ye(!1, Ue) : me = setTimeout(() => { ye(!1, 1e-7) }, 1e3) } Ue === 1 && !rectsAreEqual(Ee, fe.getBoundingClientRect()) && ye(), Ne = !1 } try { pe = new IntersectionObserver(ke, { ...Pe, root: ge.ownerDocument }) } catch { pe = new IntersectionObserver(ke, Pe) } pe.observe(fe) } return ye(!0), xe } function autoUpdate(fe, K, pe, me) { me === void 0 && (me = {}); const { ancestorScroll: ge = !0, ancestorResize: xe = !0, elementResize: ye = typeof ResizeObserver == "function", layoutShift: ve = typeof IntersectionObserver == "function", animationFrame: _e = !1 } = me, Ee = unwrapElement(fe), be = ge || xe ? [...Ee ? getOverflowAncestors(Ee) : [], ...getOverflowAncestors(K)] : []; be.forEach(Re => { ge && Re.addEventListener("scroll", pe, { passive: !0 }), xe && Re.addEventListener("resize", pe) }); const Ae = Ee && ve ? observeMove(Ee, pe) : null; let Se = -1, Ce = null; ye && (Ce = new ResizeObserver(Re => { let [Ie] = Re; Ie && Ie.target === Ee && Ce && (Ce.unobserve(K), cancelAnimationFrame(Se), Se = requestAnimationFrame(() => { var Pe; (Pe = Ce) == null || Pe.observe(K) })), pe() }), Ee && !_e && Ce.observe(Ee), Ce.observe(K)); let we, Be = _e ? getBoundingClientRect(fe) : null; _e && De(); function De() { const Re = getBoundingClientRect(fe); Be && !rectsAreEqual(Be, Re) && pe(), Be = Re, we = requestAnimationFrame(De) } return pe(), () => { var Re; be.forEach(Ie => { ge && Ie.removeEventListener("scroll", pe), xe && Ie.removeEventListener("resize", pe) }), Ae?.(), (Re = Ce) == null || Re.disconnect(), Ce = null, _e && cancelAnimationFrame(we) } } const offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (fe, K, pe) => { const me = new Map, ge = { platform, ...pe }, xe = { ...ge.platform, _c: me }; return computePosition$1(fe, K, { ...ge, platform: xe }) }; var index$4 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect; function deepEqual(fe, K) { if (fe === K) return !0; if (typeof fe != typeof K) return !1; if (typeof fe == "function" && fe.toString() === K.toString()) return !0; let pe, me, ge; if (fe && K && typeof fe == "object") { if (Array.isArray(fe)) { if (pe = fe.length, pe !== K.length) return !1; for (me = pe; me-- !== 0;)if (!deepEqual(fe[me], K[me])) return !1; return !0 } if (ge = Object.keys(fe), pe = ge.length, pe !== Object.keys(K).length) return !1; for (me = pe; me-- !== 0;)if (!{}.hasOwnProperty.call(K, ge[me])) return !1; for (me = pe; me-- !== 0;) { const xe = ge[me]; if (!(xe === "_owner" && fe.$$typeof) && !deepEqual(fe[xe], K[xe])) return !1 } return !0 } return fe !== fe && K !== K } function getDPR(fe) { return typeof window > "u" ? 1 : (fe.ownerDocument.defaultView || window).devicePixelRatio || 1 } function roundByDPR(fe, K) { const pe = getDPR(fe); return Math.round(K * pe) / pe } function useLatestRef$1(fe) { const K = reactExports.useRef(fe); return index$4(() => { K.current = fe }), K } function useFloating$1(fe) { fe === void 0 && (fe = {}); const { placement: K = "bottom", strategy: pe = "absolute", middleware: me = [], platform: ge, elements: { reference: xe, floating: ye } = {}, transform: ve = !0, whileElementsMounted: _e, open: Ee } = fe, [be, Ae] = reactExports.useState({ x: 0, y: 0, strategy: pe, placement: K, middlewareData: {}, isPositioned: !1 }), [Se, Ce] = reactExports.useState(me); deepEqual(Se, me) || Ce(me); const [we, Be] = reactExports.useState(null), [De, Re] = reactExports.useState(null), Ie = reactExports.useCallback(st => { st !== Oe.current && (Oe.current = st, Be(st)) }, []), Pe = reactExports.useCallback(st => { st !== Ue.current && (Ue.current = st, Re(st)) }, []), Ne = xe || we, ke = ye || De, Oe = reactExports.useRef(null), Ue = reactExports.useRef(null), He = reactExports.useRef(be), Ge = _e != null, ze = useLatestRef$1(_e), We = useLatestRef$1(ge), Xe = useLatestRef$1(Ee), Ye = reactExports.useCallback(() => { if (!Oe.current || !Ue.current) return; const st = { placement: K, strategy: pe, middleware: Se }; We.current && (st.platform = We.current), computePosition(Oe.current, Ue.current, st).then(Nt => { const Je = { ...Nt, isPositioned: Xe.current !== !1 }; Ze.current && !deepEqual(He.current, Je) && (He.current = Je, reactDomExports.flushSync(() => { Ae(Je) })) }) }, [Se, K, pe, We, Xe]); index$4(() => { Ee === !1 && He.current.isPositioned && (He.current.isPositioned = !1, Ae(st => ({ ...st, isPositioned: !1 }))) }, [Ee]); const Ze = reactExports.useRef(!1); index$4(() => (Ze.current = !0, () => { Ze.current = !1 }), []), index$4(() => { if (Ne && (Oe.current = Ne), ke && (Ue.current = ke), Ne && ke) { if (ze.current) return ze.current(Ne, ke, Ye); Ye() } }, [Ne, ke, Ye, ze, Ge]); const ot = reactExports.useMemo(() => ({ reference: Oe, floating: Ue, setReference: Ie, setFloating: Pe }), [Ie, Pe]), qe = reactExports.useMemo(() => ({ reference: Ne, floating: ke }), [Ne, ke]), Qe = reactExports.useMemo(() => { const st = { position: pe, left: 0, top: 0 }; if (!qe.floating) return st; const Nt = roundByDPR(qe.floating, be.x), Je = roundByDPR(qe.floating, be.y); return ve ? { ...st, transform: "translate(" + Nt + "px, " + Je + "px)", ...getDPR(qe.floating) >= 1.5 && { willChange: "transform" } } : { position: pe, left: Nt, top: Je } }, [pe, ve, qe.floating, be.x, be.y]); return reactExports.useMemo(() => ({ ...be, update: Ye, refs: ot, elements: qe, floatingStyles: Qe }), [be, Ye, ot, qe, Qe]) } const arrow$1 = fe => { function K(pe) { return {}.hasOwnProperty.call(pe, "current") } return { name: "arrow", options: fe, fn(pe) { const { element: me, padding: ge } = typeof fe == "function" ? fe(pe) : fe; return me && K(me) ? me.current != null ? arrow$2({ element: me.current, padding: ge }).fn(pe) : {} : me ? arrow$2({ element: me, padding: ge }).fn(pe) : {} } } }, offset = (fe, K) => ({ ...offset$1(fe), options: [fe, K] }), shift = (fe, K) => ({ ...shift$1(fe), options: [fe, K] }), limitShift = (fe, K) => ({ ...limitShift$1(fe), options: [fe, K] }), flip = (fe, K) => ({ ...flip$1(fe), options: [fe, K] }), size = (fe, K) => ({ ...size$1(fe), options: [fe, K] }), hide = (fe, K) => ({ ...hide$1(fe), options: [fe, K] }), inline = (fe, K) => ({ ...inline$1(fe), options: [fe, K] }), arrow = (fe, K) => ({ ...arrow$1(fe), options: [fe, K] }); function useMergeRefs(fe) { return reactExports.useMemo(() => fe.every(K => K == null) ? null : K => { fe.forEach(pe => { typeof pe == "function" ? pe(K) : pe != null && (pe.current = K) }) }, fe) } const SafeReact = { ...React$5 }, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || (fe => fe()); function useEffectEvent(fe) { const K = reactExports.useRef(() => { }); return useSafeInsertionEffect(() => { K.current = fe }), reactExports.useCallback(function () { for (var pe = arguments.length, me = new Array(pe), ge = 0; ge < pe; ge++)me[ge] = arguments[ge]; return K.current == null ? void 0 : K.current(...me) }, []) } var index$3 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect; let serverHandoffComplete = !1, count = 0; const genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++; function useFloatingId() { const [fe, K] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0); return index$3(() => { fe == null && K(genId()) }, []), reactExports.useEffect(() => { serverHandoffComplete = !0 }, []), fe } const useReactId = SafeReact.useId, useId = useReactId || useFloatingId; function createPubSub() { const fe = new Map; return { emit(K, pe) { var me; (me = fe.get(K)) == null || me.forEach(ge => ge(pe)) }, on(K, pe) { fe.set(K, [...fe.get(K) || [], pe]) }, off(K, pe) { var me; fe.set(K, ((me = fe.get(K)) == null ? void 0 : me.filter(ge => ge !== pe)) || []) } } } const FloatingNodeContext = reactExports.createContext(null), FloatingTreeContext = reactExports.createContext(null), useFloatingParentNodeId = () => { var fe; return ((fe = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : fe.id) || null }, useFloatingTree = () => reactExports.useContext(FloatingTreeContext); function createAttribute(fe) { return "data-floating-ui-" + fe } function useLatestRef(fe) { const K = reactExports.useRef(fe); return index$3(() => { K.current = fe }), K } const safePolygonIdentifier = createAttribute("safe-polygon"); function getDelay(fe, K, pe) { return pe && !isMouseLikePointerType(pe) ? 0 : typeof fe == "number" ? fe : fe?.[K] } function useHover(fe, K) { K === void 0 && (K = {}); const { open: pe, onOpenChange: me, dataRef: ge, events: xe, elements: ye } = fe, { enabled: ve = !0, delay: _e = 0, handleClose: Ee = null, mouseOnly: be = !1, restMs: Ae = 0, move: Se = !0 } = K, Ce = useFloatingTree(), we = useFloatingParentNodeId(), Be = useLatestRef(Ee), De = useLatestRef(_e), Re = useLatestRef(pe), Ie = reactExports.useRef(), Pe = reactExports.useRef(-1), Ne = reactExports.useRef(), ke = reactExports.useRef(-1), Oe = reactExports.useRef(!0), Ue = reactExports.useRef(!1), He = reactExports.useRef(() => { }), Ge = reactExports.useRef(!1), ze = reactExports.useCallback(() => { var Qe; const st = (Qe = ge.current.openEvent) == null ? void 0 : Qe.type; return st?.includes("mouse") && st !== "mousedown" }, [ge]); reactExports.useEffect(() => { if (!ve) return; function Qe(st) { let { open: Nt } = st; Nt || (clearTimeout(Pe.current), clearTimeout(ke.current), Oe.current = !0, Ge.current = !1) } return xe.on("openchange", Qe), () => { xe.off("openchange", Qe) } }, [ve, xe]), reactExports.useEffect(() => { if (!ve || !Be.current || !pe) return; function Qe(Nt) { ze() && me(!1, Nt, "hover") } const st = getDocument(ye.floating).documentElement; return st.addEventListener("mouseleave", Qe), () => { st.removeEventListener("mouseleave", Qe) } }, [ye.floating, pe, me, ve, Be, ze]); const We = reactExports.useCallback(function (Qe, st, Nt) { st === void 0 && (st = !0), Nt === void 0 && (Nt = "hover"); const Je = getDelay(De.current, "close", Ie.current); Je && !Ne.current ? (clearTimeout(Pe.current), Pe.current = window.setTimeout(() => me(!1, Qe, Nt), Je)) : st && (clearTimeout(Pe.current), me(!1, Qe, Nt)) }, [De, me]), Xe = useEffectEvent(() => { He.current(), Ne.current = void 0 }), Ye = useEffectEvent(() => { if (Ue.current) { const Qe = getDocument(ye.floating).body; Qe.style.pointerEvents = "", Qe.removeAttribute(safePolygonIdentifier), Ue.current = !1 } }), Ze = useEffectEvent(() => ge.current.openEvent ? ["click", "mousedown"].includes(ge.current.openEvent.type) : !1); reactExports.useEffect(() => { if (!ve) return; function Qe(jt) { if (clearTimeout(Pe.current), Oe.current = !1, be && !isMouseLikePointerType(Ie.current) || Ae > 0 && !getDelay(De.current, "open")) return; const Xt = getDelay(De.current, "open", Ie.current); Xt ? Pe.current = window.setTimeout(() => { Re.current || me(!0, jt, "hover") }, Xt) : pe || me(!0, jt, "hover") } function st(jt) { if (Ze()) return; He.current(); const Xt = getDocument(ye.floating); if (clearTimeout(ke.current), Ge.current = !1, Be.current && ge.current.floatingContext) { pe || clearTimeout(Pe.current), Ne.current = Be.current({ ...ge.current.floatingContext, tree: Ce, x: jt.clientX, y: jt.clientY, onClose() { Ye(), Xe(), Ze() || We(jt, !0, "safe-polygon") } }); const nn = Ne.current; Xt.addEventListener("mousemove", nn), He.current = () => { Xt.removeEventListener("mousemove", nn) }; return } (Ie.current === "touch" ? !contains(ye.floating, jt.relatedTarget) : !0) && We(jt) } function Nt(jt) { Ze() || ge.current.floatingContext && (Be.current == null || Be.current({ ...ge.current.floatingContext, tree: Ce, x: jt.clientX, y: jt.clientY, onClose() { Ye(), Xe(), Ze() || We(jt) } })(jt)) } if (isElement(ye.domReference)) { var Je; const jt = ye.domReference; return pe && jt.addEventListener("mouseleave", Nt), (Je = ye.floating) == null || Je.addEventListener("mouseleave", Nt), Se && jt.addEventListener("mousemove", Qe, { once: !0 }), jt.addEventListener("mouseenter", Qe), jt.addEventListener("mouseleave", st), () => { var Xt; pe && jt.removeEventListener("mouseleave", Nt), (Xt = ye.floating) == null || Xt.removeEventListener("mouseleave", Nt), Se && jt.removeEventListener("mousemove", Qe), jt.removeEventListener("mouseenter", Qe), jt.removeEventListener("mouseleave", st) } } }, [ye, ve, fe, be, Ae, Se, We, Xe, Ye, me, pe, Re, Ce, De, Be, ge, Ze]), index$3(() => { var Qe; if (ve && pe && (Qe = Be.current) != null && Qe.__options.blockPointerEvents && ze()) { Ue.current = !0; const Nt = ye.floating; if (isElement(ye.domReference) && Nt) { var st; const Je = getDocument(ye.floating).body; Je.setAttribute(safePolygonIdentifier, ""); const jt = ye.domReference, Xt = Ce == null || (st = Ce.nodesRef.current.find(ct => ct.id === we)) == null || (st = st.context) == null ? void 0 : st.elements.floating; return Xt && (Xt.style.pointerEvents = ""), Je.style.pointerEvents = "none", jt.style.pointerEvents = "auto", Nt.style.pointerEvents = "auto", () => { Je.style.pointerEvents = "", jt.style.pointerEvents = "", Nt.style.pointerEvents = "" } } } }, [ve, pe, we, ye, Ce, Be, ze]), index$3(() => { pe || (Ie.current = void 0, Ge.current = !1, Xe(), Ye()) }, [pe, Xe, Ye]), reactExports.useEffect(() => () => { Xe(), clearTimeout(Pe.current), clearTimeout(ke.current), Ye() }, [ve, ye.domReference, Xe, Ye]); const ot = reactExports.useMemo(() => { function Qe(st) { Ie.current = st.pointerType } return { onPointerDown: Qe, onPointerEnter: Qe, onMouseMove(st) { const { nativeEvent: Nt } = st; function Je() { !Oe.current && !Re.current && me(!0, Nt, "hover") } be && !isMouseLikePointerType(Ie.current) || pe || Ae === 0 || Ge.current && st.movementX ** 2 + st.movementY ** 2 < 2 || (clearTimeout(ke.current), Ie.current === "touch" ? Je() : (Ge.current = !0, ke.current = window.setTimeout(Je, Ae))) } } }, [be, me, pe, Re, Ae]), qe = reactExports.useMemo(() => ({ onMouseEnter() { clearTimeout(Pe.current) }, onMouseLeave(Qe) { Ze() || We(Qe.nativeEvent, !1) } }), [We, Ze]); return reactExports.useMemo(() => ve ? { reference: ot, floating: qe } : {}, [ve, ot, qe]) } const NOOP = () => { }, FloatingDelayGroupContext = reactExports.createContext({ delay: 0, initialDelay: 0, timeoutMs: 0, currentId: null, setCurrentId: NOOP, setState: NOOP, isInstantPhase: !1 }), useDelayGroupContext = () => reactExports.useContext(FloatingDelayGroupContext); function FloatingDelayGroup(fe) { const { children: K, delay: pe, timeoutMs: me = 0 } = fe, [ge, xe] = reactExports.useReducer((_e, Ee) => ({ ..._e, ...Ee }), { delay: pe, timeoutMs: me, initialDelay: pe, currentId: null, isInstantPhase: !1 }), ye = reactExports.useRef(null), ve = reactExports.useCallback(_e => { xe({ currentId: _e }) }, []); return index$3(() => { ge.currentId ? ye.current === null ? ye.current = ge.currentId : ge.isInstantPhase || xe({ isInstantPhase: !0 }) : (ge.isInstantPhase && xe({ isInstantPhase: !1 }), ye.current = null) }, [ge.currentId, ge.isInstantPhase]), reactExports.createElement(FloatingDelayGroupContext.Provider, { value: reactExports.useMemo(() => ({ ...ge, setState: xe, setCurrentId: ve }), [ge, ve]) }, K) } function useDelayGroup(fe, K) { K === void 0 && (K = {}); const { open: pe, onOpenChange: me, floatingId: ge } = fe, { id: xe, enabled: ye = !0 } = K, ve = xe ?? ge, _e = useDelayGroupContext(), { currentId: Ee, setCurrentId: be, initialDelay: Ae, setState: Se, timeoutMs: Ce } = _e; return index$3(() => { ye && Ee && (Se({ delay: { open: 1, close: getDelay(Ae, "close") } }), Ee !== ve && me(!1)) }, [ye, ve, me, Se, Ee, Ae]), index$3(() => { function we() { me(!1), Se({ delay: Ae, currentId: null }) } if (ye && Ee && !pe && Ee === ve) { if (Ce) { const Be = window.setTimeout(we, Ce); return () => { clearTimeout(Be) } } we() } }, [ye, pe, Se, Ee, ve, me, Ae, Ce]), index$3(() => { ye && (be === NOOP || !pe || be(ve)) }, [ye, pe, be, ve]), _e } function getChildren(fe, K) { let pe = fe.filter(ge => { var xe; return ge.parentId === K && ((xe = ge.context) == null ? void 0 : xe.open) }), me = pe; for (; me.length;)me = fe.filter(ge => { var xe; return (xe = me) == null ? void 0 : xe.some(ye => { var ve; return ge.parentId === ye.id && ((ve = ge.context) == null ? void 0 : ve.open) }) }), pe = pe.concat(me); return pe } const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", bubbleHandlerKeys = { pointerdown: "onPointerDown", mousedown: "onMouseDown", click: "onClick" }, captureHandlerKeys = { pointerdown: "onPointerDownCapture", mousedown: "onMouseDownCapture", click: "onClickCapture" }, normalizeProp = fe => { var K, pe; return { escapeKey: typeof fe == "boolean" ? fe : (K = fe?.escapeKey) != null ? K : !1, outsidePress: typeof fe == "boolean" ? fe : (pe = fe?.outsidePress) != null ? pe : !0 } }; function useDismiss(fe, K) { K === void 0 && (K = {}); const { open: pe, onOpenChange: me, elements: ge, dataRef: xe } = fe, { enabled: ye = !0, escapeKey: ve = !0, outsidePress: _e = !0, outsidePressEvent: Ee = "pointerdown", referencePress: be = !1, referencePressEvent: Ae = "pointerdown", ancestorScroll: Se = !1, bubbles: Ce, capture: we } = K, Be = useFloatingTree(), De = useEffectEvent(typeof _e == "function" ? _e : () => !1), Re = typeof _e == "function" ? De : _e, Ie = reactExports.useRef(!1), Pe = reactExports.useRef(!1), { escapeKey: Ne, outsidePress: ke } = normalizeProp(Ce), { escapeKey: Oe, outsidePress: Ue } = normalizeProp(we), He = reactExports.useRef(!1), Ge = useEffectEvent(ot => { var qe; if (!pe || !ye || !ve || ot.key !== "Escape" || He.current) return; const Qe = (qe = xe.current.floatingContext) == null ? void 0 : qe.nodeId, st = Be ? getChildren(Be.nodesRef.current, Qe) : []; if (!Ne && (ot.stopPropagation(), st.length > 0)) { let Nt = !0; if (st.forEach(Je => { var jt; if ((jt = Je.context) != null && jt.open && !Je.context.dataRef.current.__escapeKeyBubbles) { Nt = !1; return } }), !Nt) return } me(!1, isReactEvent(ot) ? ot.nativeEvent : ot, "escape-key") }), ze = useEffectEvent(ot => { var qe; const Qe = () => { var st; Ge(ot), (st = getTarget(ot)) == null || st.removeEventListener("keydown", Qe) }; (qe = getTarget(ot)) == null || qe.addEventListener("keydown", Qe) }), We = useEffectEvent(ot => { var qe; const Qe = Ie.current; Ie.current = !1; const st = Pe.current; if (Pe.current = !1, Ee === "click" && st || Qe || typeof Re == "function" && !Re(ot)) return; const Nt = getTarget(ot), Je = "[" + createAttribute("inert") + "]", jt = getDocument(ge.floating).querySelectorAll(Je); let Xt = isElement(Nt) ? Nt : null; for (; Xt && !isLastTraversableNode(Xt);) { const an = getParentNode(Xt); if (isLastTraversableNode(an) || !isElement(an)) break; Xt = an } if (jt.length && isElement(Nt) && !isRootElement(Nt) && !contains(Nt, ge.floating) && Array.from(jt).every(an => !contains(Xt, an))) return; if (isHTMLElement(Nt) && Ze) { const an = Nt.clientWidth > 0 && Nt.scrollWidth > Nt.clientWidth, gn = Nt.clientHeight > 0 && Nt.scrollHeight > Nt.clientHeight; let Mn = gn && ot.offsetX > Nt.clientWidth; if (gn && getComputedStyle$1(Nt).direction === "rtl" && (Mn = ot.offsetX <= Nt.offsetWidth - Nt.clientWidth), Mn || an && ot.offsetY > Nt.clientHeight) return } const ct = (qe = xe.current.floatingContext) == null ? void 0 : qe.nodeId, nn = Be && getChildren(Be.nodesRef.current, ct).some(an => { var gn; return isEventTargetWithin(ot, (gn = an.context) == null ? void 0 : gn.elements.floating) }); if (isEventTargetWithin(ot, ge.floating) || isEventTargetWithin(ot, ge.domReference) || nn) return; const $t = Be ? getChildren(Be.nodesRef.current, ct) : []; if ($t.length > 0) { let an = !0; if ($t.forEach(gn => { var Mn; if ((Mn = gn.context) != null && Mn.open && !gn.context.dataRef.current.__outsidePressBubbles) { an = !1; return } }), !an) return } me(!1, ot, "outside-press") }), Xe = useEffectEvent(ot => { var qe; const Qe = () => { var st; We(ot), (st = getTarget(ot)) == null || st.removeEventListener(Ee, Qe) }; (qe = getTarget(ot)) == null || qe.addEventListener(Ee, Qe) }); reactExports.useEffect(() => { if (!pe || !ye) return; xe.current.__escapeKeyBubbles = Ne, xe.current.__outsidePressBubbles = ke; let ot = -1; function qe(jt) { me(!1, jt, "ancestor-scroll") } function Qe() { window.clearTimeout(ot), He.current = !0 } function st() { ot = window.setTimeout(() => { He.current = !1 }, isWebKit() ? 5 : 0) } const Nt = getDocument(ge.floating); ve && (Nt.addEventListener("keydown", Oe ? ze : Ge, Oe), Nt.addEventListener("compositionstart", Qe), Nt.addEventListener("compositionend", st)), Re && Nt.addEventListener(Ee, Ue ? Xe : We, Ue); let Je = []; return Se && (isElement(ge.domReference) && (Je = getOverflowAncestors(ge.domReference)), isElement(ge.floating) && (Je = Je.concat(getOverflowAncestors(ge.floating))), !isElement(ge.reference) && ge.reference && ge.reference.contextElement && (Je = Je.concat(getOverflowAncestors(ge.reference.contextElement)))), Je = Je.filter(jt => { var Xt; return jt !== ((Xt = Nt.defaultView) == null ? void 0 : Xt.visualViewport) }), Je.forEach(jt => { jt.addEventListener("scroll", qe, { passive: !0 }) }), () => { ve && (Nt.removeEventListener("keydown", Oe ? ze : Ge, Oe), Nt.removeEventListener("compositionstart", Qe), Nt.removeEventListener("compositionend", st)), Re && Nt.removeEventListener(Ee, Ue ? Xe : We, Ue), Je.forEach(jt => { jt.removeEventListener("scroll", qe) }), window.clearTimeout(ot) } }, [xe, ge, ve, Re, Ee, pe, me, Se, ye, Ne, ke, Ge, Oe, ze, We, Ue, Xe]), reactExports.useEffect(() => { Ie.current = !1 }, [Re, Ee]); const Ye = reactExports.useMemo(() => ({ onKeyDown: Ge, [bubbleHandlerKeys[Ae]]: ot => { be && me(!1, ot.nativeEvent, "reference-press") } }), [Ge, me, be, Ae]), Ze = reactExports.useMemo(() => ({ onKeyDown: Ge, onMouseDown() { Pe.current = !0 }, onMouseUp() { Pe.current = !0 }, [captureHandlerKeys[Ee]]: () => { Ie.current = !0 } }), [Ge, Ee]); return reactExports.useMemo(() => ye ? { reference: Ye, floating: Ze } : {}, [ye, Ye, Ze]) } function useFloatingRootContext(fe) { const { open: K = !1, onOpenChange: pe, elements: me } = fe, ge = useId(), xe = reactExports.useRef({}), [ye] = reactExports.useState(() => createPubSub()), ve = useFloatingParentNodeId() != null, [_e, Ee] = reactExports.useState(me.reference), be = useEffectEvent((Ce, we, Be) => { xe.current.openEvent = Ce ? we : void 0, ye.emit("openchange", { open: Ce, event: we, reason: Be, nested: ve }), pe?.(Ce, we, Be) }), Ae = reactExports.useMemo(() => ({ setPositionReference: Ee }), []), Se = reactExports.useMemo(() => ({ reference: _e || me.reference || null, floating: me.floating || null, domReference: me.reference }), [_e, me.reference, me.floating]); return reactExports.useMemo(() => ({ dataRef: xe, open: K, onOpenChange: be, elements: Se, events: ye, floatingId: ge, refs: Ae }), [K, be, Se, ye, ge, Ae]) } function useFloating(fe) { fe === void 0 && (fe = {}); const { nodeId: K } = fe, pe = useFloatingRootContext({ ...fe, elements: { reference: null, floating: null, ...fe.elements } }), me = fe.rootContext || pe, ge = me.elements, [xe, ye] = reactExports.useState(null), [ve, _e] = reactExports.useState(null), be = ge?.domReference || xe, Ae = reactExports.useRef(null), Se = useFloatingTree(); index$3(() => { be && (Ae.current = be) }, [be]); const Ce = useFloating$1({ ...fe, elements: { ...ge, ...ve && { reference: ve } } }), we = reactExports.useCallback(Pe => { const Ne = isElement(Pe) ? { getBoundingClientRect: () => Pe.getBoundingClientRect(), contextElement: Pe } : Pe; _e(Ne), Ce.refs.setReference(Ne) }, [Ce.refs]), Be = reactExports.useCallback(Pe => { (isElement(Pe) || Pe === null) && (Ae.current = Pe, ye(Pe)), (isElement(Ce.refs.reference.current) || Ce.refs.reference.current === null || Pe !== null && !isElement(Pe)) && Ce.refs.setReference(Pe) }, [Ce.refs]), De = reactExports.useMemo(() => ({ ...Ce.refs, setReference: Be, setPositionReference: we, domReference: Ae }), [Ce.refs, Be, we]), Re = reactExports.useMemo(() => ({ ...Ce.elements, domReference: be }), [Ce.elements, be]), Ie = reactExports.useMemo(() => ({ ...Ce, ...me, refs: De, elements: Re, nodeId: K }), [Ce, De, Re, K, me]); return index$3(() => { me.dataRef.current.floatingContext = Ie; const Pe = Se?.nodesRef.current.find(Ne => Ne.id === K); Pe && (Pe.context = Ie) }), reactExports.useMemo(() => ({ ...Ce, context: Ie, refs: De, elements: Re }), [Ce, De, Re, Ie]) } function useFocus(fe, K) { K === void 0 && (K = {}); const { open: pe, onOpenChange: me, events: ge, dataRef: xe, elements: ye } = fe, { enabled: ve = !0, visibleOnly: _e = !0 } = K, Ee = reactExports.useRef(!1), be = reactExports.useRef(), Ae = reactExports.useRef(!0); reactExports.useEffect(() => { if (!ve) return; const Ce = getWindow(ye.domReference); function we() { !pe && isHTMLElement(ye.domReference) && ye.domReference === activeElement(getDocument(ye.domReference)) && (Ee.current = !0) } function Be() { Ae.current = !0 } return Ce.addEventListener("blur", we), Ce.addEventListener("keydown", Be, !0), () => { Ce.removeEventListener("blur", we), Ce.removeEventListener("keydown", Be, !0) } }, [ye.domReference, pe, ve]), reactExports.useEffect(() => { if (!ve) return; function Ce(we) { let { reason: Be } = we; (Be === "reference-press" || Be === "escape-key") && (Ee.current = !0) } return ge.on("openchange", Ce), () => { ge.off("openchange", Ce) } }, [ge, ve]), reactExports.useEffect(() => () => { clearTimeout(be.current) }, []); const Se = reactExports.useMemo(() => ({ onPointerDown(Ce) { isVirtualPointerEvent(Ce.nativeEvent) || (Ae.current = !1) }, onMouseLeave() { Ee.current = !1 }, onFocus(Ce) { if (Ee.current) return; const we = getTarget(Ce.nativeEvent); if (_e && isElement(we)) try { if (isSafari() && isMac$1()) throw Error(); if (!we.matches(":focus-visible")) return } catch { if (!Ae.current && !isTypeableElement(we)) return } me(!0, Ce.nativeEvent, "focus") }, onBlur(Ce) { Ee.current = !1; const we = Ce.relatedTarget, Be = Ce.nativeEvent, De = isElement(we) && we.hasAttribute(createAttribute("focus-guard")) && we.getAttribute("data-type") === "outside"; be.current = window.setTimeout(() => { var Re; const Ie = activeElement(ye.domReference ? ye.domReference.ownerDocument : document); !we && Ie === ye.domReference || contains((Re = xe.current.floatingContext) == null ? void 0 : Re.refs.floating.current, Ie) || contains(ye.domReference, Ie) || De || me(!1, Be, "focus") }) } }), [xe, ye.domReference, me, _e]); return reactExports.useMemo(() => ve ? { reference: Se } : {}, [ve, Se]) } const ACTIVE_KEY = "active", SELECTED_KEY = "selected"; function mergeProps(fe, K, pe) { const me = new Map, ge = pe === "item"; let xe = fe; if (ge && fe) { const { [ACTIVE_KEY]: ye, [SELECTED_KEY]: ve, ..._e } = fe; xe = _e } return { ...pe === "floating" && { tabIndex: -1, [FOCUSABLE_ATTRIBUTE]: "" }, ...xe, ...K.map(ye => { const ve = ye ? ye[pe] : null; return typeof ve == "function" ? fe ? ve(fe) : null : ve }).concat(fe).reduce((ye, ve) => (ve && Object.entries(ve).forEach(_e => { let [Ee, be] = _e; if (!(ge && [ACTIVE_KEY, SELECTED_KEY].includes(Ee))) if (Ee.indexOf("on") === 0) { if (me.has(Ee) || me.set(Ee, []), typeof be == "function") { var Ae; (Ae = me.get(Ee)) == null || Ae.push(be), ye[Ee] = function () { for (var Se, Ce = arguments.length, we = new Array(Ce), Be = 0; Be < Ce; Be++)we[Be] = arguments[Be]; return (Se = me.get(Ee)) == null ? void 0 : Se.map(De => De(...we)).find(De => De !== void 0) } } } else ye[Ee] = be }), ye), {}) } } function useInteractions(fe) { fe === void 0 && (fe = []); const K = fe.map(ve => ve?.reference), pe = fe.map(ve => ve?.floating), me = fe.map(ve => ve?.item), ge = reactExports.useCallback(ve => mergeProps(ve, fe, "reference"), K), xe = reactExports.useCallback(ve => mergeProps(ve, fe, "floating"), pe), ye = reactExports.useCallback(ve => mergeProps(ve, fe, "item"), me); return reactExports.useMemo(() => ({ getReferenceProps: ge, getFloatingProps: xe, getItemProps: ye }), [ge, xe, ye]) } const componentRoleToAriaRoleMap = new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]); function useRole(fe, K) { var pe; K === void 0 && (K = {}); const { open: me, floatingId: ge } = fe, { enabled: xe = !0, role: ye = "dialog" } = K, ve = (pe = componentRoleToAriaRoleMap.get(ye)) != null ? pe : ye, _e = useId(), be = useFloatingParentNodeId() != null, Ae = reactExports.useMemo(() => ve === "tooltip" || ye === "label" ? { ["aria-" + (ye === "label" ? "labelledby" : "describedby")]: me ? ge : void 0 } : { "aria-expanded": me ? "true" : "false", "aria-haspopup": ve === "alertdialog" ? "dialog" : ve, "aria-controls": me ? ge : void 0, ...ve === "listbox" && { role: "combobox" }, ...ve === "menu" && { id: _e }, ...ve === "menu" && be && { role: "menuitem" }, ...ye === "select" && { "aria-autocomplete": "none" }, ...ye === "combobox" && { "aria-autocomplete": "list" } }, [ve, ge, be, me, _e, ye]), Se = reactExports.useMemo(() => { const we = { id: ge, ...ve && { role: ve } }; return ve === "tooltip" || ye === "label" ? we : { ...we, ...ve === "menu" && { "aria-labelledby": _e } } }, [ve, ge, _e, ye]), Ce = reactExports.useCallback(we => { let { active: Be, selected: De } = we; const Re = { role: "option", ...Be && { id: ge + "-option" } }; switch (ye) { case "select": return { ...Re, "aria-selected": Be && De }; case "combobox": return { ...Re, ...Be && { "aria-selected": !0 } } }return {} }, [ge, ye]); return reactExports.useMemo(() => xe ? { reference: Ae, floating: Se, item: Ce } : {}, [xe, Ae, Se, Ce]) } const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext("ScrollArea.Root component was not found in tree"); function useResizeObserver(fe, K) { const pe = useCallbackRef$1(K); useIsomorphicEffect$1(() => { let me = 0; if (fe) { const ge = new ResizeObserver(() => { cancelAnimationFrame(me), me = window.requestAnimationFrame(pe) }); return ge.observe(fe), () => { window.cancelAnimationFrame(me), ge.unobserve(fe) } } }, [fe, pe]) } const Corner = reactExports.forwardRef((fe, K) => { const { style: pe, ...me } = fe, ge = useScrollAreaContext(), [xe, ye] = reactExports.useState(0), [ve, _e] = reactExports.useState(0), Ee = !!(xe && ve); return useResizeObserver(ge.scrollbarX, () => { const be = ge.scrollbarX?.offsetHeight || 0; ge.onCornerHeightChange(be), _e(be) }), useResizeObserver(ge.scrollbarY, () => { const be = ge.scrollbarY?.offsetWidth || 0; ge.onCornerWidthChange(be), ye(be) }), Ee ? jsxRuntimeExports.jsx("div", { ...me, ref: K, style: { ...pe, width: xe, height: ve } }) : null }), ScrollAreaCorner = reactExports.forwardRef((fe, K) => { const pe = useScrollAreaContext(), me = !!(pe.scrollbarX && pe.scrollbarY); return pe.type !== "scroll" && me ? jsxRuntimeExports.jsx(Corner, { ...fe, ref: K }) : null }), defaultProps$1q = { scrollHideDelay: 1e3, type: "hover" }, ScrollAreaRoot = reactExports.forwardRef((fe, K) => { const { type: pe, scrollHideDelay: me, scrollbars: ge, getStyles: xe, ...ye } = useProps("ScrollAreaRoot", defaultProps$1q, fe), [ve, _e] = reactExports.useState(null), [Ee, be] = reactExports.useState(null), [Ae, Se] = reactExports.useState(null), [Ce, we] = reactExports.useState(null), [Be, De] = reactExports.useState(null), [Re, Ie] = reactExports.useState(0), [Pe, Ne] = reactExports.useState(0), [ke, Oe] = reactExports.useState(!1), [Ue, He] = reactExports.useState(!1), Ge = useMergedRef(K, ze => _e(ze)); return jsxRuntimeExports.jsx(ScrollAreaProvider, { value: { type: pe, scrollHideDelay: me, scrollArea: ve, viewport: Ee, onViewportChange: be, content: Ae, onContentChange: Se, scrollbarX: Ce, onScrollbarXChange: we, scrollbarXEnabled: ke, onScrollbarXEnabledChange: Oe, scrollbarY: Be, onScrollbarYChange: De, scrollbarYEnabled: Ue, onScrollbarYEnabledChange: He, onCornerWidthChange: Ie, onCornerHeightChange: Ne, getStyles: xe }, children: jsxRuntimeExports.jsx(Box, { ...ye, ref: Ge, __vars: { "--sa-corner-width": ge !== "xy" ? "0px" : `${Re}px`, "--sa-corner-height": ge !== "xy" ? "0px" : `${Pe}px` } }) }) }); ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot"; function getThumbRatio(fe, K) { const pe = fe / K; return Number.isNaN(pe) ? 0 : pe } function getThumbSize(fe) { const K = getThumbRatio(fe.viewport, fe.content), pe = fe.scrollbar.paddingStart + fe.scrollbar.paddingEnd, me = (fe.scrollbar.size - pe) * K; return Math.max(me, 18) } function linearScale(fe, K) { return pe => { if (fe[0] === fe[1] || K[0] === K[1]) return K[0]; const me = (K[1] - K[0]) / (fe[1] - fe[0]); return K[0] + me * (pe - fe[0]) } } function clamp$5(fe, [K, pe]) { return Math.min(pe, Math.max(K, fe)) } function getThumbOffsetFromScroll(fe, K, pe = "ltr") { const me = getThumbSize(K), ge = K.scrollbar.paddingStart + K.scrollbar.paddingEnd, xe = K.scrollbar.size - ge, ye = K.content - K.viewport, ve = xe - me, _e = pe === "ltr" ? [0, ye] : [ye * -1, 0], Ee = clamp$5(fe, _e); return linearScale([0, ye], [0, ve])(Ee) } function getScrollPositionFromPointer(fe, K, pe, me = "ltr") { const ge = getThumbSize(pe), xe = ge / 2, ye = K || xe, ve = ge - ye, _e = pe.scrollbar.paddingStart + ye, Ee = pe.scrollbar.size - pe.scrollbar.paddingEnd - ve, be = pe.content - pe.viewport, Ae = me === "ltr" ? [0, be] : [be * -1, 0]; return linearScale([_e, Ee], Ae)(fe) } function isScrollingWithinScrollbarBounds(fe, K) { return fe > 0 && fe < K } function toInt(fe) { return fe ? parseInt(fe, 10) : 0 } function composeEventHandlers(fe, K, { checkForDefaultPrevented: pe = !0 } = {}) { return me => { fe?.(me), (pe === !1 || !me.defaultPrevented) && K?.(me) } } const [ScrollbarProvider, useScrollbarContext] = createSafeContext("ScrollAreaScrollbar was not found in tree"), Scrollbar = reactExports.forwardRef((fe, K) => { const { sizes: pe, hasThumb: me, onThumbChange: ge, onThumbPointerUp: xe, onThumbPointerDown: ye, onThumbPositionChange: ve, onDragScroll: _e, onWheelScroll: Ee, onResize: be, ...Ae } = fe, Se = useScrollAreaContext(), [Ce, we] = reactExports.useState(null), Be = useMergedRef(K, He => we(He)), De = reactExports.useRef(null), Re = reactExports.useRef(""), { viewport: Ie } = Se, Pe = pe.content - pe.viewport, Ne = useCallbackRef$1(Ee), ke = useCallbackRef$1(ve), Oe = useDebouncedCallback(be, 10), Ue = He => { if (De.current) { const Ge = He.clientX - De.current.left, ze = He.clientY - De.current.top; _e({ x: Ge, y: ze }) } }; return reactExports.useEffect(() => { const He = Ge => { const ze = Ge.target; Ce?.contains(ze) && Ne(Ge, Pe) }; return document.addEventListener("wheel", He, { passive: !1 }), () => document.removeEventListener("wheel", He, { passive: !1 }) }, [Ie, Ce, Pe, Ne]), reactExports.useEffect(ke, [pe, ke]), useResizeObserver(Ce, Oe), useResizeObserver(Se.content, Oe), jsxRuntimeExports.jsx(ScrollbarProvider, { value: { scrollbar: Ce, hasThumb: me, onThumbChange: useCallbackRef$1(ge), onThumbPointerUp: useCallbackRef$1(xe), onThumbPositionChange: ke, onThumbPointerDown: useCallbackRef$1(ye) }, children: jsxRuntimeExports.jsx("div", { ...Ae, ref: Be, "data-mantine-scrollbar": !0, style: { position: "absolute", ...Ae.style }, onPointerDown: composeEventHandlers(fe.onPointerDown, He => { He.preventDefault(), He.button === 0 && (He.target.setPointerCapture(He.pointerId), De.current = Ce.getBoundingClientRect(), Re.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", Ue(He)) }), onPointerMove: composeEventHandlers(fe.onPointerMove, Ue), onPointerUp: composeEventHandlers(fe.onPointerUp, He => { const Ge = He.target; Ge.hasPointerCapture(He.pointerId) && (He.preventDefault(), Ge.releasePointerCapture(He.pointerId)) }), onLostPointerCapture: () => { document.body.style.webkitUserSelect = Re.current, De.current = null } }) }) }), ScrollAreaScrollbarX = reactExports.forwardRef((fe, K) => { const { sizes: pe, onSizesChange: me, style: ge, ...xe } = fe, ye = useScrollAreaContext(), [ve, _e] = reactExports.useState(), Ee = reactExports.useRef(null), be = useMergedRef(K, Ee, ye.onScrollbarXChange); return reactExports.useEffect(() => { Ee.current && _e(getComputedStyle(Ee.current)) }, [Ee]), jsxRuntimeExports.jsx(Scrollbar, { "data-orientation": "horizontal", ...xe, ref: be, sizes: pe, style: { ...ge, "--sa-thumb-width": `${getThumbSize(pe)}px` }, onThumbPointerDown: Ae => fe.onThumbPointerDown(Ae.x), onDragScroll: Ae => fe.onDragScroll(Ae.x), onWheelScroll: (Ae, Se) => { if (ye.viewport) { const Ce = ye.viewport.scrollLeft + Ae.deltaX; fe.onWheelScroll(Ce), isScrollingWithinScrollbarBounds(Ce, Se) && Ae.preventDefault() } }, onResize: () => { Ee.current && ye.viewport && ve && me({ content: ye.viewport.scrollWidth, viewport: ye.viewport.offsetWidth, scrollbar: { size: Ee.current.clientWidth, paddingStart: toInt(ve.paddingLeft), paddingEnd: toInt(ve.paddingRight) } }) } }) }); ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX"; const ScrollAreaScrollbarY = reactExports.forwardRef((fe, K) => { const { sizes: pe, onSizesChange: me, style: ge, ...xe } = fe, ye = useScrollAreaContext(), [ve, _e] = reactExports.useState(), Ee = reactExports.useRef(null), be = useMergedRef(K, Ee, ye.onScrollbarYChange); return reactExports.useEffect(() => { Ee.current && _e(window.getComputedStyle(Ee.current)) }, []), jsxRuntimeExports.jsx(Scrollbar, { ...xe, "data-orientation": "vertical", ref: be, sizes: pe, style: { "--sa-thumb-height": `${getThumbSize(pe)}px`, ...ge }, onThumbPointerDown: Ae => fe.onThumbPointerDown(Ae.y), onDragScroll: Ae => fe.onDragScroll(Ae.y), onWheelScroll: (Ae, Se) => { if (ye.viewport) { const Ce = ye.viewport.scrollTop + Ae.deltaY; fe.onWheelScroll(Ce), isScrollingWithinScrollbarBounds(Ce, Se) && Ae.preventDefault() } }, onResize: () => { Ee.current && ye.viewport && ve && me({ content: ye.viewport.scrollHeight, viewport: ye.viewport.offsetHeight, scrollbar: { size: Ee.current.clientHeight, paddingStart: toInt(ve.paddingTop), paddingEnd: toInt(ve.paddingBottom) } }) } }) }); ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY"; const ScrollAreaScrollbarVisible = reactExports.forwardRef((fe, K) => { const { orientation: pe = "vertical", ...me } = fe, { dir: ge } = useDirection(), xe = useScrollAreaContext(), ye = reactExports.useRef(null), ve = reactExports.useRef(0), [_e, Ee] = reactExports.useState({ content: 0, viewport: 0, scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 } }), be = getThumbRatio(_e.viewport, _e.content), Ae = { ...me, sizes: _e, onSizesChange: Ee, hasThumb: be > 0 && be < 1, onThumbChange: Ce => { ye.current = Ce }, onThumbPointerUp: () => { ve.current = 0 }, onThumbPointerDown: Ce => { ve.current = Ce } }, Se = (Ce, we) => getScrollPositionFromPointer(Ce, ve.current, _e, we); return pe === "horizontal" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarX, { ...Ae, ref: K, onThumbPositionChange: () => { if (xe.viewport && ye.current) { const Ce = xe.viewport.scrollLeft, we = getThumbOffsetFromScroll(Ce, _e, ge); ye.current.style.transform = `translate3d(${we}px, 0, 0)` } }, onWheelScroll: Ce => { xe.viewport && (xe.viewport.scrollLeft = Ce) }, onDragScroll: Ce => { xe.viewport && (xe.viewport.scrollLeft = Se(Ce, ge)) } }) : pe === "vertical" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarY, { ...Ae, ref: K, onThumbPositionChange: () => { if (xe.viewport && ye.current) { const Ce = xe.viewport.scrollTop, we = getThumbOffsetFromScroll(Ce, _e); _e.scrollbar.size === 0 ? ye.current.style.setProperty("--thumb-opacity", "0") : ye.current.style.setProperty("--thumb-opacity", "1"), ye.current.style.transform = `translate3d(0, ${we}px, 0)` } }, onWheelScroll: Ce => { xe.viewport && (xe.viewport.scrollTop = Ce) }, onDragScroll: Ce => { xe.viewport && (xe.viewport.scrollTop = Se(Ce)) } }) : null }); ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible"; const ScrollAreaScrollbarAuto = reactExports.forwardRef((fe, K) => { const pe = useScrollAreaContext(), { forceMount: me, ...ge } = fe, [xe, ye] = reactExports.useState(!1), ve = fe.orientation === "horizontal", _e = useDebouncedCallback(() => { if (pe.viewport) { const Ee = pe.viewport.offsetWidth < pe.viewport.scrollWidth, be = pe.viewport.offsetHeight < pe.viewport.scrollHeight; ye(ve ? Ee : be) } }, 10); return useResizeObserver(pe.viewport, _e), useResizeObserver(pe.content, _e), me || xe ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { "data-state": xe ? "visible" : "hidden", ...ge, ref: K }) : null }); ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto"; const ScrollAreaScrollbarHover = reactExports.forwardRef((fe, K) => { const { forceMount: pe, ...me } = fe, ge = useScrollAreaContext(), [xe, ye] = reactExports.useState(!1); return reactExports.useEffect(() => { const { scrollArea: ve } = ge; let _e = 0; if (ve) { const Ee = () => { window.clearTimeout(_e), ye(!0) }, be = () => { _e = window.setTimeout(() => ye(!1), ge.scrollHideDelay) }; return ve.addEventListener("pointerenter", Ee), ve.addEventListener("pointerleave", be), () => { window.clearTimeout(_e), ve.removeEventListener("pointerenter", Ee), ve.removeEventListener("pointerleave", be) } } }, [ge.scrollArea, ge.scrollHideDelay]), pe || xe ? jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { "data-state": xe ? "visible" : "hidden", ...me, ref: K }) : null }); ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover"; const ScrollAreaScrollbarScroll = reactExports.forwardRef((fe, K) => { const { forceMount: pe, ...me } = fe, ge = useScrollAreaContext(), xe = fe.orientation === "horizontal", [ye, ve] = reactExports.useState("hidden"), _e = useDebouncedCallback(() => ve("idle"), 100); return reactExports.useEffect(() => { if (ye === "idle") { const Ee = window.setTimeout(() => ve("hidden"), ge.scrollHideDelay); return () => window.clearTimeout(Ee) } }, [ye, ge.scrollHideDelay]), reactExports.useEffect(() => { const { viewport: Ee } = ge, be = xe ? "scrollLeft" : "scrollTop"; if (Ee) { let Ae = Ee[be]; const Se = () => { const Ce = Ee[be]; Ae !== Ce && (ve("scrolling"), _e()), Ae = Ce }; return Ee.addEventListener("scroll", Se), () => Ee.removeEventListener("scroll", Se) } }, [ge.viewport, xe, _e]), pe || ye !== "hidden" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { "data-state": ye === "hidden" ? "hidden" : "visible", ...me, ref: K, onPointerEnter: composeEventHandlers(fe.onPointerEnter, () => ve("interacting")), onPointerLeave: composeEventHandlers(fe.onPointerLeave, () => ve("idle")) }) : null }), ScrollAreaScrollbar = reactExports.forwardRef((fe, K) => { const { forceMount: pe, ...me } = fe, ge = useScrollAreaContext(), { onScrollbarXEnabledChange: xe, onScrollbarYEnabledChange: ye } = ge, ve = fe.orientation === "horizontal"; return reactExports.useEffect(() => (ve ? xe(!0) : ye(!0), () => { ve ? xe(!1) : ye(!1) }), [ve, xe, ye]), ge.type === "hover" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...me, ref: K, forceMount: pe }) : ge.type === "scroll" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...me, ref: K, forceMount: pe }) : ge.type === "auto" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...me, ref: K, forceMount: pe }) : ge.type === "always" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...me, ref: K }) : null }); ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar"; function addUnlinkedScrollListener(fe, K = () => { }) { let pe = { left: fe.scrollLeft, top: fe.scrollTop }, me = 0; return function ge() { const xe = { left: fe.scrollLeft, top: fe.scrollTop }, ye = pe.left !== xe.left, ve = pe.top !== xe.top; (ye || ve) && K(), pe = xe, me = window.requestAnimationFrame(ge) }(), () => window.cancelAnimationFrame(me) } const Thumb$2 = reactExports.forwardRef((fe, K) => { const { style: pe, ...me } = fe, ge = useScrollAreaContext(), xe = useScrollbarContext(), { onThumbPositionChange: ye } = xe, ve = useMergedRef(K, be => xe.onThumbChange(be)), _e = reactExports.useRef(void 0), Ee = useDebouncedCallback(() => { _e.current && (_e.current(), _e.current = void 0) }, 100); return reactExports.useEffect(() => { const { viewport: be } = ge; if (be) { const Ae = () => { if (Ee(), !_e.current) { const Se = addUnlinkedScrollListener(be, ye); _e.current = Se, ye() } }; return ye(), be.addEventListener("scroll", Ae), () => be.removeEventListener("scroll", Ae) } }, [ge.viewport, Ee, ye]), jsxRuntimeExports.jsx("div", { "data-state": xe.hasThumb ? "visible" : "hidden", ...me, ref: ve, style: { width: "var(--sa-thumb-width)", height: "var(--sa-thumb-height)", ...pe }, onPointerDownCapture: composeEventHandlers(fe.onPointerDownCapture, be => { const Se = be.target.getBoundingClientRect(), Ce = be.clientX - Se.left, we = be.clientY - Se.top; xe.onThumbPointerDown({ x: Ce, y: we }) }), onPointerUp: composeEventHandlers(fe.onPointerUp, xe.onThumbPointerUp) }) }); Thumb$2.displayName = "@mantine/core/ScrollAreaThumb"; const ScrollAreaThumb = reactExports.forwardRef((fe, K) => { const { forceMount: pe, ...me } = fe, ge = useScrollbarContext(); return pe || ge.hasThumb ? jsxRuntimeExports.jsx(Thumb$2, { ref: K, ...me }) : null }); ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb"; const ScrollAreaViewport = reactExports.forwardRef(({ children: fe, style: K, ...pe }, me) => { const ge = useScrollAreaContext(), xe = useMergedRef(me, ge.onViewportChange); return jsxRuntimeExports.jsx(Box, { ...pe, ref: xe, style: { overflowX: ge.scrollbarXEnabled ? "scroll" : "hidden", overflowY: ge.scrollbarYEnabled ? "scroll" : "hidden", ...K }, children: jsxRuntimeExports.jsx("div", { ...ge.getStyles("content"), ref: ge.onContentChange, children: fe }) }) }); ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport"; var __default__$F = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268", content: "m_b1336c6" }; const defaultProps$1p = { scrollHideDelay: 1e3, type: "hover", scrollbars: "xy" }, varsResolver$K = (fe, { scrollbarSize: K, overscrollBehavior: pe }) => ({ root: { "--scrollarea-scrollbar-size": rem(K), "--scrollarea-over-scroll-behavior": pe } }), ScrollArea = factory((fe, K) => { const pe = useProps("ScrollArea", defaultProps$1p, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, scrollbarSize: _e, vars: Ee, type: be, scrollHideDelay: Ae, viewportProps: Se, viewportRef: Ce, onScrollPositionChange: we, children: Be, offsetScrollbars: De, scrollbars: Re, onBottomReached: Ie, onTopReached: Pe, overscrollBehavior: Ne, ...ke } = pe, [Oe, Ue] = reactExports.useState(!1), [He, Ge] = reactExports.useState(!1), [ze, We] = reactExports.useState(!1), Xe = useStyles({ name: "ScrollArea", props: pe, classes: __default__$F, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: Ee, varsResolver: varsResolver$K }), Ye = reactExports.useRef(null), Ze = useMergeRefs([Ce, Ye]); return reactExports.useEffect(() => { if (!Ye.current || De !== "present") return; const ot = Ye.current, qe = new ResizeObserver(() => { const { scrollHeight: Qe, clientHeight: st, scrollWidth: Nt, clientWidth: Je } = ot; Ge(Qe > st), We(Nt > Je) }); return qe.observe(ot), () => qe.disconnect() }, [Ye, De]), jsxRuntimeExports.jsxs(ScrollAreaRoot, { getStyles: Xe, type: be === "never" ? "always" : be, scrollHideDelay: Ae, ref: K, scrollbars: Re, ...Xe("root"), ...ke, children: [jsxRuntimeExports.jsx(ScrollAreaViewport, { ...Se, ...Xe("viewport", { style: Se?.style }), ref: Ze, "data-offset-scrollbars": De === !0 ? "xy" : De || void 0, "data-scrollbars": Re || void 0, "data-horizontal-hidden": De === "present" && !ze ? "true" : void 0, "data-vertical-hidden": De === "present" && !He ? "true" : void 0, onScroll: ot => { Se?.onScroll?.(ot), we?.({ x: ot.currentTarget.scrollLeft, y: ot.currentTarget.scrollTop }); const { scrollTop: qe, scrollHeight: Qe, clientHeight: st } = ot.currentTarget; qe - (Qe - st) >= -.6 && Ie?.(), qe === 0 && Pe?.() }, children: Be }), (Re === "xy" || Re === "x") && jsxRuntimeExports.jsx(ScrollAreaScrollbar, { ...Xe("scrollbar"), orientation: "horizontal", "data-hidden": be === "never" || De === "present" && !ze ? !0 : void 0, forceMount: !0, onMouseEnter: () => Ue(!0), onMouseLeave: () => Ue(!1), children: jsxRuntimeExports.jsx(ScrollAreaThumb, { ...Xe("thumb") }) }), (Re === "xy" || Re === "y") && jsxRuntimeExports.jsx(ScrollAreaScrollbar, { ...Xe("scrollbar"), orientation: "vertical", "data-hidden": be === "never" || De === "present" && !He ? !0 : void 0, forceMount: !0, onMouseEnter: () => Ue(!0), onMouseLeave: () => Ue(!1), children: jsxRuntimeExports.jsx(ScrollAreaThumb, { ...Xe("thumb") }) }), jsxRuntimeExports.jsx(ScrollAreaCorner, { ...Xe("corner"), "data-hovered": Oe || void 0, "data-hidden": be === "never" || void 0 })] }) }); ScrollArea.displayName = "@mantine/core/ScrollArea"; const ScrollAreaAutosize = factory((fe, K) => { const { children: pe, classNames: me, styles: ge, scrollbarSize: xe, scrollHideDelay: ye, type: ve, dir: _e, offsetScrollbars: Ee, viewportRef: be, onScrollPositionChange: Ae, unstyled: Se, variant: Ce, viewportProps: we, scrollbars: Be, style: De, vars: Re, onBottomReached: Ie, onTopReached: Pe, ...Ne } = useProps("ScrollAreaAutosize", defaultProps$1p, fe); return jsxRuntimeExports.jsx(Box, { ...Ne, ref: K, style: [{ display: "flex", overflow: "auto" }, De], children: jsxRuntimeExports.jsx(Box, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: jsxRuntimeExports.jsx(ScrollArea, { classNames: me, styles: ge, scrollHideDelay: ye, scrollbarSize: xe, type: ve, dir: _e, offsetScrollbars: Ee, viewportRef: be, onScrollPositionChange: Ae, unstyled: Se, variant: Ce, viewportProps: we, vars: Re, scrollbars: Be, onBottomReached: Ie, onTopReached: Pe, children: pe }) }) }) }); ScrollArea.classes = __default__$F; ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize"; ScrollAreaAutosize.classes = __default__$F; ScrollArea.Autosize = ScrollAreaAutosize; var __default__$E = { root: "m_87cf2631" }; const defaultProps$1o = { __staticSelector: "UnstyledButton" }, UnstyledButton = polymorphicFactory((fe, K) => { const pe = useProps("UnstyledButton", defaultProps$1o, fe), { className: me, component: ge = "button", __staticSelector: xe, unstyled: ye, classNames: ve, styles: _e, style: Ee, ...be } = pe, Ae = useStyles({ name: xe, props: pe, classes: __default__$E, className: me, style: Ee, classNames: ve, styles: _e, unstyled: ye }); return jsxRuntimeExports.jsx(Box, { ...Ae("root", { focusable: !0 }), component: ge, ref: K, type: ge === "button" ? "button" : void 0, ...be }) }); UnstyledButton.classes = __default__$E; UnstyledButton.displayName = "@mantine/core/UnstyledButton"; var __default__$D = { root: "m_515a97f8" }; const defaultProps$1n = {}, VisuallyHidden = factory((fe, K) => { const pe = useProps("VisuallyHidden", defaultProps$1n, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, ...Ee } = pe, be = useStyles({ name: "VisuallyHidden", classes: __default__$D, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve }); return jsxRuntimeExports.jsx(Box, { component: "span", ref: K, ...be("root"), ...Ee }) }); VisuallyHidden.classes = __default__$D; VisuallyHidden.displayName = "@mantine/core/VisuallyHidden"; var __default__$C = { root: "m_1b7284a3" }; const defaultProps$1m = {}, varsResolver$J = (fe, { radius: K, shadow: pe }) => ({ root: { "--paper-radius": K === void 0 ? void 0 : getRadius(K), "--paper-shadow": getShadow(pe) } }), Paper = polymorphicFactory((fe, K) => { const pe = useProps("Paper", defaultProps$1m, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, withBorder: _e, vars: Ee, radius: be, shadow: Ae, variant: Se, mod: Ce, ...we } = pe, Be = useStyles({ name: "Paper", props: pe, classes: __default__$C, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: Ee, varsResolver: varsResolver$J }); return jsxRuntimeExports.jsx(Box, { ref: K, mod: [{ "data-with-border": _e }, Ce], ...Be("root"), variant: Se, ...we }) }); Paper.classes = __default__$C; Paper.displayName = "@mantine/core/Paper"; function getFloatingPosition(fe, K) { if (fe === "rtl" && (K.includes("right") || K.includes("left"))) { const [pe, me] = K.split("-"), ge = pe === "right" ? "left" : "right"; return me === void 0 ? ge : `${ge}-${me}` } return K } function horizontalSide(fe, K, pe, me) { return fe === "center" || me === "center" ? { top: K } : fe === "end" ? { bottom: pe } : fe === "start" ? { top: pe } : {} } function verticalSide(fe, K, pe, me, ge) { return fe === "center" || me === "center" ? { left: K } : fe === "end" ? { [ge === "ltr" ? "right" : "left"]: pe } : fe === "start" ? { [ge === "ltr" ? "left" : "right"]: pe } : {} } const radiusByFloatingSide = { bottom: "borderTopLeftRadius", left: "borderTopRightRadius", right: "borderBottomLeftRadius", top: "borderBottomRightRadius" }; function getArrowPositionStyles({ position: fe, arrowSize: K, arrowOffset: pe, arrowRadius: me, arrowPosition: ge, arrowX: xe, arrowY: ye, dir: ve }) { const [_e, Ee = "center"] = fe.split("-"), be = { width: K, height: K, transform: "rotate(45deg)", position: "absolute", [radiusByFloatingSide[_e]]: me }, Ae = -K / 2; return _e === "left" ? { ...be, ...horizontalSide(Ee, ye, pe, ge), right: Ae, borderLeftColor: "transparent", borderBottomColor: "transparent", clipPath: "polygon(100% 0, 0 0, 100% 100%)" } : _e === "right" ? { ...be, ...horizontalSide(Ee, ye, pe, ge), left: Ae, borderRightColor: "transparent", borderTopColor: "transparent", clipPath: "polygon(0 100%, 0 0, 100% 100%)" } : _e === "top" ? { ...be, ...verticalSide(Ee, xe, pe, ge, ve), bottom: Ae, borderTopColor: "transparent", borderLeftColor: "transparent", clipPath: "polygon(0 100%, 100% 100%, 100% 0)" } : _e === "bottom" ? { ...be, ...verticalSide(Ee, xe, pe, ge, ve), top: Ae, borderBottomColor: "transparent", borderRightColor: "transparent", clipPath: "polygon(0 100%, 0 0, 100% 0)" } : {} } const FloatingArrow = reactExports.forwardRef(({ position: fe, arrowSize: K, arrowOffset: pe, arrowRadius: me, arrowPosition: ge, visible: xe, arrowX: ye, arrowY: ve, style: _e, ...Ee }, be) => { const { dir: Ae } = useDirection(); return xe ? jsxRuntimeExports.jsx("div", { ...Ee, ref: be, style: { ..._e, ...getArrowPositionStyles({ position: fe, arrowSize: K, arrowOffset: pe, arrowRadius: me, arrowPosition: ge, dir: Ae, arrowX: ye, arrowY: ve }) } }) : null }); FloatingArrow.displayName = "@mantine/core/FloatingArrow"; var __default__$B = { root: "m_9814e45f" }; const defaultProps$1l = { zIndex: getDefaultZIndex("modal") }, varsResolver$I = (fe, { gradient: K, color: pe, backgroundOpacity: me, blur: ge, radius: xe, zIndex: ye }) => ({ root: { "--overlay-bg": K || (pe !== void 0 || me !== void 0) && rgba$1(pe || "#000", me ?? .6) || void 0, "--overlay-filter": ge ? `blur(${rem(ge)})` : void 0, "--overlay-radius": xe === void 0 ? void 0 : getRadius(xe), "--overlay-z-index": ye?.toString() } }), Overlay = polymorphicFactory((fe, K) => { const pe = useProps("Overlay", defaultProps$1l, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, fixed: Ee, center: be, children: Ae, radius: Se, zIndex: Ce, gradient: we, blur: Be, color: De, backgroundOpacity: Re, mod: Ie, ...Pe } = pe, Ne = useStyles({ name: "Overlay", props: pe, classes: __default__$B, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$I }); return jsxRuntimeExports.jsx(Box, { ref: K, ...Ne("root"), mod: [{ center: be, fixed: Ee }, Ie], ...Pe, children: Ae }) }); Overlay.classes = __default__$B; Overlay.displayName = "@mantine/core/Overlay"; function createPortalNode(fe) { const K = document.createElement("div"); return K.setAttribute("data-portal", "true"), typeof fe.className == "string" && K.classList.add(...fe.className.split(" ").filter(Boolean)), typeof fe.style == "object" && Object.assign(K.style, fe.style), typeof fe.id == "string" && K.setAttribute("id", fe.id), K } function getTargetNode({ target: fe, reuseTargetNode: K, ...pe }) { if (fe) return typeof fe == "string" ? document.querySelector(fe) || createPortalNode(pe) : fe; if (K) { const me = document.querySelector("[data-mantine-shared-portal-node]"); if (me) return me; const ge = createPortalNode(pe); return ge.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(ge), ge } return createPortalNode(pe) } const defaultProps$1k = { reuseTargetNode: !0 }, Portal$1 = factory((fe, K) => { const { children: pe, target: me, reuseTargetNode: ge, ...xe } = useProps("Portal", defaultProps$1k, fe), [ye, ve] = reactExports.useState(!1), _e = reactExports.useRef(null); return useIsomorphicEffect$1(() => (ve(!0), _e.current = getTargetNode({ target: me, reuseTargetNode: ge, ...xe }), assignRef$1(K, _e.current), !me && !ge && _e.current && document.body.appendChild(_e.current), () => { !me && !ge && _e.current && document.body.removeChild(_e.current) }), [me]), !ye || !_e.current ? null : reactDomExports.createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: pe }), _e.current) }); Portal$1.displayName = "@mantine/core/Portal"; const OptionalPortal = factory(({ withinPortal: fe = !0, children: K, ...pe }, me) => useMantineEnv() === "test" || !fe ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: K }) : jsxRuntimeExports.jsx(Portal$1, { ref: me, ...pe, children: K })); OptionalPortal.displayName = "@mantine/core/OptionalPortal"; const popIn = fe => ({ in: { opacity: 1, transform: "scale(1)" }, out: { opacity: 0, transform: `scale(.9) translateY(${fe === "bottom" ? 10 : -10}px)` }, transitionProperty: "transform, opacity" }), transitions = { fade: { in: { opacity: 1 }, out: { opacity: 0 }, transitionProperty: "opacity" }, "fade-up": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(30px)" }, transitionProperty: "opacity, transform" }, "fade-down": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(-30px)" }, transitionProperty: "opacity, transform" }, "fade-left": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(30px)" }, transitionProperty: "opacity, transform" }, "fade-right": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(-30px)" }, transitionProperty: "opacity, transform" }, scale: { in: { opacity: 1, transform: "scale(1)" }, out: { opacity: 0, transform: "scale(0)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "scale-y": { in: { opacity: 1, transform: "scaleY(1)" }, out: { opacity: 0, transform: "scaleY(0)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "scale-x": { in: { opacity: 1, transform: "scaleX(1)" }, out: { opacity: 0, transform: "scaleX(0)" }, common: { transformOrigin: "left" }, transitionProperty: "transform, opacity" }, "skew-up": { in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" }, out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "skew-down": { in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" }, out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "rotate-left": { in: { opacity: 1, transform: "translateY(0) rotate(0deg)" }, out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "rotate-right": { in: { opacity: 1, transform: "translateY(0) rotate(0deg)" }, out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "slide-down": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(-100%)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "slide-up": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(100%)" }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "slide-left": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(100%)" }, common: { transformOrigin: "left" }, transitionProperty: "transform, opacity" }, "slide-right": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(-100%)" }, common: { transformOrigin: "right" }, transitionProperty: "transform, opacity" }, pop: { ...popIn("bottom"), common: { transformOrigin: "center center" } }, "pop-bottom-left": { ...popIn("bottom"), common: { transformOrigin: "bottom left" } }, "pop-bottom-right": { ...popIn("bottom"), common: { transformOrigin: "bottom right" } }, "pop-top-left": { ...popIn("top"), common: { transformOrigin: "top left" } }, "pop-top-right": { ...popIn("top"), common: { transformOrigin: "top right" } } }, transitionStatuses = { entering: "in", entered: "in", exiting: "out", exited: "out", "pre-exiting": "out", "pre-entering": "out" }; function getTransitionStyles({ transition: fe, state: K, duration: pe, timingFunction: me }) { const ge = { WebkitBackfaceVisibility: "hidden", willChange: "transform, opacity", transitionDuration: `${pe}ms`, transitionTimingFunction: me }; return typeof fe == "string" ? fe in transitions ? { transitionProperty: transitions[fe].transitionProperty, ...ge, ...transitions[fe].common, ...transitions[fe][transitionStatuses[K]] } : {} : { transitionProperty: fe.transitionProperty, ...ge, ...fe.common, ...fe[transitionStatuses[K]] } } function useTransition({ duration: fe, exitDuration: K, timingFunction: pe, mounted: me, onEnter: ge, onExit: xe, onEntered: ye, onExited: ve, enterDelay: _e, exitDelay: Ee }) { const be = useMantineTheme(), Ae = useReducedMotion(), Se = be.respectReducedMotion ? Ae : !1, [Ce, we] = reactExports.useState(Se ? 0 : fe), [Be, De] = reactExports.useState(me ? "entered" : "exited"), Re = reactExports.useRef(-1), Ie = reactExports.useRef(-1), Pe = reactExports.useRef(-1); function Ne() { window.clearTimeout(Re.current), window.clearTimeout(Ie.current), cancelAnimationFrame(Pe.current) } const ke = Ue => { Ne(); const He = Ue ? ge : xe, Ge = Ue ? ye : ve, ze = Se ? 0 : Ue ? fe : K; we(ze), ze === 0 ? (typeof He == "function" && He(), typeof Ge == "function" && Ge(), De(Ue ? "entered" : "exited")) : Pe.current = requestAnimationFrame(() => { ReactDOM$2.flushSync(() => { De(Ue ? "pre-entering" : "pre-exiting") }), Pe.current = requestAnimationFrame(() => { typeof He == "function" && He(), De(Ue ? "entering" : "exiting"), Re.current = window.setTimeout(() => { typeof Ge == "function" && Ge(), De(Ue ? "entered" : "exited") }, ze) }) }) }, Oe = Ue => { if (Ne(), typeof (Ue ? _e : Ee) != "number") { ke(Ue); return } Ie.current = window.setTimeout(() => { ke(Ue) }, Ue ? _e : Ee) }; return useDidUpdate(() => { Oe(me) }, [me]), reactExports.useEffect(() => () => { Ne() }, []), { transitionDuration: Ce, transitionStatus: Be, transitionTimingFunction: pe || "ease" } } function Transition$1({ keepMounted: fe, transition: K = "fade", duration: pe = 250, exitDuration: me = pe, mounted: ge, children: xe, timingFunction: ye = "ease", onExit: ve, onEntered: _e, onEnter: Ee, onExited: be, enterDelay: Ae, exitDelay: Se }) { const Ce = useMantineEnv(), { transitionDuration: we, transitionStatus: Be, transitionTimingFunction: De } = useTransition({ mounted: ge, exitDuration: me, duration: pe, timingFunction: ye, onExit: ve, onEntered: _e, onEnter: Ee, onExited: be, enterDelay: Ae, exitDelay: Se }); return we === 0 || Ce === "test" ? ge ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: xe({}) }) : fe ? xe({ display: "none" }) : null : Be === "exited" ? fe ? xe({ display: "none" }) : null : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: xe(getTransitionStyles({ transition: K, duration: we, state: Be, timingFunction: De })) }) } Transition$1.displayName = "@mantine/core/Transition"; const [PopoverContextProvider, usePopoverContext] = createSafeContext("Popover component was not found in the tree"); function FocusTrap({ children: fe, active: K = !0, refProp: pe = "ref", innerRef: me }) { const ge = useFocusTrap(K), xe = useMergedRef(ge, me); return isElement$1(fe) ? reactExports.cloneElement(fe, { [pe]: xe }) : fe } function FocusTrapInitialFocus(fe) { return jsxRuntimeExports.jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...fe }) } FocusTrap.displayName = "@mantine/core/FocusTrap"; FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus"; FocusTrap.InitialFocus = FocusTrapInitialFocus; var __default__$A = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" }; const defaultProps$1j = {}, PopoverDropdown = factory((fe, K) => { const pe = useProps("PopoverDropdown", defaultProps$1j, fe), { className: me, style: ge, vars: xe, children: ye, onKeyDownCapture: ve, variant: _e, classNames: Ee, styles: be, ...Ae } = pe, Se = usePopoverContext(), Ce = useFocusReturn({ opened: Se.opened, shouldReturnFocus: Se.returnFocus }), we = Se.withRoles ? { "aria-labelledby": Se.getTargetId(), id: Se.getDropdownId(), role: "dialog", tabIndex: -1 } : {}, Be = useMergedRef(K, Se.floating); return Se.disabled ? null : jsxRuntimeExports.jsx(OptionalPortal, { ...Se.portalProps, withinPortal: Se.withinPortal, children: jsxRuntimeExports.jsx(Transition$1, { mounted: Se.opened, ...Se.transitionProps, transition: Se.transitionProps?.transition || "fade", duration: Se.transitionProps?.duration ?? 150, keepMounted: Se.keepMounted, exitDuration: typeof Se.transitionProps?.exitDuration == "number" ? Se.transitionProps.exitDuration : Se.transitionProps?.duration, children: De => jsxRuntimeExports.jsx(FocusTrap, { active: Se.trapFocus && Se.opened, innerRef: Be, children: jsxRuntimeExports.jsxs(Box, { ...we, ...Ae, variant: _e, onKeyDownCapture: closeOnEscape(() => { Se.onClose?.(), Se.onDismiss?.() }, { active: Se.closeOnEscape, onTrigger: Ce, onKeyDown: ve }), "data-position": Se.placement, "data-fixed": Se.floatingStrategy === "fixed" || void 0, ...Se.getStyles("dropdown", { className: me, props: pe, classNames: Ee, styles: be, style: [{ ...De, zIndex: Se.zIndex, top: Se.y ?? 0, left: Se.x ?? 0, width: Se.width === "target" ? void 0 : rem(Se.width), ...Se.referenceHidden ? { display: "none" } : null }, Se.resolvedStyles.dropdown, be?.dropdown, ge] }), children: [ye, jsxRuntimeExports.jsx(FloatingArrow, { ref: Se.arrowRef, arrowX: Se.arrowX, arrowY: Se.arrowY, visible: Se.withArrow, position: Se.placement, arrowSize: Se.arrowSize, arrowRadius: Se.arrowRadius, arrowOffset: Se.arrowOffset, arrowPosition: Se.arrowPosition, ...Se.getStyles("arrow", { props: pe, classNames: Ee, styles: be }) })] }) }) }) }) }); PopoverDropdown.classes = __default__$A; PopoverDropdown.displayName = "@mantine/core/PopoverDropdown"; const defaultProps$1i = { refProp: "ref", popupType: "dialog" }, PopoverTarget = factory((fe, K) => { const { children: pe, refProp: me, popupType: ge, ...xe } = useProps("PopoverTarget", defaultProps$1i, fe); if (!isElement$1(pe)) throw new Error("Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"); const ye = xe, ve = usePopoverContext(), _e = useMergedRef(ve.reference, getRefProp(pe), K), Ee = ve.withRoles ? { "aria-haspopup": ge, "aria-expanded": ve.opened, "aria-controls": ve.getDropdownId(), id: ve.getTargetId() } : {}; return reactExports.cloneElement(pe, { ...ye, ...Ee, ...ve.targetProps, className: clsx(ve.targetProps.className, ye.className, pe.props.className), [me]: _e, ...ve.controlled ? null : { onClick: ve.onToggle } }) }); PopoverTarget.displayName = "@mantine/core/PopoverTarget"; function useFloatingAutoUpdate({ opened: fe, floating: K, position: pe, positionDependencies: me }) { const [ge, xe] = reactExports.useState(0); reactExports.useEffect(() => { if (K.refs.reference.current && K.refs.floating.current && fe) return autoUpdate(K.refs.reference.current, K.refs.floating.current, K.update) }, [K.refs.reference.current, K.refs.floating.current, fe, ge, pe]), useDidUpdate(() => { K.update() }, me), useDidUpdate(() => { xe(ye => ye + 1) }, [fe]) } function getDefaultMiddlewares$1(fe) { if (fe === void 0) return { shift: !0, flip: !0 }; const K = { ...fe }; return fe.shift === void 0 && (K.shift = !0), fe.flip === void 0 && (K.flip = !0), K } function getPopoverMiddlewares(fe, K) { const pe = getDefaultMiddlewares$1(fe.middlewares), me = [offset(fe.offset), hide()]; return pe.shift && me.push(shift(typeof pe.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...pe.shift })), pe.flip && me.push(typeof pe.flip == "boolean" ? flip() : flip(pe.flip)), pe.inline && me.push(typeof pe.inline == "boolean" ? inline() : inline(pe.inline)), me.push(arrow({ element: fe.arrowRef, padding: fe.arrowOffset })), (pe.size || fe.width === "target") && me.push(size({ ...typeof pe.size == "boolean" ? {} : pe.size, apply({ rects: ge, availableWidth: xe, availableHeight: ye, ...ve }) { const Ee = K().refs.floating.current?.style ?? {}; pe.size && (typeof pe.size == "object" && pe.size.apply ? pe.size.apply({ rects: ge, availableWidth: xe, availableHeight: ye, ...ve }) : Object.assign(Ee, { maxWidth: `${xe}px`, maxHeight: `${ye}px` })), fe.width === "target" && Object.assign(Ee, { width: `${ge.reference.width}px` }) } })), me } function usePopover(fe) { const [K, pe] = useUncontrolled({ value: fe.opened, defaultValue: fe.defaultOpened, finalValue: !1, onChange: fe.onChange }), me = reactExports.useRef(K), ge = () => { K && !fe.disabled && pe(!1) }, xe = () => !fe.disabled && pe(!K), ye = useFloating({ strategy: fe.strategy, placement: fe.position, middleware: getPopoverMiddlewares(fe, () => ye) }); return useFloatingAutoUpdate({ opened: K, position: fe.position, positionDependencies: fe.positionDependencies || [], floating: ye }), useDidUpdate(() => { fe.onPositionChange?.(ye.placement) }, [ye.placement]), useDidUpdate(() => { K !== me.current && (K ? fe.onOpen?.() : fe.onClose?.()), me.current = K }, [K, fe.onClose, fe.onOpen]), { floating: ye, controlled: typeof fe.opened == "boolean", opened: K, onClose: ge, onToggle: xe } } const defaultProps$1h = { position: "bottom", offset: 8, positionDependencies: [], transitionProps: { transition: "fade", duration: 150 }, middlewares: { flip: !0, shift: !0, inline: !1 }, arrowSize: 7, arrowOffset: 5, arrowRadius: 0, arrowPosition: "side", closeOnClickOutside: !0, withinPortal: !0, closeOnEscape: !0, trapFocus: !1, withRoles: !0, returnFocus: !1, withOverlay: !1, hideDetached: !0, clickOutsideEvents: ["mousedown", "touchstart"], zIndex: getDefaultZIndex("popover"), __staticSelector: "Popover", width: "max-content" }, varsResolver$H = (fe, { radius: K, shadow: pe }) => ({ dropdown: { "--popover-radius": K === void 0 ? void 0 : getRadius(K), "--popover-shadow": getShadow(pe) } }); function Popover(fe) { const K = useProps("Popover", defaultProps$1h, fe), { children: pe, position: me, offset: ge, onPositionChange: xe, positionDependencies: ye, opened: ve, transitionProps: _e, onExitTransitionEnd: Ee, onEnterTransitionEnd: be, width: Ae, middlewares: Se, withArrow: Ce, arrowSize: we, arrowOffset: Be, arrowRadius: De, arrowPosition: Re, unstyled: Ie, classNames: Pe, styles: Ne, closeOnClickOutside: ke, withinPortal: Oe, portalProps: Ue, closeOnEscape: He, clickOutsideEvents: Ge, trapFocus: ze, onClose: We, onDismiss: Xe, onOpen: Ye, onChange: Ze, zIndex: ot, radius: qe, shadow: Qe, id: st, defaultOpened: Nt, __staticSelector: Je, withRoles: jt, disabled: Xt, returnFocus: ct, variant: nn, keepMounted: $t, vars: an, floatingStrategy: gn, withOverlay: Mn, overlayProps: Xn, hideDetached: Ln, ...Gn } = K, wn = useStyles({ name: Je, props: K, classes: __default__$A, classNames: Pe, styles: Ne, unstyled: Ie, rootSelector: "dropdown", vars: an, varsResolver: varsResolver$H }), { resolvedStyles: Bn } = useResolvedStylesApi({ classNames: Pe, styles: Ne, props: K }), Gt = reactExports.useRef(null), [nr, Kn] = reactExports.useState(null), [vn, yn] = reactExports.useState(null), { dir: Hn } = useDirection(), kn = useMantineEnv(), Ht = useId$1(st), Dt = usePopover({ middlewares: Se, width: Ae, position: getFloatingPosition(Hn, me), offset: typeof ge == "number" ? ge + (Ce ? we / 2 : 0) : ge, arrowRef: Gt, arrowOffset: Be, onPositionChange: xe, positionDependencies: ye, opened: ve, defaultOpened: Nt, onChange: Ze, onOpen: Ye, onClose: We, onDismiss: Xe, strategy: gn, disabled: Xt }); useClickOutside(() => { ke && (Dt.onClose(), Xe?.()) }, Ge, [nr, vn]); const fn = reactExports.useCallback(un => { Kn(un), Dt.floating.refs.setReference(un) }, [Dt.floating.refs.setReference]), en = reactExports.useCallback(un => { yn(un), Dt.floating.refs.setFloating(un) }, [Dt.floating.refs.setFloating]), cn = reactExports.useCallback(() => { _e?.onExited?.(), Ee?.() }, [_e?.onExited, Ee]), Wt = reactExports.useCallback(() => { _e?.onEntered?.(), be?.() }, [_e?.onEntered, be]); return jsxRuntimeExports.jsxs(PopoverContextProvider, { value: { returnFocus: ct, disabled: Xt, controlled: Dt.controlled, reference: fn, floating: en, x: Dt.floating.x, y: Dt.floating.y, arrowX: Dt.floating?.middlewareData?.arrow?.x, arrowY: Dt.floating?.middlewareData?.arrow?.y, opened: Dt.opened, arrowRef: Gt, transitionProps: { ..._e, onExited: cn, onEntered: Wt }, width: Ae, withArrow: Ce, arrowSize: we, arrowOffset: Be, arrowRadius: De, arrowPosition: Re, placement: Dt.floating.placement, trapFocus: ze, withinPortal: Oe, portalProps: Ue, zIndex: ot, radius: qe, shadow: Qe, closeOnEscape: He, onDismiss: Xe, onClose: Dt.onClose, onToggle: Dt.onToggle, getTargetId: () => `${Ht}-target`, getDropdownId: () => `${Ht}-dropdown`, withRoles: jt, targetProps: Gn, __staticSelector: Je, classNames: Pe, styles: Ne, unstyled: Ie, variant: nn, keepMounted: $t, getStyles: wn, resolvedStyles: Bn, floatingStrategy: gn, referenceHidden: Ln && kn !== "test" ? Dt.floating.middlewareData.hide?.referenceHidden : !1 }, children: [pe, Mn && jsxRuntimeExports.jsx(Transition$1, { transition: "fade", mounted: Dt.opened, duration: _e?.duration || 250, exitDuration: _e?.exitDuration || 250, children: un => jsxRuntimeExports.jsx(OptionalPortal, { withinPortal: Oe, children: jsxRuntimeExports.jsx(Overlay, { ...Xn, ...wn("overlay", { className: Xn?.className, style: [un, Xn?.style] }) }) }) })] }) } Popover.Target = PopoverTarget; Popover.Dropdown = PopoverDropdown; Popover.displayName = "@mantine/core/Popover"; Popover.extend = fe => fe; var __default__$z = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" }; const Bars = reactExports.forwardRef(({ className: fe, ...K }, pe) => jsxRuntimeExports.jsxs(Box, { component: "span", className: clsx(__default__$z.barsLoader, fe), ...K, ref: pe, children: [jsxRuntimeExports.jsx("span", { className: __default__$z.bar }), jsxRuntimeExports.jsx("span", { className: __default__$z.bar }), jsxRuntimeExports.jsx("span", { className: __default__$z.bar })] })); Bars.displayName = "@mantine/core/Bars"; const Dots = reactExports.forwardRef(({ className: fe, ...K }, pe) => jsxRuntimeExports.jsxs(Box, { component: "span", className: clsx(__default__$z.dotsLoader, fe), ...K, ref: pe, children: [jsxRuntimeExports.jsx("span", { className: __default__$z.dot }), jsxRuntimeExports.jsx("span", { className: __default__$z.dot }), jsxRuntimeExports.jsx("span", { className: __default__$z.dot })] })); Dots.displayName = "@mantine/core/Dots"; const Oval = reactExports.forwardRef(({ className: fe, ...K }, pe) => jsxRuntimeExports.jsx(Box, { component: "span", className: clsx(__default__$z.ovalLoader, fe), ...K, ref: pe })); Oval.displayName = "@mantine/core/Oval"; const defaultLoaders = { bars: Bars, oval: Oval, dots: Dots }, defaultProps$1g = { loaders: defaultLoaders, type: "oval" }, varsResolver$G = (fe, { size: K, color: pe }) => ({ root: { "--loader-size": getSize(K, "loader-size"), "--loader-color": pe ? getThemeColor(pe, fe) : void 0 } }), Loader$1 = factory((fe, K) => { const pe = useProps("Loader", defaultProps$1g, fe), { size: me, color: ge, type: xe, vars: ye, className: ve, style: _e, classNames: Ee, styles: be, unstyled: Ae, loaders: Se, variant: Ce, children: we, ...Be } = pe, De = useStyles({ name: "Loader", props: pe, classes: __default__$z, className: ve, style: _e, classNames: Ee, styles: be, unstyled: Ae, vars: ye, varsResolver: varsResolver$G }); return we ? jsxRuntimeExports.jsx(Box, { ...De("root"), ref: K, ...Be, children: we }) : jsxRuntimeExports.jsx(Box, { ...De("root"), ref: K, component: Se[xe], variant: Ce, size: me, ...Be }) }); Loader$1.defaultLoaders = defaultLoaders; Loader$1.classes = __default__$z; Loader$1.displayName = "@mantine/core/Loader"; var __default__$y = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" }; const defaultProps$1f = { orientation: "horizontal" }, varsResolver$F = (fe, { borderWidth: K }) => ({ group: { "--ai-border-width": rem(K) } }), ActionIconGroup = factory((fe, K) => { const pe = useProps("ActionIconGroup", defaultProps$1f, fe), { className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, orientation: _e, vars: Ee, borderWidth: be, variant: Ae, mod: Se, ...Ce } = useProps("ActionIconGroup", defaultProps$1f, fe), we = useStyles({ name: "ActionIconGroup", props: pe, classes: __default__$y, className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: Ee, varsResolver: varsResolver$F, rootSelector: "group" }); return jsxRuntimeExports.jsx(Box, { ...we("group"), ref: K, variant: Ae, mod: [{ "data-orientation": _e }, Se], role: "group", ...Ce }) }); ActionIconGroup.classes = __default__$y; ActionIconGroup.displayName = "@mantine/core/ActionIconGroup"; const defaultProps$1e = {}, varsResolver$E = (fe, { radius: K, color: pe, gradient: me, variant: ge, autoContrast: xe, size: ye }) => { const ve = fe.variantColorResolver({ color: pe || fe.primaryColor, theme: fe, gradient: me, variant: ge || "filled", autoContrast: xe }); return { groupSection: { "--section-height": getSize(ye, "section-height"), "--section-padding-x": getSize(ye, "section-padding-x"), "--section-fz": getFontSize(ye), "--section-radius": K === void 0 ? void 0 : getRadius(K), "--section-bg": pe || ge ? ve.background : void 0, "--section-color": ve.color, "--section-bd": pe || ge ? ve.border : void 0 } } }, ActionIconGroupSection = factory((fe, K) => { const pe = useProps("ActionIconGroupSection", defaultProps$1e, fe), { className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: _e, variant: Ee, gradient: be, radius: Ae, autoContrast: Se, ...Ce } = useProps("ActionIconGroupSection", defaultProps$1e, fe), we = useStyles({ name: "ActionIconGroupSection", props: pe, classes: __default__$y, className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$E, rootSelector: "groupSection" }); return jsxRuntimeExports.jsx(Box, { ...we("groupSection"), ref: K, variant: Ee, ...Ce }) }); ActionIconGroupSection.classes = __default__$y; ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection"; const defaultProps$1d = {}, varsResolver$D = (fe, { size: K, radius: pe, variant: me, gradient: ge, color: xe, autoContrast: ye }) => { const ve = fe.variantColorResolver({ color: xe || fe.primaryColor, theme: fe, gradient: ge, variant: me || "filled", autoContrast: ye }); return { root: { "--ai-size": getSize(K, "ai-size"), "--ai-radius": pe === void 0 ? void 0 : getRadius(pe), "--ai-bg": xe || me ? ve.background : void 0, "--ai-hover": xe || me ? ve.hover : void 0, "--ai-hover-color": xe || me ? ve.hoverColor : void 0, "--ai-color": ve.color, "--ai-bd": xe || me ? ve.border : void 0 } } }, ActionIcon = polymorphicFactory((fe, K) => { const pe = useProps("ActionIcon", defaultProps$1d, fe), { className: me, unstyled: ge, variant: xe, classNames: ye, styles: ve, style: _e, loading: Ee, loaderProps: be, size: Ae, color: Se, radius: Ce, __staticSelector: we, gradient: Be, vars: De, children: Re, disabled: Ie, "data-disabled": Pe, autoContrast: Ne, mod: ke, ...Oe } = pe, Ue = useStyles({ name: ["ActionIcon", we], props: pe, className: me, style: _e, classes: __default__$y, classNames: ye, styles: ve, unstyled: ge, vars: De, varsResolver: varsResolver$D }); return jsxRuntimeExports.jsxs(UnstyledButton, { ...Ue("root", { active: !Ie && !Ee && !Pe }), ...Oe, unstyled: ge, variant: xe, size: Ae, disabled: Ie || Ee, ref: K, mod: [{ loading: Ee, disabled: Ie || Pe }, ke], children: [jsxRuntimeExports.jsx(Transition$1, { mounted: !!Ee, transition: "slide-down", duration: 150, children: He => jsxRuntimeExports.jsx(Box, { component: "span", ...Ue("loader", { style: He }), "aria-hidden": !0, children: jsxRuntimeExports.jsx(Loader$1, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...be }) }) }), jsxRuntimeExports.jsx(Box, { component: "span", mod: { loading: Ee }, ...Ue("icon"), children: Re })] }) }); ActionIcon.classes = __default__$y; ActionIcon.displayName = "@mantine/core/ActionIcon"; ActionIcon.Group = ActionIconGroup; ActionIcon.GroupSection = ActionIconGroupSection; const CloseIcon = reactExports.forwardRef(({ size: fe = "var(--cb-icon-size, 70%)", style: K, ...pe }, me) => jsxRuntimeExports.jsx("svg", { viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { ...K, width: fe, height: fe }, ref: me, ...pe, children: jsxRuntimeExports.jsx("path", { d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }) })); CloseIcon.displayName = "@mantine/core/CloseIcon"; var __default__$x = { root: "m_86a44da5", "root--subtle": "m_220c80f2" }; const defaultProps$1c = { variant: "subtle" }, varsResolver$C = (fe, { size: K, radius: pe, iconSize: me }) => ({ root: { "--cb-size": getSize(K, "cb-size"), "--cb-radius": pe === void 0 ? void 0 : getRadius(pe), "--cb-icon-size": rem(me) } }), CloseButton = polymorphicFactory((fe, K) => { const pe = useProps("CloseButton", defaultProps$1c, fe), { iconSize: me, children: ge, vars: xe, radius: ye, className: ve, classNames: _e, style: Ee, styles: be, unstyled: Ae, "data-disabled": Se, disabled: Ce, variant: we, icon: Be, mod: De, __staticSelector: Re, ...Ie } = pe, Pe = useStyles({ name: Re || "CloseButton", props: pe, className: ve, style: Ee, classes: __default__$x, classNames: _e, styles: be, unstyled: Ae, vars: xe, varsResolver: varsResolver$C }); return jsxRuntimeExports.jsxs(UnstyledButton, { ref: K, ...Ie, unstyled: Ae, variant: we, disabled: Ce, mod: [{ disabled: Ce || Se }, De], ...Pe("root", { variant: we, active: !Ce && !Se }), children: [Be || jsxRuntimeExports.jsx(CloseIcon, {}), ge] }) }); CloseButton.classes = __default__$x; CloseButton.displayName = "@mantine/core/CloseButton"; function filterFalsyChildren(fe) { return reactExports.Children.toArray(fe).filter(Boolean) } var __default__$w = { root: "m_4081bf90" }; const defaultProps$1b = { preventGrowOverflow: !0, gap: "md", align: "center", justify: "flex-start", wrap: "wrap" }, varsResolver$B = (fe, { grow: K, preventGrowOverflow: pe, gap: me, align: ge, justify: xe, wrap: ye }, { childWidth: ve }) => ({ root: { "--group-child-width": K && pe ? ve : void 0, "--group-gap": getSpacing(me), "--group-align": ge, "--group-justify": xe, "--group-wrap": ye } }), Group$1 = factory((fe, K) => { const pe = useProps("Group", defaultProps$1b, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, children: _e, gap: Ee, align: be, justify: Ae, wrap: Se, grow: Ce, preventGrowOverflow: we, vars: Be, variant: De, __size: Re, mod: Ie, ...Pe } = pe, Ne = filterFalsyChildren(_e), ke = Ne.length, Oe = getSpacing(Ee ?? "md"), He = { childWidth: `calc(${100 / ke}% - (${Oe} - ${Oe} / ${ke}))` }, Ge = useStyles({ name: "Group", props: pe, stylesCtx: He, className: ge, style: xe, classes: __default__$w, classNames: me, styles: ye, unstyled: ve, vars: Be, varsResolver: varsResolver$B }); return jsxRuntimeExports.jsx(Box, { ...Ge("root"), ref: K, variant: De, mod: [{ grow: Ce }, Ie], size: Re, ...Pe, children: Ne }) }); Group$1.classes = __default__$w; Group$1.displayName = "@mantine/core/Group"; const [ModalBaseProvider, useModalBaseContext] = createSafeContext("ModalBase component was not found in tree"); function useLockScroll({ opened: fe, transitionDuration: K }) { const [pe, me] = reactExports.useState(fe), ge = reactExports.useRef(-1), ye = useReducedMotion() ? 0 : K; return reactExports.useEffect(() => (fe ? (me(!0), window.clearTimeout(ge.current)) : ye === 0 ? me(!1) : ge.current = window.setTimeout(() => me(!1), ye), () => window.clearTimeout(ge.current)), [fe, ye]), pe } function useModal({ id: fe, transitionProps: K, opened: pe, trapFocus: me, closeOnEscape: ge, onClose: xe, returnFocus: ye }) { const ve = useId$1(fe), [_e, Ee] = reactExports.useState(!1), [be, Ae] = reactExports.useState(!1), Se = typeof K?.duration == "number" ? K?.duration : 200, Ce = useLockScroll({ opened: pe, transitionDuration: Se }); return useWindowEvent("keydown", we => { we.key === "Escape" && ge && !we.isComposing && pe && we.target?.getAttribute("data-mantine-stop-propagation") !== "true" && xe() }, { capture: !0 }), useFocusReturn({ opened: pe, shouldReturnFocus: me && ye }), { _id: ve, titleMounted: _e, bodyMounted: be, shouldLockScroll: Ce, setTitleMounted: Ee, setBodyMounted: Ae } } const ModalBase = reactExports.forwardRef(({ keepMounted: fe, opened: K, onClose: pe, id: me, transitionProps: ge, onExitTransitionEnd: xe, onEnterTransitionEnd: ye, trapFocus: ve, closeOnEscape: _e, returnFocus: Ee, closeOnClickOutside: be, withinPortal: Ae, portalProps: Se, lockScroll: Ce, children: we, zIndex: Be, shadow: De, padding: Re, __vars: Ie, unstyled: Pe, removeScrollProps: Ne, ...ke }, Oe) => { const { _id: Ue, titleMounted: He, bodyMounted: Ge, shouldLockScroll: ze, setTitleMounted: We, setBodyMounted: Xe } = useModal({ id: me, transitionProps: ge, opened: K, trapFocus: ve, closeOnEscape: _e, onClose: pe, returnFocus: Ee }), { key: Ye, ...Ze } = Ne || {}; return jsxRuntimeExports.jsx(OptionalPortal, { ...Se, withinPortal: Ae, children: jsxRuntimeExports.jsx(ModalBaseProvider, { value: { opened: K, onClose: pe, closeOnClickOutside: be, onExitTransitionEnd: xe, onEnterTransitionEnd: ye, transitionProps: { ...ge, keepMounted: fe }, getTitleId: () => `${Ue}-title`, getBodyId: () => `${Ue}-body`, titleMounted: He, bodyMounted: Ge, setTitleMounted: We, setBodyMounted: Xe, trapFocus: ve, closeOnEscape: _e, zIndex: Be, unstyled: Pe }, children: jsxRuntimeExports.jsx(ReactRemoveScroll, { enabled: ze && Ce, ...Ze, children: jsxRuntimeExports.jsx(Box, { ref: Oe, ...ke, __vars: { ...Ie, "--mb-z-index": (Be || getDefaultZIndex("modal")).toString(), "--mb-shadow": getShadow(De), "--mb-padding": getSpacing(Re) }, children: we }) }, Ye) }) }) }); ModalBase.displayName = "@mantine/core/ModalBase"; function useModalBodyId() { const fe = useModalBaseContext(); return reactExports.useEffect(() => (fe.setBodyMounted(!0), () => fe.setBodyMounted(!1)), []), fe.getBodyId() } var __default__$v = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" }; const ModalBaseBody = reactExports.forwardRef(({ className: fe, ...K }, pe) => { const me = useModalBodyId(), ge = useModalBaseContext(); return jsxRuntimeExports.jsx(Box, { ref: pe, ...K, id: me, className: clsx({ [__default__$v.body]: !ge.unstyled }, fe) }) }); ModalBaseBody.displayName = "@mantine/core/ModalBaseBody"; const ModalBaseCloseButton = reactExports.forwardRef(({ className: fe, onClick: K, ...pe }, me) => { const ge = useModalBaseContext(); return jsxRuntimeExports.jsx(CloseButton, { ref: me, ...pe, onClick: xe => { ge.onClose(), K?.(xe) }, className: clsx({ [__default__$v.close]: !ge.unstyled }, fe), unstyled: ge.unstyled }) }); ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton"; const ModalBaseContent = reactExports.forwardRef(({ transitionProps: fe, className: K, innerProps: pe, onKeyDown: me, style: ge, ...xe }, ye) => { const ve = useModalBaseContext(); return jsxRuntimeExports.jsx(Transition$1, { mounted: ve.opened, transition: "pop", ...ve.transitionProps, onExited: () => { ve.onExitTransitionEnd?.(), ve.transitionProps?.onExited?.() }, onEntered: () => { ve.onEnterTransitionEnd?.(), ve.transitionProps?.onEntered?.() }, ...fe, children: _e => jsxRuntimeExports.jsx("div", { ...pe, className: clsx({ [__default__$v.inner]: !ve.unstyled }, pe.className), children: jsxRuntimeExports.jsx(FocusTrap, { active: ve.opened && ve.trapFocus, innerRef: ye, children: jsxRuntimeExports.jsx(Paper, { ...xe, component: "section", role: "dialog", tabIndex: -1, "aria-modal": !0, "aria-describedby": ve.bodyMounted ? ve.getBodyId() : void 0, "aria-labelledby": ve.titleMounted ? ve.getTitleId() : void 0, style: [ge, _e], className: clsx({ [__default__$v.content]: !ve.unstyled }, K), unstyled: ve.unstyled, children: xe.children }) }) }) }) }); ModalBaseContent.displayName = "@mantine/core/ModalBaseContent"; const ModalBaseHeader = reactExports.forwardRef(({ className: fe, ...K }, pe) => { const me = useModalBaseContext(); return jsxRuntimeExports.jsx(Box, { component: "header", ref: pe, className: clsx({ [__default__$v.header]: !me.unstyled }, fe), ...K }) }); ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader"; const DEFAULT_TRANSITION = { duration: 200, timingFunction: "ease", transition: "fade" }; function useModalTransition(fe) { const K = useModalBaseContext(); return { ...DEFAULT_TRANSITION, ...K.transitionProps, ...fe } } const ModalBaseOverlay = reactExports.forwardRef(({ onClick: fe, transitionProps: K, style: pe, visible: me, ...ge }, xe) => { const ye = useModalBaseContext(), ve = useModalTransition(K); return jsxRuntimeExports.jsx(Transition$1, { mounted: me !== void 0 ? me : ye.opened, ...ve, transition: "fade", children: _e => jsxRuntimeExports.jsx(Overlay, { ref: xe, fixed: !0, style: [pe, _e], zIndex: ye.zIndex, unstyled: ye.unstyled, onClick: Ee => { fe?.(Ee), ye.closeOnClickOutside && ye.onClose() }, ...ge }) }) }); ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay"; function useModalTitle() { const fe = useModalBaseContext(); return reactExports.useEffect(() => (fe.setTitleMounted(!0), () => fe.setTitleMounted(!1)), []), fe.getTitleId() } const ModalBaseTitle = reactExports.forwardRef(({ className: fe, ...K }, pe) => { const me = useModalTitle(), ge = useModalBaseContext(); return jsxRuntimeExports.jsx(Box, { component: "h2", ref: pe, className: clsx({ [__default__$v.title]: !ge.unstyled }, fe), ...K, id: me }) }); ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle"; function NativeScrollArea({ children: fe }) { return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: fe }) } const [InputContext, useInputContext] = createOptionalContext({ size: "sm" }), defaultProps$1a = {}, InputClearButton = factory((fe, K) => { const pe = useProps("InputClearButton", defaultProps$1a, fe), { size: me, variant: ge, vars: xe, classNames: ye, styles: ve, ..._e } = pe, Ee = useInputContext(), { resolvedClassNames: be, resolvedStyles: Ae } = useResolvedStylesApi({ classNames: ye, styles: ve, props: pe }); return jsxRuntimeExports.jsx(CloseButton, { variant: ge || "transparent", ref: K, size: me || Ee?.size || "sm", classNames: be, styles: Ae, __staticSelector: "InputClearButton", ..._e }) }); InputClearButton.displayName = "@mantine/core/InputClearButton"; const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({ offsetBottom: !1, offsetTop: !1, describedBy: void 0, getStyles: null, inputId: void 0, labelId: void 0 }); var __default__$u = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" }; const defaultProps$19 = {}, varsResolver$A = (fe, { size: K }) => ({ description: { "--input-description-size": K === void 0 ? void 0 : `calc(${getFontSize(K)} - ${rem(2)})` } }), InputDescription = factory((fe, K) => { const pe = useProps("InputDescription", defaultProps$19, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, size: Ee, __staticSelector: be, __inheritStyles: Ae = !0, variant: Se, ...Ce } = useProps("InputDescription", defaultProps$19, pe), we = useInputWrapperContext(), Be = useStyles({ name: ["InputWrapper", be], props: pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, rootSelector: "description", vars: _e, varsResolver: varsResolver$A }), De = Ae && we?.getStyles || Be; return jsxRuntimeExports.jsx(Box, { component: "p", ref: K, variant: Se, size: Ee, ...De("description", we?.getStyles ? { className: ge, style: xe } : void 0), ...Ce }) }); InputDescription.classes = __default__$u; InputDescription.displayName = "@mantine/core/InputDescription"; const defaultProps$18 = {}, varsResolver$z = (fe, { size: K }) => ({ error: { "--input-error-size": K === void 0 ? void 0 : `calc(${getFontSize(K)} - ${rem(2)})` } }), InputError = factory((fe, K) => { const pe = useProps("InputError", defaultProps$18, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, size: Ee, __staticSelector: be, __inheritStyles: Ae = !0, variant: Se, ...Ce } = pe, we = useStyles({ name: ["InputWrapper", be], props: pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, rootSelector: "error", vars: _e, varsResolver: varsResolver$z }), Be = useInputWrapperContext(), De = Ae && Be?.getStyles || we; return jsxRuntimeExports.jsx(Box, { component: "p", ref: K, variant: Se, size: Ee, ...De("error", Be?.getStyles ? { className: ge, style: xe } : void 0), ...Ce }) }); InputError.classes = __default__$u; InputError.displayName = "@mantine/core/InputError"; const defaultProps$17 = { labelElement: "label" }, varsResolver$y = (fe, { size: K }) => ({ label: { "--input-label-size": getFontSize(K), "--input-asterisk-color": void 0 } }), InputLabel = factory((fe, K) => { const pe = useProps("InputLabel", defaultProps$17, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, labelElement: Ee, size: be, required: Ae, htmlFor: Se, onMouseDown: Ce, children: we, __staticSelector: Be, variant: De, mod: Re, ...Ie } = useProps("InputLabel", defaultProps$17, pe), Pe = useStyles({ name: ["InputWrapper", Be], props: pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, rootSelector: "label", vars: _e, varsResolver: varsResolver$y }), Ne = useInputWrapperContext(), ke = Ne?.getStyles || Pe; return jsxRuntimeExports.jsxs(Box, { ...ke("label", Ne?.getStyles ? { className: ge, style: xe } : void 0), component: Ee, variant: De, size: be, ref: K, htmlFor: Ee === "label" ? Se : void 0, mod: [{ required: Ae }, Re], onMouseDown: Oe => { Ce?.(Oe), !Oe.defaultPrevented && Oe.detail > 1 && Oe.preventDefault() }, ...Ie, children: [we, Ae && jsxRuntimeExports.jsx("span", { ...ke("required"), "aria-hidden": !0, children: " *" })] }) }); InputLabel.classes = __default__$u; InputLabel.displayName = "@mantine/core/InputLabel"; const defaultProps$16 = {}, InputPlaceholder = factory((fe, K) => { const pe = useProps("InputPlaceholder", defaultProps$16, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, __staticSelector: Ee, variant: be, error: Ae, mod: Se, ...Ce } = useProps("InputPlaceholder", defaultProps$16, pe), we = useStyles({ name: ["InputPlaceholder", Ee], props: pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, rootSelector: "placeholder" }); return jsxRuntimeExports.jsx(Box, { ...we("placeholder"), mod: [{ error: !!Ae }, Se], component: "span", variant: be, ref: K, ...Ce }) }); InputPlaceholder.classes = __default__$u; InputPlaceholder.displayName = "@mantine/core/InputPlaceholder"; function getInputOffsets(fe, { hasDescription: K, hasError: pe }) { const me = fe.findIndex(_e => _e === "input"), ge = fe.slice(0, me), xe = fe.slice(me + 1), ye = K && ge.includes("description") || pe && ge.includes("error"); return { offsetBottom: K && xe.includes("description") || pe && xe.includes("error"), offsetTop: ye } } const defaultProps$15 = { labelElement: "label", inputContainer: fe => fe, inputWrapperOrder: ["label", "description", "input", "error"] }, varsResolver$x = (fe, { size: K }) => ({ label: { "--input-label-size": getFontSize(K), "--input-asterisk-color": void 0 }, error: { "--input-error-size": K === void 0 ? void 0 : `calc(${getFontSize(K)} - ${rem(2)})` }, description: { "--input-description-size": K === void 0 ? void 0 : `calc(${getFontSize(K)} - ${rem(2)})` } }), InputWrapper = factory((fe, K) => { const pe = useProps("InputWrapper", defaultProps$15, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, size: Ee, variant: be, __staticSelector: Ae, inputContainer: Se, inputWrapperOrder: Ce, label: we, error: Be, description: De, labelProps: Re, descriptionProps: Ie, errorProps: Pe, labelElement: Ne, children: ke, withAsterisk: Oe, id: Ue, required: He, __stylesApiProps: Ge, mod: ze, ...We } = pe, Xe = useStyles({ name: ["InputWrapper", Ae], props: Ge || pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$x }), Ye = { size: Ee, variant: be, __staticSelector: Ae }, Ze = useId$1(Ue), ot = typeof Oe == "boolean" ? Oe : He, qe = Pe?.id || `${Ze}-error`, Qe = Ie?.id || `${Ze}-description`, st = Ze, Nt = !!Be && typeof Be != "boolean", Je = !!De, jt = `${Nt ? qe : ""} ${Je ? Qe : ""}`, Xt = jt.trim().length > 0 ? jt.trim() : void 0, ct = Re?.id || `${Ze}-label`, nn = we && jsxRuntimeExports.jsx(InputLabel, { labelElement: Ne, id: ct, htmlFor: st, required: ot, ...Ye, ...Re, children: we }, "label"), $t = Je && jsxRuntimeExports.jsx(InputDescription, { ...Ie, ...Ye, size: Ie?.size || Ye.size, id: Ie?.id || Qe, children: De }, "description"), an = jsxRuntimeExports.jsx(reactExports.Fragment, { children: Se(ke) }, "input"), gn = Nt && reactExports.createElement(InputError, { ...Pe, ...Ye, size: Pe?.size || Ye.size, key: "error", id: Pe?.id || qe }, Be), Mn = Ce.map(Xn => { switch (Xn) { case "label": return nn; case "input": return an; case "description": return $t; case "error": return gn; default: return null } }); return jsxRuntimeExports.jsx(InputWrapperProvider, { value: { getStyles: Xe, describedBy: Xt, inputId: st, labelId: ct, ...getInputOffsets(Ce, { hasDescription: Je, hasError: Nt }) }, children: jsxRuntimeExports.jsx(Box, { ref: K, variant: be, size: Ee, mod: [{ error: !!Be }, ze], ...Xe("root"), ...We, children: Mn }) }) }); InputWrapper.classes = __default__$u; InputWrapper.displayName = "@mantine/core/InputWrapper"; const defaultProps$14 = { variant: "default", leftSectionPointerEvents: "none", rightSectionPointerEvents: "none", withAria: !0, withErrorStyles: !0 }, varsResolver$w = (fe, K, pe) => ({ wrapper: { "--input-margin-top": pe.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0, "--input-margin-bottom": pe.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0, "--input-height": getSize(K.size, "input-height"), "--input-fz": getFontSize(K.size), "--input-radius": K.radius === void 0 ? void 0 : getRadius(K.radius), "--input-left-section-width": K.leftSectionWidth !== void 0 ? rem(K.leftSectionWidth) : void 0, "--input-right-section-width": K.rightSectionWidth !== void 0 ? rem(K.rightSectionWidth) : void 0, "--input-padding-y": K.multiline ? getSize(K.size, "input-padding-y") : void 0, "--input-left-section-pointer-events": K.leftSectionPointerEvents, "--input-right-section-pointer-events": K.rightSectionPointerEvents } }), Input = polymorphicFactory((fe, K) => { const pe = useProps("Input", defaultProps$14, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, required: _e, __staticSelector: Ee, __stylesApiProps: be, size: Ae, wrapperProps: Se, error: Ce, disabled: we, leftSection: Be, leftSectionProps: De, leftSectionWidth: Re, rightSection: Ie, rightSectionProps: Pe, rightSectionWidth: Ne, rightSectionPointerEvents: ke, leftSectionPointerEvents: Oe, variant: Ue, vars: He, pointer: Ge, multiline: ze, radius: We, id: Xe, withAria: Ye, withErrorStyles: Ze, mod: ot, inputSize: qe, __clearSection: Qe, __clearable: st, __defaultRightSection: Nt, ...Je } = pe, { styleProps: jt, rest: Xt } = extractStyleProps(Je), ct = useInputWrapperContext(), nn = { offsetBottom: ct?.offsetBottom, offsetTop: ct?.offsetTop }, $t = useStyles({ name: ["Input", Ee], props: be || pe, classes: __default__$u, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, stylesCtx: nn, rootSelector: "wrapper", vars: He, varsResolver: varsResolver$w }), an = Ye ? { required: _e, disabled: we, "aria-invalid": !!Ce, "aria-describedby": ct?.describedBy, id: ct?.inputId || Xe } : {}, gn = Ie || st && Qe || Nt; return jsxRuntimeExports.jsx(InputContext, { value: { size: Ae || "sm" }, children: jsxRuntimeExports.jsxs(Box, { ...$t("wrapper"), ...jt, ...Se, mod: [{ error: !!Ce && Ze, pointer: Ge, disabled: we, multiline: ze, "data-with-right-section": !!gn, "data-with-left-section": !!Be }, ot], variant: Ue, size: Ae, children: [Be && jsxRuntimeExports.jsx("div", { ...De, "data-position": "left", ...$t("section", { className: De?.className, style: De?.style }), children: Be }), jsxRuntimeExports.jsx(Box, { component: "input", ...Xt, ...an, ref: K, required: _e, mod: { disabled: we, error: !!Ce && Ze }, variant: Ue, __size: qe, ...$t("input") }), gn && jsxRuntimeExports.jsx("div", { ...Pe, "data-position": "right", ...$t("section", { className: Pe?.className, style: Pe?.style }), children: gn })] }) }) }); Input.classes = __default__$u; Input.Wrapper = InputWrapper; Input.Label = InputLabel; Input.Error = InputError; Input.Description = InputDescription; Input.Placeholder = InputPlaceholder; Input.ClearButton = InputClearButton; Input.displayName = "@mantine/core/Input"; function useInputProps(fe, K, pe) { const me = useProps(fe, K, pe), { label: ge, description: xe, error: ye, required: ve, classNames: _e, styles: Ee, className: be, unstyled: Ae, __staticSelector: Se, __stylesApiProps: Ce, errorProps: we, labelProps: Be, descriptionProps: De, wrapperProps: Re, id: Ie, size: Pe, style: Ne, inputContainer: ke, inputWrapperOrder: Oe, withAsterisk: Ue, variant: He, vars: Ge, mod: ze, ...We } = me, { styleProps: Xe, rest: Ye } = extractStyleProps(We), Ze = { label: ge, description: xe, error: ye, required: ve, classNames: _e, className: be, __staticSelector: Se, __stylesApiProps: Ce || me, errorProps: we, labelProps: Be, descriptionProps: De, unstyled: Ae, styles: Ee, size: Pe, style: Ne, inputContainer: ke, inputWrapperOrder: Oe, withAsterisk: Ue, variant: He, id: Ie, mod: ze, ...Re }; return { ...Ye, classNames: _e, styles: Ee, unstyled: Ae, wrapperProps: { ...Ze, ...Xe }, inputProps: { required: ve, classNames: _e, styles: Ee, unstyled: Ae, size: Pe, __staticSelector: Se, __stylesApiProps: Ce || me, error: ye, variant: He, id: Ie } } } const defaultProps$13 = { __staticSelector: "InputBase", withAria: !0 }, InputBase = polymorphicFactory((fe, K) => { const { inputProps: pe, wrapperProps: me, ...ge } = useInputProps("InputBase", defaultProps$13, fe); return jsxRuntimeExports.jsx(Input.Wrapper, { ...me, children: jsxRuntimeExports.jsx(Input, { ...pe, ...ge, ref: K }) }) }); InputBase.classes = { ...Input.classes, ...Input.Wrapper.classes }; InputBase.displayName = "@mantine/core/InputBase"; const FLEX_STYLE_PROPS_DATA = { gap: { type: "spacing", property: "gap" }, rowGap: { type: "spacing", property: "rowGap" }, columnGap: { type: "spacing", property: "columnGap" }, align: { type: "identity", property: "alignItems" }, justify: { type: "identity", property: "justifyContent" }, wrap: { type: "identity", property: "flexWrap" }, direction: { type: "identity", property: "flexDirection" } }; var __default__$t = { root: "m_8bffd616" }; const defaultProps$12 = {}, Flex = polymorphicFactory((fe, K) => { const pe = useProps("Flex", defaultProps$12, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, gap: Ee, rowGap: be, columnGap: Ae, align: Se, justify: Ce, wrap: we, direction: Be, ...De } = pe, Re = useStyles({ name: "Flex", classes: __default__$t, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e }), Ie = useMantineTheme(), Pe = useRandomClassName(), Ne = parseStyleProps({ styleProps: { gap: Ee, rowGap: be, columnGap: Ae, align: Se, justify: Ce, wrap: we, direction: Be }, theme: Ie, data: FLEX_STYLE_PROPS_DATA }); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [Ne.hasResponsiveStyles && jsxRuntimeExports.jsx(InlineStyles, { selector: `.${Pe}`, styles: Ne.styles, media: Ne.media }), jsxRuntimeExports.jsx(Box, { ref: K, ...Re("root", { className: Pe, style: filterProps(Ne.inlineStyles) }), ...De })] }) }); Flex.classes = __default__$t; Flex.displayName = "@mantine/core/Flex"; var __default__$s = { root: "m_b6d8b162" }; function getTextTruncate(fe) { if (fe === "start") return "start"; if (fe === "end" || fe) return "end" } const defaultProps$11 = { inherit: !1 }, varsResolver$v = (fe, { variant: K, lineClamp: pe, gradient: me, size: ge, color: xe }) => ({ root: { "--text-fz": getFontSize(ge), "--text-lh": getLineHeight(ge), "--text-gradient": K === "gradient" ? getGradient(me, fe) : void 0, "--text-line-clamp": typeof pe == "number" ? pe.toString() : void 0, "--text-color": xe ? getThemeColor(xe, fe) : void 0 } }), Text = polymorphicFactory((fe, K) => { const pe = useProps("Text", defaultProps$11, fe), { lineClamp: me, truncate: ge, inline: xe, inherit: ye, gradient: ve, span: _e, __staticSelector: Ee, vars: be, className: Ae, style: Se, classNames: Ce, styles: we, unstyled: Be, variant: De, mod: Re, size: Ie, ...Pe } = pe, Ne = useStyles({ name: ["Text", Ee], props: pe, classes: __default__$s, className: Ae, style: Se, classNames: Ce, styles: we, unstyled: Be, vars: be, varsResolver: varsResolver$v }); return jsxRuntimeExports.jsx(Box, { ...Ne("root", { focusable: !0 }), ref: K, component: _e ? "span" : "p", variant: De, mod: [{ "data-truncate": getTextTruncate(ge), "data-line-clamp": typeof me == "number", "data-inline": xe, "data-inherit": ye }, Re], size: Ie, ...Pe }) }); Text.classes = __default__$s; Text.displayName = "@mantine/core/Text"; var __default__$r = { root: "m_849cf0da" }; const defaultProps$10 = { underline: "hover" }, Anchor = polymorphicFactory((fe, K) => { const { underline: pe, className: me, unstyled: ge, mod: xe, ...ye } = useProps("Anchor", defaultProps$10, fe); return jsxRuntimeExports.jsx(Text, { component: "a", ref: K, className: clsx({ [__default__$r.root]: !ge }, me), ...ye, mod: [{ underline: pe }, xe], __staticSelector: "Anchor", unstyled: ge }) }); Anchor.classes = __default__$r; Anchor.displayName = "@mantine/core/Anchor"; function parseItem(fe) { return typeof fe == "string" ? { value: fe, label: fe } : "value" in fe && !("label" in fe) ? { value: fe.value, label: fe.value, disabled: fe.disabled } : typeof fe == "number" ? { value: fe.toString(), label: fe.toString() } : "group" in fe ? { group: fe.group, items: fe.items.map(K => parseItem(K)) } : fe } function getParsedComboboxData(fe) { return fe ? fe.map(K => parseItem(K)) : [] } function getOptionsLockup(fe) { return fe.reduce((K, pe) => "group" in pe ? { ...K, ...getOptionsLockup(pe.items) } : (K[pe.value] = pe, K), {}) } var __default__$q = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2" }; const defaultProps$$ = { error: null }, varsResolver$u = (fe, { size: K, color: pe }) => ({ chevron: { "--combobox-chevron-size": getSize(K, "combobox-chevron-size"), "--combobox-chevron-color": pe ? getThemeColor(pe, fe) : void 0 } }), ComboboxChevron = factory((fe, K) => { const pe = useProps("ComboboxChevron", defaultProps$$, fe), { size: me, error: ge, style: xe, className: ye, classNames: ve, styles: _e, unstyled: Ee, vars: be, mod: Ae, ...Se } = pe, Ce = useStyles({ name: "ComboboxChevron", classes: __default__$q, props: pe, style: xe, className: ye, classNames: ve, styles: _e, unstyled: Ee, vars: be, varsResolver: varsResolver$u, rootSelector: "chevron" }); return jsxRuntimeExports.jsx(Box, { component: "svg", ...Se, ...Ce("chevron"), size: me, viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", mod: ["combobox-chevron", { error: ge }, Ae], ref: K, children: jsxRuntimeExports.jsx("path", { d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }) }) }); ComboboxChevron.classes = __default__$q; ComboboxChevron.displayName = "@mantine/core/ComboboxChevron"; const [ComboboxProvider, useComboboxContext] = createSafeContext("Combobox component was not found in tree"), ComboboxClearButton = reactExports.forwardRef(({ size: fe, onMouseDown: K, onClick: pe, onClear: me, ...ge }, xe) => jsxRuntimeExports.jsx(Input.ClearButton, { ref: xe, tabIndex: -1, "aria-hidden": !0, ...ge, onMouseDown: ye => { ye.preventDefault(), K?.(ye) }, onClick: ye => { me(), pe?.(ye) } })); ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton"; const defaultProps$_ = {}, ComboboxDropdown = factory((fe, K) => { const { classNames: pe, styles: me, className: ge, style: xe, hidden: ye, ...ve } = useProps("ComboboxDropdown", defaultProps$_, fe), _e = useComboboxContext(); return jsxRuntimeExports.jsx(Popover.Dropdown, { ...ve, ref: K, role: "presentation", "data-hidden": ye || void 0, ..._e.getStyles("dropdown", { className: ge, style: xe, classNames: pe, styles: me }) }) }); ComboboxDropdown.classes = __default__$q; ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown"; const defaultProps$Z = { refProp: "ref" }, ComboboxDropdownTarget = factory((fe, K) => { const { children: pe, refProp: me } = useProps("ComboboxDropdownTarget", defaultProps$Z, fe); if (useComboboxContext(), !isElement$1(pe)) throw new Error("Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"); return jsxRuntimeExports.jsx(Popover.Target, { ref: K, refProp: me, children: pe }) }); ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget"; const defaultProps$Y = {}, ComboboxEmpty = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, ...ve } = useProps("ComboboxEmpty", defaultProps$Y, fe), _e = useComboboxContext(); return jsxRuntimeExports.jsx(Box, { ref: K, ..._e.getStyles("empty", { className: me, classNames: pe, styles: xe, style: ge }), ...ve }) }); ComboboxEmpty.classes = __default__$q; ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty"; function useComboboxTargetProps({ onKeyDown: fe, withKeyboardNavigation: K, withAriaAttributes: pe, withExpandedAttribute: me, targetType: ge, autoComplete: xe }) { const ye = useComboboxContext(), [ve, _e] = reactExports.useState(null), Ee = Ae => { if (fe?.(Ae), !ye.readOnly && K) { if (Ae.nativeEvent.isComposing) return; if (Ae.nativeEvent.code === "ArrowDown" && (Ae.preventDefault(), ye.store.dropdownOpened ? _e(ye.store.selectNextOption()) : (ye.store.openDropdown("keyboard"), _e(ye.store.selectActiveOption()), ye.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), Ae.nativeEvent.code === "ArrowUp" && (Ae.preventDefault(), ye.store.dropdownOpened ? _e(ye.store.selectPreviousOption()) : (ye.store.openDropdown("keyboard"), _e(ye.store.selectActiveOption()), ye.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), Ae.nativeEvent.code === "Enter" || Ae.nativeEvent.code === "NumpadEnter") { if (Ae.nativeEvent.keyCode === 229) return; const Se = ye.store.getSelectedOptionIndex(); ye.store.dropdownOpened && Se !== -1 ? (Ae.preventDefault(), ye.store.clickSelectedOption()) : ge === "button" && (Ae.preventDefault(), ye.store.openDropdown("keyboard")) } Ae.key === "Escape" && ye.store.closeDropdown("keyboard"), Ae.nativeEvent.code === "Space" && ge === "button" && (Ae.preventDefault(), ye.store.toggleDropdown("keyboard")) } }; return { ...pe ? { "aria-haspopup": "listbox", "aria-expanded": me && !!(ye.store.listId && ye.store.dropdownOpened) || void 0, "aria-controls": ye.store.dropdownOpened ? ye.store.listId : void 0, "aria-activedescendant": ye.store.dropdownOpened && ve || void 0, autoComplete: xe, "data-expanded": ye.store.dropdownOpened || void 0, "data-mantine-stop-propagation": ye.store.dropdownOpened || void 0 } : {}, onKeyDown: Ee } } const defaultProps$X = { refProp: "ref", targetType: "input", withKeyboardNavigation: !0, withAriaAttributes: !0, withExpandedAttribute: !1, autoComplete: "off" }, ComboboxEventsTarget = factory((fe, K) => { const { children: pe, refProp: me, withKeyboardNavigation: ge, withAriaAttributes: xe, withExpandedAttribute: ye, targetType: ve, autoComplete: _e, ...Ee } = useProps("ComboboxEventsTarget", defaultProps$X, fe); if (!isElement$1(pe)) throw new Error("Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"); const be = useComboboxContext(), Ae = useComboboxTargetProps({ targetType: ve, withAriaAttributes: xe, withKeyboardNavigation: ge, withExpandedAttribute: ye, onKeyDown: pe.props.onKeyDown, autoComplete: _e }); return reactExports.cloneElement(pe, { ...Ae, ...Ee, [me]: useMergedRef(K, be.store.targetRef, getRefProp(pe)) }) }); ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget"; const defaultProps$W = {}, ComboboxFooter = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, ...ve } = useProps("ComboboxFooter", defaultProps$W, fe), _e = useComboboxContext(); return jsxRuntimeExports.jsx(Box, { ref: K, ..._e.getStyles("footer", { className: me, classNames: pe, style: ge, styles: xe }), ...ve, onMouseDown: Ee => { Ee.preventDefault() } }) }); ComboboxFooter.classes = __default__$q; ComboboxFooter.displayName = "@mantine/core/ComboboxFooter"; const defaultProps$V = {}, ComboboxGroup = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, children: ve, label: _e, ...Ee } = useProps("ComboboxGroup", defaultProps$V, fe), be = useComboboxContext(); return jsxRuntimeExports.jsxs(Box, { ref: K, ...be.getStyles("group", { className: me, classNames: pe, style: ge, styles: xe }), ...Ee, children: [_e && jsxRuntimeExports.jsx("div", { ...be.getStyles("groupLabel", { classNames: pe, styles: xe }), children: _e }), ve] }) }); ComboboxGroup.classes = __default__$q; ComboboxGroup.displayName = "@mantine/core/ComboboxGroup"; const defaultProps$U = {}, ComboboxHeader = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, ...ve } = useProps("ComboboxHeader", defaultProps$U, fe), _e = useComboboxContext(); return jsxRuntimeExports.jsx(Box, { ref: K, ..._e.getStyles("header", { className: me, classNames: pe, style: ge, styles: xe }), ...ve, onMouseDown: Ee => { Ee.preventDefault() } }) }); ComboboxHeader.classes = __default__$q; ComboboxHeader.displayName = "@mantine/core/ComboboxHeader"; function ComboboxHiddenInput({ value: fe, valuesDivider: K = ",", ...pe }) { return jsxRuntimeExports.jsx("input", { type: "hidden", value: Array.isArray(fe) ? fe.join(K) : fe || "", ...pe }) } ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput"; const defaultProps$T = {}, ComboboxOption = factory((fe, K) => { const pe = useProps("ComboboxOption", defaultProps$T, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, onClick: _e, id: Ee, active: be, onMouseDown: Ae, onMouseOver: Se, disabled: Ce, selected: we, mod: Be, ...De } = pe, Re = useComboboxContext(), Ie = reactExports.useId(), Pe = Ee || Ie; return jsxRuntimeExports.jsx(Box, { ...Re.getStyles("option", { className: ge, classNames: me, styles: ye, style: xe }), ...De, ref: K, id: Pe, mod: ["combobox-option", { "combobox-active": be, "combobox-disabled": Ce, "combobox-selected": we }, Be], role: "option", onClick: Ne => { Ce ? Ne.preventDefault() : (Re.onOptionSubmit?.(pe.value, pe), _e?.(Ne)) }, onMouseDown: Ne => { Ne.preventDefault(), Ae?.(Ne) }, onMouseOver: Ne => { Re.resetSelectionOnOptionHover && Re.store.resetSelectedOption(), Se?.(Ne) } }) }); ComboboxOption.classes = __default__$q; ComboboxOption.displayName = "@mantine/core/ComboboxOption"; const defaultProps$S = {}, ComboboxOptions = factory((fe, K) => { const pe = useProps("ComboboxOptions", defaultProps$S, fe), { classNames: me, className: ge, style: xe, styles: ye, id: ve, onMouseDown: _e, labelledBy: Ee, ...be } = pe, Ae = useComboboxContext(), Se = useId$1(ve); return reactExports.useEffect(() => { Ae.store.setListId(Se) }, [Se]), jsxRuntimeExports.jsx(Box, { ref: K, ...Ae.getStyles("options", { className: ge, style: xe, classNames: me, styles: ye }), ...be, id: Se, role: "listbox", "aria-labelledby": Ee, onMouseDown: Ce => { Ce.preventDefault(), _e?.(Ce) } }) }); ComboboxOptions.classes = __default__$q; ComboboxOptions.displayName = "@mantine/core/ComboboxOptions"; const defaultProps$R = { withAriaAttributes: !0, withKeyboardNavigation: !0 }, ComboboxSearch = factory((fe, K) => { const pe = useProps("ComboboxSearch", defaultProps$R, fe), { classNames: me, styles: ge, unstyled: xe, vars: ye, withAriaAttributes: ve, onKeyDown: _e, withKeyboardNavigation: Ee, size: be, ...Ae } = pe, Se = useComboboxContext(), Ce = Se.getStyles("search"), we = useComboboxTargetProps({ targetType: "input", withAriaAttributes: ve, withKeyboardNavigation: Ee, withExpandedAttribute: !1, onKeyDown: _e, autoComplete: "off" }); return jsxRuntimeExports.jsx(Input, { ref: useMergedRef(K, Se.store.searchRef), classNames: [{ input: Ce.className }, me], styles: [{ input: Ce.style }, ge], size: be || Se.size, ...we, ...Ae, __staticSelector: "Combobox" }) }); ComboboxSearch.classes = __default__$q; ComboboxSearch.displayName = "@mantine/core/ComboboxSearch"; const defaultProps$Q = { refProp: "ref", targetType: "input", withKeyboardNavigation: !0, withAriaAttributes: !0, withExpandedAttribute: !1, autoComplete: "off" }, ComboboxTarget = factory((fe, K) => { const { children: pe, refProp: me, withKeyboardNavigation: ge, withAriaAttributes: xe, withExpandedAttribute: ye, targetType: ve, autoComplete: _e, ...Ee } = useProps("ComboboxTarget", defaultProps$Q, fe); if (!isElement$1(pe)) throw new Error("Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"); const be = useComboboxContext(), Ae = useComboboxTargetProps({ targetType: ve, withAriaAttributes: xe, withKeyboardNavigation: ge, withExpandedAttribute: ye, onKeyDown: pe.props.onKeyDown, autoComplete: _e }), Se = reactExports.cloneElement(pe, { ...Ae, ...Ee }); return jsxRuntimeExports.jsx(Popover.Target, { ref: useMergedRef(K, be.store.targetRef), children: Se }) }); ComboboxTarget.displayName = "@mantine/core/ComboboxTarget"; function getPreviousIndex(fe, K, pe) { for (let me = fe - 1; me >= 0; me -= 1)if (!K[me].hasAttribute("data-combobox-disabled")) return me; if (pe) { for (let me = K.length - 1; me > -1; me -= 1)if (!K[me].hasAttribute("data-combobox-disabled")) return me } return fe } function getNextIndex(fe, K, pe) { for (let me = fe + 1; me < K.length; me += 1)if (!K[me].hasAttribute("data-combobox-disabled")) return me; if (pe) { for (let me = 0; me < K.length; me += 1)if (!K[me].hasAttribute("data-combobox-disabled")) return me } return fe } function getFirstIndex(fe) { for (let K = 0; K < fe.length; K += 1)if (!fe[K].hasAttribute("data-combobox-disabled")) return K; return -1 } function useCombobox({ defaultOpened: fe, opened: K, onOpenedChange: pe, onDropdownClose: me, onDropdownOpen: ge, loop: xe = !0, scrollBehavior: ye = "instant" } = {}) { const [ve, _e] = useUncontrolled({ value: K, defaultValue: fe, finalValue: !1, onChange: pe }), Ee = reactExports.useRef(null), be = reactExports.useRef(-1), Ae = reactExports.useRef(null), Se = reactExports.useRef(null), Ce = reactExports.useRef(-1), we = reactExports.useRef(-1), Be = reactExports.useRef(-1), De = reactExports.useCallback((qe = "unknown") => { ve || (_e(!0), ge?.(qe)) }, [_e, ge, ve]), Re = reactExports.useCallback((qe = "unknown") => { ve && (_e(!1), me?.(qe)) }, [_e, me, ve]), Ie = reactExports.useCallback((qe = "unknown") => { ve ? Re(qe) : De(qe) }, [Re, De, ve]), Pe = reactExports.useCallback(() => { const qe = document.querySelector(`#${Ee.current} [data-combobox-selected]`); qe?.removeAttribute("data-combobox-selected"), qe?.removeAttribute("aria-selected") }, []), Ne = reactExports.useCallback(qe => { const st = document.getElementById(Ee.current)?.querySelectorAll("[data-combobox-option]"); if (!st) return null; const Nt = qe >= st.length ? 0 : qe < 0 ? st.length - 1 : qe; return be.current = Nt, st?.[Nt] && !st[Nt].hasAttribute("data-combobox-disabled") ? (Pe(), st[Nt].setAttribute("data-combobox-selected", "true"), st[Nt].setAttribute("aria-selected", "true"), st[Nt].scrollIntoView({ block: "nearest", behavior: ye }), st[Nt].id) : null }, [ye, Pe]), ke = reactExports.useCallback(() => { const qe = document.querySelector(`#${Ee.current} [data-combobox-active]`); if (qe) { const Qe = document.querySelectorAll(`#${Ee.current} [data-combobox-option]`), st = Array.from(Qe).findIndex(Nt => Nt === qe); return Ne(st) } return Ne(0) }, [Ne]), Oe = reactExports.useCallback(() => Ne(getNextIndex(be.current, document.querySelectorAll(`#${Ee.current} [data-combobox-option]`), xe)), [Ne, xe]), Ue = reactExports.useCallback(() => Ne(getPreviousIndex(be.current, document.querySelectorAll(`#${Ee.current} [data-combobox-option]`), xe)), [Ne, xe]), He = reactExports.useCallback(() => Ne(getFirstIndex(document.querySelectorAll(`#${Ee.current} [data-combobox-option]`))), [Ne]), Ge = reactExports.useCallback((qe = "selected", Qe) => { Be.current = window.setTimeout(() => { const st = document.querySelectorAll(`#${Ee.current} [data-combobox-option]`), Nt = Array.from(st).findIndex(Je => Je.hasAttribute(`data-combobox-${qe}`)); be.current = Nt, Qe?.scrollIntoView && st[Nt]?.scrollIntoView({ block: "nearest", behavior: ye }) }, 0) }, []), ze = reactExports.useCallback(() => { be.current = -1, Pe() }, [Pe]), We = reactExports.useCallback(() => { document.querySelectorAll(`#${Ee.current} [data-combobox-option]`)?.[be.current]?.click() }, []), Xe = reactExports.useCallback(qe => { Ee.current = qe }, []), Ye = reactExports.useCallback(() => { Ce.current = window.setTimeout(() => Ae.current.focus(), 0) }, []), Ze = reactExports.useCallback(() => { we.current = window.setTimeout(() => Se.current.focus(), 0) }, []), ot = reactExports.useCallback(() => be.current, []); return reactExports.useEffect(() => () => { window.clearTimeout(Ce.current), window.clearTimeout(we.current), window.clearTimeout(Be.current) }, []), { dropdownOpened: ve, openDropdown: De, closeDropdown: Re, toggleDropdown: Ie, selectedOptionIndex: be.current, getSelectedOptionIndex: ot, selectOption: Ne, selectFirstOption: He, selectActiveOption: ke, selectNextOption: Oe, selectPreviousOption: Ue, resetSelectedOption: ze, updateSelectedOptionIndex: Ge, listId: Ee.current, setListId: Xe, clickSelectedOption: We, searchRef: Ae, focusSearchInput: Ye, targetRef: Se, focusTarget: Ze } } const defaultProps$P = { keepMounted: !0, withinPortal: !0, resetSelectionOnOptionHover: !1, width: "target", transitionProps: { transition: "fade", duration: 0 } }, varsResolver$t = (fe, { size: K, dropdownPadding: pe }) => ({ options: { "--combobox-option-fz": getFontSize(K), "--combobox-option-padding": getSize(K, "combobox-option-padding") }, dropdown: { "--combobox-padding": pe === void 0 ? void 0 : rem(pe), "--combobox-option-fz": getFontSize(K), "--combobox-option-padding": getSize(K, "combobox-option-padding") } }); function Combobox(fe) { const K = useProps("Combobox", defaultProps$P, fe), { classNames: pe, styles: me, unstyled: ge, children: xe, store: ye, vars: ve, onOptionSubmit: _e, onClose: Ee, size: be, dropdownPadding: Ae, resetSelectionOnOptionHover: Se, __staticSelector: Ce, readOnly: we, ...Be } = K, De = useCombobox(), Re = ye || De, Ie = useStyles({ name: Ce || "Combobox", classes: __default__$q, props: K, classNames: pe, styles: me, unstyled: ge, vars: ve, varsResolver: varsResolver$t }), Pe = () => { Ee?.(), Re.closeDropdown() }; return jsxRuntimeExports.jsx(ComboboxProvider, { value: { getStyles: Ie, store: Re, onOptionSubmit: _e, size: be, resetSelectionOnOptionHover: Se, readOnly: we }, children: jsxRuntimeExports.jsx(Popover, { opened: Re.dropdownOpened, ...Be, onChange: Ne => !Ne && Pe(), withRoles: !1, unstyled: ge, children: xe }) }) } const extendCombobox = fe => fe; Combobox.extend = extendCombobox; Combobox.classes = __default__$q; Combobox.displayName = "@mantine/core/Combobox"; Combobox.Target = ComboboxTarget; Combobox.Dropdown = ComboboxDropdown; Combobox.Options = ComboboxOptions; Combobox.Option = ComboboxOption; Combobox.Search = ComboboxSearch; Combobox.Empty = ComboboxEmpty; Combobox.Chevron = ComboboxChevron; Combobox.Footer = ComboboxFooter; Combobox.Header = ComboboxHeader; Combobox.EventsTarget = ComboboxEventsTarget; Combobox.DropdownTarget = ComboboxDropdownTarget; Combobox.Group = ComboboxGroup; Combobox.ClearButton = ComboboxClearButton; Combobox.HiddenInput = ComboboxHiddenInput; var __default__$p = { root: "m_5f75b09e", body: "m_5f6e695e", labelWrapper: "m_d3ea56bb", label: "m_8ee546b8", description: "m_328f68c0", error: "m_8e8a99cc" }; const InlineInputClasses = __default__$p, InlineInput = reactExports.forwardRef(({ __staticSelector: fe, __stylesApiProps: K, className: pe, classNames: me, styles: ge, unstyled: xe, children: ye, label: ve, description: _e, id: Ee, disabled: be, error: Ae, size: Se, labelPosition: Ce = "left", bodyElement: we = "div", labelElement: Be = "label", variant: De, style: Re, vars: Ie, mod: Pe, ...Ne }, ke) => { const Oe = useStyles({ name: fe, props: K, className: pe, style: Re, classes: __default__$p, classNames: me, styles: ge, unstyled: xe }); return jsxRuntimeExports.jsx(Box, { ...Oe("root"), ref: ke, __vars: { "--label-fz": getFontSize(Se), "--label-lh": getSize(Se, "label-lh") }, mod: [{ "label-position": Ce }, Pe], variant: De, size: Se, ...Ne, children: jsxRuntimeExports.jsxs(Box, { component: we, htmlFor: we === "label" ? Ee : void 0, ...Oe("body"), children: [ye, jsxRuntimeExports.jsxs("div", { ...Oe("labelWrapper"), "data-disabled": be || void 0, children: [ve && jsxRuntimeExports.jsx(Box, { component: Be, htmlFor: Be === "label" ? Ee : void 0, ...Oe("label"), "data-disabled": be || void 0, children: ve }), _e && jsxRuntimeExports.jsx(Input.Description, { size: Se, __inheritStyles: !1, ...Oe("description"), children: _e }), Ae && typeof Ae != "boolean" && jsxRuntimeExports.jsx(Input.Error, { size: Se, __inheritStyles: !1, ...Oe("error"), children: Ae })] })] }) }) }); InlineInput.displayName = "@mantine/core/InlineInput"; const CheckboxGroupContext = reactExports.createContext(null), CheckboxGroupProvider = CheckboxGroupContext.Provider, useCheckboxGroupContext = () => reactExports.useContext(CheckboxGroupContext), [CheckboxCardProvider, useCheckboxCardContext] = createOptionalContext(); var __default__$o = { card: "m_26775b0a" }; const defaultProps$O = { withBorder: !0 }, varsResolver$s = (fe, { radius: K }) => ({ card: { "--card-radius": getRadius(K) } }), CheckboxCard = factory((fe, K) => { const pe = useProps("CheckboxCard", defaultProps$O, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, checked: Ee, mod: be, withBorder: Ae, value: Se, onClick: Ce, defaultChecked: we, onChange: Be, ...De } = pe, Re = useStyles({ name: "CheckboxCard", classes: __default__$o, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$s, rootSelector: "card" }), Ie = useCheckboxGroupContext(), Pe = typeof Ee == "boolean" ? Ee : Ie ? Ie.value.includes(Se || "") : void 0, [Ne, ke] = useUncontrolled({ value: Pe, defaultValue: we, finalValue: !1, onChange: Be }); return jsxRuntimeExports.jsx(CheckboxCardProvider, { value: { checked: Ne }, children: jsxRuntimeExports.jsx(UnstyledButton, { ref: K, mod: [{ "with-border": Ae, checked: Ne }, be], ...Re("card"), ...De, role: "checkbox", "aria-checked": Ne, onClick: Oe => { Ce?.(Oe), Ie?.onChange(Se || ""), ke(!Ne) } }) }) }); CheckboxCard.displayName = "@mantine/core/CheckboxCard"; CheckboxCard.classes = __default__$o; function InputsGroupFieldset({ children: fe, role: K }) { const pe = useInputWrapperContext(); return pe ? jsxRuntimeExports.jsx("div", { role: K, "aria-labelledby": pe.labelId, "aria-describedby": pe.describedBy, children: fe }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: fe }) } const defaultProps$N = {}, CheckboxGroup = factory((fe, K) => { const { value: pe, defaultValue: me, onChange: ge, size: xe, wrapperProps: ye, children: ve, readOnly: _e, ...Ee } = useProps("CheckboxGroup", defaultProps$N, fe), [be, Ae] = useUncontrolled({ value: pe, defaultValue: me, finalValue: [], onChange: ge }), Se = Ce => { const we = typeof Ce == "string" ? Ce : Ce.currentTarget.value; !_e && Ae(be.includes(we) ? be.filter(Be => Be !== we) : [...be, we]) }; return jsxRuntimeExports.jsx(CheckboxGroupProvider, { value: { value: be, onChange: Se, size: xe }, children: jsxRuntimeExports.jsx(Input.Wrapper, { size: xe, ref: K, ...ye, ...Ee, labelElement: "div", __staticSelector: "CheckboxGroup", children: jsxRuntimeExports.jsx(InputsGroupFieldset, { role: "group", children: ve }) }) }) }); CheckboxGroup.classes = Input.Wrapper.classes; CheckboxGroup.displayName = "@mantine/core/CheckboxGroup"; function CheckIcon({ size: fe, style: K, ...pe }) { const me = fe !== void 0 ? { width: rem(fe), height: rem(fe), ...K } : K; return jsxRuntimeExports.jsx("svg", { viewBox: "0 0 10 7", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: me, "aria-hidden": !0, ...pe, children: jsxRuntimeExports.jsx("path", { d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }) }) } function CheckboxIcon({ indeterminate: fe, ...K }) { return fe ? jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 32 6", "aria-hidden": !0, ...K, children: jsxRuntimeExports.jsx("rect", { width: "32", height: "6", fill: "currentColor", rx: "3" }) }) : jsxRuntimeExports.jsx(CheckIcon, { ...K }) } var __default__$n = { indicator: "m_5e5256ee", icon: "m_1b1c543a", "indicator--outline": "m_76e20374" }; const defaultProps$M = { icon: CheckboxIcon }, varsResolver$r = (fe, { radius: K, color: pe, size: me, iconColor: ge, variant: xe, autoContrast: ye }) => { const ve = parseThemeColor({ color: pe || fe.primaryColor, theme: fe }), _e = ve.isThemeColor && ve.shade === void 0 ? `var(--mantine-color-${ve.color}-outline)` : ve.color; return { indicator: { "--checkbox-size": getSize(me, "checkbox-size"), "--checkbox-radius": K === void 0 ? void 0 : getRadius(K), "--checkbox-color": xe === "outline" ? _e : getThemeColor(pe, fe), "--checkbox-icon-color": ge ? getThemeColor(ge, fe) : getAutoContrastValue(ye, fe) ? getContrastColor({ color: pe, theme: fe, autoContrast: ye }) : void 0 } } }, CheckboxIndicator = factory((fe, K) => { const pe = useProps("CheckboxIndicator", defaultProps$M, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, icon: Ee, indeterminate: be, radius: Ae, color: Se, iconColor: Ce, autoContrast: we, checked: Be, mod: De, variant: Re, disabled: Ie, ...Pe } = pe, Ne = Ee, ke = useStyles({ name: "CheckboxIndicator", classes: __default__$n, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$r, rootSelector: "indicator" }), Oe = useCheckboxCardContext(), Ue = typeof Be == "boolean" || typeof be == "boolean" ? Be || be : Oe?.checked || !1; return jsxRuntimeExports.jsx(Box, { ref: K, ...ke("indicator", { variant: Re }), variant: Re, mod: [{ checked: Ue, disabled: Ie }, De], ...Pe, children: jsxRuntimeExports.jsx(Ne, { indeterminate: be, ...ke("icon") }) }) }); CheckboxIndicator.displayName = "@mantine/core/CheckboxIndicator"; CheckboxIndicator.classes = __default__$n; var __default__$m = { root: "m_bf2d988c", inner: "m_26062bec", input: "m_26063560", icon: "m_bf295423", "input--outline": "m_215c4542" }; const defaultProps$L = { labelPosition: "right", icon: CheckboxIcon }, varsResolver$q = (fe, { radius: K, color: pe, size: me, iconColor: ge, variant: xe, autoContrast: ye }) => { const ve = parseThemeColor({ color: pe || fe.primaryColor, theme: fe }), _e = ve.isThemeColor && ve.shade === void 0 ? `var(--mantine-color-${ve.color}-outline)` : ve.color; return { root: { "--checkbox-size": getSize(me, "checkbox-size"), "--checkbox-radius": K === void 0 ? void 0 : getRadius(K), "--checkbox-color": xe === "outline" ? _e : getThemeColor(pe, fe), "--checkbox-icon-color": ge ? getThemeColor(ge, fe) : getAutoContrastValue(ye, fe) ? getContrastColor({ color: pe, theme: fe, autoContrast: ye }) : void 0 } } }, Checkbox = factory((fe, K) => { const pe = useProps("Checkbox", defaultProps$L, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, color: Ee, label: be, id: Ae, size: Se, radius: Ce, wrapperProps: we, checked: Be, labelPosition: De, description: Re, error: Ie, disabled: Pe, variant: Ne, indeterminate: ke, icon: Oe, rootRef: Ue, iconColor: He, onChange: Ge, autoContrast: ze, mod: We, ...Xe } = pe, Ye = useCheckboxGroupContext(), Ze = Se || Ye?.size, ot = Oe, qe = useStyles({ name: "Checkbox", props: pe, classes: __default__$m, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$q }), { styleProps: Qe, rest: st } = extractStyleProps(Xe), Nt = useId$1(Ae), Je = Ye ? { checked: Ye.value.includes(st.value), onChange: ct => { Ye.onChange(ct), Ge?.(ct) } } : {}, jt = reactExports.useRef(null), Xt = K || jt; return reactExports.useEffect(() => { Xt && "current" in Xt && Xt.current && (Xt.current.indeterminate = ke || !1) }, [ke, Xt]), jsxRuntimeExports.jsx(InlineInput, { ...qe("root"), __staticSelector: "Checkbox", __stylesApiProps: pe, id: Nt, size: Ze, labelPosition: De, label: be, description: Re, error: Ie, disabled: Pe, classNames: me, styles: ye, unstyled: ve, "data-checked": Je.checked || Be || void 0, variant: Ne, ref: Ue, mod: We, ...Qe, ...we, children: jsxRuntimeExports.jsxs(Box, { ...qe("inner"), mod: { "data-label-position": De }, children: [jsxRuntimeExports.jsx(Box, { component: "input", id: Nt, ref: Xt, checked: Be, disabled: Pe, mod: { error: !!Ie, indeterminate: ke }, ...qe("input", { focusable: !0, variant: Ne }), onChange: Ge, ...st, ...Je, type: "checkbox" }), jsxRuntimeExports.jsx(ot, { indeterminate: ke, ...qe("icon") })] }) }) }); Checkbox.classes = { ...__default__$m, ...InlineInputClasses }; Checkbox.displayName = "@mantine/core/Checkbox"; Checkbox.Group = CheckboxGroup; Checkbox.Indicator = CheckboxIndicator; Checkbox.Card = CheckboxCard; function isOptionsGroup(fe) { return "group" in fe } function defaultOptionsFilter({ options: fe, search: K, limit: pe }) { const me = K.trim().toLowerCase(), ge = []; for (let xe = 0; xe < fe.length; xe += 1) { const ye = fe[xe]; if (ge.length === pe) return ge; isOptionsGroup(ye) && ge.push({ group: ye.group, items: defaultOptionsFilter({ options: ye.items, search: K, limit: pe - ge.length }) }), isOptionsGroup(ye) || ye.label.toLowerCase().includes(me) && ge.push(ye) } return ge } function isEmptyComboboxData(fe) { if (fe.length === 0) return !0; for (const K of fe) if (!("group" in K) || K.items.length > 0) return !1; return !0 } function validateOptions(fe, K = new Set) { if (Array.isArray(fe)) for (const pe of fe) if (isOptionsGroup(pe)) validateOptions(pe.items, K); else { if (typeof pe.value > "u") throw new Error("[@mantine/core] Each option must have value property"); if (typeof pe.value != "string") throw new Error(`[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof pe.value}`); if (K.has(pe.value)) throw new Error(`[@mantine/core] Duplicate options are not supported. Option with value "${pe.value}" was provided more than once`); K.add(pe.value) } } function isValueChecked(fe, K) { return Array.isArray(fe) ? fe.includes(K) : fe === K } function Option({ data: fe, withCheckIcon: K, value: pe, checkIconPosition: me, unstyled: ge, renderOption: xe }) { if (!isOptionsGroup(fe)) { const ve = isValueChecked(pe, fe.value), _e = K && ve && jsxRuntimeExports.jsx(CheckIcon, { className: __default__$q.optionsDropdownCheckIcon }), Ee = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [me === "left" && _e, jsxRuntimeExports.jsx("span", { children: fe.label }), me === "right" && _e] }); return jsxRuntimeExports.jsx(Combobox.Option, { value: fe.value, disabled: fe.disabled, className: clsx({ [__default__$q.optionsDropdownOption]: !ge }), "data-reverse": me === "right" || void 0, "data-checked": ve || void 0, "aria-selected": ve, active: ve, children: typeof xe == "function" ? xe({ option: fe, checked: ve }) : Ee }) } const ye = fe.items.map(ve => jsxRuntimeExports.jsx(Option, { data: ve, value: pe, unstyled: ge, withCheckIcon: K, checkIconPosition: me, renderOption: xe }, ve.value)); return jsxRuntimeExports.jsx(Combobox.Group, { label: fe.group, children: ye }) } function OptionsDropdown({ data: fe, hidden: K, hiddenWhenEmpty: pe, filter: me, search: ge, limit: xe, maxDropdownHeight: ye, withScrollArea: ve = !0, filterOptions: _e = !0, withCheckIcon: Ee = !1, value: be, checkIconPosition: Ae, nothingFoundMessage: Se, unstyled: Ce, labelId: we, renderOption: Be, scrollAreaProps: De, "aria-label": Re }) { validateOptions(fe); const Pe = typeof ge == "string" ? (me || defaultOptionsFilter)({ options: fe, search: _e ? ge : "", limit: xe ?? 1 / 0 }) : fe, Ne = isEmptyComboboxData(Pe), ke = Pe.map(Oe => jsxRuntimeExports.jsx(Option, { data: Oe, withCheckIcon: Ee, value: be, checkIconPosition: Ae, unstyled: Ce, renderOption: Be }, isOptionsGroup(Oe) ? Oe.group : Oe.value)); return jsxRuntimeExports.jsx(Combobox.Dropdown, { hidden: K || pe && Ne, "data-composed": !0, children: jsxRuntimeExports.jsxs(Combobox.Options, { labelledBy: we, "aria-label": Re, children: [ve ? jsxRuntimeExports.jsx(ScrollArea.Autosize, { mah: ye ?? 220, type: "scroll", scrollbarSize: "var(--combobox-padding)", offsetScrollbars: "y", ...De, children: ke }) : ke, Ne && Se && jsxRuntimeExports.jsx(Combobox.Empty, { children: Se })] }) }) } var __default__$l = { root: "m_ddec01c0", icon: "m_dde7bd57", cite: "m_dde51a35" }; const defaultProps$K = { iconSize: 48 }, varsResolver$p = (fe, { color: K, iconSize: pe, radius: me }) => { const ge = parseThemeColor({ color: K || fe.primaryColor, theme: fe, colorScheme: "dark" }), xe = parseThemeColor({ color: K || fe.primaryColor, theme: fe, colorScheme: "light" }); return { root: { "--bq-bg-light": rgba$1(xe.value, .07), "--bq-bg-dark": rgba$1(ge.value, .06), "--bq-bd": getThemeColor(K, fe), "--bq-icon-size": rem(pe), "--bq-radius": getRadius(me) } } }, Blockquote = factory((fe, K) => { const pe = useProps("Blockquote", defaultProps$K, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, children: Ee, icon: be, iconSize: Ae, cite: Se, ...Ce } = pe, we = useStyles({ name: "Blockquote", classes: __default__$l, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$p }); return jsxRuntimeExports.jsxs(Box, { component: "blockquote", ref: K, ...we("root"), ...Ce, children: [be && jsxRuntimeExports.jsx("span", { ...we("icon"), children: be }), Ee, Se && jsxRuntimeExports.jsx("cite", { ...we("cite"), children: Se })] }) }); Blockquote.classes = __default__$l; Blockquote.displayName = "@mantine/core/Blockquote"; var __default__$k = { root: "m_fea6bf1a", burger: "m_d4fb9cad" }; const defaultProps$J = {}, varsResolver$o = (fe, { color: K, size: pe, lineSize: me, transitionDuration: ge, transitionTimingFunction: xe }) => ({ root: { "--burger-color": K ? getThemeColor(K, fe) : void 0, "--burger-size": getSize(pe, "burger-size"), "--burger-line-size": me ? rem(me) : void 0, "--burger-transition-duration": ge === void 0 ? void 0 : `${ge}ms`, "--burger-transition-timing-function": xe } }), Burger = factory((fe, K) => { const pe = useProps("Burger", defaultProps$J, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, opened: Ee, children: be, transitionDuration: Ae, transitionTimingFunction: Se, lineSize: Ce, ...we } = pe, Be = useStyles({ name: "Burger", classes: __default__$k, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$o }); return jsxRuntimeExports.jsxs(UnstyledButton, { ...Be("root"), ref: K, ...we, children: [jsxRuntimeExports.jsx(Box, { mod: ["reduce-motion", { opened: Ee }], ...Be("burger") }), be] }) }); Burger.classes = __default__$k; Burger.displayName = "@mantine/core/Burger"; var __default__$j = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" }; const defaultProps$I = { orientation: "horizontal" }, varsResolver$n = (fe, { borderWidth: K }) => ({ group: { "--button-border-width": rem(K) } }), ButtonGroup = factory((fe, K) => { const pe = useProps("ButtonGroup", defaultProps$I, fe), { className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, orientation: _e, vars: Ee, borderWidth: be, variant: Ae, mod: Se, ...Ce } = useProps("ButtonGroup", defaultProps$I, fe), we = useStyles({ name: "ButtonGroup", props: pe, classes: __default__$j, className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: Ee, varsResolver: varsResolver$n, rootSelector: "group" }); return jsxRuntimeExports.jsx(Box, { ...we("group"), ref: K, variant: Ae, mod: [{ "data-orientation": _e }, Se], role: "group", ...Ce }) }); ButtonGroup.classes = __default__$j; ButtonGroup.displayName = "@mantine/core/ButtonGroup"; const defaultProps$H = {}, varsResolver$m = (fe, { radius: K, color: pe, gradient: me, variant: ge, autoContrast: xe, size: ye }) => { const ve = fe.variantColorResolver({ color: pe || fe.primaryColor, theme: fe, gradient: me, variant: ge || "filled", autoContrast: xe }); return { groupSection: { "--section-height": getSize(ye, "section-height"), "--section-padding-x": getSize(ye, "section-padding-x"), "--section-fz": ye?.includes("compact") ? getFontSize(ye.replace("compact-", "")) : getFontSize(ye), "--section-radius": K === void 0 ? void 0 : getRadius(K), "--section-bg": pe || ge ? ve.background : void 0, "--section-color": ve.color, "--section-bd": pe || ge ? ve.border : void 0 } } }, ButtonGroupSection = factory((fe, K) => { const pe = useProps("ButtonGroupSection", defaultProps$H, fe), { className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: _e, variant: Ee, gradient: be, radius: Ae, autoContrast: Se, ...Ce } = useProps("ButtonGroupSection", defaultProps$H, fe), we = useStyles({ name: "ButtonGroupSection", props: pe, classes: __default__$j, className: me, style: ge, classNames: xe, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$m, rootSelector: "groupSection" }); return jsxRuntimeExports.jsx(Box, { ...we("groupSection"), ref: K, variant: Ee, ...Ce }) }); ButtonGroupSection.classes = __default__$j; ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection"; const loaderTransition = { in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` }, out: { opacity: 0, transform: "translate(-50%, -200%)" }, common: { transformOrigin: "center" }, transitionProperty: "transform, opacity" }, defaultProps$G = {}, varsResolver$l = (fe, { radius: K, color: pe, gradient: me, variant: ge, size: xe, justify: ye, autoContrast: ve }) => { const _e = fe.variantColorResolver({ color: pe || fe.primaryColor, theme: fe, gradient: me, variant: ge || "filled", autoContrast: ve }); return { root: { "--button-justify": ye, "--button-height": getSize(xe, "button-height"), "--button-padding-x": getSize(xe, "button-padding-x"), "--button-fz": xe?.includes("compact") ? getFontSize(xe.replace("compact-", "")) : getFontSize(xe), "--button-radius": K === void 0 ? void 0 : getRadius(K), "--button-bg": pe || ge ? _e.background : void 0, "--button-hover": pe || ge ? _e.hover : void 0, "--button-color": _e.color, "--button-bd": pe || ge ? _e.border : void 0, "--button-hover-color": pe || ge ? _e.hoverColor : void 0 } } }, Button = polymorphicFactory((fe, K) => { const pe = useProps("Button", defaultProps$G, fe), { style: me, vars: ge, className: xe, color: ye, disabled: ve, children: _e, leftSection: Ee, rightSection: be, fullWidth: Ae, variant: Se, radius: Ce, loading: we, loaderProps: Be, gradient: De, classNames: Re, styles: Ie, unstyled: Pe, "data-disabled": Ne, autoContrast: ke, mod: Oe, ...Ue } = pe, He = useStyles({ name: "Button", props: pe, classes: __default__$j, className: xe, style: me, classNames: Re, styles: Ie, unstyled: Pe, vars: ge, varsResolver: varsResolver$l }), Ge = !!Ee, ze = !!be; return jsxRuntimeExports.jsxs(UnstyledButton, { ref: K, ...He("root", { active: !ve && !we && !Ne }), unstyled: Pe, variant: Se, disabled: ve || we, mod: [{ disabled: ve || Ne, loading: we, block: Ae, "with-left-section": Ge, "with-right-section": ze }, Oe], ...Ue, children: [jsxRuntimeExports.jsx(Transition$1, { mounted: !!we, transition: loaderTransition, duration: 150, children: We => jsxRuntimeExports.jsx(Box, { component: "span", ...He("loader", { style: We }), "aria-hidden": !0, children: jsxRuntimeExports.jsx(Loader$1, { color: "var(--button-color)", size: "calc(var(--button-height) / 1.8)", ...Be }) }) }), jsxRuntimeExports.jsxs("span", { ...He("inner"), children: [Ee && jsxRuntimeExports.jsx(Box, { component: "span", ...He("section"), mod: { position: "left" }, children: Ee }), jsxRuntimeExports.jsx(Box, { component: "span", mod: { loading: we }, ...He("label"), children: _e }), be && jsxRuntimeExports.jsx(Box, { component: "span", ...He("section"), mod: { position: "right" }, children: be })] })] }) }); Button.classes = __default__$j; Button.displayName = "@mantine/core/Button"; Button.Group = ButtonGroup; Button.GroupSection = ButtonGroupSection; var __default__$i = { root: "m_b183c0a2" }; const defaultProps$F = {}, varsResolver$k = (fe, { color: K }) => ({ root: { "--code-bg": K ? getThemeColor(K, fe) : void 0 } }), Code = factory((fe, K) => { const pe = useProps("Code", defaultProps$F, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, color: Ee, block: be, variant: Ae, mod: Se, ...Ce } = pe, we = useStyles({ name: "Code", props: pe, classes: __default__$i, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$k }); return jsxRuntimeExports.jsx(Box, { component: be ? "pre" : "code", variant: Ae, ref: K, mod: [{ block: be }, Se], ...we("root"), ...Ce, dir: "ltr" }) }); Code.classes = __default__$i; Code.displayName = "@mantine/core/Code"; var __default__$h = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" }; const defaultProps$E = { withShadow: !0 }, varsResolver$j = (fe, { radius: K, size: pe }) => ({ root: { "--cs-radius": K === void 0 ? void 0 : getRadius(K), "--cs-size": rem(pe) } }), ColorSwatch = polymorphicFactory((fe, K) => { const pe = useProps("ColorSwatch", defaultProps$E, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, color: Ee, size: be, radius: Ae, withShadow: Se, children: Ce, variant: we, ...Be } = useProps("ColorSwatch", defaultProps$E, pe), De = useStyles({ name: "ColorSwatch", props: pe, classes: __default__$h, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$j }); return jsxRuntimeExports.jsxs(Box, { ref: K, variant: we, size: be, ...De("root", { focusable: !0 }), ...Be, children: [jsxRuntimeExports.jsx("span", { ...De("alphaOverlay") }), Se && jsxRuntimeExports.jsx("span", { ...De("shadowOverlay") }), jsxRuntimeExports.jsx("span", { ...De("colorOverlay", { style: { backgroundColor: Ee } }) }), jsxRuntimeExports.jsx("span", { ...De("childrenOverlay"), children: Ce })] }) }); ColorSwatch.classes = __default__$h; ColorSwatch.displayName = "@mantine/core/ColorSwatch"; const [ColorPickerProvider, useColorPickerContext] = createOptionalContext(null), Thumb$1 = reactExports.forwardRef(({ position: fe, ...K }, pe) => jsxRuntimeExports.jsx(Box, { ref: pe, __vars: { "--thumb-y-offset": `${fe.y * 100}%`, "--thumb-x-offset": `${fe.x * 100}%` }, ...K })); Thumb$1.displayName = "@mantine/core/ColorPickerThumb"; var __default__$g = { wrapper: "m_fee9c77", preview: "m_9dddfbac", body: "m_bffecc3e", sliders: "m_3283bb96", thumb: "m_40d572ba", swatch: "m_d8ee6fd8", swatches: "m_5711e686", saturation: "m_202a296e", saturationOverlay: "m_11b3db02", slider: "m_d856d47d", sliderOverlay: "m_8f327113" }; const defaultProps$D = {}, ColorSlider = factory((fe, K) => { const pe = useProps("ColorSlider", defaultProps$D, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, onChange: Ee, onChangeEnd: be, maxValue: Ae, round: Se, size: Ce = "md", focusable: we = !0, value: Be, overlays: De, thumbColor: Re = "transparent", onScrubStart: Ie, onScrubEnd: Pe, __staticSelector: Ne = "ColorPicker", ...ke } = pe, Oe = useStyles({ name: Ne, classes: __default__$g, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve }), He = useColorPickerContext()?.getStyles || Oe, Ge = useMantineTheme(), [ze, We] = reactExports.useState({ y: 0, x: Be / Ae }), Xe = reactExports.useRef(ze), Ye = st => Se ? Math.round(st * Ae) : st * Ae, { ref: Ze } = useMove(({ x: st, y: Nt }) => { Xe.current = { x: st, y: Nt }, Ee?.(Ye(st)) }, { onScrubEnd: () => { const { x: st } = Xe.current; be?.(Ye(st)), Pe?.() }, onScrubStart: Ie }); useDidUpdate(() => { We({ y: 0, x: Be / Ae }) }, [Be]); const ot = (st, Nt) => { st.preventDefault(); const Je = clampUseMovePosition(Nt); Ee?.(Ye(Je.x)), be?.(Ye(Je.x)) }, qe = st => { switch (st.key) { case "ArrowRight": { ot(st, { x: ze.x + .05, y: ze.y }); break } case "ArrowLeft": { ot(st, { x: ze.x - .05, y: ze.y }); break } } }, Qe = De.map((st, Nt) => reactExports.createElement("div", { ...He("sliderOverlay"), style: st, key: Nt })); return jsxRuntimeExports.jsxs(Box, { ...ke, ref: useMergedRef(Ze, K), ...He("slider"), role: "slider", "aria-valuenow": Be, "aria-valuemax": Ae, "aria-valuemin": 0, tabIndex: we ? 0 : -1, onKeyDown: qe, "data-focus-ring": Ge.focusRing, __vars: { "--cp-thumb-size": `var(--cp-thumb-size-${Ce})` }, children: [Qe, jsxRuntimeExports.jsx(Thumb$1, { position: ze, ...He("thumb", { style: { top: rem(1), background: Re } }) })] }) }); ColorSlider.displayName = "@mantine/core/ColorSlider"; function round$1(fe, K = 0, pe = 10 ** K) { return Math.round(pe * fe) / pe } function hslaToHsva({ h: fe, s: K, l: pe, a: me }) { const ge = K * ((pe < 50 ? pe : 100 - pe) / 100); return { h: fe, s: ge > 0 ? 2 * ge / (pe + ge) * 100 : 0, v: pe + ge, a: me } } const angleUnits = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) }; function parseHue(fe, K = "deg") { return Number(fe) * (angleUnits[K] || 1) } const HSL_REGEXP = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i; function parseHsla(fe) { const K = HSL_REGEXP.exec(fe); return K ? hslaToHsva({ h: parseHue(K[1], K[2]), s: Number(K[3]), l: Number(K[4]), a: K[5] === void 0 ? 1 : Number(K[5]) / (K[6] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 } } function rgbaToHsva({ r: fe, g: K, b: pe, a: me }) { const ge = Math.max(fe, K, pe), xe = ge - Math.min(fe, K, pe), ye = xe ? ge === fe ? (K - pe) / xe : ge === K ? 2 + (pe - fe) / xe : 4 + (fe - K) / xe : 0; return { h: round$1(60 * (ye < 0 ? ye + 6 : ye), 3), s: round$1(ge ? xe / ge * 100 : 0, 3), v: round$1(ge / 255 * 100, 3), a: me } } function parseHex(fe) { const K = fe[0] === "#" ? fe.slice(1) : fe; return K.length === 3 ? rgbaToHsva({ r: parseInt(K[0] + K[0], 16), g: parseInt(K[1] + K[1], 16), b: parseInt(K[2] + K[2], 16), a: 1 }) : rgbaToHsva({ r: parseInt(K.slice(0, 2), 16), g: parseInt(K.slice(2, 4), 16), b: parseInt(K.slice(4, 6), 16), a: 1 }) } function parseHexa(fe) { const K = fe[0] === "#" ? fe.slice(1) : fe, pe = ye => round$1(parseInt(ye, 16) / 255, 3); if (K.length === 4) { const ye = K.slice(0, 3), ve = pe(K[3] + K[3]); return { ...parseHex(ye), a: ve } } const me = K.slice(0, 6), ge = pe(K.slice(6, 8)); return { ...parseHex(me), a: ge } } const RGB_REGEXP = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i; function parseRgba(fe) { const K = RGB_REGEXP.exec(fe); return K ? rgbaToHsva({ r: Number(K[1]) / (K[2] ? 100 / 255 : 1), g: Number(K[3]) / (K[4] ? 100 / 255 : 1), b: Number(K[5]) / (K[6] ? 100 / 255 : 1), a: K[7] === void 0 ? 1 : Number(K[7]) / (K[8] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 } } const VALIDATION_REGEXP = { hex: /^#?([0-9A-F]{3}){1,2}$/i, hexa: /^#?([0-9A-F]{4}){1,2}$/i, rgb: /^rgb\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i, rgba: /^rgba\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i, hsl: /hsl\(\s*(\d+)\s*,\s*(\d+(?:\.\d+)?%)\s*,\s*(\d+(?:\.\d+)?%)\)/i, hsla: /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/i }, CONVERTERS$1 = { hex: parseHex, hexa: parseHexa, rgb: parseRgba, rgba: parseRgba, hsl: parseHsla, hsla: parseHsla }; function isColorValid(fe) { for (const [, K] of Object.entries(VALIDATION_REGEXP)) if (K.test(fe)) return !0; return !1 } function parseColor(fe) { if (typeof fe != "string") return { h: 0, s: 0, v: 0, a: 1 }; if (fe === "transparent") return { h: 0, s: 0, v: 0, a: 0 }; const K = fe.trim(); for (const [pe, me] of Object.entries(VALIDATION_REGEXP)) if (me.test(K)) return CONVERTERS$1[pe](K); return { h: 0, s: 0, v: 0, a: 1 } } const defaultProps$C = {}, AlphaSlider = reactExports.forwardRef((fe, K) => { const { value: pe, onChange: me, onChangeEnd: ge, color: xe, ...ye } = useProps("AlphaSlider", defaultProps$C, fe); return jsxRuntimeExports.jsx(ColorSlider, { ...ye, ref: K, value: pe, onChange: ve => me?.(round$1(ve, 2)), onChangeEnd: ve => ge?.(round$1(ve, 2)), maxValue: 1, round: !1, "data-alpha": !0, overlays: [{ backgroundImage: "linear-gradient(45deg, var(--slider-checkers) 25%, transparent 25%), linear-gradient(-45deg, var(--slider-checkers) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--slider-checkers) 75%), linear-gradient(-45deg, var(--mantine-color-body) 75%, var(--slider-checkers) 75%)", backgroundSize: `${rem(8)} ${rem(8)}`, backgroundPosition: `0 0, 0 ${rem(4)}, ${rem(4)} ${rem(-4)}, ${rem(-4)} 0` }, { backgroundImage: `linear-gradient(90deg, transparent, ${xe})` }, { boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${rem(1)} inset, rgb(0, 0, 0, .15) 0 0 ${rem(4)} inset` }] }) }); AlphaSlider.displayName = "@mantine/core/AlphaSlider"; function hsvaToRgbaObject({ h: fe, s: K, v: pe, a: me }) { const ge = fe / 360 * 6, xe = K / 100, ye = pe / 100, ve = Math.floor(ge), _e = ye * (1 - xe), Ee = ye * (1 - (ge - ve) * xe), be = ye * (1 - (1 - ge + ve) * xe), Ae = ve % 6; return { r: round$1([ye, Ee, _e, _e, be, ye][Ae] * 255), g: round$1([be, ye, ye, Ee, _e, _e][Ae] * 255), b: round$1([_e, _e, be, ye, ye, Ee][Ae] * 255), a: round$1(me, 2) } } function hsvaToRgba(fe, K) { const { r: pe, g: me, b: ge, a: xe } = hsvaToRgbaObject(fe); return K ? `rgba(${pe}, ${me}, ${ge}, ${round$1(xe, 2)})` : `rgb(${pe}, ${me}, ${ge})` } function hsvaToHsl({ h: fe, s: K, v: pe, a: me }, ge) { const xe = (200 - K) * pe / 100, ye = { h: Math.round(fe), s: Math.round(xe > 0 && xe < 200 ? K * pe / 100 / (xe <= 100 ? xe : 200 - xe) * 100 : 0), l: Math.round(xe / 2) }; return ge ? `hsla(${ye.h}, ${ye.s}%, ${ye.l}%, ${round$1(me, 2)})` : `hsl(${ye.h}, ${ye.s}%, ${ye.l}%)` } function formatHexPart(fe) { const K = fe.toString(16); return K.length < 2 ? `0${K}` : K } function hsvaToHex(fe) { const { r: K, g: pe, b: me } = hsvaToRgbaObject(fe); return `#${formatHexPart(K)}${formatHexPart(pe)}${formatHexPart(me)}` } function hsvaToHexa(fe) { const K = Math.round(fe.a * 255); return `${hsvaToHex(fe)}${formatHexPart(K)}` } const CONVERTERS = { hex: hsvaToHex, hexa: fe => hsvaToHexa(fe), rgb: fe => hsvaToRgba(fe, !1), rgba: fe => hsvaToRgba(fe, !0), hsl: fe => hsvaToHsl(fe, !1), hsla: fe => hsvaToHsl(fe, !0) }; function convertHsvaTo(fe, K) { return K ? fe in CONVERTERS ? CONVERTERS[fe](K) : CONVERTERS.hex(K) : "#000000" } const HueSlider = reactExports.forwardRef((fe, K) => { const { value: pe, onChange: me, onChangeEnd: ge, color: xe, ...ye } = useProps("HueSlider", {}, fe); return jsxRuntimeExports.jsx(ColorSlider, { ...ye, ref: K, value: pe, onChange: me, onChangeEnd: ge, maxValue: 360, thumbColor: `hsl(${pe}, 100%, 50%)`, round: !0, "data-hue": !0, overlays: [{ backgroundImage: "linear-gradient(to right,hsl(0,100%,50%),hsl(60,100%,50%),hsl(120,100%,50%),hsl(170,100%,50%),hsl(240,100%,50%),hsl(300,100%,50%),hsl(360,100%,50%))" }, { boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${rem(1)} inset, rgb(0, 0, 0, .15) 0 0 ${rem(4)} inset` }] }) }); HueSlider.displayName = "@mantine/core/HueSlider"; function Saturation({ className: fe, onChange: K, onChangeEnd: pe, value: me, saturationLabel: ge, focusable: xe = !0, size: ye, color: ve, onScrubStart: _e, onScrubEnd: Ee, ...be }) { const { getStyles: Ae } = useColorPickerContext(), [Se, Ce] = reactExports.useState({ x: me.s / 100, y: 1 - me.v / 100 }), we = reactExports.useRef(Se), { ref: Be } = useMove(({ x: Ie, y: Pe }) => { we.current = { x: Ie, y: Pe }, K({ s: Math.round(Ie * 100), v: Math.round((1 - Pe) * 100) }) }, { onScrubEnd: () => { const { x: Ie, y: Pe } = we.current; pe({ s: Math.round(Ie * 100), v: Math.round((1 - Pe) * 100) }), Ee?.() }, onScrubStart: _e }); reactExports.useEffect(() => { Ce({ x: me.s / 100, y: 1 - me.v / 100 }) }, [me.s, me.v]); const De = (Ie, Pe) => { Ie.preventDefault(); const Ne = clampUseMovePosition(Pe); K({ s: Math.round(Ne.x * 100), v: Math.round((1 - Ne.y) * 100) }), pe({ s: Math.round(Ne.x * 100), v: Math.round((1 - Ne.y) * 100) }) }, Re = Ie => { switch (Ie.key) { case "ArrowUp": { De(Ie, { y: Se.y - .05, x: Se.x }); break } case "ArrowDown": { De(Ie, { y: Se.y + .05, x: Se.x }); break } case "ArrowRight": { De(Ie, { x: Se.x + .05, y: Se.y }); break } case "ArrowLeft": { De(Ie, { x: Se.x - .05, y: Se.y }); break } } }; return jsxRuntimeExports.jsxs(Box, { ...Ae("saturation"), ref: Be, ...be, role: "slider", "aria-label": ge, "aria-valuenow": Se.x, "aria-valuetext": convertHsvaTo("rgba", me), tabIndex: xe ? 0 : -1, onKeyDown: Re, children: [jsxRuntimeExports.jsx("div", { ...Ae("saturationOverlay", { style: { backgroundColor: `hsl(${me.h}, 100%, 50%)` } }) }), jsxRuntimeExports.jsx("div", { ...Ae("saturationOverlay", { style: { backgroundImage: "linear-gradient(90deg, #fff, transparent)" } }) }), jsxRuntimeExports.jsx("div", { ...Ae("saturationOverlay", { style: { backgroundImage: "linear-gradient(0deg, #000, transparent)" } }) }), jsxRuntimeExports.jsx(Thumb$1, { position: Se, ...Ae("thumb", { style: { backgroundColor: ve } }) })] }) } Saturation.displayName = "@mantine/core/Saturation"; const Swatches = reactExports.forwardRef(({ className: fe, datatype: K, setValue: pe, onChangeEnd: me, size: ge, focusable: xe, data: ye, swatchesPerRow: ve, ..._e }, Ee) => { const be = useColorPickerContext(), Ae = ye.map((Se, Ce) => reactExports.createElement(ColorSwatch, { ...be.getStyles("swatch"), unstyled: be.unstyled, component: "button", type: "button", color: Se, key: Ce, radius: "sm", onClick: () => { pe(Se), me?.(Se) }, "aria-label": Se, tabIndex: xe ? 0 : -1, "data-swatch": !0 })); return jsxRuntimeExports.jsx(Box, { ...be.getStyles("swatches"), ref: Ee, ..._e, children: Ae }) }); Swatches.displayName = "@mantine/core/Swatches"; const defaultProps$B = { swatchesPerRow: 7, withPicker: !0, focusable: !0, size: "md", __staticSelector: "ColorPicker" }, varsResolver$i = (fe, { size: K, swatchesPerRow: pe }) => ({ wrapper: { "--cp-preview-size": getSize(K, "cp-preview-size"), "--cp-width": getSize(K, "cp-width"), "--cp-body-spacing": getSpacing(K), "--cp-swatch-size": `${100 / pe}%`, "--cp-thumb-size": getSize(K, "cp-thumb-size"), "--cp-saturation-height": getSize(K, "cp-saturation-height") } }), ColorPicker = factory((fe, K) => { const pe = useProps("ColorPicker", defaultProps$B, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, format: Ee, value: be, defaultValue: Ae, onChange: Se, onChangeEnd: Ce, withPicker: we, size: Be, saturationLabel: De, hueLabel: Re, alphaLabel: Ie, focusable: Pe, swatches: Ne, swatchesPerRow: ke, fullWidth: Oe, onColorSwatchClick: Ue, __staticSelector: He, mod: Ge, ...ze } = pe, We = useStyles({ name: He, props: pe, classes: __default__$g, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, rootSelector: "wrapper", vars: _e, varsResolver: varsResolver$i }), Xe = reactExports.useRef(Ee), Ye = reactExports.useRef(""), Ze = reactExports.useRef(-1), ot = reactExports.useRef(!1), qe = Ee === "hexa" || Ee === "rgba" || Ee === "hsla", [Qe, st, Nt] = useUncontrolled({ value: be, defaultValue: Ae, finalValue: "#FFFFFF", onChange: Se }), [Je, jt] = reactExports.useState(parseColor(Qe)), Xt = () => { window.clearTimeout(Ze.current), ot.current = !0 }, ct = () => { window.clearTimeout(Ze.current), Ze.current = window.setTimeout(() => { ot.current = !1 }, 200) }, nn = $t => { jt(an => { const gn = { ...an, ...$t }; return Ye.current = convertHsvaTo(Xe.current, gn), gn }), st(Ye.current) }; return useDidUpdate(() => { isColorValid(be) && !ot.current && jt(parseColor(be)) }, [be]), useDidUpdate(() => { Xe.current = Ee, st(convertHsvaTo(Ee, Je)) }, [Ee]), jsxRuntimeExports.jsx(ColorPickerProvider, { value: { getStyles: We, unstyled: ve }, children: jsxRuntimeExports.jsxs(Box, { ref: K, ...We("wrapper"), size: Be, mod: [{ "full-width": Oe }, Ge], ...ze, children: [we && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Saturation, { value: Je, onChange: nn, onChangeEnd: ({ s: $t, v: an }) => Ce?.(convertHsvaTo(Xe.current, { ...Je, s: $t, v: an })), color: Qe, size: Be, focusable: Pe, saturationLabel: De, onScrubStart: Xt, onScrubEnd: ct }), jsxRuntimeExports.jsxs("div", { ...We("body"), children: [jsxRuntimeExports.jsxs("div", { ...We("sliders"), children: [jsxRuntimeExports.jsx(HueSlider, { value: Je.h, onChange: $t => nn({ h: $t }), onChangeEnd: $t => Ce?.(convertHsvaTo(Xe.current, { ...Je, h: $t })), size: Be, focusable: Pe, "aria-label": Re, onScrubStart: Xt, onScrubEnd: ct }), qe && jsxRuntimeExports.jsx(AlphaSlider, { value: Je.a, onChange: $t => nn({ a: $t }), onChangeEnd: $t => { Ce?.(convertHsvaTo(Xe.current, { ...Je, a: $t })) }, size: Be, color: convertHsvaTo("hex", Je), focusable: Pe, "aria-label": Ie, onScrubStart: Xt, onScrubEnd: ct })] }), qe && jsxRuntimeExports.jsx(ColorSwatch, { color: Qe, radius: "sm", size: "var(--cp-preview-size)", ...We("preview") })] })] }), Array.isArray(Ne) && jsxRuntimeExports.jsx(Swatches, { data: Ne, swatchesPerRow: ke, focusable: Pe, setValue: st, onChangeEnd: $t => { const an = convertHsvaTo(Ee, parseColor($t)); Ue?.(an), Ce?.(an), Nt || jt(parseColor($t)) } })] }) }) }); ColorPicker.classes = __default__$g; ColorPicker.displayName = "@mantine/core/ColorPicker"; function EyeDropperIcon({ style: fe, ...K }) { return jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", style: { width: "var(--ci-eye-dropper-icon-size)", height: "var(--ci-eye-dropper-icon-size)", ...fe }, viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", ...K, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }), jsxRuntimeExports.jsx("path", { d: "M12 3l0 4" }), jsxRuntimeExports.jsx("path", { d: "M12 21l0 -3" }), jsxRuntimeExports.jsx("path", { d: "M3 12l4 0" }), jsxRuntimeExports.jsx("path", { d: "M21 12l-3 0" }), jsxRuntimeExports.jsx("path", { d: "M12 12l0 .01" })] }) } var __default__$f = { eyeDropperIcon: "m_b077c2bc", colorPreview: "m_c5ccdcab", dropdown: "m_5ece2cd7" }; const defaultProps$A = { format: "hex", fixOnBlur: !0, withPreview: !0, swatchesPerRow: 7, withPicker: !0, popoverProps: { transitionProps: { transition: "fade", duration: 0 } }, withEyeDropper: !0 }, varsResolver$h = (fe, { size: K }) => ({ eyeDropperIcon: { "--ci-eye-dropper-icon-size": getSize(K, "ci-eye-dropper-icon-size") }, colorPreview: { "--ci-preview-size": getSize(K, "ci-preview-size") } }), ColorInput = factory((fe, K) => { const pe = useProps("ColorInput", defaultProps$A, fe), { classNames: me, styles: ge, unstyled: xe, disallowInput: ye, fixOnBlur: ve, popoverProps: _e, withPreview: Ee, withEyeDropper: be, eyeDropperIcon: Ae, closeOnColorSwatchClick: Se, eyeDropperButtonProps: Ce, value: we, defaultValue: Be, onChange: De, onChangeEnd: Re, onClick: Ie, onFocus: Pe, onBlur: Ne, inputProps: ke, format: Oe, wrapperProps: Ue, readOnly: He, withPicker: Ge, swatches: ze, disabled: We, leftSection: Xe, rightSection: Ye, swatchesPerRow: Ze, ...ot } = useInputProps("ColorInput", defaultProps$A, fe), qe = useStyles({ name: "ColorInput", props: pe, classes: __default__$f, classNames: me, styles: ge, unstyled: xe, rootSelector: "wrapper", vars: pe.vars, varsResolver: varsResolver$h }), { resolvedClassNames: Qe, resolvedStyles: st } = useResolvedStylesApi({ classNames: me, styles: ge, props: pe }), [Nt, Je] = reactExports.useState(!1), [jt, Xt] = reactExports.useState(""), [ct, nn] = useUncontrolled({ value: we, defaultValue: Be, finalValue: "", onChange: De }), { supported: $t, open: an } = useEyeDropper(), gn = jsxRuntimeExports.jsx(ActionIcon, { ...Ce, ...qe("eyeDropperButton", { className: Ce?.className, style: Ce?.style }), variant: "subtle", color: "gray", size: ke.size, unstyled: xe, onClick: () => an().then(Gn => { if (Gn?.sRGBHex) { const wn = convertHsvaTo(Oe, parseColor(Gn.sRGBHex)); nn(wn), Re?.(wn) } }).catch(() => { }), children: Ae || jsxRuntimeExports.jsx(EyeDropperIcon, { ...qe("eyeDropperIcon") }) }), Mn = Gn => { Pe?.(Gn), Je(!0) }, Xn = Gn => { ve && nn(jt), Ne?.(Gn), Je(!1) }, Ln = Gn => { Ie?.(Gn), Je(!0) }; return reactExports.useEffect(() => { (isColorValid(ct) || ct.trim() === "") && Xt(ct) }, [ct]), useDidUpdate(() => { isColorValid(ct) && nn(convertHsvaTo(Oe, parseColor(ct))) }, [Oe]), jsxRuntimeExports.jsx(Input.Wrapper, { ...Ue, classNames: Qe, styles: st, __staticSelector: "ColorInput", children: jsxRuntimeExports.jsxs(Popover, { __staticSelector: "ColorInput", position: "bottom-start", offset: 5, opened: Nt, ..._e, classNames: Qe, styles: st, unstyled: xe, withRoles: !1, disabled: He || Ge === !1 && (!Array.isArray(ze) || ze.length === 0), children: [jsxRuntimeExports.jsx(Popover.Target, { children: jsxRuntimeExports.jsx(Input, { autoComplete: "off", ...ot, ...ke, classNames: Qe, styles: st, disabled: We, ref: K, __staticSelector: "ColorInput", onFocus: Mn, onBlur: Xn, onClick: Ln, spellCheck: !1, value: ct, onChange: Gn => { const wn = Gn.currentTarget.value; nn(wn), isColorValid(wn) && Re?.(convertHsvaTo(Oe, parseColor(wn))) }, leftSection: Xe || (Ee ? jsxRuntimeExports.jsx(ColorSwatch, { color: isColorValid(ct) ? ct : "#fff", size: "var(--ci-preview-size)", ...qe("colorPreview") }) : null), readOnly: ye || He, pointer: ye, unstyled: xe, rightSection: Ye || (be && !We && !He && $t ? gn : null) }) }), jsxRuntimeExports.jsx(Popover.Dropdown, { onMouseDown: Gn => Gn.preventDefault(), className: __default__$f.dropdown, children: jsxRuntimeExports.jsx(ColorPicker, { __staticSelector: "ColorInput", value: ct, onChange: nn, onChangeEnd: Re, format: Oe, swatches: ze, swatchesPerRow: Ze, withPicker: Ge, size: ke.size, focusable: !1, unstyled: xe, styles: st, classNames: Qe, onColorSwatchClick: () => Se && Je(!1) }) })] }) }) }); ColorInput.classes = InputBase.classes; ColorInput.displayName = "@mantine/core/ColorInput"; var __default__$e = { root: "m_7485cace" }; const defaultProps$z = {}, varsResolver$g = (fe, { size: K, fluid: pe }) => ({ root: { "--container-size": pe ? void 0 : getSize(K, "container-size") } }), Container = factory((fe, K) => { const pe = useProps("Container", defaultProps$z, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, fluid: Ee, mod: be, ...Ae } = pe, Se = useStyles({ name: "Container", classes: __default__$e, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$g }); return jsxRuntimeExports.jsx(Box, { ref: K, mod: [{ fluid: Ee }, be], ...Se("root"), ...Ae }) }); Container.classes = __default__$e; Container.displayName = "@mantine/core/Container"; const defaultProps$y = { timeout: 1e3 }; function CopyButton(fe) { const { children: K, timeout: pe, value: me, ...ge } = useProps("CopyButton", defaultProps$y, fe), xe = useClipboard({ timeout: pe }), ye = () => xe.copy(me); return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: K({ copy: ye, copied: xe.copied, ...ge }) }) } CopyButton.displayName = "@mantine/core/CopyButton"; var __default__$d = { root: "m_3eebeb36", label: "m_9e365f20" }; const defaultProps$x = { orientation: "horizontal" }, varsResolver$f = (fe, { color: K, variant: pe, size: me }) => ({ root: { "--divider-color": K ? getThemeColor(K, fe) : void 0, "--divider-border-style": pe, "--divider-size": getSize(me, "divider-size") } }), Divider = factory((fe, K) => { const pe = useProps("Divider", defaultProps$x, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, color: Ee, orientation: be, label: Ae, labelPosition: Se, mod: Ce, ...we } = pe, Be = useStyles({ name: "Divider", classes: __default__$d, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$f }); return jsxRuntimeExports.jsx(Box, { ref: K, mod: [{ orientation: be, "with-label": !!Ae }, Ce], ...Be("root"), ...we, role: "separator", children: Ae && jsxRuntimeExports.jsx(Box, { component: "span", mod: { position: Se }, ...Be("label"), children: Ae }) }) }); Divider.classes = __default__$d; Divider.displayName = "@mantine/core/Divider"; var __default__$c = { root: "m_9e117634" }; const defaultProps$w = {}, varsResolver$e = (fe, { radius: K, fit: pe }) => ({ root: { "--image-radius": K === void 0 ? void 0 : getRadius(K), "--image-object-fit": pe } }), Image$1 = polymorphicFactory((fe, K) => { const pe = useProps("Image", defaultProps$w, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, onError: Ee, src: be, radius: Ae, fit: Se, fallbackSrc: Ce, mod: we, ...Be } = pe, [De, Re] = reactExports.useState(!be); reactExports.useEffect(() => Re(!be), [be]); const Ie = useStyles({ name: "Image", classes: __default__$c, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$e }); return De && Ce ? jsxRuntimeExports.jsx(Box, { component: "img", ref: K, src: Ce, ...Ie("root"), onError: Ee, mod: ["fallback", we], ...Be }) : jsxRuntimeExports.jsx(Box, { component: "img", ref: K, ...Ie("root"), src: be, onError: Pe => { Ee?.(Pe), Re(!0) }, mod: we, ...Be }) }); Image$1.classes = __default__$c; Image$1.displayName = "@mantine/core/Image"; var index$2 = reactExports.useLayoutEffect, useLatest = function (K) { var pe = React$4.useRef(K); return index$2(function () { pe.current = K }), pe }, updateRef = function (K, pe) { if (typeof K == "function") { K(pe); return } K.current = pe }, useComposedRef = function (K, pe) { var me = React$4.useRef(); return React$4.useCallback(function (ge) { K.current = ge, me.current && updateRef(me.current, null), me.current = pe, pe && updateRef(pe, ge) }, [pe]) }, HIDDEN_TEXTAREA_STYLE = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0", display: "block" }, forceHiddenStyles = function (K) { Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (pe) { K.style.setProperty(pe, HIDDEN_TEXTAREA_STYLE[pe], "important") }) }, forceHiddenStyles$1 = forceHiddenStyles, hiddenTextarea = null, getHeight = function (K, pe) { var me = K.scrollHeight; return pe.sizingStyle.boxSizing === "border-box" ? me + pe.borderSize : me - pe.paddingSize }; function calculateNodeHeight(fe, K, pe, me) { pe === void 0 && (pe = 1), me === void 0 && (me = 1 / 0), hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tabindex", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), forceHiddenStyles$1(hiddenTextarea)), hiddenTextarea.parentNode === null && document.body.appendChild(hiddenTextarea); var ge = fe.paddingSize, xe = fe.borderSize, ye = fe.sizingStyle, ve = ye.boxSizing; Object.keys(ye).forEach(function (Se) { var Ce = Se; hiddenTextarea.style[Ce] = ye[Ce] }), forceHiddenStyles$1(hiddenTextarea), hiddenTextarea.value = K; var _e = getHeight(hiddenTextarea, fe); hiddenTextarea.value = K, _e = getHeight(hiddenTextarea, fe), hiddenTextarea.value = "x"; var Ee = hiddenTextarea.scrollHeight - ge, be = Ee * pe; ve === "border-box" && (be = be + ge + xe), _e = Math.max(be, _e); var Ae = Ee * me; return ve === "border-box" && (Ae = Ae + ge + xe), _e = Math.min(Ae, _e), [_e, Ee] } var noop$2 = function () { }, pick = function (K, pe) { return K.reduce(function (me, ge) { return me[ge] = pe[ge], me }, {}) }, SIZING_STYLE = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width", "wordBreak", "wordSpacing", "scrollbarGutter"], isIE = !!document.documentElement.currentStyle, getSizingData = function (K) { var pe = window.getComputedStyle(K); if (pe === null) return null; var me = pick(SIZING_STYLE, pe), ge = me.boxSizing; if (ge === "") return null; isIE && ge === "border-box" && (me.width = parseFloat(me.width) + parseFloat(me.borderRightWidth) + parseFloat(me.borderLeftWidth) + parseFloat(me.paddingRight) + parseFloat(me.paddingLeft) + "px"); var xe = parseFloat(me.paddingBottom) + parseFloat(me.paddingTop), ye = parseFloat(me.borderBottomWidth) + parseFloat(me.borderTopWidth); return { sizingStyle: me, paddingSize: xe, borderSize: ye } }, getSizingData$1 = getSizingData; function useListener(fe, K, pe) { var me = useLatest(pe); reactExports.useLayoutEffect(function () { var ge = function (ye) { return me.current(ye) }; if (fe) return fe.addEventListener(K, ge), function () { return fe.removeEventListener(K, ge) } }, []) } var useFormResetListener = function (K, pe) { useListener(document.body, "reset", function (me) { K.current.form === me.target && pe(me) }) }, useWindowResizeListener = function (K) { useListener(window, "resize", K) }, useFontsLoadedListener = function (K) { useListener(document.fonts, "loadingdone", K) }, _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], TextareaAutosize = function (K, pe) { var me = K.cacheMeasurements, ge = K.maxRows, xe = K.minRows, ye = K.onChange, ve = ye === void 0 ? noop$2 : ye, _e = K.onHeightChange, Ee = _e === void 0 ? noop$2 : _e, be = _objectWithoutPropertiesLoose(K, _excluded), Ae = be.value !== void 0, Se = reactExports.useRef(null), Ce = useComposedRef(Se, pe), we = reactExports.useRef(0), Be = reactExports.useRef(), De = function () { var Pe = Se.current, Ne = me && Be.current ? Be.current : getSizingData$1(Pe); if (Ne) { Be.current = Ne; var ke = calculateNodeHeight(Ne, Pe.value || Pe.placeholder || "x", xe, ge), Oe = ke[0], Ue = ke[1]; we.current !== Oe && (we.current = Oe, Pe.style.setProperty("height", Oe + "px", "important"), Ee(Oe, { rowHeight: Ue })) } }, Re = function (Pe) { Ae || De(), ve(Pe) }; return reactExports.useLayoutEffect(De), useFormResetListener(Se, function () { if (!Ae) { var Ie = Se.current.value; requestAnimationFrame(function () { var Pe = Se.current; Pe && Ie !== Pe.value && De() }) } }), useWindowResizeListener(De), useFontsLoadedListener(De), reactExports.createElement("textarea", _extends$2({}, be, { onChange: Re, ref: Ce })) }, index$1 = reactExports.forwardRef(TextareaAutosize); const defaultProps$v = {}, Textarea = factory((fe, K) => { const { autosize: pe, maxRows: me, minRows: ge, __staticSelector: xe, resize: ye, ...ve } = useProps("Textarea", defaultProps$v, fe), _e = pe && getEnv() !== "test", Ee = _e ? { maxRows: me, minRows: ge } : {}; return jsxRuntimeExports.jsx(InputBase, { component: _e ? index$1 : "textarea", ref: K, ...ve, __staticSelector: xe || "Textarea", multiline: !0, "data-no-overflow": pe && me === void 0 || void 0, __vars: { "--input-resize": ye }, ...Ee }) }); Textarea.classes = InputBase.classes; Textarea.displayName = "@mantine/core/Textarea"; const [ListProvider, useListContext] = createSafeContext("List component was not found in tree"); var __default__$b = { root: "m_abbac491", item: "m_abb6bec2", itemWrapper: "m_75cd9f71", itemIcon: "m_60f83e5b" }; const defaultProps$u = {}, ListItem = factory((fe, K) => { const pe = useProps("ListItem", defaultProps$u, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, icon: _e, children: Ee, mod: be, ...Ae } = pe, Se = useListContext(), Ce = _e || Se.icon, we = { classNames: me, styles: ye }; return jsxRuntimeExports.jsx(Box, { ...Se.getStyles("item", { ...we, className: ge, style: xe }), component: "li", mod: [{ "with-icon": !!Ce, centered: Se.center }, be], ref: K, ...Ae, children: jsxRuntimeExports.jsxs("div", { ...Se.getStyles("itemWrapper", we), children: [Ce && jsxRuntimeExports.jsx("span", { ...Se.getStyles("itemIcon", we), children: Ce }), jsxRuntimeExports.jsx("span", { ...Se.getStyles("itemLabel", we), children: Ee })] }) }) }); ListItem.classes = __default__$b; ListItem.displayName = "@mantine/core/ListItem"; const defaultProps$t = { type: "unordered" }, varsResolver$d = (fe, { size: K, spacing: pe }) => ({ root: { "--list-fz": getFontSize(K), "--list-lh": getLineHeight(K), "--list-spacing": getSpacing(pe) } }), List = factory((fe, K) => { const pe = useProps("List", defaultProps$t, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, children: Ee, type: be, withPadding: Ae, icon: Se, spacing: Ce, center: we, listStyleType: Be, mod: De, ...Re } = pe, Ie = useStyles({ name: "List", classes: __default__$b, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$d }); return jsxRuntimeExports.jsx(ListProvider, { value: { center: we, icon: Se, getStyles: Ie }, children: jsxRuntimeExports.jsx(Box, { ...Ie("root", { style: { listStyleType: Be } }), component: be === "unordered" ? "ul" : "ol", mod: [{ "with-padding": Ae }, De], ref: K, ...Re, children: Ee }) }) }); List.classes = __default__$b; List.displayName = "@mantine/core/List"; List.Item = ListItem; const [ModalProvider, useModalContext] = createSafeContext("Modal component was not found in tree"); var __default__$a = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" }; const defaultProps$s = {}, ModalBody = factory((fe, K) => { const pe = useProps("ModalBody", defaultProps$s, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, ..._e } = pe, Ee = useModalContext(); return jsxRuntimeExports.jsx(ModalBaseBody, { ref: K, ...Ee.getStyles("body", { classNames: me, style: xe, styles: ye, className: ge }), ..._e }) }); ModalBody.classes = __default__$a; ModalBody.displayName = "@mantine/core/ModalBody"; const defaultProps$r = {}, ModalCloseButton = factory((fe, K) => { const pe = useProps("ModalCloseButton", defaultProps$r, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, ..._e } = pe, Ee = useModalContext(); return jsxRuntimeExports.jsx(ModalBaseCloseButton, { ref: K, ...Ee.getStyles("close", { classNames: me, style: xe, styles: ye, className: ge }), ..._e }) }); ModalCloseButton.classes = __default__$a; ModalCloseButton.displayName = "@mantine/core/ModalCloseButton"; const defaultProps$q = {}, ModalContent = factory((fe, K) => { const pe = useProps("ModalContent", defaultProps$q, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, children: _e, __hidden: Ee, ...be } = pe, Ae = useModalContext(), Se = Ae.scrollAreaComponent || NativeScrollArea; return jsxRuntimeExports.jsx(ModalBaseContent, { ...Ae.getStyles("content", { className: ge, style: xe, styles: ye, classNames: me }), innerProps: Ae.getStyles("inner", { className: ge, style: xe, styles: ye, classNames: me }), "data-full-screen": Ae.fullScreen || void 0, "data-modal-content": !0, "data-hidden": Ee || void 0, ref: K, ...be, children: jsxRuntimeExports.jsx(Se, { style: { maxHeight: Ae.fullScreen ? "100dvh" : `calc(100dvh - (${rem(Ae.yOffset)} * 2))` }, children: _e }) }) }); ModalContent.classes = __default__$a; ModalContent.displayName = "@mantine/core/ModalContent"; const defaultProps$p = {}, ModalHeader = factory((fe, K) => { const pe = useProps("ModalHeader", defaultProps$p, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, ..._e } = pe, Ee = useModalContext(); return jsxRuntimeExports.jsx(ModalBaseHeader, { ref: K, ...Ee.getStyles("header", { classNames: me, style: xe, styles: ye, className: ge }), ..._e }) }); ModalHeader.classes = __default__$a; ModalHeader.displayName = "@mantine/core/ModalHeader"; const defaultProps$o = {}, ModalOverlay = factory((fe, K) => { const pe = useProps("ModalOverlay", defaultProps$o, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, ..._e } = pe, Ee = useModalContext(); return jsxRuntimeExports.jsx(ModalBaseOverlay, { ref: K, ...Ee.getStyles("overlay", { classNames: me, style: xe, styles: ye, className: ge }), ..._e }) }); ModalOverlay.classes = __default__$a; ModalOverlay.displayName = "@mantine/core/ModalOverlay"; const defaultProps$n = { __staticSelector: "Modal", closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: getDefaultZIndex("modal"), transitionProps: { duration: 200, transition: "fade-down" }, yOffset: "5dvh" }, varsResolver$c = (fe, { radius: K, size: pe, yOffset: me, xOffset: ge }) => ({ root: { "--modal-radius": K === void 0 ? void 0 : getRadius(K), "--modal-size": getSize(pe, "modal-size"), "--modal-y-offset": rem(me), "--modal-x-offset": rem(ge) } }), ModalRoot = factory((fe, K) => { const pe = useProps("ModalRoot", defaultProps$n, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, yOffset: Ee, scrollAreaComponent: be, radius: Ae, fullScreen: Se, centered: Ce, xOffset: we, __staticSelector: Be, ...De } = pe, Re = useStyles({ name: Be, classes: __default__$a, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$c }); return jsxRuntimeExports.jsx(ModalProvider, { value: { yOffset: Ee, scrollAreaComponent: be, getStyles: Re, fullScreen: Se }, children: jsxRuntimeExports.jsx(ModalBase, { ref: K, ...Re("root"), "data-full-screen": Se || void 0, "data-centered": Ce || void 0, "data-offset-scrollbars": be === ScrollArea.Autosize || void 0, unstyled: ve, ...De }) }) }); ModalRoot.classes = __default__$a; ModalRoot.displayName = "@mantine/core/ModalRoot"; const [ModalStackProvider, useModalStackContext] = createOptionalContext(); function ModalStack({ children: fe }) { const [K, pe] = reactExports.useState([]), [me, ge] = reactExports.useState(getDefaultZIndex("modal")); return jsxRuntimeExports.jsx(ModalStackProvider, { value: { stack: K, addModal: (xe, ye) => { pe(ve => [...new Set([...ve, xe])]), ge(ve => typeof ye == "number" && typeof ve == "number" ? Math.max(ve, ye) : ve) }, removeModal: xe => pe(ye => ye.filter(ve => ve !== xe)), getZIndex: xe => `calc(${me} + ${K.indexOf(xe)} + 1)`, currentId: K[K.length - 1], maxZIndex: me }, children: fe }) } ModalStack.displayName = "@mantine/core/ModalStack"; const defaultProps$m = {}, ModalTitle = factory((fe, K) => { const pe = useProps("ModalTitle", defaultProps$m, fe), { classNames: me, className: ge, style: xe, styles: ye, vars: ve, ..._e } = pe, Ee = useModalContext(); return jsxRuntimeExports.jsx(ModalBaseTitle, { ref: K, ...Ee.getStyles("title", { classNames: me, style: xe, styles: ye, className: ge }), ..._e }) }); ModalTitle.classes = __default__$a; ModalTitle.displayName = "@mantine/core/ModalTitle"; const defaultProps$l = { closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: getDefaultZIndex("modal"), transitionProps: { duration: 200, transition: "fade-down" }, withOverlay: !0, withCloseButton: !0 }, Modal = factory((fe, K) => { const { title: pe, withOverlay: me, overlayProps: ge, withCloseButton: xe, closeButtonProps: ye, children: ve, radius: _e, opened: Ee, stackId: be, zIndex: Ae, ...Se } = useProps("Modal", defaultProps$l, fe), Ce = useModalStackContext(), we = !!pe || xe, Be = Ce && be ? { closeOnEscape: Ce.currentId === be, trapFocus: Ce.currentId === be, zIndex: Ce.getZIndex(be) } : {}, De = me === !1 ? !1 : be && Ce ? Ce.currentId === be : Ee; return reactExports.useEffect(() => { Ce && be && (Ee ? Ce.addModal(be, Ae || getDefaultZIndex("modal")) : Ce.removeModal(be)) }, [Ee, be, Ae]), jsxRuntimeExports.jsxs(ModalRoot, { ref: K, radius: _e, opened: Ee, zIndex: Ce && be ? Ce.getZIndex(be) : Ae, ...Se, ...Be, children: [me && jsxRuntimeExports.jsx(ModalOverlay, { visible: De, transitionProps: Ce && be ? { duration: 0 } : void 0, ...ge }), jsxRuntimeExports.jsxs(ModalContent, { radius: _e, __hidden: Ce && be && Ee ? be !== Ce.currentId : !1, children: [we && jsxRuntimeExports.jsxs(ModalHeader, { children: [pe && jsxRuntimeExports.jsx(ModalTitle, { children: pe }), xe && jsxRuntimeExports.jsx(ModalCloseButton, { ...ye })] }), jsxRuntimeExports.jsx(ModalBody, { children: ve })] })] }) }); Modal.classes = __default__$a; Modal.displayName = "@mantine/core/Modal"; Modal.Root = ModalRoot; Modal.Overlay = ModalOverlay; Modal.Content = ModalContent; Modal.Body = ModalBody; Modal.Header = ModalHeader; Modal.Title = ModalTitle; Modal.CloseButton = ModalCloseButton; Modal.Stack = ModalStack; var __default__$9 = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" }; const defaultProps$k = { withCloseButton: !0 }, varsResolver$b = (fe, { radius: K, color: pe }) => ({ root: { "--notification-radius": K === void 0 ? void 0 : getRadius(K), "--notification-color": pe ? getThemeColor(pe, fe) : void 0 } }), Notification = factory((fe, K) => { const pe = useProps("Notification", defaultProps$k, fe), { className: me, color: ge, radius: xe, loading: ye, withCloseButton: ve, withBorder: _e, title: Ee, icon: be, children: Ae, onClose: Se, closeButtonProps: Ce, classNames: we, style: Be, styles: De, unstyled: Re, variant: Ie, vars: Pe, mod: Ne, loaderProps: ke, role: Oe, ...Ue } = pe, He = useStyles({ name: "Notification", classes: __default__$9, props: pe, className: me, style: Be, classNames: we, styles: De, unstyled: Re, vars: Pe, varsResolver: varsResolver$b }); return jsxRuntimeExports.jsxs(Box, { ...He("root"), mod: [{ "data-with-icon": !!be || ye, "data-with-border": _e }, Ne], ref: K, variant: Ie, role: Oe || "alert", ...Ue, children: [be && !ye && jsxRuntimeExports.jsx("div", { ...He("icon"), children: be }), ye && jsxRuntimeExports.jsx(Loader$1, { size: 28, color: ge, ...ke, ...He("loader") }), jsxRuntimeExports.jsxs("div", { ...He("body"), children: [Ee && jsxRuntimeExports.jsx("div", { ...He("title"), children: Ee }), jsxRuntimeExports.jsx(Box, { ...He("description"), mod: { "data-with-title": !!Ee }, children: Ae })] }), ve && jsxRuntimeExports.jsx(CloseButton, { iconSize: 16, color: "gray", ...Ce, unstyled: Re, onClick: Se, ...He("closeButton") })] }) }); Notification.classes = __default__$9; Notification.displayName = "@mantine/core/Notification"; function __rest(fe, K) { var pe = {}; for (var me in fe) Object.prototype.hasOwnProperty.call(fe, me) && K.indexOf(me) < 0 && (pe[me] = fe[me]); if (fe != null && typeof Object.getOwnPropertySymbols == "function") for (var ge = 0, me = Object.getOwnPropertySymbols(fe); ge < me.length; ge++)K.indexOf(me[ge]) < 0 && Object.prototype.propertyIsEnumerable.call(fe, me[ge]) && (pe[me[ge]] = fe[me[ge]]); return pe } var SourceType; (function (fe) { fe.event = "event", fe.props = "prop" })(SourceType || (SourceType = {})); function noop$1() { } function memoizeOnce(fe) { var K, pe = void 0; return function () { for (var me = [], ge = arguments.length; ge--;)me[ge] = arguments[ge]; return K && me.length === K.length && me.every(function (xe, ye) { return xe === K[ye] }) || (K = me, pe = fe.apply(void 0, me)), pe } } function charIsNumber(fe) { return !!(fe || "").match(/\d/) } function isNil(fe) { return fe == null } function isNanValue(fe) { return typeof fe == "number" && isNaN(fe) } function isNotValidValue(fe) { return isNil(fe) || isNanValue(fe) || typeof fe == "number" && !isFinite(fe) } function escapeRegExp(fe) { return fe.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&") } function getThousandsGroupRegex(fe) { switch (fe) { case "lakh": return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g; case "wan": return /(\d)(?=(\d{4})+(?!\d))/g; case "thousand": default: return /(\d)(?=(\d{3})+(?!\d))/g } } function applyThousandSeparator(fe, K, pe) { var me = getThousandsGroupRegex(pe), ge = fe.search(/[1-9]/); return ge = ge === -1 ? fe.length : ge, fe.substring(0, ge) + fe.substring(ge, fe.length).replace(me, "$1" + K) } function usePersistentCallback(fe) { var K = reactExports.useRef(fe); K.current = fe; var pe = reactExports.useRef(function () { for (var me = [], ge = arguments.length; ge--;)me[ge] = arguments[ge]; return K.current.apply(K, me) }); return pe.current } function splitDecimal(fe, K) { K === void 0 && (K = !0); var pe = fe[0] === "-", me = pe && K; fe = fe.replace("-", ""); var ge = fe.split("."), xe = ge[0], ye = ge[1] || ""; return { beforeDecimal: xe, afterDecimal: ye, hasNegation: pe, addNegation: me } } function fixLeadingZero(fe) { if (!fe) return fe; var K = fe[0] === "-"; K && (fe = fe.substring(1, fe.length)); var pe = fe.split("."), me = pe[0].replace(/^0+/, "") || "0", ge = pe[1] || ""; return (K ? "-" : "") + me + (ge ? "." + ge : "") } function limitToScale(fe, K, pe) { for (var me = "", ge = pe ? "0" : "", xe = 0; xe <= K - 1; xe++)me += fe[xe] || ge; return me } function repeat$1(fe, K) { return Array(K + 1).join(fe) } function toNumericString(fe) { var K = fe + "", pe = K[0] === "-" ? "-" : ""; pe && (K = K.substring(1)); var me = K.split(/[eE]/g), ge = me[0], xe = me[1]; if (xe = Number(xe), !xe) return pe + ge; ge = ge.replace(".", ""); var ye = 1 + xe, ve = ge.length; return ye < 0 ? ge = "0." + repeat$1("0", Math.abs(ye)) + ge : ye >= ve ? ge = ge + repeat$1("0", ye - ve) : ge = (ge.substring(0, ye) || "0") + "." + ge.substring(ye), pe + ge } function roundToPrecision(fe, K, pe) { if (["", "-"].indexOf(fe) !== -1) return fe; var me = (fe.indexOf(".") !== -1 || pe) && K, ge = splitDecimal(fe), xe = ge.beforeDecimal, ye = ge.afterDecimal, ve = ge.hasNegation, _e = parseFloat("0." + (ye || "0")), Ee = ye.length <= K ? "0." + ye : _e.toFixed(K), be = Ee.split("."), Ae = xe; xe && Number(be[0]) && (Ae = xe.split("").reverse().reduce(function (Be, De, Re) { return Be.length > Re ? (Number(Be[0]) + Number(De)).toString() + Be.substring(1, Be.length) : De + Be }, be[0])); var Se = limitToScale(be[1] || "", K, pe), Ce = ve ? "-" : "", we = me ? "." : ""; return "" + Ce + Ae + we + Se } function setCaretPosition(fe, K) { if (fe.value = fe.value, fe !== null) { if (fe.createTextRange) { var pe = fe.createTextRange(); return pe.move("character", K), pe.select(), !0 } return fe.selectionStart || fe.selectionStart === 0 ? (fe.focus(), fe.setSelectionRange(K, K), !0) : (fe.focus(), !1) } } var findChangeRange = memoizeOnce(function (fe, K) { for (var pe = 0, me = 0, ge = fe.length, xe = K.length; fe[pe] === K[pe] && pe < ge;)pe++; for (; fe[ge - 1 - me] === K[xe - 1 - me] && xe - me > pe && ge - me > pe;)me++; return { from: { start: pe, end: ge - me }, to: { start: pe, end: xe - me } } }), findChangedRangeFromCaretPositions = function (fe, K) { var pe = Math.min(fe.selectionStart, K); return { from: { start: pe, end: fe.selectionEnd }, to: { start: pe, end: K } } }; function clamp$4(fe, K, pe) { return Math.min(Math.max(fe, K), pe) } function geInputCaretPosition(fe) { return Math.max(fe.selectionStart, fe.selectionEnd) } function addInputMode() { return typeof navigator < "u" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform)) } function getDefaultChangeMeta(fe) { return { from: { start: 0, end: 0 }, to: { start: 0, end: fe.length }, lastValue: "" } } function defaultIsCharacterSame(fe) { var K = fe.currentValue, pe = fe.formattedValue, me = fe.currentValueIndex, ge = fe.formattedValueIndex; return K[me] === pe[ge] } function getCaretPosition(fe, K, pe, me, ge, xe, ye) { ye === void 0 && (ye = defaultIsCharacterSame); var ve = ge.findIndex(function (Ne) { return Ne }), _e = fe.slice(0, ve); !K && !pe.startsWith(_e) && (K = _e, pe = _e + pe, me = me + _e.length); for (var Ee = pe.length, be = fe.length, Ae = {}, Se = new Array(Ee), Ce = 0; Ce < Ee; Ce++) { Se[Ce] = -1; for (var we = 0, Be = be; we < Be; we++) { var De = ye({ currentValue: pe, lastValue: K, formattedValue: fe, currentValueIndex: Ce, formattedValueIndex: we }); if (De && Ae[we] !== !0) { Se[Ce] = we, Ae[we] = !0; break } } } for (var Re = me; Re < Ee && (Se[Re] === -1 || !xe(pe[Re]));)Re++; var Ie = Re === Ee || Se[Re] === -1 ? be : Se[Re]; for (Re = me - 1; Re > 0 && Se[Re] === -1;)Re--; var Pe = Re === -1 || Se[Re] === -1 ? 0 : Se[Re] + 1; return Pe > Ie ? Ie : me - Pe < Ie - me ? Pe : Ie } function getCaretPosInBoundary(fe, K, pe, me) { var ge = fe.length; if (K = clamp$4(K, 0, ge), me === "left") { for (; K >= 0 && !pe[K];)K--; K === -1 && (K = pe.indexOf(!0)) } else { for (; K <= ge && !pe[K];)K++; K > ge && (K = pe.lastIndexOf(!0)) } return K === -1 && (K = ge), K } function caretUnknownFormatBoundary(fe) { for (var K = Array.from({ length: fe.length + 1 }).map(function () { return !0 }), pe = 0, me = K.length; pe < me; pe++)K[pe] = !!(charIsNumber(fe[pe]) || charIsNumber(fe[pe - 1])); return K } function useInternalValues(fe, K, pe, me, ge, xe) { xe === void 0 && (xe = noop$1); var ye = usePersistentCallback(function (we, Be) { var De, Re; return isNotValidValue(we) ? (Re = "", De = "") : typeof we == "number" || Be ? (Re = typeof we == "number" ? toNumericString(we) : we, De = me(Re)) : (Re = ge(we, void 0), De = me(Re)), { formattedValue: De, numAsString: Re } }), ve = reactExports.useState(function () { return ye(isNil(fe) ? K : fe, pe) }), _e = ve[0], Ee = ve[1], be = function (we, Be) { we.formattedValue !== _e.formattedValue && Ee({ formattedValue: we.formattedValue, numAsString: we.value }), xe(we, Be) }, Ae = fe, Se = pe; isNil(fe) && (Ae = _e.numAsString, Se = !0); var Ce = ye(Ae, Se); return reactExports.useMemo(function () { Ee(Ce) }, [Ce.formattedValue]), [_e, be] } function defaultRemoveFormatting(fe) { return fe.replace(/[^0-9]/g, "") } function defaultFormat(fe) { return fe } function NumberFormatBase(fe) { var K = fe.type; K === void 0 && (K = "text"); var pe = fe.displayType; pe === void 0 && (pe = "input"); var me = fe.customInput, ge = fe.renderText, xe = fe.getInputRef, ye = fe.format; ye === void 0 && (ye = defaultFormat); var ve = fe.removeFormatting; ve === void 0 && (ve = defaultRemoveFormatting); var _e = fe.defaultValue, Ee = fe.valueIsNumericString, be = fe.onValueChange, Ae = fe.isAllowed, Se = fe.onChange; Se === void 0 && (Se = noop$1); var Ce = fe.onKeyDown; Ce === void 0 && (Ce = noop$1); var we = fe.onMouseUp; we === void 0 && (we = noop$1); var Be = fe.onFocus; Be === void 0 && (Be = noop$1); var De = fe.onBlur; De === void 0 && (De = noop$1); var Re = fe.value, Ie = fe.getCaretBoundary; Ie === void 0 && (Ie = caretUnknownFormatBoundary); var Pe = fe.isValidInputCharacter; Pe === void 0 && (Pe = charIsNumber); var Ne = fe.isCharacterSame, ke = __rest(fe, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]), Oe = useInternalValues(Re, _e, !!Ee, ye, ve, be), Ue = Oe[0], He = Ue.formattedValue, Ge = Ue.numAsString, ze = Oe[1], We = reactExports.useRef(), Xe = reactExports.useRef({ formattedValue: He, numAsString: Ge }), Ye = function (vn, yn) { Xe.current = { formattedValue: vn.formattedValue, numAsString: vn.value }, ze(vn, yn) }, Ze = reactExports.useState(!1), ot = Ze[0], qe = Ze[1], Qe = reactExports.useRef(null), st = reactExports.useRef({ setCaretTimeout: null, focusTimeout: null }); reactExports.useEffect(function () { return qe(!0), function () { clearTimeout(st.current.setCaretTimeout), clearTimeout(st.current.focusTimeout) } }, []); var Nt = ye, Je = function (vn, yn) { var Hn = parseFloat(yn); return { formattedValue: vn, value: yn, floatValue: isNaN(Hn) ? void 0 : Hn } }, jt = function (vn, yn, Hn) { vn.selectionStart === 0 && vn.selectionEnd === vn.value.length || (setCaretPosition(vn, yn), st.current.setCaretTimeout = setTimeout(function () { vn.value === Hn && vn.selectionStart !== yn && setCaretPosition(vn, yn) }, 0)) }, Xt = function (vn, yn, Hn) { return getCaretPosInBoundary(vn, yn, Ie(vn), Hn) }, ct = function (vn, yn, Hn) { var kn = Ie(yn), Ht = getCaretPosition(yn, He, vn, Hn, kn, Pe, Ne); return Ht = getCaretPosInBoundary(yn, Ht, kn), Ht }, nn = function (vn) { var yn = vn.formattedValue; yn === void 0 && (yn = ""); var Hn = vn.input, kn = vn.source, Ht = vn.event, Dt = vn.numAsString, fn; if (Hn) { var en = vn.inputValue || Hn.value, cn = geInputCaretPosition(Hn); Hn.value = yn, fn = ct(en, yn, cn), fn !== void 0 && jt(Hn, fn, yn) } yn !== He && Ye(Je(yn, Dt), { event: Ht, source: kn }) }; reactExports.useEffect(function () { var vn = Xe.current, yn = vn.formattedValue, Hn = vn.numAsString; (He !== yn || Ge !== Hn) && Ye(Je(He, Ge), { event: void 0, source: SourceType.props }) }, [He, Ge]); var $t = Qe.current ? geInputCaretPosition(Qe.current) : void 0, an = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect; an(function () { var vn = Qe.current; if (He !== Xe.current.formattedValue && vn) { var yn = ct(Xe.current.formattedValue, He, $t); vn.value = He, jt(vn, yn, He) } }, [He]); var gn = function (vn, yn, Hn) { var kn = yn.target, Ht = We.current ? findChangedRangeFromCaretPositions(We.current, kn.selectionEnd) : findChangeRange(He, vn), Dt = Object.assign(Object.assign({}, Ht), { lastValue: He }), fn = ve(vn, Dt), en = Nt(fn); if (fn = ve(en, void 0), Ae && !Ae(Je(en, fn))) { var cn = yn.target, Wt = geInputCaretPosition(cn), un = ct(vn, He, Wt); return cn.value = He, jt(cn, un, He), !1 } return nn({ formattedValue: en, numAsString: fn, inputValue: vn, event: yn, source: Hn, input: yn.target }), !0 }, Mn = function (vn, yn) { yn === void 0 && (yn = 0); var Hn = vn.selectionStart, kn = vn.selectionEnd; We.current = { selectionStart: Hn, selectionEnd: kn + yn } }, Xn = function (vn) { var yn = vn.target, Hn = yn.value, kn = gn(Hn, vn, SourceType.event); kn && Se(vn), We.current = void 0 }, Ln = function (vn) { var yn = vn.target, Hn = vn.key, kn = yn.selectionStart, Ht = yn.selectionEnd, Dt = yn.value; Dt === void 0 && (Dt = ""); var fn; Hn === "ArrowLeft" || Hn === "Backspace" ? fn = Math.max(kn - 1, 0) : Hn === "ArrowRight" ? fn = Math.min(kn + 1, Dt.length) : Hn === "Delete" && (fn = kn); var en = 0; Hn === "Delete" && kn === Ht && (en = 1); var cn = Hn === "ArrowLeft" || Hn === "ArrowRight"; if (fn === void 0 || kn !== Ht && !cn) { Ce(vn), Mn(yn, en); return } var Wt = fn; if (cn) { var un = Hn === "ArrowLeft" ? "left" : "right"; Wt = Xt(Dt, fn, un), Wt !== fn && vn.preventDefault() } else Hn === "Delete" && !Pe(Dt[fn]) ? Wt = Xt(Dt, fn, "right") : Hn === "Backspace" && !Pe(Dt[fn]) && (Wt = Xt(Dt, fn, "left")); Wt !== fn && jt(yn, Wt, Dt), Ce(vn), Mn(yn, en) }, Gn = function (vn) { var yn = vn.target, Hn = function () { var kn = yn.selectionStart, Ht = yn.selectionEnd, Dt = yn.value; if (Dt === void 0 && (Dt = ""), kn === Ht) { var fn = Xt(Dt, kn); fn !== kn && jt(yn, fn, Dt) } }; Hn(), requestAnimationFrame(function () { Hn() }), we(vn), Mn(yn) }, wn = function (vn) { vn.persist && vn.persist(); var yn = vn.target, Hn = vn.currentTarget; Qe.current = yn, st.current.focusTimeout = setTimeout(function () { var kn = yn.selectionStart, Ht = yn.selectionEnd, Dt = yn.value; Dt === void 0 && (Dt = ""); var fn = Xt(Dt, kn); fn !== kn && !(kn === 0 && Ht === Dt.length) && jt(yn, fn, Dt), Be(Object.assign(Object.assign({}, vn), { currentTarget: Hn })) }, 0) }, Bn = function (vn) { Qe.current = null, clearTimeout(st.current.focusTimeout), clearTimeout(st.current.setCaretTimeout), De(vn) }, Gt = ot && addInputMode() ? "numeric" : void 0, nr = Object.assign({ inputMode: Gt }, ke, { type: K, value: He, onChange: Xn, onKeyDown: Ln, onMouseUp: Gn, onFocus: wn, onBlur: Bn }); if (pe === "text") return ge ? React$4.createElement(React$4.Fragment, null, ge(He, ke) || null) : React$4.createElement("span", Object.assign({}, ke, { ref: xe }), He); if (me) { var Kn = me; return React$4.createElement(Kn, Object.assign({}, nr, { ref: xe })) } return React$4.createElement("input", Object.assign({}, nr, { ref: xe })) } function format(fe, K) { var pe = K.decimalScale, me = K.fixedDecimalScale, ge = K.prefix; ge === void 0 && (ge = ""); var xe = K.suffix; xe === void 0 && (xe = ""); var ye = K.allowNegative, ve = K.thousandsGroupStyle; if (ve === void 0 && (ve = "thousand"), fe === "" || fe === "-") return fe; var _e = getSeparators(K), Ee = _e.thousandSeparator, be = _e.decimalSeparator, Ae = pe !== 0 && fe.indexOf(".") !== -1 || pe && me, Se = splitDecimal(fe, ye), Ce = Se.beforeDecimal, we = Se.afterDecimal, Be = Se.addNegation; return pe !== void 0 && (we = limitToScale(we, pe, !!me)), Ee && (Ce = applyThousandSeparator(Ce, Ee, ve)), ge && (Ce = ge + Ce), xe && (we = we + xe), Be && (Ce = "-" + Ce), fe = Ce + (Ae && be || "") + we, fe } function getSeparators(fe) { var K = fe.decimalSeparator; K === void 0 && (K = "."); var pe = fe.thousandSeparator, me = fe.allowedDecimalSeparators; return pe === !0 && (pe = ","), me || (me = [K, "."]), { decimalSeparator: K, thousandSeparator: pe, allowedDecimalSeparators: me } } function handleNegation(fe, K) { fe === void 0 && (fe = ""); var pe = new RegExp("(-)"), me = new RegExp("(-)(.)*(-)"), ge = pe.test(fe), xe = me.test(fe); return fe = fe.replace(/-/g, ""), ge && !xe && K && (fe = "-" + fe), fe } function getNumberRegex(fe, K) { return new RegExp("(^-)|[0-9]|" + escapeRegExp(fe), "g") } function isNumericString(fe, K, pe) { return fe === "" ? !0 : !K?.match(/\d/) && !pe?.match(/\d/) && typeof fe == "string" && !isNaN(Number(fe)) } function removeFormatting(fe, K, pe) { var me; K === void 0 && (K = getDefaultChangeMeta(fe)); var ge = pe.allowNegative, xe = pe.prefix; xe === void 0 && (xe = ""); var ye = pe.suffix; ye === void 0 && (ye = ""); var ve = pe.decimalScale, _e = K.from, Ee = K.to, be = Ee.start, Ae = Ee.end, Se = getSeparators(pe), Ce = Se.allowedDecimalSeparators, we = Se.decimalSeparator, Be = fe[Ae] === we; if (charIsNumber(fe) && (fe === xe || fe === ye) && K.lastValue === "") return fe; if (Ae - be === 1 && Ce.indexOf(fe[be]) !== -1) { var De = ve === 0 ? "" : we; fe = fe.substring(0, be) + De + fe.substring(be + 1, fe.length) } var Re = function (Qe, st, Nt) { var Je = !1, jt = !1; xe.startsWith("-") ? Je = !1 : Qe.startsWith("--") ? (Je = !1, jt = !0) : ye.startsWith("-") && Qe.length === ye.length ? Je = !1 : Qe[0] === "-" && (Je = !0); var Xt = Je ? 1 : 0; return jt && (Xt = 2), Xt && (Qe = Qe.substring(Xt), st -= Xt, Nt -= Xt), { value: Qe, start: st, end: Nt, hasNegation: Je } }, Ie = Re(fe, be, Ae), Pe = Ie.hasNegation; me = Ie, fe = me.value, be = me.start, Ae = me.end; var Ne = Re(K.lastValue, _e.start, _e.end), ke = Ne.start, Oe = Ne.end, Ue = Ne.value, He = fe.substring(be, Ae); fe.length && Ue.length && (ke > Ue.length - ye.length || Oe < xe.length) && !(He && ye.startsWith(He)) && (fe = Ue); var Ge = 0; fe.startsWith(xe) ? Ge += xe.length : be < xe.length && (Ge = be), fe = fe.substring(Ge), Ae -= Ge; var ze = fe.length, We = fe.length - ye.length; fe.endsWith(ye) ? ze = We : (Ae > We || Ae > fe.length - ye.length) && (ze = Ae), fe = fe.substring(0, ze), fe = handleNegation(Pe ? "-" + fe : fe, ge), fe = (fe.match(getNumberRegex(we)) || []).join(""); var Xe = fe.indexOf(we); fe = fe.replace(new RegExp(escapeRegExp(we), "g"), function (Qe, st) { return st === Xe ? "." : "" }); var Ye = splitDecimal(fe, ge), Ze = Ye.beforeDecimal, ot = Ye.afterDecimal, qe = Ye.addNegation; return Ee.end - Ee.start < _e.end - _e.start && Ze === "" && Be && !parseFloat(ot) && (fe = qe ? "-" : ""), fe } function getCaretBoundary(fe, K) { var pe = K.prefix; pe === void 0 && (pe = ""); var me = K.suffix; me === void 0 && (me = ""); var ge = Array.from({ length: fe.length + 1 }).map(function () { return !0 }), xe = fe[0] === "-"; ge.fill(!1, 0, pe.length + (xe ? 1 : 0)); var ye = fe.length; return ge.fill(!1, ye - me.length + 1, ye + 1), ge } function validateAndUpdateProps(fe) {
	var K = getSeparators(fe), pe = K.thousandSeparator, me = K.decimalSeparator, ge = fe.prefix; ge === void 0 && (ge = ""); var xe = fe.allowNegative; if (xe === void 0 && (xe = !0), pe === me) throw new Error(`
        Decimal separator can't be same as thousand separator.
        thousandSeparator: `+ pe + ` (thousandSeparator = {true} is same as thousandSeparator = ",")
        decimalSeparator: `+ me + ` (default value for decimalSeparator is .)
     `); return ge.startsWith("-") && xe && (console.error(`
      Prefix can't start with '-' when allowNegative is true.
      prefix: `+ ge + `
      allowNegative: `+ xe + `
    `), xe = !1), Object.assign(Object.assign({}, fe), { allowNegative: xe })
} function useNumericFormat(fe) { fe = validateAndUpdateProps(fe), fe.decimalSeparator, fe.allowedDecimalSeparators, fe.thousandsGroupStyle; var K = fe.suffix, pe = fe.allowNegative, me = fe.allowLeadingZeros, ge = fe.onKeyDown; ge === void 0 && (ge = noop$1); var xe = fe.onBlur; xe === void 0 && (xe = noop$1); var ye = fe.thousandSeparator, ve = fe.decimalScale, _e = fe.fixedDecimalScale, Ee = fe.prefix; Ee === void 0 && (Ee = ""); var be = fe.defaultValue, Ae = fe.value, Se = fe.valueIsNumericString, Ce = fe.onValueChange, we = __rest(fe, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]), Be = getSeparators(fe), De = Be.decimalSeparator, Re = Be.allowedDecimalSeparators, Ie = function (qe) { return format(qe, fe) }, Pe = function (qe, Qe) { return removeFormatting(qe, Qe, fe) }, Ne = isNil(Ae) ? be : Ae, ke = Se ?? isNumericString(Ne, Ee, K); isNil(Ae) ? isNil(be) || (ke = ke || typeof be == "number") : ke = ke || typeof Ae == "number"; var Oe = function (qe) { return isNotValidValue(qe) ? qe : (typeof qe == "number" && (qe = toNumericString(qe)), ke && typeof ve == "number" ? roundToPrecision(qe, ve, !!_e) : qe) }, Ue = useInternalValues(Oe(Ae), Oe(be), !!ke, Ie, Pe, Ce), He = Ue[0], Ge = He.numAsString, ze = He.formattedValue, We = Ue[1], Xe = function (qe) { var Qe = qe.target, st = qe.key, Nt = Qe.selectionStart, Je = Qe.selectionEnd, jt = Qe.value; if (jt === void 0 && (jt = ""), (st === "Backspace" || st === "Delete") && Je < Ee.length) { qe.preventDefault(); return } if (Nt !== Je) { ge(qe); return } st === "Backspace" && jt[0] === "-" && Nt === Ee.length + 1 && pe && setCaretPosition(Qe, 1), ve && _e && (st === "Backspace" && jt[Nt - 1] === De ? (setCaretPosition(Qe, Nt - 1), qe.preventDefault()) : st === "Delete" && jt[Nt] === De && qe.preventDefault()), Re?.includes(st) && jt[Nt] === De && setCaretPosition(Qe, Nt + 1); var Xt = ye === !0 ? "," : ye; st === "Backspace" && jt[Nt - 1] === Xt && setCaretPosition(Qe, Nt - 1), st === "Delete" && jt[Nt] === Xt && setCaretPosition(Qe, Nt + 1), ge(qe) }, Ye = function (qe) { var Qe = Ge; if (Qe.match(/\d/g) || (Qe = ""), me || (Qe = fixLeadingZero(Qe)), _e && ve && (Qe = roundToPrecision(Qe, ve, _e)), Qe !== Ge) { var st = format(Qe, fe); We({ formattedValue: st, value: Qe, floatValue: parseFloat(Qe) }, { event: qe, source: SourceType.event }) } xe(qe) }, Ze = function (qe) { return qe === De ? !0 : charIsNumber(qe) }, ot = function (qe) { var Qe = qe.currentValue, st = qe.lastValue, Nt = qe.formattedValue, Je = qe.currentValueIndex, jt = qe.formattedValueIndex, Xt = Qe[Je], ct = Nt[jt], nn = findChangeRange(st, Qe), $t = nn.to, an = function (gn) { return Pe(gn).indexOf(".") + Ee.length }; return Ae === 0 && _e && ve && Qe[$t.start] === De && an(Qe) < Je && an(Nt) > jt ? !1 : Je >= $t.start && Je < $t.end && Re && Re.includes(Xt) && ct === De ? !0 : Xt === ct }; return Object.assign(Object.assign({}, we), { value: ze, valueIsNumericString: !1, isValidInputCharacter: Ze, isCharacterSame: ot, onValueChange: We, format: Ie, removeFormatting: Pe, getCaretBoundary: function (qe) { return getCaretBoundary(qe, fe) }, onKeyDown: Xe, onBlur: Ye }) } function NumericFormat(fe) { var K = useNumericFormat(fe); return React$4.createElement(NumberFormatBase, Object.assign({}, K)) } function NumberInputChevron({ direction: fe, style: K, ...pe }) { return jsxRuntimeExports.jsx("svg", { style: { width: "var(--ni-chevron-size)", height: "var(--ni-chevron-size)", transform: fe === "up" ? "rotate(180deg)" : void 0, ...K }, viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...pe, children: jsxRuntimeExports.jsx("path", { d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }) }) } var __default__$8 = { root: "m_e2f5cd4e", controls: "m_95e17d22", control: "m_80b4b171" }; const leadingDecimalZeroPattern = /^(0\.0*|-0(\.0*)?)$/, leadingZerosPattern = /^-?0\d+(\.\d+)?\.?$/; function isNumberString(fe) { return typeof fe == "string" && fe !== "" && !Number.isNaN(Number(fe)) } function canIncrement(fe) { return typeof fe == "number" ? fe < Number.MAX_SAFE_INTEGER : fe === "" || isNumberString(fe) && Number(fe) < Number.MAX_SAFE_INTEGER } function getDecimalPlaces(fe) { return fe.toString().replace(".", "").length } function isValidNumber(fe, K) { return (typeof fe == "number" ? fe < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(fe))) && !Number.isNaN(fe) && getDecimalPlaces(K) < 14 && K !== "" } function isInRange(fe, K, pe) { if (fe === void 0) return !0; const me = K === void 0 || fe >= K, ge = pe === void 0 || fe <= pe; return me && ge } const defaultProps$j = { step: 1, clampBehavior: "blur", allowDecimal: !0, allowNegative: !0, withKeyboardEvents: !0, allowLeadingZeros: !0, trimLeadingZeroesOnBlur: !0, startValue: 0 }, varsResolver$a = (fe, { size: K }) => ({ controls: { "--ni-chevron-size": getSize(K, "ni-chevron-size") } }); function clampAndSanitizeInput(fe, K, pe) { const me = fe.toString().replace(/^0+/, ""), ge = parseFloat(me); return Number.isNaN(ge) ? me : ge > Number.MAX_SAFE_INTEGER ? K !== void 0 ? String(K) : me : clamp$7(ge, pe, K) } const NumberInput = factory((fe, K) => { const pe = useProps("NumberInput", defaultProps$j, fe), { className: me, classNames: ge, styles: xe, unstyled: ye, vars: ve, onChange: _e, onValueChange: Ee, value: be, defaultValue: Ae, max: Se, min: Ce, step: we, hideControls: Be, rightSection: De, isAllowed: Re, clampBehavior: Ie, onBlur: Pe, allowDecimal: Ne, decimalScale: ke, onKeyDown: Oe, onKeyDownCapture: Ue, handlersRef: He, startValue: Ge, disabled: ze, rightSectionPointerEvents: We, allowNegative: Xe, readOnly: Ye, size: Ze, rightSectionWidth: ot, stepHoldInterval: qe, stepHoldDelay: Qe, allowLeadingZeros: st, withKeyboardEvents: Nt, trimLeadingZeroesOnBlur: Je, ...jt } = pe, Xt = useStyles({ name: "NumberInput", classes: __default__$8, props: pe, classNames: ge, styles: xe, unstyled: ye, vars: ve, varsResolver: varsResolver$a }), { resolvedClassNames: ct, resolvedStyles: nn } = useResolvedStylesApi({ classNames: ge, styles: xe, props: pe }), [$t, an] = useUncontrolled({ value: be, defaultValue: Ae, finalValue: "", onChange: _e }), gn = Qe !== void 0 && qe !== void 0, Mn = reactExports.useRef(null), Xn = reactExports.useRef(null), Ln = reactExports.useRef(0), Gn = (en, cn) => { cn.source === "event" && an(isValidNumber(en.floatValue, en.value) && !leadingDecimalZeroPattern.test(en.value) && !(st && leadingZerosPattern.test(en.value)) ? en.floatValue : en.value), Ee?.(en, cn) }, wn = en => { const cn = String(en).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return cn ? Math.max(0, (cn[1] ? cn[1].length : 0) - (cn[2] ? +cn[2] : 0)) : 0 }, Bn = en => { Mn.current && typeof en < "u" && Mn.current.setSelectionRange(en, en) }, Gt = reactExports.useRef(noop$3); Gt.current = () => { if (!canIncrement($t)) return; let en; const cn = wn($t), Wt = wn(we), un = Math.max(cn, Wt), Ft = 10 ** un; if (!isNumberString($t) && (typeof $t != "number" || Number.isNaN($t))) en = clamp$7(Ge, Ce, Se); else if (Se !== void 0) { const lr = (Math.round(Number($t) * Ft) + Math.round(we * Ft)) / Ft; en = lr <= Se ? lr : Se } else en = (Math.round(Number($t) * Ft) + Math.round(we * Ft)) / Ft; const Sn = en.toFixed(un); an(parseFloat(Sn)), Ee?.({ floatValue: parseFloat(Sn), formattedValue: Sn, value: Sn }, { source: "increment" }), setTimeout(() => Bn(Mn.current?.value.length), 0) }; const nr = reactExports.useRef(noop$3); nr.current = () => { if (!canIncrement($t)) return; let en; const cn = Ce !== void 0 ? Ce : Xe ? Number.MIN_SAFE_INTEGER : 0, Wt = wn($t), un = wn(we), Ft = Math.max(Wt, un), Sn = 10 ** Ft; if (!isNumberString($t) && typeof $t != "number" || Number.isNaN($t)) en = clamp$7(Ge, cn, Se); else { const jn = (Math.round(Number($t) * Sn) - Math.round(we * Sn)) / Sn; en = cn !== void 0 && jn < cn ? cn : jn } const lr = en.toFixed(Ft); an(parseFloat(lr)), Ee?.({ floatValue: parseFloat(lr), formattedValue: lr, value: lr }, { source: "decrement" }), setTimeout(() => Bn(Mn.current?.value.length), 0) }; const Kn = en => { Oe?.(en), !(Ye || !Nt) && (en.key === "ArrowUp" && (en.preventDefault(), Gt.current()), en.key === "ArrowDown" && (en.preventDefault(), nr.current())) }, vn = en => { if (Ue?.(en), en.key === "Backspace") { const cn = Mn.current; cn.selectionStart === 0 && cn.selectionStart === cn.selectionEnd && (en.preventDefault(), window.setTimeout(() => Bn(0), 0)) } }, yn = en => { let cn = $t; Ie === "blur" && typeof cn == "number" && (cn = clamp$7(cn, Ce, Se)), Je && typeof cn == "string" && wn(cn) < 15 && (cn = clampAndSanitizeInput(cn, Se, Ce)), $t !== cn && an(cn), Pe?.(en) }; assignRef$1(He, { increment: Gt.current, decrement: nr.current }); const Hn = en => { en ? Gt.current() : nr.current(), Ln.current += 1 }, kn = en => { if (Hn(en), gn) { const cn = typeof qe == "number" ? qe : qe(Ln.current); Xn.current = window.setTimeout(() => kn(en), cn) } }, Ht = (en, cn) => { en.preventDefault(), Mn.current?.focus(), Hn(cn), gn && (Xn.current = window.setTimeout(() => kn(cn), Qe)) }, Dt = () => { Xn.current && window.clearTimeout(Xn.current), Xn.current = null, Ln.current = 0 }, fn = jsxRuntimeExports.jsxs("div", { ...Xt("controls"), children: [jsxRuntimeExports.jsx(UnstyledButton, { ...Xt("control"), tabIndex: -1, "aria-hidden": !0, disabled: ze || typeof $t == "number" && Se !== void 0 && $t >= Se, mod: { direction: "up" }, onMouseDown: en => en.preventDefault(), onPointerDown: en => { Ht(en, !0) }, onPointerUp: Dt, onPointerLeave: Dt, children: jsxRuntimeExports.jsx(NumberInputChevron, { direction: "up" }) }), jsxRuntimeExports.jsx(UnstyledButton, { ...Xt("control"), tabIndex: -1, "aria-hidden": !0, disabled: ze || typeof $t == "number" && Ce !== void 0 && $t <= Ce, mod: { direction: "down" }, onMouseDown: en => en.preventDefault(), onPointerDown: en => { Ht(en, !1) }, onPointerUp: Dt, onPointerLeave: Dt, children: jsxRuntimeExports.jsx(NumberInputChevron, { direction: "down" }) })] }); return jsxRuntimeExports.jsx(InputBase, { component: NumericFormat, allowNegative: Xe, className: clsx(__default__$8.root, me), size: Ze, ...jt, readOnly: Ye, disabled: ze, value: $t, getInputRef: useMergedRef(K, Mn), onValueChange: Gn, rightSection: Be || Ye || !canIncrement($t) ? De : De || fn, classNames: ct, styles: nn, unstyled: ye, __staticSelector: "NumberInput", decimalScale: Ne ? ke : 0, onKeyDown: Kn, onKeyDownCapture: vn, rightSectionPointerEvents: We ?? (ze ? "none" : void 0), rightSectionWidth: ot ?? `var(--ni-right-section-width-${Ze || "sm"})`, allowLeadingZeros: st, onBlur: yn, isAllowed: en => Ie === "strict" ? Re ? Re(en) && isInRange(en.floatValue, Ce, Se) : isInRange(en.floatValue, Ce, Se) : Re ? Re(en) : !0 }) }); NumberInput.classes = { ...InputBase.classes, ...__default__$8 }; NumberInput.displayName = "@mantine/core/NumberInput"; const [ProgressProvider, useProgressContext] = createSafeContext("Progress.Root component was not found in tree"); var __default__$7 = { root: "m_db6d6462", section: "m_2242eb65", "stripes-animation": "m_81a374bd", label: "m_91e40b74" }; const defaultProps$i = {}, ProgressLabel = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, ...ve } = useProps("ProgressLabel", defaultProps$i, fe), _e = useProgressContext(); return jsxRuntimeExports.jsx(Box, { ref: K, ..._e.getStyles("label", { className: me, style: ge, classNames: pe, styles: xe }), ...ve }) }); ProgressLabel.classes = __default__$7; ProgressLabel.displayName = "@mantine/core/ProgressLabel"; const defaultProps$h = {}, varsResolver$9 = (fe, { size: K, radius: pe, transitionDuration: me }) => ({ root: { "--progress-size": getSize(K, "progress-size"), "--progress-radius": pe === void 0 ? void 0 : getRadius(pe), "--progress-transition-duration": typeof me == "number" ? `${me}ms` : void 0 } }), ProgressRoot = factory((fe, K) => { const pe = useProps("ProgressRoot", defaultProps$h, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, autoContrast: Ee, transitionDuration: be, ...Ae } = pe, Se = useStyles({ name: "Progress", classes: __default__$7, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$9 }); return jsxRuntimeExports.jsx(ProgressProvider, { value: { getStyles: Se, autoContrast: Ee }, children: jsxRuntimeExports.jsx(Box, { ref: K, ...Se("root"), ...Ae }) }) }); ProgressRoot.classes = __default__$7; ProgressRoot.displayName = "@mantine/core/ProgressRoot"; const defaultProps$g = { withAria: !0 }, ProgressSection = factory((fe, K) => { const { classNames: pe, className: me, style: ge, styles: xe, vars: ye, value: ve, withAria: _e, color: Ee, striped: be, animated: Ae, mod: Se, ...Ce } = useProps("ProgressSection", defaultProps$g, fe), we = useProgressContext(), Be = useMantineTheme(), De = _e ? { role: "progressbar", "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": ve, "aria-valuetext": `${ve}%` } : {}; return jsxRuntimeExports.jsx(Box, { ref: K, ...we.getStyles("section", { className: me, classNames: pe, styles: xe, style: ge }), ...Ce, ...De, mod: [{ striped: be || Ae, animated: Ae }, Se], __vars: { "--progress-section-width": `${ve}%`, "--progress-section-color": getThemeColor(Ee, Be), "--progress-label-color": getAutoContrastValue(we.autoContrast, Be) ? getContrastColor({ color: Ee, theme: Be, autoContrast: we.autoContrast }) : void 0 } }) }); ProgressSection.classes = __default__$7; ProgressSection.displayName = "@mantine/core/ProgressSection"; const defaultProps$f = {}, Progress = factory((fe, K) => { const pe = useProps("Progress", defaultProps$f, fe), { value: me, classNames: ge, styles: xe, vars: ye, color: ve, striped: _e, animated: Ee, "aria-label": be, ...Ae } = pe, { resolvedClassNames: Se, resolvedStyles: Ce } = useResolvedStylesApi({ classNames: ge, styles: xe, props: pe }); return jsxRuntimeExports.jsx(ProgressRoot, { ref: K, classNames: Se, styles: Ce, vars: ye, ...Ae, children: jsxRuntimeExports.jsx(ProgressSection, { value: me, color: ve, striped: _e, animated: Ee, "aria-label": be }) }) }); Progress.classes = __default__$7; Progress.displayName = "@mantine/core/Progress"; Progress.Section = ProgressSection; Progress.Root = ProgressRoot; Progress.Label = ProgressLabel; const defaultTransition = { duration: 100, transition: "fade" }; function getTransitionProps(fe, K) { return { ...defaultTransition, ...K, ...fe } } function useFloatingTooltip({ offset: fe, position: K, defaultOpened: pe }) { const [me, ge] = reactExports.useState(pe), xe = reactExports.useRef(null), { x: ye, y: ve, elements: _e, refs: Ee, update: be, placement: Ae } = useFloating({ placement: K, middleware: [shift({ crossAxis: !0, padding: 5, rootBoundary: "document" })] }), Se = Ae.includes("right") ? fe : K.includes("left") ? fe * -1 : 0, Ce = Ae.includes("bottom") ? fe : K.includes("top") ? fe * -1 : 0, we = reactExports.useCallback(({ clientX: Be, clientY: De }) => { Ee.setPositionReference({ getBoundingClientRect() { return { width: 0, height: 0, x: Be, y: De, left: Be + Se, top: De + Ce, right: Be, bottom: De } } }) }, [_e.reference]); return reactExports.useEffect(() => { if (Ee.floating.current) { const Be = xe.current; Be.addEventListener("mousemove", we); const De = getOverflowAncestors(Ee.floating.current); return De.forEach(Re => { Re.addEventListener("scroll", be) }), () => { Be.removeEventListener("mousemove", we), De.forEach(Re => { Re.removeEventListener("scroll", be) }) } } }, [_e.reference, Ee.floating.current, be, we, me]), { handleMouseMove: we, x: ye, y: ve, opened: me, setOpened: ge, boundaryRef: xe, floating: Ee.setFloating } } var __default__$6 = { tooltip: "m_1b3c8819", arrow: "m_f898399f" }; const defaultProps$e = { refProp: "ref", withinPortal: !0, offset: 10, defaultOpened: !1, position: "right", zIndex: getDefaultZIndex("popover") }, varsResolver$8 = (fe, { radius: K, color: pe }) => ({ tooltip: { "--tooltip-radius": K === void 0 ? void 0 : getRadius(K), "--tooltip-bg": pe ? getThemeColor(pe, fe) : void 0, "--tooltip-color": pe ? "var(--mantine-color-white)" : void 0 } }), TooltipFloating = factory((fe, K) => { const pe = useProps("TooltipFloating", defaultProps$e, fe), { children: me, refProp: ge, withinPortal: xe, style: ye, className: ve, classNames: _e, styles: Ee, unstyled: be, radius: Ae, color: Se, label: Ce, offset: we, position: Be, multiline: De, zIndex: Re, disabled: Ie, defaultOpened: Pe, variant: Ne, vars: ke, portalProps: Oe, ...Ue } = pe, He = useMantineTheme(), Ge = useStyles({ name: "TooltipFloating", props: pe, classes: __default__$6, className: ve, style: ye, classNames: _e, styles: Ee, unstyled: be, rootSelector: "tooltip", vars: ke, varsResolver: varsResolver$8 }), { handleMouseMove: ze, x: We, y: Xe, opened: Ye, boundaryRef: Ze, floating: ot, setOpened: qe } = useFloatingTooltip({ offset: we, position: Be, defaultOpened: Pe }); if (!isElement$1(me)) throw new Error("[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"); const Qe = useMergedRef(Ze, getRefProp(me), K), st = me.props, Nt = jt => { st.onMouseEnter?.(jt), ze(jt), qe(!0) }, Je = jt => { st.onMouseLeave?.(jt), qe(!1) }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(OptionalPortal, { ...Oe, withinPortal: xe, children: jsxRuntimeExports.jsx(Box, { ...Ue, ...Ge("tooltip", { style: { ...getStyleObject(ye, He), zIndex: Re, display: !Ie && Ye ? "block" : "none", top: (Xe && Math.round(Xe)) ?? "", left: (We && Math.round(We)) ?? "" } }), variant: Ne, ref: ot, mod: { multiline: De }, children: Ce }) }), reactExports.cloneElement(me, { ...st, [ge]: Qe, onMouseEnter: Nt, onMouseLeave: Je })] }) }); TooltipFloating.classes = __default__$6; TooltipFloating.displayName = "@mantine/core/TooltipFloating"; const TooltipGroupContext = reactExports.createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => reactExports.useContext(TooltipGroupContext), defaultProps$d = { openDelay: 0, closeDelay: 0 }; function TooltipGroup(fe) { const { openDelay: K, closeDelay: pe, children: me } = useProps("TooltipGroup", defaultProps$d, fe); return jsxRuntimeExports.jsx(TooltipGroupProvider, { value: !0, children: jsxRuntimeExports.jsx(FloatingDelayGroup, { delay: { open: K, close: pe }, children: me }) }) } TooltipGroup.displayName = "@mantine/core/TooltipGroup"; TooltipGroup.extend = fe => fe; function getDefaultMiddlewares(fe) { if (fe === void 0) return { shift: !0, flip: !0 }; const K = { ...fe }; return fe.shift === void 0 && (K.shift = !0), fe.flip === void 0 && (K.flip = !0), K } function getTooltipMiddlewares(fe) { const K = getDefaultMiddlewares(fe.middlewares), pe = [offset(fe.offset)]; return K.shift && pe.push(shift(typeof K.shift == "boolean" ? { padding: 8 } : { padding: 8, ...K.shift })), K.flip && pe.push(typeof K.flip == "boolean" ? flip() : flip(K.flip)), pe.push(arrow({ element: fe.arrowRef, padding: fe.arrowOffset })), K.inline ? pe.push(typeof K.inline == "boolean" ? inline() : inline(K.inline)) : fe.inline && pe.push(inline()), pe } function useTooltip(fe) { const [K, pe] = reactExports.useState(fe.defaultOpened), ge = typeof fe.opened == "boolean" ? fe.opened : K, xe = useTooltipGroupContext(), ye = useId$1(), ve = reactExports.useCallback(Oe => { pe(Oe), Oe && Ie(ye) }, [ye]), { x: _e, y: Ee, context: be, refs: Ae, update: Se, placement: Ce, middlewareData: { arrow: { x: we, y: Be } = {} } } = useFloating({ strategy: fe.strategy, placement: fe.position, open: ge, onOpenChange: ve, middleware: getTooltipMiddlewares(fe) }), { delay: De, currentId: Re, setCurrentId: Ie } = useDelayGroup(be, { id: ye }), { getReferenceProps: Pe, getFloatingProps: Ne } = useInteractions([useHover(be, { enabled: fe.events?.hover, delay: xe ? De : { open: fe.openDelay, close: fe.closeDelay }, mouseOnly: !fe.events?.touch }), useFocus(be, { enabled: fe.events?.focus, visibleOnly: !0 }), useRole(be, { role: "tooltip" }), useDismiss(be, { enabled: typeof fe.opened > "u" })]); useFloatingAutoUpdate({ opened: ge, position: fe.position, positionDependencies: fe.positionDependencies, floating: { refs: Ae, update: Se } }), useDidUpdate(() => { fe.onPositionChange?.(Ce) }, [Ce]); const ke = ge && Re && Re !== ye; return { x: _e, y: Ee, arrowX: we, arrowY: Be, reference: Ae.setReference, floating: Ae.setFloating, getFloatingProps: Ne, getReferenceProps: Pe, isGroupPhase: ke, opened: ge, placement: Ce } } const defaultProps$c = { position: "top", refProp: "ref", withinPortal: !0, inline: !1, defaultOpened: !1, arrowSize: 4, arrowOffset: 5, arrowRadius: 0, arrowPosition: "side", offset: 5, transitionProps: { duration: 100, transition: "fade" }, events: { hover: !0, focus: !1, touch: !1 }, zIndex: getDefaultZIndex("popover"), positionDependencies: [], middlewares: { flip: !0, shift: !0, inline: !1 } }, varsResolver$7 = (fe, { radius: K, color: pe }) => ({ tooltip: { "--tooltip-radius": K === void 0 ? void 0 : getRadius(K), "--tooltip-bg": pe ? getThemeColor(pe, fe) : void 0, "--tooltip-color": pe ? "var(--mantine-color-white)" : void 0 } }), Tooltip = factory((fe, K) => { const pe = useProps("Tooltip", defaultProps$c, fe), { children: me, position: ge, refProp: xe, label: ye, openDelay: ve, closeDelay: _e, onPositionChange: Ee, opened: be, defaultOpened: Ae, withinPortal: Se, radius: Ce, color: we, classNames: Be, styles: De, unstyled: Re, style: Ie, className: Pe, withArrow: Ne, arrowSize: ke, arrowOffset: Oe, arrowRadius: Ue, arrowPosition: He, offset: Ge, transitionProps: ze, multiline: We, events: Xe, zIndex: Ye, disabled: Ze, positionDependencies: ot, onClick: qe, onMouseEnter: Qe, onMouseLeave: st, inline: Nt, variant: Je, keepMounted: jt, vars: Xt, portalProps: ct, mod: nn, floatingStrategy: $t, middlewares: an, ...gn } = useProps("Tooltip", defaultProps$c, pe), { dir: Mn } = useDirection(), Xn = reactExports.useRef(null), Ln = useTooltip({ position: getFloatingPosition(Mn, ge), closeDelay: _e, openDelay: ve, onPositionChange: Ee, opened: be, defaultOpened: Ae, events: Xe, arrowRef: Xn, arrowOffset: Oe, offset: typeof Ge == "number" ? Ge + (Ne ? ke / 2 : 0) : Ge, positionDependencies: [...ot, me], inline: Nt, strategy: $t, middlewares: an }), Gn = useStyles({ name: "Tooltip", props: pe, classes: __default__$6, className: Pe, style: Ie, classNames: Be, styles: De, unstyled: Re, rootSelector: "tooltip", vars: Xt, varsResolver: varsResolver$7 }); if (!isElement$1(me)) throw new Error("[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"); const wn = useMergedRef(Ln.reference, getRefProp(me), K), Bn = getTransitionProps(ze, { duration: 100, transition: "fade" }), Gt = me.props; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(OptionalPortal, { ...ct, withinPortal: Se, children: jsxRuntimeExports.jsx(Transition$1, { ...Bn, keepMounted: jt, mounted: !Ze && !!Ln.opened, duration: Ln.isGroupPhase ? 10 : Bn.duration, children: nr => jsxRuntimeExports.jsxs(Box, { ...gn, "data-fixed": $t === "fixed" || void 0, variant: Je, mod: [{ multiline: We }, nn], ...Ln.getFloatingProps({ ref: Ln.floating, className: Gn("tooltip").className, style: { ...Gn("tooltip").style, ...nr, zIndex: Ye, top: Ln.y ?? 0, left: Ln.x ?? 0 } }), children: [ye, jsxRuntimeExports.jsx(FloatingArrow, { ref: Xn, arrowX: Ln.arrowX, arrowY: Ln.arrowY, visible: Ne, position: Ln.placement, arrowSize: ke, arrowOffset: Oe, arrowRadius: Ue, arrowPosition: He, ...Gn("arrow") })] }) }) }), reactExports.cloneElement(me, Ln.getReferenceProps({ onClick: qe, onMouseEnter: Qe, onMouseLeave: st, onMouseMove: pe.onMouseMove, onPointerDown: pe.onPointerDown, onPointerEnter: pe.onPointerEnter, className: clsx(Pe, Gt.className), ...Gt, [xe]: wn }))] }) }); Tooltip.classes = __default__$6; Tooltip.displayName = "@mantine/core/Tooltip"; Tooltip.Floating = TooltipFloating; Tooltip.Group = TooltipGroup; const defaultProps$b = { searchable: !1, withCheckIcon: !0, allowDeselect: !0, checkIconPosition: "left" }, Select = factory((fe, K) => { const pe = useProps("Select", defaultProps$b, fe), { classNames: me, styles: ge, unstyled: xe, vars: ye, dropdownOpened: ve, defaultDropdownOpened: _e, onDropdownClose: Ee, onDropdownOpen: be, onFocus: Ae, onBlur: Se, onClick: Ce, onChange: we, data: Be, value: De, defaultValue: Re, selectFirstOptionOnChange: Ie, onOptionSubmit: Pe, comboboxProps: Ne, readOnly: ke, disabled: Oe, filter: Ue, limit: He, withScrollArea: Ge, maxDropdownHeight: ze, size: We, searchable: Xe, rightSection: Ye, checkIconPosition: Ze, withCheckIcon: ot, nothingFoundMessage: qe, name: Qe, form: st, searchValue: Nt, defaultSearchValue: Je, onSearchChange: jt, allowDeselect: Xt, error: ct, rightSectionPointerEvents: nn, id: $t, clearable: an, clearButtonProps: gn, hiddenInputProps: Mn, renderOption: Xn, onClear: Ln, autoComplete: Gn, scrollAreaProps: wn, __defaultRightSection: Bn, __clearSection: Gt, __clearable: nr, chevronColor: Kn, ...vn } = pe, yn = reactExports.useMemo(() => getParsedComboboxData(Be), [Be]), Hn = reactExports.useMemo(() => getOptionsLockup(yn), [yn]), kn = useId$1($t), [Ht, Dt, fn] = useUncontrolled({ value: De, defaultValue: Re, finalValue: null, onChange: we }), en = typeof Ht == "string" ? Hn[Ht] : void 0, cn = usePrevious(en), [Wt, un, Ft] = useUncontrolled({ value: Nt, defaultValue: Je, finalValue: en ? en.label : "", onChange: jt }), Sn = useCombobox({ opened: ve, defaultOpened: _e, onDropdownOpen: () => { be?.(), Sn.updateSelectedOptionIndex("active", { scrollIntoView: !0 }) }, onDropdownClose: () => { Ee?.(), Sn.resetSelectedOption() } }), lr = sr => { un(sr), Sn.resetSelectedOption() }, { resolvedClassNames: jn, resolvedStyles: Pn } = useResolvedStylesApi({ props: pe, styles: ge, classNames: me }); reactExports.useEffect(() => { Ie && Sn.selectFirstOption() }, [Ie, Wt]), reactExports.useEffect(() => { De === null && lr(""), typeof De == "string" && en && (cn?.value !== en.value || cn?.label !== en.label) && lr(en.label) }, [De, en]), reactExports.useEffect(() => { !fn && !Ft && lr(typeof Ht == "string" && Hn[Ht]?.label || "") }, [Be, Ht]); const fr = jsxRuntimeExports.jsx(Combobox.ClearButton, { ...gn, onClear: () => { Dt(null, null), lr(""), Ln?.() } }), Yn = an && !!Ht && !Oe && !ke; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Combobox, { store: Sn, __staticSelector: "Select", classNames: jn, styles: Pn, unstyled: xe, readOnly: ke, onOptionSubmit: sr => { Pe?.(sr); const Ar = Xt && Hn[sr].value === Ht ? null : Hn[sr], Er = Ar ? Ar.value : null; Er !== Ht && Dt(Er, Ar), !fn && lr(typeof Er == "string" && Ar?.label || ""), Sn.closeDropdown() }, size: We, ...Ne, children: [jsxRuntimeExports.jsx(Combobox.Target, { targetType: Xe ? "input" : "button", autoComplete: Gn, children: jsxRuntimeExports.jsx(InputBase, { id: kn, ref: K, __defaultRightSection: jsxRuntimeExports.jsx(Combobox.Chevron, { size: We, error: ct, unstyled: xe, color: Kn }), __clearSection: fr, __clearable: Yn, rightSection: Ye, rightSectionPointerEvents: nn || (Yn ? "all" : "none"), ...vn, size: We, __staticSelector: "Select", disabled: Oe, readOnly: ke || !Xe, value: Wt, onChange: sr => { lr(sr.currentTarget.value), Sn.openDropdown(), Ie && Sn.selectFirstOption() }, onFocus: sr => { Xe && Sn.openDropdown(), Ae?.(sr) }, onBlur: sr => { Xe && Sn.closeDropdown(), lr(Ht != null && Hn[Ht]?.label || ""), Se?.(sr) }, onClick: sr => { Xe ? Sn.openDropdown() : Sn.toggleDropdown(), Ce?.(sr) }, classNames: jn, styles: Pn, unstyled: xe, pointer: !Xe, error: ct }) }), jsxRuntimeExports.jsx(OptionsDropdown, { data: yn, hidden: ke || Oe, filter: Ue, search: Wt, limit: He, hiddenWhenEmpty: !qe, withScrollArea: Ge, maxDropdownHeight: ze, filterOptions: Xe && en?.label !== Wt, value: Ht, checkIconPosition: Ze, withCheckIcon: ot, nothingFoundMessage: qe, unstyled: xe, labelId: vn.label ? `${kn}-label` : void 0, "aria-label": vn.label ? void 0 : vn["aria-label"], renderOption: Xn, scrollAreaProps: wn })] }), jsxRuntimeExports.jsx(Combobox.HiddenInput, { value: Ht, name: Qe, form: st, disabled: Oe, ...Mn })] }) }); Select.classes = { ...InputBase.classes, ...Combobox.classes }; Select.displayName = "@mantine/core/Select"; const [SliderProvider, useSliderContext] = createSafeContext("SliderProvider was not found in tree"), SliderRoot = reactExports.forwardRef(({ size: fe, disabled: K, variant: pe, color: me, thumbSize: ge, radius: xe, ...ye }, ve) => { const { getStyles: _e } = useSliderContext(); return jsxRuntimeExports.jsx(Box, { tabIndex: -1, variant: pe, size: fe, ref: ve, ..._e("root"), ...ye }) }); SliderRoot.displayName = "@mantine/core/SliderRoot"; const Thumb = reactExports.forwardRef(({ max: fe, min: K, value: pe, position: me, label: ge, dragging: xe, onMouseDown: ye, onKeyDownCapture: ve, labelTransitionProps: _e, labelAlwaysOn: Ee, thumbLabel: be, onFocus: Ae, onBlur: Se, showLabelOnHover: Ce, isHovered: we, children: Be = null, disabled: De }, Re) => { const { getStyles: Ie } = useSliderContext(), [Pe, Ne] = reactExports.useState(!1), ke = Ee || xe || Pe || Ce && we; return jsxRuntimeExports.jsxs(Box, { tabIndex: 0, role: "slider", "aria-label": be, "aria-valuemax": fe, "aria-valuemin": K, "aria-valuenow": pe, ref: Re, __vars: { "--slider-thumb-offset": `${me}%` }, ...Ie("thumb", { focusable: !0 }), mod: { dragging: xe, disabled: De }, onFocus: Oe => { Ne(!0), typeof Ae == "function" && Ae(Oe) }, onBlur: Oe => { Ne(!1), typeof Se == "function" && Se(Oe) }, onTouchStart: ye, onMouseDown: ye, onKeyDownCapture: ve, onClick: Oe => Oe.stopPropagation(), children: [Be, jsxRuntimeExports.jsx(Transition$1, { mounted: ge != null && !!ke, transition: "fade", duration: 0, ..._e, children: Oe => jsxRuntimeExports.jsx("div", { ...Ie("label", { style: Oe }), children: ge }) })] }) }); Thumb.displayName = "@mantine/core/SliderThumb"; function getPosition({ value: fe, min: K, max: pe }) { const me = (fe - K) / (pe - K) * 100; return Math.min(Math.max(me, 0), 100) } function isMarkFilled({ mark: fe, offset: K, value: pe, inverted: me = !1 }) { return me ? typeof K == "number" && fe.value <= K || fe.value >= pe : typeof K == "number" ? fe.value >= K && fe.value <= pe : fe.value <= pe } function Marks({ marks: fe, min: K, max: pe, disabled: me, value: ge, offset: xe, inverted: ye }) { const { getStyles: ve } = useSliderContext(); if (!fe) return null; const _e = fe.map((Ee, be) => reactExports.createElement(Box, { ...ve("markWrapper"), __vars: { "--mark-offset": `${getPosition({ value: Ee.value, min: K, max: pe })}%` }, key: be }, jsxRuntimeExports.jsx(Box, { ...ve("mark"), mod: { filled: isMarkFilled({ mark: Ee, value: ge, offset: xe, inverted: ye }), disabled: me } }), Ee.label && jsxRuntimeExports.jsx("div", { ...ve("markLabel"), children: Ee.label }))); return jsxRuntimeExports.jsx("div", { children: _e }) } Marks.displayName = "@mantine/core/SliderMarks"; function Track({ filled: fe, children: K, offset: pe, disabled: me, marksOffset: ge, inverted: xe, containerProps: ye, ...ve }) { const { getStyles: _e } = useSliderContext(); return jsxRuntimeExports.jsx(Box, { ..._e("trackContainer"), mod: { disabled: me }, ...ye, children: jsxRuntimeExports.jsxs(Box, { ..._e("track"), mod: { inverted: xe, disabled: me }, children: [jsxRuntimeExports.jsx(Box, { mod: { inverted: xe, disabled: me }, __vars: { "--slider-bar-width": `calc(${fe}% + 2 * var(--slider-size))`, "--slider-bar-offset": `calc(${pe}% - var(--slider-size))` }, ..._e("bar") }), K, jsxRuntimeExports.jsx(Marks, { ...ve, offset: ge, disabled: me, inverted: xe })] }) }) } Track.displayName = "@mantine/core/SliderTrack"; function getChangeValue({ value: fe, containerWidth: K, min: pe, max: me, step: ge, precision: xe }) { const ve = (K ? Math.min(Math.max(fe, 0), K) / K : fe) * (me - pe), _e = (ve !== 0 ? Math.round(ve / ge) * ge : 0) + pe, Ee = Math.max(_e, pe); return xe !== void 0 ? Number(Ee.toFixed(xe)) : Ee } function getFloatingValue(fe, K) { return parseFloat(fe.toFixed(K)) } function getPrecision(fe) { if (!fe) return 0; const K = fe.toString().split("."); return K.length > 1 ? K[1].length : 0 } function getNextMarkValue(fe, K) { const me = [...K].sort((ge, xe) => ge.value - xe.value).find(ge => ge.value > fe); return me ? me.value : fe } function getPreviousMarkValue(fe, K) { const me = [...K].sort((ge, xe) => xe.value - ge.value).find(ge => ge.value < fe); return me ? me.value : fe } function getFirstMarkValue(fe) { const K = [...fe].sort((pe, me) => pe.value - me.value); return K.length > 0 ? K[0].value : 0 } function getLastMarkValue(fe) { const K = [...fe].sort((pe, me) => pe.value - me.value); return K.length > 0 ? K[K.length - 1].value : 100 } var __default__$5 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" }; const defaultProps$a = { radius: "xl", min: 0, max: 100, step: 1, marks: [], label: fe => fe, labelTransitionProps: { transition: "fade", duration: 0 }, labelAlwaysOn: !1, thumbLabel: "", showLabelOnHover: !0, disabled: !1, scale: fe => fe }, varsResolver$6 = (fe, { size: K, color: pe, thumbSize: me, radius: ge }) => ({ root: { "--slider-size": getSize(K, "slider-size"), "--slider-color": pe ? getThemeColor(pe, fe) : void 0, "--slider-radius": ge === void 0 ? void 0 : getRadius(ge), "--slider-thumb-size": me !== void 0 ? rem(me) : "calc(var(--slider-size) * 2)" } }), Slider = factory((fe, K) => { const pe = useProps("Slider", defaultProps$a, fe), { classNames: me, styles: ge, value: xe, onChange: ye, onChangeEnd: ve, size: _e, min: Ee, max: be, step: Ae, precision: Se, defaultValue: Ce, name: we, marks: Be, label: De, labelTransitionProps: Re, labelAlwaysOn: Ie, thumbLabel: Pe, showLabelOnHover: Ne, thumbChildren: ke, disabled: Oe, unstyled: Ue, scale: He, inverted: Ge, className: ze, style: We, vars: Xe, hiddenInputProps: Ye, restrictToMarks: Ze, thumbProps: ot, ...qe } = pe, Qe = useStyles({ name: "Slider", props: pe, classes: __default__$5, classNames: me, className: ze, styles: ge, style: We, vars: Xe, varsResolver: varsResolver$6, unstyled: Ue }), { dir: st } = useDirection(), [Nt, Je] = reactExports.useState(!1), [jt, Xt] = useUncontrolled({ value: typeof xe == "number" ? clamp$7(xe, Ee, be) : xe, defaultValue: typeof Ce == "number" ? clamp$7(Ce, Ee, be) : Ce, finalValue: clamp$7(0, Ee, be), onChange: ye }), ct = reactExports.useRef(jt), nn = reactExports.useRef(ve); reactExports.useEffect(() => { nn.current = ve }, [ve]); const $t = reactExports.useRef(null), an = reactExports.useRef(null), gn = getPosition({ value: jt, min: Ee, max: be }), Mn = He(jt), Xn = typeof De == "function" ? De(Mn) : De, Ln = Se ?? getPrecision(Ae), Gn = reactExports.useCallback(({ x: vn }) => { if (!Oe) { const yn = getChangeValue({ value: vn, min: Ee, max: be, step: Ae, precision: Ln }); Xt(Ze && Be?.length ? findClosestNumber(yn, Be.map(Hn => Hn.value)) : yn), ct.current = yn } }, [Oe, Ee, be, Ae, Ln, Xt, Be, Ze]), wn = reactExports.useCallback(() => { if (!Oe && nn.current) { const vn = Ze && Be?.length ? findClosestNumber(ct.current, Be.map(yn => yn.value)) : ct.current; nn.current(vn) } }, [Oe, Be, Ze]), { ref: Bn, active: Gt } = useMove(Gn, { onScrubEnd: wn }, st), nr = reactExports.useCallback(vn => { !Oe && nn.current && nn.current(vn) }, [Oe]), Kn = vn => { if (!Oe) switch (vn.key) { case "ArrowUp": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { const Hn = getNextMarkValue(jt, Be); Xt(Hn), nr(Hn); break } const yn = getFloatingValue(Math.min(Math.max(jt + Ae, Ee), be), Ln); Xt(yn), nr(yn); break } case "ArrowRight": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { const Hn = st === "rtl" ? getPreviousMarkValue(jt, Be) : getNextMarkValue(jt, Be); Xt(Hn), nr(Hn); break } const yn = getFloatingValue(Math.min(Math.max(st === "rtl" ? jt - Ae : jt + Ae, Ee), be), Ln); Xt(yn), nr(yn); break } case "ArrowDown": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { const Hn = getPreviousMarkValue(jt, Be); Xt(Hn), nr(Hn); break } const yn = getFloatingValue(Math.min(Math.max(jt - Ae, Ee), be), Ln); Xt(yn), nr(yn); break } case "ArrowLeft": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { const Hn = st === "rtl" ? getNextMarkValue(jt, Be) : getPreviousMarkValue(jt, Be); Xt(Hn), nr(Hn); break } const yn = getFloatingValue(Math.min(Math.max(st === "rtl" ? jt + Ae : jt - Ae, Ee), be), Ln); Xt(yn), nr(yn); break } case "Home": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { Xt(getFirstMarkValue(Be)), nr(getFirstMarkValue(Be)); break } Xt(Ee), nr(Ee); break } case "End": { if (vn.preventDefault(), an.current?.focus(), Ze && Be) { Xt(getLastMarkValue(Be)), nr(getLastMarkValue(Be)); break } Xt(be), nr(be); break } } }; return jsxRuntimeExports.jsx(SliderProvider, { value: { getStyles: Qe }, children: jsxRuntimeExports.jsxs(SliderRoot, { ...qe, ref: useMergedRef(K, $t), onKeyDownCapture: Kn, onMouseDownCapture: () => $t.current?.focus(), size: _e, disabled: Oe, children: [jsxRuntimeExports.jsx(Track, { inverted: Ge, offset: 0, filled: gn, marks: Be, min: Ee, max: be, value: Mn, disabled: Oe, containerProps: { ref: Bn, onMouseEnter: Ne ? () => Je(!0) : void 0, onMouseLeave: Ne ? () => Je(!1) : void 0 }, children: jsxRuntimeExports.jsx(Thumb, { max: be, min: Ee, value: Mn, position: gn, dragging: Gt, label: Xn, ref: an, labelTransitionProps: Re, labelAlwaysOn: Ie, thumbLabel: Pe, showLabelOnHover: Ne, isHovered: Nt, disabled: Oe, ...ot, children: ke }) }), jsxRuntimeExports.jsx("input", { type: "hidden", name: we, value: Mn, ...Ye })] }) }) }); Slider.classes = __default__$5; Slider.displayName = "@mantine/core/Slider"; var __default__$4 = { root: "m_6d731127" }; const defaultProps$9 = { gap: "md", align: "stretch", justify: "flex-start" }, varsResolver$5 = (fe, { gap: K, align: pe, justify: me }) => ({ root: { "--stack-gap": getSpacing(K), "--stack-align": pe, "--stack-justify": me } }), Stack = factory((fe, K) => { const pe = useProps("Stack", defaultProps$9, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, align: Ee, justify: be, gap: Ae, variant: Se, ...Ce } = pe, we = useStyles({ name: "Stack", props: pe, classes: __default__$4, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$5 }); return jsxRuntimeExports.jsx(Box, { ref: K, ...we("root"), variant: Se, ...Ce }) }); Stack.classes = __default__$4; Stack.displayName = "@mantine/core/Stack"; const [TableProvider, useTableContext] = createSafeContext("Table component was not found in the tree"); var __default__$3 = { table: "m_b23fa0ef", th: "m_4e7aa4f3", tr: "m_4e7aa4fd", td: "m_4e7aa4ef", tbody: "m_b2404537", thead: "m_b242d975", caption: "m_9e5a3ac7", scrollContainer: "m_a100c15", scrollContainerInner: "m_62259741" }; function getDataAttributes(fe, K) { if (!K) return; const pe = {}; return K.columnBorder && fe.withColumnBorders && (pe["data-with-column-border"] = !0), K.rowBorder && fe.withRowBorders && (pe["data-with-row-border"] = !0), K.striped && fe.striped && (pe["data-striped"] = fe.striped), K.highlightOnHover && fe.highlightOnHover && (pe["data-hover"] = !0), K.captionSide && fe.captionSide && (pe["data-side"] = fe.captionSide), K.stickyHeader && fe.stickyHeader && (pe["data-sticky"] = !0), pe } function tableElement(fe, K) { const pe = `Table${fe.charAt(0).toUpperCase()}${fe.slice(1)}`, me = factory((ge, xe) => { const ye = useProps(pe, {}, ge), { classNames: ve, className: _e, style: Ee, styles: be, ...Ae } = ye, Se = useTableContext(); return jsxRuntimeExports.jsx(Box, { component: fe, ref: xe, ...getDataAttributes(Se, K), ...Se.getStyles(fe, { className: _e, classNames: ve, style: Ee, styles: be, props: ye }), ...Ae }) }); return me.displayName = `@mantine/core/${pe}`, me.classes = __default__$3, me } const TableTh = tableElement("th", { columnBorder: !0 }), TableTd = tableElement("td", { columnBorder: !0 }), TableTr = tableElement("tr", { rowBorder: !0, striped: !0, highlightOnHover: !0 }), TableThead = tableElement("thead", { stickyHeader: !0 }), TableTbody = tableElement("tbody"), TableTfoot = tableElement("tfoot"), TableCaption = tableElement("caption", { captionSide: !0 }); function TableDataRenderer({ data: fe }) { return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [fe.caption && jsxRuntimeExports.jsx(TableCaption, { children: fe.caption }), fe.head && jsxRuntimeExports.jsx(TableThead, { children: jsxRuntimeExports.jsx(TableTr, { children: fe.head.map((K, pe) => jsxRuntimeExports.jsx(TableTh, { children: K }, pe)) }) }), fe.body && jsxRuntimeExports.jsx(TableTbody, { children: fe.body.map((K, pe) => jsxRuntimeExports.jsx(TableTr, { children: K.map((me, ge) => jsxRuntimeExports.jsx(TableTd, { children: me }, ge)) }, pe)) }), fe.foot && jsxRuntimeExports.jsx(TableTfoot, { children: jsxRuntimeExports.jsx(TableTr, { children: fe.foot.map((K, pe) => jsxRuntimeExports.jsx(TableTh, { children: K }, pe)) }) })] }) } TableDataRenderer.displayName = "@mantine/core/TableDataRenderer"; const defaultProps$8 = { type: "scrollarea" }, varsResolver$4 = (fe, { minWidth: K, maxHeight: pe, type: me }) => ({ scrollContainer: { "--table-min-width": rem(K), "--table-max-height": rem(pe), "--table-overflow": me === "native" ? "auto" : void 0 } }), TableScrollContainer = factory((fe, K) => { const pe = useProps("TableScrollContainer", defaultProps$8, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, children: Ee, minWidth: be, maxHeight: Ae, type: Se, scrollAreaProps: Ce, ...we } = pe, Be = useStyles({ name: "TableScrollContainer", classes: __default__$3, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver: varsResolver$4, rootSelector: "scrollContainer" }); return jsxRuntimeExports.jsx(Box, { component: Se === "scrollarea" ? ScrollArea : "div", ...Se === "scrollarea" ? Ae ? { offsetScrollbars: "xy", ...Ce } : { offsetScrollbars: "x", ...Ce } : {}, ref: K, ...Be("scrollContainer"), ...we, children: jsxRuntimeExports.jsx("div", { ...Be("scrollContainerInner"), children: Ee }) }) }); TableScrollContainer.classes = __default__$3; TableScrollContainer.displayName = "@mantine/core/TableScrollContainer"; const defaultProps$7 = { withRowBorders: !0, verticalSpacing: 7 }, varsResolver$3 = (fe, { layout: K, captionSide: pe, horizontalSpacing: me, verticalSpacing: ge, borderColor: xe, stripedColor: ye, highlightOnHoverColor: ve, striped: _e, highlightOnHover: Ee, stickyHeaderOffset: be, stickyHeader: Ae }) => ({ table: { "--table-layout": K, "--table-caption-side": pe, "--table-horizontal-spacing": getSpacing(me), "--table-vertical-spacing": getSpacing(ge), "--table-border-color": xe ? getThemeColor(xe, fe) : void 0, "--table-striped-color": _e && ye ? getThemeColor(ye, fe) : void 0, "--table-highlight-on-hover-color": Ee && ve ? getThemeColor(ve, fe) : void 0, "--table-sticky-header-offset": Ae ? rem(be) : void 0 } }), Table = factory((fe, K) => { const pe = useProps("Table", defaultProps$7, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, horizontalSpacing: Ee, verticalSpacing: be, captionSide: Ae, stripedColor: Se, highlightOnHoverColor: Ce, striped: we, highlightOnHover: Be, withColumnBorders: De, withRowBorders: Re, withTableBorder: Ie, borderColor: Pe, layout: Ne, variant: ke, data: Oe, children: Ue, stickyHeader: He, stickyHeaderOffset: Ge, mod: ze, tabularNums: We, ...Xe } = pe, Ye = useStyles({ name: "Table", props: pe, className: ge, style: xe, classes: __default__$3, classNames: me, styles: ye, unstyled: ve, rootSelector: "table", vars: _e, varsResolver: varsResolver$3 }); return jsxRuntimeExports.jsx(TableProvider, { value: { getStyles: Ye, stickyHeader: He, striped: we === !0 ? "odd" : we || void 0, highlightOnHover: Be, withColumnBorders: De, withRowBorders: Re, captionSide: Ae || "bottom" }, children: jsxRuntimeExports.jsx(Box, { component: "table", variant: ke, ref: K, mod: [{ "data-with-table-border": Ie, "data-tabular-nums": We }, ze], ...Ye("table"), ...Xe, children: Ue || !!Oe && jsxRuntimeExports.jsx(TableDataRenderer, { data: Oe }) }) }) }); Table.classes = __default__$3; Table.displayName = "@mantine/core/Table"; Table.Td = TableTd; Table.Th = TableTh; Table.Tr = TableTr; Table.Thead = TableThead; Table.Tbody = TableTbody; Table.Tfoot = TableTfoot; Table.Caption = TableCaption; Table.ScrollContainer = TableScrollContainer; Table.DataRenderer = TableDataRenderer; const [TabsProvider, useTabsContext] = createSafeContext("Tabs component was not found in the tree"); var __default__$2 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", tab: "m_4ec4dce6", panel: "m_b0c91715", tabSection: "m_fc420b1f", tabLabel: "m_42bbd1ae", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" }; const defaultProps$6 = {}, TabsList = factory((fe, K) => { const pe = useProps("TabsList", defaultProps$6, fe), { children: me, className: ge, grow: xe, justify: ye, classNames: ve, styles: _e, style: Ee, mod: be, ...Ae } = pe, Se = useTabsContext(); return jsxRuntimeExports.jsx(Box, { ...Ae, ...Se.getStyles("list", { className: ge, style: Ee, classNames: ve, styles: _e, props: pe, variant: Se.variant }), ref: K, role: "tablist", variant: Se.variant, mod: [{ grow: xe, orientation: Se.orientation, placement: Se.orientation === "vertical" && Se.placement, inverted: Se.inverted }, be], "aria-orientation": Se.orientation, __vars: { "--tabs-justify": ye }, children: me }) }); TabsList.classes = __default__$2; TabsList.displayName = "@mantine/core/TabsList"; const defaultProps$5 = {}, TabsPanel = factory((fe, K) => { const pe = useProps("TabsPanel", defaultProps$5, fe), { children: me, className: ge, value: xe, classNames: ye, styles: ve, style: _e, mod: Ee, keepMounted: be, ...Ae } = pe, Se = useTabsContext(), Ce = Se.value === xe, we = Se.keepMounted || be || Ce ? me : null; return jsxRuntimeExports.jsx(Box, { ...Ae, ...Se.getStyles("panel", { className: ge, classNames: ye, styles: ve, style: [_e, Ce ? void 0 : { display: "none" }], props: pe }), ref: K, mod: [{ orientation: Se.orientation }, Ee], role: "tabpanel", id: Se.getPanelId(xe), "aria-labelledby": Se.getTabId(xe), children: we }) }); TabsPanel.classes = __default__$2; TabsPanel.displayName = "@mantine/core/TabsPanel"; const defaultProps$4 = {}, TabsTab = factory((fe, K) => { const pe = useProps("TabsTab", defaultProps$4, fe), { className: me, children: ge, rightSection: xe, leftSection: ye, value: ve, onClick: _e, onKeyDown: Ee, disabled: be, color: Ae, style: Se, classNames: Ce, styles: we, vars: Be, mod: De, tabIndex: Re, ...Ie } = pe, Pe = useMantineTheme(), { dir: Ne } = useDirection(), ke = useTabsContext(), Oe = ve === ke.value, Ue = Ge => { ke.onChange(ke.allowTabDeactivation && ve === ke.value ? null : ve), _e?.(Ge) }, He = { classNames: Ce, styles: we, props: pe }; return jsxRuntimeExports.jsxs(UnstyledButton, { ...Ie, ...ke.getStyles("tab", { className: me, style: Se, variant: ke.variant, ...He }), disabled: be, unstyled: ke.unstyled, variant: ke.variant, mod: [{ active: Oe, disabled: be, orientation: ke.orientation, inverted: ke.inverted, placement: ke.orientation === "vertical" && ke.placement }, De], ref: K, role: "tab", id: ke.getTabId(ve), "aria-selected": Oe, tabIndex: Re !== void 0 ? Re : Oe || ke.value === null ? 0 : -1, "aria-controls": ke.getPanelId(ve), onClick: Ue, __vars: { "--tabs-color": Ae ? getThemeColor(Ae, Pe) : void 0 }, onKeyDown: createScopedKeydownHandler({ siblingSelector: '[role="tab"]', parentSelector: '[role="tablist"]', activateOnFocus: ke.activateTabWithKeyboard, loop: ke.loop, orientation: ke.orientation || "horizontal", dir: Ne, onKeyDown: Ee }), children: [ye && jsxRuntimeExports.jsx("span", { ...ke.getStyles("tabSection", He), "data-position": "left", children: ye }), ge && jsxRuntimeExports.jsx("span", { ...ke.getStyles("tabLabel", He), children: ge }), xe && jsxRuntimeExports.jsx("span", { ...ke.getStyles("tabSection", He), "data-position": "right", children: xe })] }) }); TabsTab.classes = __default__$2; TabsTab.displayName = "@mantine/core/TabsTab"; const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$3 = { keepMounted: !0, orientation: "horizontal", loop: !0, activateTabWithKeyboard: !0, allowTabDeactivation: !1, unstyled: !1, inverted: !1, variant: "default", placement: "left" }, varsResolver$2 = (fe, { radius: K, color: pe, autoContrast: me }) => ({ root: { "--tabs-radius": getRadius(K), "--tabs-color": getThemeColor(pe, fe), "--tabs-text-color": getAutoContrastValue(me, fe) ? getContrastColor({ color: pe, theme: fe, autoContrast: me }) : void 0 } }), Tabs = factory((fe, K) => { const pe = useProps("Tabs", defaultProps$3, fe), { defaultValue: me, value: ge, onChange: xe, orientation: ye, children: ve, loop: _e, id: Ee, activateTabWithKeyboard: be, allowTabDeactivation: Ae, variant: Se, color: Ce, radius: we, inverted: Be, placement: De, keepMounted: Re, classNames: Ie, styles: Pe, unstyled: Ne, className: ke, style: Oe, vars: Ue, autoContrast: He, mod: Ge, ...ze } = pe, We = useId$1(Ee), [Xe, Ye] = useUncontrolled({ value: ge, defaultValue: me, finalValue: null, onChange: xe }), Ze = useStyles({ name: "Tabs", props: pe, classes: __default__$2, className: ke, style: Oe, classNames: Ie, styles: Pe, unstyled: Ne, vars: Ue, varsResolver: varsResolver$2 }); return jsxRuntimeExports.jsx(TabsProvider, { value: { placement: De, value: Xe, orientation: ye, id: We, loop: _e, activateTabWithKeyboard: be, getTabId: getSafeId(`${We}-tab`, VALUE_ERROR), getPanelId: getSafeId(`${We}-panel`, VALUE_ERROR), onChange: Ye, allowTabDeactivation: Ae, variant: Se, color: Ce, radius: we, inverted: Be, keepMounted: Re, unstyled: Ne, getStyles: Ze }, children: jsxRuntimeExports.jsx(Box, { ref: K, id: We, variant: Se, mod: [{ orientation: ye, inverted: ye === "horizontal" && Be, placement: ye === "vertical" && De }, Ge], ...Ze("root"), ...ze, children: ve }) }) }); Tabs.classes = __default__$2; Tabs.displayName = "@mantine/core/Tabs"; Tabs.Tab = TabsTab; Tabs.Panel = TabsPanel; Tabs.List = TabsList; const defaultProps$2 = {}, TextInput = factory((fe, K) => { const pe = useProps("TextInput", defaultProps$2, fe); return jsxRuntimeExports.jsx(InputBase, { component: "input", ref: K, ...pe, __staticSelector: "TextInput" }) }); TextInput.classes = InputBase.classes; TextInput.displayName = "@mantine/core/TextInput"; const headings = ["h1", "h2", "h3", "h4", "h5", "h6"], sizes = ["xs", "sm", "md", "lg", "xl"]; function getTitleSize(fe, K) { const pe = K !== void 0 ? K : `h${fe}`; return headings.includes(pe) ? { fontSize: `var(--mantine-${pe}-font-size)`, fontWeight: `var(--mantine-${pe}-font-weight)`, lineHeight: `var(--mantine-${pe}-line-height)` } : sizes.includes(pe) ? { fontSize: `var(--mantine-font-size-${pe})`, fontWeight: `var(--mantine-h${fe}-font-weight)`, lineHeight: `var(--mantine-h${fe}-line-height)` } : { fontSize: rem(pe), fontWeight: `var(--mantine-h${fe}-font-weight)`, lineHeight: `var(--mantine-h${fe}-line-height)` } } var __default__$1 = { root: "m_8a5d1357" }; const defaultProps$1 = { order: 1 }, varsResolver$1 = (fe, { order: K, size: pe, lineClamp: me, textWrap: ge }) => { const xe = getTitleSize(K, pe); return { root: { "--title-fw": xe.fontWeight, "--title-lh": xe.lineHeight, "--title-fz": xe.fontSize, "--title-line-clamp": typeof me == "number" ? me.toString() : void 0, "--title-text-wrap": ge } } }, Title = factory((fe, K) => { const pe = useProps("Title", defaultProps$1, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, order: _e, vars: Ee, size: be, variant: Ae, lineClamp: Se, textWrap: Ce, mod: we, ...Be } = pe, De = useStyles({ name: "Title", props: pe, classes: __default__$1, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: Ee, varsResolver: varsResolver$1 }); return [1, 2, 3, 4, 5, 6].includes(_e) ? jsxRuntimeExports.jsx(Box, { ...De("root"), component: `h${_e}`, variant: Ae, ref: K, mod: [{ order: _e, "data-line-clamp": typeof Se == "number" }, we], size: be, ...Be }) : null }); Title.classes = __default__$1; Title.displayName = "@mantine/core/Title"; const positions = ["bottom-center", "bottom-left", "bottom-right", "top-center", "top-left", "top-right"]; function getGroupedNotifications(fe, K) { return fe.reduce((pe, me) => (pe[me.position || K].push(me), pe), positions.reduce((pe, me) => (pe[me] = [], pe), {})) } const transforms = { left: "translateX(-100%)", right: "translateX(100%)", "top-center": "translateY(-100%)", "bottom-center": "translateY(100%)" }, noTransform = { left: "translateX(0)", right: "translateX(0)", "top-center": "translateY(0)", "bottom-center": "translateY(0)" }; function getNotificationStateStyles({ state: fe, maxHeight: K, position: pe, transitionDuration: me }) { const [ge, xe] = pe.split("-"), ye = xe === "center" ? `${ge}-center` : xe, ve = { opacity: 0, maxHeight: K, transform: transforms[ye], transitionDuration: `${me}ms, ${me}ms, ${me}ms`, transitionTimingFunction: "cubic-bezier(.51,.3,0,1.21), cubic-bezier(.51,.3,0,1.21), linear", transitionProperty: "opacity, transform, max-height" }, _e = { opacity: 1, transform: noTransform[ye] }, Ee = { opacity: 0, maxHeight: 0, transform: transforms[ye] }; return { ...ve, ...{ entering: _e, entered: _e, exiting: Ee, exited: Ee }[fe] } } function getAutoClose(fe, K) { return typeof K == "number" ? K : K === !1 || fe === !1 ? !1 : fe } const NotificationContainer = reactExports.forwardRef(({ data: fe, onHide: K, autoClose: pe, ...me }, ge) => { const { autoClose: xe, message: ye, ...ve } = fe, _e = getAutoClose(pe, fe.autoClose), Ee = reactExports.useRef(-1), be = () => window.clearTimeout(Ee.current), Ae = () => { K(fe.id), be() }, Se = () => { typeof _e == "number" && (Ee.current = window.setTimeout(Ae, _e)) }; return reactExports.useEffect(() => { fe.onOpen?.(fe) }, []), reactExports.useEffect(() => (Se(), be), [_e]), jsxRuntimeExports.jsx(Notification, { ...me, ...ve, onClose: Ae, ref: ge, onMouseEnter: be, onMouseLeave: Se, children: ye }) }); NotificationContainer.displayName = "@mantine/notifications/NotificationContainer"; var __default__ = { root: "m_b37d9ac7", notification: "m_5ed0edd0" }; const Transition = Transition$2, defaultProps = { position: "bottom-right", autoClose: 4e3, transitionDuration: 250, containerWidth: 440, notificationMaxHeight: 200, limit: 5, zIndex: getDefaultZIndex("overlay"), store: notificationsStore, withinPortal: !0 }, varsResolver = (fe, { zIndex: K, containerWidth: pe }) => ({ root: { "--notifications-z-index": K?.toString(), "--notifications-container-width": rem(pe) } }), Notifications = factory((fe, K) => { const pe = useProps("Notifications", defaultProps, fe), { classNames: me, className: ge, style: xe, styles: ye, unstyled: ve, vars: _e, position: Ee, autoClose: be, transitionDuration: Ae, containerWidth: Se, notificationMaxHeight: Ce, limit: we, zIndex: Be, store: De, portalProps: Re, withinPortal: Ie, ...Pe } = pe, Ne = useMantineTheme(), ke = useNotifications(De), Oe = useForceUpdate(), Ue = useReducedMotion(), He = reactExports.useRef({}), Ge = reactExports.useRef(0), We = (Ne.respectReducedMotion ? Ue : !1) ? 1 : Ae, Xe = useStyles({ name: "Notifications", classes: __default__, props: pe, className: ge, style: xe, classNames: me, styles: ye, unstyled: ve, vars: _e, varsResolver }); reactExports.useEffect(() => { De?.updateState(ot => ({ ...ot, limit: we || 5, defaultPosition: Ee })) }, [we, Ee]), useDidUpdate(() => { ke.notifications.length > Ge.current && setTimeout(() => Oe(), 0), Ge.current = ke.notifications.length }, [ke.notifications]); const Ye = getGroupedNotifications(ke.notifications, Ee), Ze = positions.reduce((ot, qe) => (ot[qe] = Ye[qe].map(({ style: Qe, ...st }) => jsxRuntimeExports.jsx(Transition, { timeout: We, onEnter: () => He.current[st.id].offsetHeight, nodeRef: { current: He.current[st.id] }, children: Nt => jsxRuntimeExports.jsx(NotificationContainer, { ref: Je => { He.current[st.id] = Je }, data: st, onHide: Je => hideNotification(Je, De), autoClose: be, ...Xe("notification", { style: { ...getNotificationStateStyles({ state: Nt, position: qe, transitionDuration: We, maxHeight: Ce }), ...Qe } }) }) }, st.id)), ot), {}); return jsxRuntimeExports.jsxs(OptionalPortal, { withinPortal: Ie, ...Re, children: [jsxRuntimeExports.jsx(Box, { ...Xe("root"), "data-position": "top-center", ref: K, ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["top-center"] }) }), jsxRuntimeExports.jsx(Box, { ...Xe("root"), "data-position": "top-left", ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["top-left"] }) }), jsxRuntimeExports.jsx(Box, { ...Xe("root", { className: ReactRemoveScroll.classNames.fullWidth }), "data-position": "top-right", ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["top-right"] }) }), jsxRuntimeExports.jsx(Box, { ...Xe("root", { className: ReactRemoveScroll.classNames.fullWidth }), "data-position": "bottom-right", ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["bottom-right"] }) }), jsxRuntimeExports.jsx(Box, { ...Xe("root"), "data-position": "bottom-left", ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["bottom-left"] }) }), jsxRuntimeExports.jsx(Box, { ...Xe("root"), "data-position": "bottom-center", ...Pe, children: jsxRuntimeExports.jsx(TransitionGroup, { children: Ze["bottom-center"] }) })] }) }); Notifications.classes = __default__; Notifications.displayName = "@mantine/notifications/Notifications"; Notifications.show = notifications.show; Notifications.hide = notifications.hide; Notifications.update = notifications.update; Notifications.clean = notifications.clean; Notifications.cleanQueue = notifications.cleanQueue; Notifications.updateState = notifications.updateState;/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION = "174", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, ConstantColorFactor = 211, OneMinusConstantColorFactor = 212, ConstantAlphaFactor = 213, OneMinusConstantAlphaFactor = 214, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, AgXToneMapping = 6, NeutralToneMapping = 7, AttachedBindMode = "attached", DetachedBindMode = "detached", UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, UnsignedInt5999Type = 35902, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, RGB_BPTC_SIGNED_Format = 36494, RGB_BPTC_UNSIGNED_Format = 36495, RED_RGTC1_Format = 36283, SIGNED_RED_RGTC1_Format = 36284, RED_GREEN_RGTC2_Format = 36285, SIGNED_RED_GREEN_RGTC2_Format = 36286, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, BasicDepthPacking = 3200, RGBADepthPacking = 3201, RGBDepthPacking = 3202, RGDepthPacking = 3203, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, NoColorSpace = "", SRGBColorSpace = "srgb", LinearSRGBColorSpace = "srgb-linear", LinearTransfer = "linear", SRGBTransfer = "srgb", ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, NeverCompare = 512, LessCompare = 513, EqualCompare = 514, LessEqualCompare = 515, GreaterCompare = 516, NotEqualCompare = 517, GreaterEqualCompare = 518, AlwaysCompare = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = "100", GLSL3 = "300 es", WebGLCoordinateSystem = 2e3, WebGPUCoordinateSystem = 2001, TimestampQuery = { COMPUTE: "compute", RENDER: "render" }; let EventDispatcher$2 = class { addEventListener(K, pe) { this._listeners === void 0 && (this._listeners = {}); const me = this._listeners; me[K] === void 0 && (me[K] = []), me[K].indexOf(pe) === -1 && me[K].push(pe) } hasEventListener(K, pe) { const me = this._listeners; return me === void 0 ? !1 : me[K] !== void 0 && me[K].indexOf(pe) !== -1 } removeEventListener(K, pe) { const me = this._listeners; if (me === void 0) return; const ge = me[K]; if (ge !== void 0) { const xe = ge.indexOf(pe); xe !== -1 && ge.splice(xe, 1) } } dispatchEvent(K) { const pe = this._listeners; if (pe === void 0) return; const me = pe[K.type]; if (me !== void 0) { K.target = this; const ge = me.slice(0); for (let xe = 0, ye = ge.length; xe < ye; xe++)ge[xe].call(this, K); K.target = null } } }; const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let _seed = 1234567; const DEG2RAD$1 = Math.PI / 180, RAD2DEG = 180 / Math.PI; function generateUUID() { const fe = Math.random() * 4294967295 | 0, K = Math.random() * 4294967295 | 0, pe = Math.random() * 4294967295 | 0, me = Math.random() * 4294967295 | 0; return (_lut[fe & 255] + _lut[fe >> 8 & 255] + _lut[fe >> 16 & 255] + _lut[fe >> 24 & 255] + "-" + _lut[K & 255] + _lut[K >> 8 & 255] + "-" + _lut[K >> 16 & 15 | 64] + _lut[K >> 24 & 255] + "-" + _lut[pe & 63 | 128] + _lut[pe >> 8 & 255] + "-" + _lut[pe >> 16 & 255] + _lut[pe >> 24 & 255] + _lut[me & 255] + _lut[me >> 8 & 255] + _lut[me >> 16 & 255] + _lut[me >> 24 & 255]).toLowerCase() } function clamp$3(fe, K, pe) { return Math.max(K, Math.min(pe, fe)) } function euclideanModulo(fe, K) { return (fe % K + K) % K } function mapLinear(fe, K, pe, me, ge) { return me + (fe - K) * (ge - me) / (pe - K) } function inverseLerp(fe, K, pe) { return fe !== K ? (pe - fe) / (K - fe) : 0 } function lerp(fe, K, pe) { return (1 - pe) * fe + pe * K } function damp(fe, K, pe, me) { return lerp(fe, K, 1 - Math.exp(-pe * me)) } function pingpong(fe, K = 1) { return K - Math.abs(euclideanModulo(fe, K * 2) - K) } function smoothstep(fe, K, pe) { return fe <= K ? 0 : fe >= pe ? 1 : (fe = (fe - K) / (pe - K), fe * fe * (3 - 2 * fe)) } function smootherstep(fe, K, pe) { return fe <= K ? 0 : fe >= pe ? 1 : (fe = (fe - K) / (pe - K), fe * fe * fe * (fe * (fe * 6 - 15) + 10)) } function randInt(fe, K) { return fe + Math.floor(Math.random() * (K - fe + 1)) } function randFloat(fe, K) { return fe + Math.random() * (K - fe) } function randFloatSpread(fe) { return fe * (.5 - Math.random()) } function seededRandom(fe) { fe !== void 0 && (_seed = fe); let K = _seed += 1831565813; return K = Math.imul(K ^ K >>> 15, K | 1), K ^= K + Math.imul(K ^ K >>> 7, K | 61), ((K ^ K >>> 14) >>> 0) / 4294967296 } function degToRad(fe) { return fe * DEG2RAD$1 } function radToDeg(fe) { return fe * RAD2DEG } function isPowerOfTwo(fe) { return (fe & fe - 1) === 0 && fe !== 0 } function ceilPowerOfTwo(fe) { return Math.pow(2, Math.ceil(Math.log(fe) / Math.LN2)) } function floorPowerOfTwo(fe) { return Math.pow(2, Math.floor(Math.log(fe) / Math.LN2)) } function setQuaternionFromProperEuler(fe, K, pe, me, ge) { const xe = Math.cos, ye = Math.sin, ve = xe(pe / 2), _e = ye(pe / 2), Ee = xe((K + me) / 2), be = ye((K + me) / 2), Ae = xe((K - me) / 2), Se = ye((K - me) / 2), Ce = xe((me - K) / 2), we = ye((me - K) / 2); switch (ge) { case "XYX": fe.set(ve * be, _e * Ae, _e * Se, ve * Ee); break; case "YZY": fe.set(_e * Se, ve * be, _e * Ae, ve * Ee); break; case "ZXZ": fe.set(_e * Ae, _e * Se, ve * be, ve * Ee); break; case "XZX": fe.set(ve * be, _e * we, _e * Ce, ve * Ee); break; case "YXY": fe.set(_e * Ce, ve * be, _e * we, ve * Ee); break; case "ZYZ": fe.set(_e * we, _e * Ce, ve * be, ve * Ee); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + ge) } } function denormalize(fe, K) { switch (K.constructor) { case Float32Array: return fe; case Uint32Array: return fe / 4294967295; case Uint16Array: return fe / 65535; case Uint8Array: return fe / 255; case Int32Array: return Math.max(fe / 2147483647, -1); case Int16Array: return Math.max(fe / 32767, -1); case Int8Array: return Math.max(fe / 127, -1); default: throw new Error("Invalid component type.") } } function normalize$2(fe, K) { switch (K.constructor) { case Float32Array: return fe; case Uint32Array: return Math.round(fe * 4294967295); case Uint16Array: return Math.round(fe * 65535); case Uint8Array: return Math.round(fe * 255); case Int32Array: return Math.round(fe * 2147483647); case Int16Array: return Math.round(fe * 32767); case Int8Array: return Math.round(fe * 127); default: throw new Error("Invalid component type.") } } const MathUtils = { DEG2RAD: DEG2RAD$1, RAD2DEG, generateUUID, clamp: clamp$3, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler, normalize: normalize$2, denormalize }; class Vector2 { constructor(K = 0, pe = 0) { Vector2.prototype.isVector2 = !0, this.x = K, this.y = pe } get width() { return this.x } set width(K) { this.x = K } get height() { return this.y } set height(K) { this.y = K } set(K, pe) { return this.x = K, this.y = pe, this } setScalar(K) { return this.x = K, this.y = K, this } setX(K) { return this.x = K, this } setY(K) { return this.y = K, this } setComponent(K, pe) { switch (K) { case 0: this.x = pe; break; case 1: this.y = pe; break; default: throw new Error("index is out of range: " + K) }return this } getComponent(K) { switch (K) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + K) } } clone() { return new this.constructor(this.x, this.y) } copy(K) { return this.x = K.x, this.y = K.y, this } add(K) { return this.x += K.x, this.y += K.y, this } addScalar(K) { return this.x += K, this.y += K, this } addVectors(K, pe) { return this.x = K.x + pe.x, this.y = K.y + pe.y, this } addScaledVector(K, pe) { return this.x += K.x * pe, this.y += K.y * pe, this } sub(K) { return this.x -= K.x, this.y -= K.y, this } subScalar(K) { return this.x -= K, this.y -= K, this } subVectors(K, pe) { return this.x = K.x - pe.x, this.y = K.y - pe.y, this } multiply(K) { return this.x *= K.x, this.y *= K.y, this } multiplyScalar(K) { return this.x *= K, this.y *= K, this } divide(K) { return this.x /= K.x, this.y /= K.y, this } divideScalar(K) { return this.multiplyScalar(1 / K) } applyMatrix3(K) { const pe = this.x, me = this.y, ge = K.elements; return this.x = ge[0] * pe + ge[3] * me + ge[6], this.y = ge[1] * pe + ge[4] * me + ge[7], this } min(K) { return this.x = Math.min(this.x, K.x), this.y = Math.min(this.y, K.y), this } max(K) { return this.x = Math.max(this.x, K.x), this.y = Math.max(this.y, K.y), this } clamp(K, pe) { return this.x = clamp$3(this.x, K.x, pe.x), this.y = clamp$3(this.y, K.y, pe.y), this } clampScalar(K, pe) { return this.x = clamp$3(this.x, K, pe), this.y = clamp$3(this.y, K, pe), this } clampLength(K, pe) { const me = this.length(); return this.divideScalar(me || 1).multiplyScalar(clamp$3(me, K, pe)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(K) { return this.x * K.x + this.y * K.y } cross(K) { return this.x * K.y - this.y * K.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(K) { const pe = Math.sqrt(this.lengthSq() * K.lengthSq()); if (pe === 0) return Math.PI / 2; const me = this.dot(K) / pe; return Math.acos(clamp$3(me, -1, 1)) } distanceTo(K) { return Math.sqrt(this.distanceToSquared(K)) } distanceToSquared(K) { const pe = this.x - K.x, me = this.y - K.y; return pe * pe + me * me } manhattanDistanceTo(K) { return Math.abs(this.x - K.x) + Math.abs(this.y - K.y) } setLength(K) { return this.normalize().multiplyScalar(K) } lerp(K, pe) { return this.x += (K.x - this.x) * pe, this.y += (K.y - this.y) * pe, this } lerpVectors(K, pe, me) { return this.x = K.x + (pe.x - K.x) * me, this.y = K.y + (pe.y - K.y) * me, this } equals(K) { return K.x === this.x && K.y === this.y } fromArray(K, pe = 0) { return this.x = K[pe], this.y = K[pe + 1], this } toArray(K = [], pe = 0) { return K[pe] = this.x, K[pe + 1] = this.y, K } fromBufferAttribute(K, pe) { return this.x = K.getX(pe), this.y = K.getY(pe), this } rotateAround(K, pe) { const me = Math.cos(pe), ge = Math.sin(pe), xe = this.x - K.x, ye = this.y - K.y; return this.x = xe * me - ye * ge + K.x, this.y = xe * ge + ye * me + K.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Matrix3 { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee) { Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], K !== void 0 && this.set(K, pe, me, ge, xe, ye, ve, _e, Ee) } set(K, pe, me, ge, xe, ye, ve, _e, Ee) { const be = this.elements; return be[0] = K, be[1] = ge, be[2] = ve, be[3] = pe, be[4] = xe, be[5] = _e, be[6] = me, be[7] = ye, be[8] = Ee, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(K) { const pe = this.elements, me = K.elements; return pe[0] = me[0], pe[1] = me[1], pe[2] = me[2], pe[3] = me[3], pe[4] = me[4], pe[5] = me[5], pe[6] = me[6], pe[7] = me[7], pe[8] = me[8], this } extractBasis(K, pe, me) { return K.setFromMatrix3Column(this, 0), pe.setFromMatrix3Column(this, 1), me.setFromMatrix3Column(this, 2), this } setFromMatrix4(K) { const pe = K.elements; return this.set(pe[0], pe[4], pe[8], pe[1], pe[5], pe[9], pe[2], pe[6], pe[10]), this } multiply(K) { return this.multiplyMatrices(this, K) } premultiply(K) { return this.multiplyMatrices(K, this) } multiplyMatrices(K, pe) { const me = K.elements, ge = pe.elements, xe = this.elements, ye = me[0], ve = me[3], _e = me[6], Ee = me[1], be = me[4], Ae = me[7], Se = me[2], Ce = me[5], we = me[8], Be = ge[0], De = ge[3], Re = ge[6], Ie = ge[1], Pe = ge[4], Ne = ge[7], ke = ge[2], Oe = ge[5], Ue = ge[8]; return xe[0] = ye * Be + ve * Ie + _e * ke, xe[3] = ye * De + ve * Pe + _e * Oe, xe[6] = ye * Re + ve * Ne + _e * Ue, xe[1] = Ee * Be + be * Ie + Ae * ke, xe[4] = Ee * De + be * Pe + Ae * Oe, xe[7] = Ee * Re + be * Ne + Ae * Ue, xe[2] = Se * Be + Ce * Ie + we * ke, xe[5] = Se * De + Ce * Pe + we * Oe, xe[8] = Se * Re + Ce * Ne + we * Ue, this } multiplyScalar(K) { const pe = this.elements; return pe[0] *= K, pe[3] *= K, pe[6] *= K, pe[1] *= K, pe[4] *= K, pe[7] *= K, pe[2] *= K, pe[5] *= K, pe[8] *= K, this } determinant() { const K = this.elements, pe = K[0], me = K[1], ge = K[2], xe = K[3], ye = K[4], ve = K[5], _e = K[6], Ee = K[7], be = K[8]; return pe * ye * be - pe * ve * Ee - me * xe * be + me * ve * _e + ge * xe * Ee - ge * ye * _e } invert() { const K = this.elements, pe = K[0], me = K[1], ge = K[2], xe = K[3], ye = K[4], ve = K[5], _e = K[6], Ee = K[7], be = K[8], Ae = be * ye - ve * Ee, Se = ve * _e - be * xe, Ce = Ee * xe - ye * _e, we = pe * Ae + me * Se + ge * Ce; if (we === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const Be = 1 / we; return K[0] = Ae * Be, K[1] = (ge * Ee - be * me) * Be, K[2] = (ve * me - ge * ye) * Be, K[3] = Se * Be, K[4] = (be * pe - ge * _e) * Be, K[5] = (ge * xe - ve * pe) * Be, K[6] = Ce * Be, K[7] = (me * _e - Ee * pe) * Be, K[8] = (ye * pe - me * xe) * Be, this } transpose() { let K; const pe = this.elements; return K = pe[1], pe[1] = pe[3], pe[3] = K, K = pe[2], pe[2] = pe[6], pe[6] = K, K = pe[5], pe[5] = pe[7], pe[7] = K, this } getNormalMatrix(K) { return this.setFromMatrix4(K).invert().transpose() } transposeIntoArray(K) { const pe = this.elements; return K[0] = pe[0], K[1] = pe[3], K[2] = pe[6], K[3] = pe[1], K[4] = pe[4], K[5] = pe[7], K[6] = pe[2], K[7] = pe[5], K[8] = pe[8], this } setUvTransform(K, pe, me, ge, xe, ye, ve) { const _e = Math.cos(xe), Ee = Math.sin(xe); return this.set(me * _e, me * Ee, -me * (_e * ye + Ee * ve) + ye + K, -ge * Ee, ge * _e, -ge * (-Ee * ye + _e * ve) + ve + pe, 0, 0, 1), this } scale(K, pe) { return this.premultiply(_m3.makeScale(K, pe)), this } rotate(K) { return this.premultiply(_m3.makeRotation(-K)), this } translate(K, pe) { return this.premultiply(_m3.makeTranslation(K, pe)), this } makeTranslation(K, pe) { return K.isVector2 ? this.set(1, 0, K.x, 0, 1, K.y, 0, 0, 1) : this.set(1, 0, K, 0, 1, pe, 0, 0, 1), this } makeRotation(K) { const pe = Math.cos(K), me = Math.sin(K); return this.set(pe, -me, 0, me, pe, 0, 0, 0, 1), this } makeScale(K, pe) { return this.set(K, 0, 0, 0, pe, 0, 0, 0, 1), this } equals(K) { const pe = this.elements, me = K.elements; for (let ge = 0; ge < 9; ge++)if (pe[ge] !== me[ge]) return !1; return !0 } fromArray(K, pe = 0) { for (let me = 0; me < 9; me++)this.elements[me] = K[me + pe]; return this } toArray(K = [], pe = 0) { const me = this.elements; return K[pe] = me[0], K[pe + 1] = me[1], K[pe + 2] = me[2], K[pe + 3] = me[3], K[pe + 4] = me[4], K[pe + 5] = me[5], K[pe + 6] = me[6], K[pe + 7] = me[7], K[pe + 8] = me[8], K } clone() { return new this.constructor().fromArray(this.elements) } } const _m3 = new Matrix3; function arrayNeedsUint32(fe) { for (let K = fe.length - 1; K >= 0; --K)if (fe[K] >= 65535) return !0; return !1 } const TYPED_ARRAYS = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function getTypedArray(fe, K) { return new TYPED_ARRAYS[fe](K) } function createElementNS(fe) { return document.createElementNS("http://www.w3.org/1999/xhtml", fe) } function createCanvasElement() { const fe = createElementNS("canvas"); return fe.style.display = "block", fe } const _cache = {}; function warnOnce(fe) { fe in _cache || (_cache[fe] = !0, console.warn(fe)) } function probeAsync(fe, K, pe) { return new Promise(function (me, ge) { function xe() { switch (fe.clientWaitSync(K, fe.SYNC_FLUSH_COMMANDS_BIT, 0)) { case fe.WAIT_FAILED: ge(); break; case fe.TIMEOUT_EXPIRED: setTimeout(xe, pe); break; default: me() } } setTimeout(xe, pe) }) } function toNormalizedProjectionMatrix(fe) { const K = fe.elements; K[2] = .5 * K[2] + .5 * K[3], K[6] = .5 * K[6] + .5 * K[7], K[10] = .5 * K[10] + .5 * K[11], K[14] = .5 * K[14] + .5 * K[15] } function toReversedProjectionMatrix(fe) { const K = fe.elements; K[11] === -1 ? (K[10] = -K[10] - 1, K[14] = -K[14]) : (K[10] = -K[10], K[14] = -K[14] + 1) } const LINEAR_REC709_TO_XYZ = new Matrix3().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), XYZ_TO_LINEAR_REC709 = new Matrix3().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715); function createColorManagement() { const fe = { enabled: !0, workingColorSpace: LinearSRGBColorSpace, spaces: {}, convert: function (ge, xe, ye) { return this.enabled === !1 || xe === ye || !xe || !ye || (this.spaces[xe].transfer === SRGBTransfer && (ge.r = SRGBToLinear(ge.r), ge.g = SRGBToLinear(ge.g), ge.b = SRGBToLinear(ge.b)), this.spaces[xe].primaries !== this.spaces[ye].primaries && (ge.applyMatrix3(this.spaces[xe].toXYZ), ge.applyMatrix3(this.spaces[ye].fromXYZ)), this.spaces[ye].transfer === SRGBTransfer && (ge.r = LinearToSRGB(ge.r), ge.g = LinearToSRGB(ge.g), ge.b = LinearToSRGB(ge.b))), ge }, fromWorkingColorSpace: function (ge, xe) { return this.convert(ge, this.workingColorSpace, xe) }, toWorkingColorSpace: function (ge, xe) { return this.convert(ge, xe, this.workingColorSpace) }, getPrimaries: function (ge) { return this.spaces[ge].primaries }, getTransfer: function (ge) { return ge === NoColorSpace ? LinearTransfer : this.spaces[ge].transfer }, getLuminanceCoefficients: function (ge, xe = this.workingColorSpace) { return ge.fromArray(this.spaces[xe].luminanceCoefficients) }, define: function (ge) { Object.assign(this.spaces, ge) }, _getMatrix: function (ge, xe, ye) { return ge.copy(this.spaces[xe].toXYZ).multiply(this.spaces[ye].fromXYZ) }, _getDrawingBufferColorSpace: function (ge) { return this.spaces[ge].outputColorSpaceConfig.drawingBufferColorSpace }, _getUnpackColorSpace: function (ge = this.workingColorSpace) { return this.spaces[ge].workingColorSpaceConfig.unpackColorSpace } }, K = [.64, .33, .3, .6, .15, .06], pe = [.2126, .7152, .0722], me = [.3127, .329]; return fe.define({ [LinearSRGBColorSpace]: { primaries: K, whitePoint: me, transfer: LinearTransfer, toXYZ: LINEAR_REC709_TO_XYZ, fromXYZ: XYZ_TO_LINEAR_REC709, luminanceCoefficients: pe, workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace }, outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace } }, [SRGBColorSpace]: { primaries: K, whitePoint: me, transfer: SRGBTransfer, toXYZ: LINEAR_REC709_TO_XYZ, fromXYZ: XYZ_TO_LINEAR_REC709, luminanceCoefficients: pe, outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace } } }), fe } const ColorManagement = createColorManagement(); function SRGBToLinear(fe) { return fe < .04045 ? fe * .0773993808 : Math.pow(fe * .9478672986 + .0521327014, 2.4) } function LinearToSRGB(fe) { return fe < .0031308 ? fe * 12.92 : 1.055 * Math.pow(fe, .41666) - .055 } let _canvas; class ImageUtils { static getDataURL(K) { if (/^data:/i.test(K.src) || typeof HTMLCanvasElement > "u") return K.src; let pe; if (K instanceof HTMLCanvasElement) pe = K; else { _canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = K.width, _canvas.height = K.height; const me = _canvas.getContext("2d"); K instanceof ImageData ? me.putImageData(K, 0, 0) : me.drawImage(K, 0, 0, K.width, K.height), pe = _canvas } return pe.toDataURL("image/png") } static sRGBToLinear(K) { if (typeof HTMLImageElement < "u" && K instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && K instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && K instanceof ImageBitmap) { const pe = createElementNS("canvas"); pe.width = K.width, pe.height = K.height; const me = pe.getContext("2d"); me.drawImage(K, 0, 0, K.width, K.height); const ge = me.getImageData(0, 0, K.width, K.height), xe = ge.data; for (let ye = 0; ye < xe.length; ye++)xe[ye] = SRGBToLinear(xe[ye] / 255) * 255; return me.putImageData(ge, 0, 0), pe } else if (K.data) { const pe = K.data.slice(0); for (let me = 0; me < pe.length; me++)pe instanceof Uint8Array || pe instanceof Uint8ClampedArray ? pe[me] = Math.floor(SRGBToLinear(pe[me] / 255) * 255) : pe[me] = SRGBToLinear(pe[me]); return { data: pe, width: K.width, height: K.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), K } } let _sourceId = 0; class Source { constructor(K = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: _sourceId++ }), this.uuid = generateUUID(), this.data = K, this.dataReady = !0, this.version = 0 } set needsUpdate(K) { K === !0 && this.version++ } toJSON(K) { const pe = K === void 0 || typeof K == "string"; if (!pe && K.images[this.uuid] !== void 0) return K.images[this.uuid]; const me = { uuid: this.uuid, url: "" }, ge = this.data; if (ge !== null) { let xe; if (Array.isArray(ge)) { xe = []; for (let ye = 0, ve = ge.length; ye < ve; ye++)ge[ye].isDataTexture ? xe.push(serializeImage(ge[ye].image)) : xe.push(serializeImage(ge[ye])) } else xe = serializeImage(ge); me.url = xe } return pe || (K.images[this.uuid] = me), me } } function serializeImage(fe) { return typeof HTMLImageElement < "u" && fe instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && fe instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && fe instanceof ImageBitmap ? ImageUtils.getDataURL(fe) : fe.data ? { data: Array.from(fe.data), width: fe.width, height: fe.height, type: fe.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let _textureId = 0; class Texture extends EventDispatcher$2 { constructor(K = Texture.DEFAULT_IMAGE, pe = Texture.DEFAULT_MAPPING, me = ClampToEdgeWrapping, ge = ClampToEdgeWrapping, xe = LinearFilter, ye = LinearMipmapLinearFilter, ve = RGBAFormat, _e = UnsignedByteType, Ee = Texture.DEFAULT_ANISOTROPY, be = NoColorSpace) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: _textureId++ }), this.uuid = generateUUID(), this.name = "", this.source = new Source(K), this.mipmaps = [], this.mapping = pe, this.channel = 0, this.wrapS = me, this.wrapT = ge, this.magFilter = xe, this.minFilter = ye, this.anisotropy = Ee, this.format = ve, this.internalFormat = null, this.type = _e, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = be, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0 } get image() { return this.source.data } set image(K = null) { this.source.data = K } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(K) { return this.name = K.name, this.source = K.source, this.mipmaps = K.mipmaps.slice(0), this.mapping = K.mapping, this.channel = K.channel, this.wrapS = K.wrapS, this.wrapT = K.wrapT, this.magFilter = K.magFilter, this.minFilter = K.minFilter, this.anisotropy = K.anisotropy, this.format = K.format, this.internalFormat = K.internalFormat, this.type = K.type, this.offset.copy(K.offset), this.repeat.copy(K.repeat), this.center.copy(K.center), this.rotation = K.rotation, this.matrixAutoUpdate = K.matrixAutoUpdate, this.matrix.copy(K.matrix), this.generateMipmaps = K.generateMipmaps, this.premultiplyAlpha = K.premultiplyAlpha, this.flipY = K.flipY, this.unpackAlignment = K.unpackAlignment, this.colorSpace = K.colorSpace, this.renderTarget = K.renderTarget, this.isRenderTargetTexture = K.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(K.userData)), this.needsUpdate = !0, this } toJSON(K) { const pe = K === void 0 || typeof K == "string"; if (!pe && K.textures[this.uuid] !== void 0) return K.textures[this.uuid]; const me = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(K).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (me.userData = this.userData), pe || (K.textures[this.uuid] = me), me } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(K) { if (this.mapping !== UVMapping) return K; if (K.applyMatrix3(this.matrix), K.x < 0 || K.x > 1) switch (this.wrapS) { case RepeatWrapping: K.x = K.x - Math.floor(K.x); break; case ClampToEdgeWrapping: K.x = K.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: Math.abs(Math.floor(K.x) % 2) === 1 ? K.x = Math.ceil(K.x) - K.x : K.x = K.x - Math.floor(K.x); break }if (K.y < 0 || K.y > 1) switch (this.wrapT) { case RepeatWrapping: K.y = K.y - Math.floor(K.y); break; case ClampToEdgeWrapping: K.y = K.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: Math.abs(Math.floor(K.y) % 2) === 1 ? K.y = Math.ceil(K.y) - K.y : K.y = K.y - Math.floor(K.y); break }return this.flipY && (K.y = 1 - K.y), K } set needsUpdate(K) { K === !0 && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(K) { K === !0 && this.pmremVersion++ } } Texture.DEFAULT_IMAGE = null; Texture.DEFAULT_MAPPING = UVMapping; Texture.DEFAULT_ANISOTROPY = 1; class Vector4 { constructor(K = 0, pe = 0, me = 0, ge = 1) { Vector4.prototype.isVector4 = !0, this.x = K, this.y = pe, this.z = me, this.w = ge } get width() { return this.z } set width(K) { this.z = K } get height() { return this.w } set height(K) { this.w = K } set(K, pe, me, ge) { return this.x = K, this.y = pe, this.z = me, this.w = ge, this } setScalar(K) { return this.x = K, this.y = K, this.z = K, this.w = K, this } setX(K) { return this.x = K, this } setY(K) { return this.y = K, this } setZ(K) { return this.z = K, this } setW(K) { return this.w = K, this } setComponent(K, pe) { switch (K) { case 0: this.x = pe; break; case 1: this.y = pe; break; case 2: this.z = pe; break; case 3: this.w = pe; break; default: throw new Error("index is out of range: " + K) }return this } getComponent(K) { switch (K) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + K) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(K) { return this.x = K.x, this.y = K.y, this.z = K.z, this.w = K.w !== void 0 ? K.w : 1, this } add(K) { return this.x += K.x, this.y += K.y, this.z += K.z, this.w += K.w, this } addScalar(K) { return this.x += K, this.y += K, this.z += K, this.w += K, this } addVectors(K, pe) { return this.x = K.x + pe.x, this.y = K.y + pe.y, this.z = K.z + pe.z, this.w = K.w + pe.w, this } addScaledVector(K, pe) { return this.x += K.x * pe, this.y += K.y * pe, this.z += K.z * pe, this.w += K.w * pe, this } sub(K) { return this.x -= K.x, this.y -= K.y, this.z -= K.z, this.w -= K.w, this } subScalar(K) { return this.x -= K, this.y -= K, this.z -= K, this.w -= K, this } subVectors(K, pe) { return this.x = K.x - pe.x, this.y = K.y - pe.y, this.z = K.z - pe.z, this.w = K.w - pe.w, this } multiply(K) { return this.x *= K.x, this.y *= K.y, this.z *= K.z, this.w *= K.w, this } multiplyScalar(K) { return this.x *= K, this.y *= K, this.z *= K, this.w *= K, this } applyMatrix4(K) { const pe = this.x, me = this.y, ge = this.z, xe = this.w, ye = K.elements; return this.x = ye[0] * pe + ye[4] * me + ye[8] * ge + ye[12] * xe, this.y = ye[1] * pe + ye[5] * me + ye[9] * ge + ye[13] * xe, this.z = ye[2] * pe + ye[6] * me + ye[10] * ge + ye[14] * xe, this.w = ye[3] * pe + ye[7] * me + ye[11] * ge + ye[15] * xe, this } divide(K) { return this.x /= K.x, this.y /= K.y, this.z /= K.z, this.w /= K.w, this } divideScalar(K) { return this.multiplyScalar(1 / K) } setAxisAngleFromQuaternion(K) { this.w = 2 * Math.acos(K.w); const pe = Math.sqrt(1 - K.w * K.w); return pe < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = K.x / pe, this.y = K.y / pe, this.z = K.z / pe), this } setAxisAngleFromRotationMatrix(K) { let pe, me, ge, xe; const _e = K.elements, Ee = _e[0], be = _e[4], Ae = _e[8], Se = _e[1], Ce = _e[5], we = _e[9], Be = _e[2], De = _e[6], Re = _e[10]; if (Math.abs(be - Se) < .01 && Math.abs(Ae - Be) < .01 && Math.abs(we - De) < .01) { if (Math.abs(be + Se) < .1 && Math.abs(Ae + Be) < .1 && Math.abs(we + De) < .1 && Math.abs(Ee + Ce + Re - 3) < .1) return this.set(1, 0, 0, 0), this; pe = Math.PI; const Pe = (Ee + 1) / 2, Ne = (Ce + 1) / 2, ke = (Re + 1) / 2, Oe = (be + Se) / 4, Ue = (Ae + Be) / 4, He = (we + De) / 4; return Pe > Ne && Pe > ke ? Pe < .01 ? (me = 0, ge = .707106781, xe = .707106781) : (me = Math.sqrt(Pe), ge = Oe / me, xe = Ue / me) : Ne > ke ? Ne < .01 ? (me = .707106781, ge = 0, xe = .707106781) : (ge = Math.sqrt(Ne), me = Oe / ge, xe = He / ge) : ke < .01 ? (me = .707106781, ge = .707106781, xe = 0) : (xe = Math.sqrt(ke), me = Ue / xe, ge = He / xe), this.set(me, ge, xe, pe), this } let Ie = Math.sqrt((De - we) * (De - we) + (Ae - Be) * (Ae - Be) + (Se - be) * (Se - be)); return Math.abs(Ie) < .001 && (Ie = 1), this.x = (De - we) / Ie, this.y = (Ae - Be) / Ie, this.z = (Se - be) / Ie, this.w = Math.acos((Ee + Ce + Re - 1) / 2), this } setFromMatrixPosition(K) { const pe = K.elements; return this.x = pe[12], this.y = pe[13], this.z = pe[14], this.w = pe[15], this } min(K) { return this.x = Math.min(this.x, K.x), this.y = Math.min(this.y, K.y), this.z = Math.min(this.z, K.z), this.w = Math.min(this.w, K.w), this } max(K) { return this.x = Math.max(this.x, K.x), this.y = Math.max(this.y, K.y), this.z = Math.max(this.z, K.z), this.w = Math.max(this.w, K.w), this } clamp(K, pe) { return this.x = clamp$3(this.x, K.x, pe.x), this.y = clamp$3(this.y, K.y, pe.y), this.z = clamp$3(this.z, K.z, pe.z), this.w = clamp$3(this.w, K.w, pe.w), this } clampScalar(K, pe) { return this.x = clamp$3(this.x, K, pe), this.y = clamp$3(this.y, K, pe), this.z = clamp$3(this.z, K, pe), this.w = clamp$3(this.w, K, pe), this } clampLength(K, pe) { const me = this.length(); return this.divideScalar(me || 1).multiplyScalar(clamp$3(me, K, pe)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(K) { return this.x * K.x + this.y * K.y + this.z * K.z + this.w * K.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(K) { return this.normalize().multiplyScalar(K) } lerp(K, pe) { return this.x += (K.x - this.x) * pe, this.y += (K.y - this.y) * pe, this.z += (K.z - this.z) * pe, this.w += (K.w - this.w) * pe, this } lerpVectors(K, pe, me) { return this.x = K.x + (pe.x - K.x) * me, this.y = K.y + (pe.y - K.y) * me, this.z = K.z + (pe.z - K.z) * me, this.w = K.w + (pe.w - K.w) * me, this } equals(K) { return K.x === this.x && K.y === this.y && K.z === this.z && K.w === this.w } fromArray(K, pe = 0) { return this.x = K[pe], this.y = K[pe + 1], this.z = K[pe + 2], this.w = K[pe + 3], this } toArray(K = [], pe = 0) { return K[pe] = this.x, K[pe + 1] = this.y, K[pe + 2] = this.z, K[pe + 3] = this.w, K } fromBufferAttribute(K, pe) { return this.x = K.getX(pe), this.y = K.getY(pe), this.z = K.getZ(pe), this.w = K.getW(pe), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class RenderTarget extends EventDispatcher$2 { constructor(K = 1, pe = 1, me = {}) { super(), this.isRenderTarget = !0, this.width = K, this.height = pe, this.depth = 1, this.scissor = new Vector4(0, 0, K, pe), this.scissorTest = !1, this.viewport = new Vector4(0, 0, K, pe); const ge = { width: K, height: pe, depth: 1 }; me = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: LinearFilter, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, me); const xe = new Texture(ge, me.mapping, me.wrapS, me.wrapT, me.magFilter, me.minFilter, me.format, me.type, me.anisotropy, me.colorSpace); xe.flipY = !1, xe.generateMipmaps = me.generateMipmaps, xe.internalFormat = me.internalFormat, this.textures = []; const ye = me.count; for (let ve = 0; ve < ye; ve++)this.textures[ve] = xe.clone(), this.textures[ve].isRenderTargetTexture = !0, this.textures[ve].renderTarget = this; this.depthBuffer = me.depthBuffer, this.stencilBuffer = me.stencilBuffer, this.resolveDepthBuffer = me.resolveDepthBuffer, this.resolveStencilBuffer = me.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = me.depthTexture, this.samples = me.samples } get texture() { return this.textures[0] } set texture(K) { this.textures[0] = K } set depthTexture(K) { this._depthTexture !== null && (this._depthTexture.renderTarget = null), K !== null && (K.renderTarget = this), this._depthTexture = K } get depthTexture() { return this._depthTexture } setSize(K, pe, me = 1) { if (this.width !== K || this.height !== pe || this.depth !== me) { this.width = K, this.height = pe, this.depth = me; for (let ge = 0, xe = this.textures.length; ge < xe; ge++)this.textures[ge].image.width = K, this.textures[ge].image.height = pe, this.textures[ge].image.depth = me; this.dispose() } this.viewport.set(0, 0, K, pe), this.scissor.set(0, 0, K, pe) } clone() { return new this.constructor().copy(this) } copy(K) { this.width = K.width, this.height = K.height, this.depth = K.depth, this.scissor.copy(K.scissor), this.scissorTest = K.scissorTest, this.viewport.copy(K.viewport), this.textures.length = 0; for (let pe = 0, me = K.textures.length; pe < me; pe++) { this.textures[pe] = K.textures[pe].clone(), this.textures[pe].isRenderTargetTexture = !0, this.textures[pe].renderTarget = this; const ge = Object.assign({}, K.textures[pe].image); this.textures[pe].source = new Source(ge) } return this.depthBuffer = K.depthBuffer, this.stencilBuffer = K.stencilBuffer, this.resolveDepthBuffer = K.resolveDepthBuffer, this.resolveStencilBuffer = K.resolveStencilBuffer, K.depthTexture !== null && (this.depthTexture = K.depthTexture.clone()), this.samples = K.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class WebGLRenderTarget extends RenderTarget { constructor(K = 1, pe = 1, me = {}) { super(K, pe, me), this.isWebGLRenderTarget = !0 } } class DataArrayTexture extends Texture { constructor(K = null, pe = 1, me = 1, ge = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: K, width: pe, height: me, depth: ge }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(K) { this.layerUpdates.add(K) } clearLayerUpdates() { this.layerUpdates.clear() } } class WebGLArrayRenderTarget extends WebGLRenderTarget { constructor(K = 1, pe = 1, me = 1, ge = {}) { super(K, pe, ge), this.isWebGLArrayRenderTarget = !0, this.depth = me, this.texture = new DataArrayTexture(null, K, pe, me), this.texture.isRenderTargetTexture = !0 } } class Data3DTexture extends Texture { constructor(K = null, pe = 1, me = 1, ge = 1) { super(null), this.isData3DTexture = !0, this.image = { data: K, width: pe, height: me, depth: ge }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class WebGL3DRenderTarget extends WebGLRenderTarget { constructor(K = 1, pe = 1, me = 1, ge = {}) { super(K, pe, ge), this.isWebGL3DRenderTarget = !0, this.depth = me, this.texture = new Data3DTexture(null, K, pe, me), this.texture.isRenderTargetTexture = !0 } } class Quaternion { constructor(K = 0, pe = 0, me = 0, ge = 1) { this.isQuaternion = !0, this._x = K, this._y = pe, this._z = me, this._w = ge } static slerpFlat(K, pe, me, ge, xe, ye, ve) { let _e = me[ge + 0], Ee = me[ge + 1], be = me[ge + 2], Ae = me[ge + 3]; const Se = xe[ye + 0], Ce = xe[ye + 1], we = xe[ye + 2], Be = xe[ye + 3]; if (ve === 0) { K[pe + 0] = _e, K[pe + 1] = Ee, K[pe + 2] = be, K[pe + 3] = Ae; return } if (ve === 1) { K[pe + 0] = Se, K[pe + 1] = Ce, K[pe + 2] = we, K[pe + 3] = Be; return } if (Ae !== Be || _e !== Se || Ee !== Ce || be !== we) { let De = 1 - ve; const Re = _e * Se + Ee * Ce + be * we + Ae * Be, Ie = Re >= 0 ? 1 : -1, Pe = 1 - Re * Re; if (Pe > Number.EPSILON) { const ke = Math.sqrt(Pe), Oe = Math.atan2(ke, Re * Ie); De = Math.sin(De * Oe) / ke, ve = Math.sin(ve * Oe) / ke } const Ne = ve * Ie; if (_e = _e * De + Se * Ne, Ee = Ee * De + Ce * Ne, be = be * De + we * Ne, Ae = Ae * De + Be * Ne, De === 1 - ve) { const ke = 1 / Math.sqrt(_e * _e + Ee * Ee + be * be + Ae * Ae); _e *= ke, Ee *= ke, be *= ke, Ae *= ke } } K[pe] = _e, K[pe + 1] = Ee, K[pe + 2] = be, K[pe + 3] = Ae } static multiplyQuaternionsFlat(K, pe, me, ge, xe, ye) { const ve = me[ge], _e = me[ge + 1], Ee = me[ge + 2], be = me[ge + 3], Ae = xe[ye], Se = xe[ye + 1], Ce = xe[ye + 2], we = xe[ye + 3]; return K[pe] = ve * we + be * Ae + _e * Ce - Ee * Se, K[pe + 1] = _e * we + be * Se + Ee * Ae - ve * Ce, K[pe + 2] = Ee * we + be * Ce + ve * Se - _e * Ae, K[pe + 3] = be * we - ve * Ae - _e * Se - Ee * Ce, K } get x() { return this._x } set x(K) { this._x = K, this._onChangeCallback() } get y() { return this._y } set y(K) { this._y = K, this._onChangeCallback() } get z() { return this._z } set z(K) { this._z = K, this._onChangeCallback() } get w() { return this._w } set w(K) { this._w = K, this._onChangeCallback() } set(K, pe, me, ge) { return this._x = K, this._y = pe, this._z = me, this._w = ge, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(K) { return this._x = K.x, this._y = K.y, this._z = K.z, this._w = K.w, this._onChangeCallback(), this } setFromEuler(K, pe = !0) { const me = K._x, ge = K._y, xe = K._z, ye = K._order, ve = Math.cos, _e = Math.sin, Ee = ve(me / 2), be = ve(ge / 2), Ae = ve(xe / 2), Se = _e(me / 2), Ce = _e(ge / 2), we = _e(xe / 2); switch (ye) { case "XYZ": this._x = Se * be * Ae + Ee * Ce * we, this._y = Ee * Ce * Ae - Se * be * we, this._z = Ee * be * we + Se * Ce * Ae, this._w = Ee * be * Ae - Se * Ce * we; break; case "YXZ": this._x = Se * be * Ae + Ee * Ce * we, this._y = Ee * Ce * Ae - Se * be * we, this._z = Ee * be * we - Se * Ce * Ae, this._w = Ee * be * Ae + Se * Ce * we; break; case "ZXY": this._x = Se * be * Ae - Ee * Ce * we, this._y = Ee * Ce * Ae + Se * be * we, this._z = Ee * be * we + Se * Ce * Ae, this._w = Ee * be * Ae - Se * Ce * we; break; case "ZYX": this._x = Se * be * Ae - Ee * Ce * we, this._y = Ee * Ce * Ae + Se * be * we, this._z = Ee * be * we - Se * Ce * Ae, this._w = Ee * be * Ae + Se * Ce * we; break; case "YZX": this._x = Se * be * Ae + Ee * Ce * we, this._y = Ee * Ce * Ae + Se * be * we, this._z = Ee * be * we - Se * Ce * Ae, this._w = Ee * be * Ae - Se * Ce * we; break; case "XZY": this._x = Se * be * Ae - Ee * Ce * we, this._y = Ee * Ce * Ae - Se * be * we, this._z = Ee * be * we + Se * Ce * Ae, this._w = Ee * be * Ae + Se * Ce * we; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + ye) }return pe === !0 && this._onChangeCallback(), this } setFromAxisAngle(K, pe) { const me = pe / 2, ge = Math.sin(me); return this._x = K.x * ge, this._y = K.y * ge, this._z = K.z * ge, this._w = Math.cos(me), this._onChangeCallback(), this } setFromRotationMatrix(K) { const pe = K.elements, me = pe[0], ge = pe[4], xe = pe[8], ye = pe[1], ve = pe[5], _e = pe[9], Ee = pe[2], be = pe[6], Ae = pe[10], Se = me + ve + Ae; if (Se > 0) { const Ce = .5 / Math.sqrt(Se + 1); this._w = .25 / Ce, this._x = (be - _e) * Ce, this._y = (xe - Ee) * Ce, this._z = (ye - ge) * Ce } else if (me > ve && me > Ae) { const Ce = 2 * Math.sqrt(1 + me - ve - Ae); this._w = (be - _e) / Ce, this._x = .25 * Ce, this._y = (ge + ye) / Ce, this._z = (xe + Ee) / Ce } else if (ve > Ae) { const Ce = 2 * Math.sqrt(1 + ve - me - Ae); this._w = (xe - Ee) / Ce, this._x = (ge + ye) / Ce, this._y = .25 * Ce, this._z = (_e + be) / Ce } else { const Ce = 2 * Math.sqrt(1 + Ae - me - ve); this._w = (ye - ge) / Ce, this._x = (xe + Ee) / Ce, this._y = (_e + be) / Ce, this._z = .25 * Ce } return this._onChangeCallback(), this } setFromUnitVectors(K, pe) { let me = K.dot(pe) + 1; return me < Number.EPSILON ? (me = 0, Math.abs(K.x) > Math.abs(K.z) ? (this._x = -K.y, this._y = K.x, this._z = 0, this._w = me) : (this._x = 0, this._y = -K.z, this._z = K.y, this._w = me)) : (this._x = K.y * pe.z - K.z * pe.y, this._y = K.z * pe.x - K.x * pe.z, this._z = K.x * pe.y - K.y * pe.x, this._w = me), this.normalize() } angleTo(K) { return 2 * Math.acos(Math.abs(clamp$3(this.dot(K), -1, 1))) } rotateTowards(K, pe) { const me = this.angleTo(K); if (me === 0) return this; const ge = Math.min(1, pe / me); return this.slerp(K, ge), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(K) { return this._x * K._x + this._y * K._y + this._z * K._z + this._w * K._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let K = this.length(); return K === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (K = 1 / K, this._x = this._x * K, this._y = this._y * K, this._z = this._z * K, this._w = this._w * K), this._onChangeCallback(), this } multiply(K) { return this.multiplyQuaternions(this, K) } premultiply(K) { return this.multiplyQuaternions(K, this) } multiplyQuaternions(K, pe) { const me = K._x, ge = K._y, xe = K._z, ye = K._w, ve = pe._x, _e = pe._y, Ee = pe._z, be = pe._w; return this._x = me * be + ye * ve + ge * Ee - xe * _e, this._y = ge * be + ye * _e + xe * ve - me * Ee, this._z = xe * be + ye * Ee + me * _e - ge * ve, this._w = ye * be - me * ve - ge * _e - xe * Ee, this._onChangeCallback(), this } slerp(K, pe) { if (pe === 0) return this; if (pe === 1) return this.copy(K); const me = this._x, ge = this._y, xe = this._z, ye = this._w; let ve = ye * K._w + me * K._x + ge * K._y + xe * K._z; if (ve < 0 ? (this._w = -K._w, this._x = -K._x, this._y = -K._y, this._z = -K._z, ve = -ve) : this.copy(K), ve >= 1) return this._w = ye, this._x = me, this._y = ge, this._z = xe, this; const _e = 1 - ve * ve; if (_e <= Number.EPSILON) { const Ce = 1 - pe; return this._w = Ce * ye + pe * this._w, this._x = Ce * me + pe * this._x, this._y = Ce * ge + pe * this._y, this._z = Ce * xe + pe * this._z, this.normalize(), this } const Ee = Math.sqrt(_e), be = Math.atan2(Ee, ve), Ae = Math.sin((1 - pe) * be) / Ee, Se = Math.sin(pe * be) / Ee; return this._w = ye * Ae + this._w * Se, this._x = me * Ae + this._x * Se, this._y = ge * Ae + this._y * Se, this._z = xe * Ae + this._z * Se, this._onChangeCallback(), this } slerpQuaternions(K, pe, me) { return this.copy(K).slerp(pe, me) } random() { const K = 2 * Math.PI * Math.random(), pe = 2 * Math.PI * Math.random(), me = Math.random(), ge = Math.sqrt(1 - me), xe = Math.sqrt(me); return this.set(ge * Math.sin(K), ge * Math.cos(K), xe * Math.sin(pe), xe * Math.cos(pe)) } equals(K) { return K._x === this._x && K._y === this._y && K._z === this._z && K._w === this._w } fromArray(K, pe = 0) { return this._x = K[pe], this._y = K[pe + 1], this._z = K[pe + 2], this._w = K[pe + 3], this._onChangeCallback(), this } toArray(K = [], pe = 0) { return K[pe] = this._x, K[pe + 1] = this._y, K[pe + 2] = this._z, K[pe + 3] = this._w, K } fromBufferAttribute(K, pe) { return this._x = K.getX(pe), this._y = K.getY(pe), this._z = K.getZ(pe), this._w = K.getW(pe), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(K) { return this._onChangeCallback = K, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class Vector3 { constructor(K = 0, pe = 0, me = 0) { Vector3.prototype.isVector3 = !0, this.x = K, this.y = pe, this.z = me } set(K, pe, me) { return me === void 0 && (me = this.z), this.x = K, this.y = pe, this.z = me, this } setScalar(K) { return this.x = K, this.y = K, this.z = K, this } setX(K) { return this.x = K, this } setY(K) { return this.y = K, this } setZ(K) { return this.z = K, this } setComponent(K, pe) { switch (K) { case 0: this.x = pe; break; case 1: this.y = pe; break; case 2: this.z = pe; break; default: throw new Error("index is out of range: " + K) }return this } getComponent(K) { switch (K) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + K) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(K) { return this.x = K.x, this.y = K.y, this.z = K.z, this } add(K) { return this.x += K.x, this.y += K.y, this.z += K.z, this } addScalar(K) { return this.x += K, this.y += K, this.z += K, this } addVectors(K, pe) { return this.x = K.x + pe.x, this.y = K.y + pe.y, this.z = K.z + pe.z, this } addScaledVector(K, pe) { return this.x += K.x * pe, this.y += K.y * pe, this.z += K.z * pe, this } sub(K) { return this.x -= K.x, this.y -= K.y, this.z -= K.z, this } subScalar(K) { return this.x -= K, this.y -= K, this.z -= K, this } subVectors(K, pe) { return this.x = K.x - pe.x, this.y = K.y - pe.y, this.z = K.z - pe.z, this } multiply(K) { return this.x *= K.x, this.y *= K.y, this.z *= K.z, this } multiplyScalar(K) { return this.x *= K, this.y *= K, this.z *= K, this } multiplyVectors(K, pe) { return this.x = K.x * pe.x, this.y = K.y * pe.y, this.z = K.z * pe.z, this } applyEuler(K) { return this.applyQuaternion(_quaternion$4.setFromEuler(K)) } applyAxisAngle(K, pe) { return this.applyQuaternion(_quaternion$4.setFromAxisAngle(K, pe)) } applyMatrix3(K) { const pe = this.x, me = this.y, ge = this.z, xe = K.elements; return this.x = xe[0] * pe + xe[3] * me + xe[6] * ge, this.y = xe[1] * pe + xe[4] * me + xe[7] * ge, this.z = xe[2] * pe + xe[5] * me + xe[8] * ge, this } applyNormalMatrix(K) { return this.applyMatrix3(K).normalize() } applyMatrix4(K) { const pe = this.x, me = this.y, ge = this.z, xe = K.elements, ye = 1 / (xe[3] * pe + xe[7] * me + xe[11] * ge + xe[15]); return this.x = (xe[0] * pe + xe[4] * me + xe[8] * ge + xe[12]) * ye, this.y = (xe[1] * pe + xe[5] * me + xe[9] * ge + xe[13]) * ye, this.z = (xe[2] * pe + xe[6] * me + xe[10] * ge + xe[14]) * ye, this } applyQuaternion(K) { const pe = this.x, me = this.y, ge = this.z, xe = K.x, ye = K.y, ve = K.z, _e = K.w, Ee = 2 * (ye * ge - ve * me), be = 2 * (ve * pe - xe * ge), Ae = 2 * (xe * me - ye * pe); return this.x = pe + _e * Ee + ye * Ae - ve * be, this.y = me + _e * be + ve * Ee - xe * Ae, this.z = ge + _e * Ae + xe * be - ye * Ee, this } project(K) { return this.applyMatrix4(K.matrixWorldInverse).applyMatrix4(K.projectionMatrix) } unproject(K) { return this.applyMatrix4(K.projectionMatrixInverse).applyMatrix4(K.matrixWorld) } transformDirection(K) { const pe = this.x, me = this.y, ge = this.z, xe = K.elements; return this.x = xe[0] * pe + xe[4] * me + xe[8] * ge, this.y = xe[1] * pe + xe[5] * me + xe[9] * ge, this.z = xe[2] * pe + xe[6] * me + xe[10] * ge, this.normalize() } divide(K) { return this.x /= K.x, this.y /= K.y, this.z /= K.z, this } divideScalar(K) { return this.multiplyScalar(1 / K) } min(K) { return this.x = Math.min(this.x, K.x), this.y = Math.min(this.y, K.y), this.z = Math.min(this.z, K.z), this } max(K) { return this.x = Math.max(this.x, K.x), this.y = Math.max(this.y, K.y), this.z = Math.max(this.z, K.z), this } clamp(K, pe) { return this.x = clamp$3(this.x, K.x, pe.x), this.y = clamp$3(this.y, K.y, pe.y), this.z = clamp$3(this.z, K.z, pe.z), this } clampScalar(K, pe) { return this.x = clamp$3(this.x, K, pe), this.y = clamp$3(this.y, K, pe), this.z = clamp$3(this.z, K, pe), this } clampLength(K, pe) { const me = this.length(); return this.divideScalar(me || 1).multiplyScalar(clamp$3(me, K, pe)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(K) { return this.x * K.x + this.y * K.y + this.z * K.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(K) { return this.normalize().multiplyScalar(K) } lerp(K, pe) { return this.x += (K.x - this.x) * pe, this.y += (K.y - this.y) * pe, this.z += (K.z - this.z) * pe, this } lerpVectors(K, pe, me) { return this.x = K.x + (pe.x - K.x) * me, this.y = K.y + (pe.y - K.y) * me, this.z = K.z + (pe.z - K.z) * me, this } cross(K) { return this.crossVectors(this, K) } crossVectors(K, pe) { const me = K.x, ge = K.y, xe = K.z, ye = pe.x, ve = pe.y, _e = pe.z; return this.x = ge * _e - xe * ve, this.y = xe * ye - me * _e, this.z = me * ve - ge * ye, this } projectOnVector(K) { const pe = K.lengthSq(); if (pe === 0) return this.set(0, 0, 0); const me = K.dot(this) / pe; return this.copy(K).multiplyScalar(me) } projectOnPlane(K) { return _vector$c.copy(this).projectOnVector(K), this.sub(_vector$c) } reflect(K) { return this.sub(_vector$c.copy(K).multiplyScalar(2 * this.dot(K))) } angleTo(K) { const pe = Math.sqrt(this.lengthSq() * K.lengthSq()); if (pe === 0) return Math.PI / 2; const me = this.dot(K) / pe; return Math.acos(clamp$3(me, -1, 1)) } distanceTo(K) { return Math.sqrt(this.distanceToSquared(K)) } distanceToSquared(K) { const pe = this.x - K.x, me = this.y - K.y, ge = this.z - K.z; return pe * pe + me * me + ge * ge } manhattanDistanceTo(K) { return Math.abs(this.x - K.x) + Math.abs(this.y - K.y) + Math.abs(this.z - K.z) } setFromSpherical(K) { return this.setFromSphericalCoords(K.radius, K.phi, K.theta) } setFromSphericalCoords(K, pe, me) { const ge = Math.sin(pe) * K; return this.x = ge * Math.sin(me), this.y = Math.cos(pe) * K, this.z = ge * Math.cos(me), this } setFromCylindrical(K) { return this.setFromCylindricalCoords(K.radius, K.theta, K.y) } setFromCylindricalCoords(K, pe, me) { return this.x = K * Math.sin(pe), this.y = me, this.z = K * Math.cos(pe), this } setFromMatrixPosition(K) { const pe = K.elements; return this.x = pe[12], this.y = pe[13], this.z = pe[14], this } setFromMatrixScale(K) { const pe = this.setFromMatrixColumn(K, 0).length(), me = this.setFromMatrixColumn(K, 1).length(), ge = this.setFromMatrixColumn(K, 2).length(); return this.x = pe, this.y = me, this.z = ge, this } setFromMatrixColumn(K, pe) { return this.fromArray(K.elements, pe * 4) } setFromMatrix3Column(K, pe) { return this.fromArray(K.elements, pe * 3) } setFromEuler(K) { return this.x = K._x, this.y = K._y, this.z = K._z, this } setFromColor(K) { return this.x = K.r, this.y = K.g, this.z = K.b, this } equals(K) { return K.x === this.x && K.y === this.y && K.z === this.z } fromArray(K, pe = 0) { return this.x = K[pe], this.y = K[pe + 1], this.z = K[pe + 2], this } toArray(K = [], pe = 0) { return K[pe] = this.x, K[pe + 1] = this.y, K[pe + 2] = this.z, K } fromBufferAttribute(K, pe) { return this.x = K.getX(pe), this.y = K.getY(pe), this.z = K.getZ(pe), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const K = Math.random() * Math.PI * 2, pe = Math.random() * 2 - 1, me = Math.sqrt(1 - pe * pe); return this.x = me * Math.cos(K), this.y = pe, this.z = me * Math.sin(K), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const _vector$c = new Vector3, _quaternion$4 = new Quaternion; class Box3 { constructor(K = new Vector3(1 / 0, 1 / 0, 1 / 0), pe = new Vector3(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = K, this.max = pe } set(K, pe) { return this.min.copy(K), this.max.copy(pe), this } setFromArray(K) { this.makeEmpty(); for (let pe = 0, me = K.length; pe < me; pe += 3)this.expandByPoint(_vector$b.fromArray(K, pe)); return this } setFromBufferAttribute(K) { this.makeEmpty(); for (let pe = 0, me = K.count; pe < me; pe++)this.expandByPoint(_vector$b.fromBufferAttribute(K, pe)); return this } setFromPoints(K) { this.makeEmpty(); for (let pe = 0, me = K.length; pe < me; pe++)this.expandByPoint(K[pe]); return this } setFromCenterAndSize(K, pe) { const me = _vector$b.copy(pe).multiplyScalar(.5); return this.min.copy(K).sub(me), this.max.copy(K).add(me), this } setFromObject(K, pe = !1) { return this.makeEmpty(), this.expandByObject(K, pe) } clone() { return new this.constructor().copy(this) } copy(K) { return this.min.copy(K.min), this.max.copy(K.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(K) { return this.isEmpty() ? K.set(0, 0, 0) : K.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(K) { return this.isEmpty() ? K.set(0, 0, 0) : K.subVectors(this.max, this.min) } expandByPoint(K) { return this.min.min(K), this.max.max(K), this } expandByVector(K) { return this.min.sub(K), this.max.add(K), this } expandByScalar(K) { return this.min.addScalar(-K), this.max.addScalar(K), this } expandByObject(K, pe = !1) { K.updateWorldMatrix(!1, !1); const me = K.geometry; if (me !== void 0) { const xe = me.getAttribute("position"); if (pe === !0 && xe !== void 0 && K.isInstancedMesh !== !0) for (let ye = 0, ve = xe.count; ye < ve; ye++)K.isMesh === !0 ? K.getVertexPosition(ye, _vector$b) : _vector$b.fromBufferAttribute(xe, ye), _vector$b.applyMatrix4(K.matrixWorld), this.expandByPoint(_vector$b); else K.boundingBox !== void 0 ? (K.boundingBox === null && K.computeBoundingBox(), _box$4.copy(K.boundingBox)) : (me.boundingBox === null && me.computeBoundingBox(), _box$4.copy(me.boundingBox)), _box$4.applyMatrix4(K.matrixWorld), this.union(_box$4) } const ge = K.children; for (let xe = 0, ye = ge.length; xe < ye; xe++)this.expandByObject(ge[xe], pe); return this } containsPoint(K) { return K.x >= this.min.x && K.x <= this.max.x && K.y >= this.min.y && K.y <= this.max.y && K.z >= this.min.z && K.z <= this.max.z } containsBox(K) { return this.min.x <= K.min.x && K.max.x <= this.max.x && this.min.y <= K.min.y && K.max.y <= this.max.y && this.min.z <= K.min.z && K.max.z <= this.max.z } getParameter(K, pe) { return pe.set((K.x - this.min.x) / (this.max.x - this.min.x), (K.y - this.min.y) / (this.max.y - this.min.y), (K.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(K) { return K.max.x >= this.min.x && K.min.x <= this.max.x && K.max.y >= this.min.y && K.min.y <= this.max.y && K.max.z >= this.min.z && K.min.z <= this.max.z } intersectsSphere(K) { return this.clampPoint(K.center, _vector$b), _vector$b.distanceToSquared(K.center) <= K.radius * K.radius } intersectsPlane(K) { let pe, me; return K.normal.x > 0 ? (pe = K.normal.x * this.min.x, me = K.normal.x * this.max.x) : (pe = K.normal.x * this.max.x, me = K.normal.x * this.min.x), K.normal.y > 0 ? (pe += K.normal.y * this.min.y, me += K.normal.y * this.max.y) : (pe += K.normal.y * this.max.y, me += K.normal.y * this.min.y), K.normal.z > 0 ? (pe += K.normal.z * this.min.z, me += K.normal.z * this.max.z) : (pe += K.normal.z * this.max.z, me += K.normal.z * this.min.z), pe <= -K.constant && me >= -K.constant } intersectsTriangle(K) { if (this.isEmpty()) return !1; this.getCenter(_center$1), _extents.subVectors(this.max, _center$1), _v0$2.subVectors(K.a, _center$1), _v1$7.subVectors(K.b, _center$1), _v2$4.subVectors(K.c, _center$1), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4); let pe = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0]; return !satForAxes(pe, _v0$2, _v1$7, _v2$4, _extents) || (pe = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(pe, _v0$2, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), pe = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(pe, _v0$2, _v1$7, _v2$4, _extents)) } clampPoint(K, pe) { return pe.copy(K).clamp(this.min, this.max) } distanceToPoint(K) { return this.clampPoint(K, _vector$b).distanceTo(K) } getBoundingSphere(K) { return this.isEmpty() ? K.makeEmpty() : (this.getCenter(K.center), K.radius = this.getSize(_vector$b).length() * .5), K } intersect(K) { return this.min.max(K.min), this.max.min(K.max), this.isEmpty() && this.makeEmpty(), this } union(K) { return this.min.min(K.min), this.max.max(K.max), this } applyMatrix4(K) { return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(K), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(K), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(K), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(K), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(K), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(K), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(K), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(K), this.setFromPoints(_points), this) } translate(K) { return this.min.add(K), this.max.add(K), this } equals(K) { return K.min.equals(this.min) && K.max.equals(this.max) } } const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3], _vector$b = new Vector3, _box$4 = new Box3, _v0$2 = new Vector3, _v1$7 = new Vector3, _v2$4 = new Vector3, _f0 = new Vector3, _f1 = new Vector3, _f2 = new Vector3, _center$1 = new Vector3, _extents = new Vector3, _triangleNormal = new Vector3, _testAxis = new Vector3; function satForAxes(fe, K, pe, me, ge) { for (let xe = 0, ye = fe.length - 3; xe <= ye; xe += 3) { _testAxis.fromArray(fe, xe); const ve = ge.x * Math.abs(_testAxis.x) + ge.y * Math.abs(_testAxis.y) + ge.z * Math.abs(_testAxis.z), _e = K.dot(_testAxis), Ee = pe.dot(_testAxis), be = me.dot(_testAxis); if (Math.max(-Math.max(_e, Ee, be), Math.min(_e, Ee, be)) > ve) return !1 } return !0 } const _box$3 = new Box3, _v1$6 = new Vector3, _v2$3 = new Vector3; class Sphere { constructor(K = new Vector3, pe = -1) { this.isSphere = !0, this.center = K, this.radius = pe } set(K, pe) { return this.center.copy(K), this.radius = pe, this } setFromPoints(K, pe) { const me = this.center; pe !== void 0 ? me.copy(pe) : _box$3.setFromPoints(K).getCenter(me); let ge = 0; for (let xe = 0, ye = K.length; xe < ye; xe++)ge = Math.max(ge, me.distanceToSquared(K[xe])); return this.radius = Math.sqrt(ge), this } copy(K) { return this.center.copy(K.center), this.radius = K.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(K) { return K.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(K) { return K.distanceTo(this.center) - this.radius } intersectsSphere(K) { const pe = this.radius + K.radius; return K.center.distanceToSquared(this.center) <= pe * pe } intersectsBox(K) { return K.intersectsSphere(this) } intersectsPlane(K) { return Math.abs(K.distanceToPoint(this.center)) <= this.radius } clampPoint(K, pe) { const me = this.center.distanceToSquared(K); return pe.copy(K), me > this.radius * this.radius && (pe.sub(this.center).normalize(), pe.multiplyScalar(this.radius).add(this.center)), pe } getBoundingBox(K) { return this.isEmpty() ? (K.makeEmpty(), K) : (K.set(this.center, this.center), K.expandByScalar(this.radius), K) } applyMatrix4(K) { return this.center.applyMatrix4(K), this.radius = this.radius * K.getMaxScaleOnAxis(), this } translate(K) { return this.center.add(K), this } expandByPoint(K) { if (this.isEmpty()) return this.center.copy(K), this.radius = 0, this; _v1$6.subVectors(K, this.center); const pe = _v1$6.lengthSq(); if (pe > this.radius * this.radius) { const me = Math.sqrt(pe), ge = (me - this.radius) * .5; this.center.addScaledVector(_v1$6, ge / me), this.radius += ge } return this } union(K) { return K.isEmpty() ? this : this.isEmpty() ? (this.copy(K), this) : (this.center.equals(K.center) === !0 ? this.radius = Math.max(this.radius, K.radius) : (_v2$3.subVectors(K.center, this.center).setLength(K.radius), this.expandByPoint(_v1$6.copy(K.center).add(_v2$3)), this.expandByPoint(_v1$6.copy(K.center).sub(_v2$3))), this) } equals(K) { return K.center.equals(this.center) && K.radius === this.radius } clone() { return new this.constructor().copy(this) } } const _vector$a = new Vector3, _segCenter = new Vector3, _segDir = new Vector3, _diff = new Vector3, _edge1 = new Vector3, _edge2 = new Vector3, _normal$1 = new Vector3; class Ray { constructor(K = new Vector3, pe = new Vector3(0, 0, -1)) { this.origin = K, this.direction = pe } set(K, pe) { return this.origin.copy(K), this.direction.copy(pe), this } copy(K) { return this.origin.copy(K.origin), this.direction.copy(K.direction), this } at(K, pe) { return pe.copy(this.origin).addScaledVector(this.direction, K) } lookAt(K) { return this.direction.copy(K).sub(this.origin).normalize(), this } recast(K) { return this.origin.copy(this.at(K, _vector$a)), this } closestPointToPoint(K, pe) { pe.subVectors(K, this.origin); const me = pe.dot(this.direction); return me < 0 ? pe.copy(this.origin) : pe.copy(this.origin).addScaledVector(this.direction, me) } distanceToPoint(K) { return Math.sqrt(this.distanceSqToPoint(K)) } distanceSqToPoint(K) { const pe = _vector$a.subVectors(K, this.origin).dot(this.direction); return pe < 0 ? this.origin.distanceToSquared(K) : (_vector$a.copy(this.origin).addScaledVector(this.direction, pe), _vector$a.distanceToSquared(K)) } distanceSqToSegment(K, pe, me, ge) { _segCenter.copy(K).add(pe).multiplyScalar(.5), _segDir.copy(pe).sub(K).normalize(), _diff.copy(this.origin).sub(_segCenter); const xe = K.distanceTo(pe) * .5, ye = -this.direction.dot(_segDir), ve = _diff.dot(this.direction), _e = -_diff.dot(_segDir), Ee = _diff.lengthSq(), be = Math.abs(1 - ye * ye); let Ae, Se, Ce, we; if (be > 0) if (Ae = ye * _e - ve, Se = ye * ve - _e, we = xe * be, Ae >= 0) if (Se >= -we) if (Se <= we) { const Be = 1 / be; Ae *= Be, Se *= Be, Ce = Ae * (Ae + ye * Se + 2 * ve) + Se * (ye * Ae + Se + 2 * _e) + Ee } else Se = xe, Ae = Math.max(0, -(ye * Se + ve)), Ce = -Ae * Ae + Se * (Se + 2 * _e) + Ee; else Se = -xe, Ae = Math.max(0, -(ye * Se + ve)), Ce = -Ae * Ae + Se * (Se + 2 * _e) + Ee; else Se <= -we ? (Ae = Math.max(0, -(-ye * xe + ve)), Se = Ae > 0 ? -xe : Math.min(Math.max(-xe, -_e), xe), Ce = -Ae * Ae + Se * (Se + 2 * _e) + Ee) : Se <= we ? (Ae = 0, Se = Math.min(Math.max(-xe, -_e), xe), Ce = Se * (Se + 2 * _e) + Ee) : (Ae = Math.max(0, -(ye * xe + ve)), Se = Ae > 0 ? xe : Math.min(Math.max(-xe, -_e), xe), Ce = -Ae * Ae + Se * (Se + 2 * _e) + Ee); else Se = ye > 0 ? -xe : xe, Ae = Math.max(0, -(ye * Se + ve)), Ce = -Ae * Ae + Se * (Se + 2 * _e) + Ee; return me && me.copy(this.origin).addScaledVector(this.direction, Ae), ge && ge.copy(_segCenter).addScaledVector(_segDir, Se), Ce } intersectSphere(K, pe) { _vector$a.subVectors(K.center, this.origin); const me = _vector$a.dot(this.direction), ge = _vector$a.dot(_vector$a) - me * me, xe = K.radius * K.radius; if (ge > xe) return null; const ye = Math.sqrt(xe - ge), ve = me - ye, _e = me + ye; return _e < 0 ? null : ve < 0 ? this.at(_e, pe) : this.at(ve, pe) } intersectsSphere(K) { return this.distanceSqToPoint(K.center) <= K.radius * K.radius } distanceToPlane(K) { const pe = K.normal.dot(this.direction); if (pe === 0) return K.distanceToPoint(this.origin) === 0 ? 0 : null; const me = -(this.origin.dot(K.normal) + K.constant) / pe; return me >= 0 ? me : null } intersectPlane(K, pe) { const me = this.distanceToPlane(K); return me === null ? null : this.at(me, pe) } intersectsPlane(K) { const pe = K.distanceToPoint(this.origin); return pe === 0 || K.normal.dot(this.direction) * pe < 0 } intersectBox(K, pe) { let me, ge, xe, ye, ve, _e; const Ee = 1 / this.direction.x, be = 1 / this.direction.y, Ae = 1 / this.direction.z, Se = this.origin; return Ee >= 0 ? (me = (K.min.x - Se.x) * Ee, ge = (K.max.x - Se.x) * Ee) : (me = (K.max.x - Se.x) * Ee, ge = (K.min.x - Se.x) * Ee), be >= 0 ? (xe = (K.min.y - Se.y) * be, ye = (K.max.y - Se.y) * be) : (xe = (K.max.y - Se.y) * be, ye = (K.min.y - Se.y) * be), me > ye || xe > ge || ((xe > me || isNaN(me)) && (me = xe), (ye < ge || isNaN(ge)) && (ge = ye), Ae >= 0 ? (ve = (K.min.z - Se.z) * Ae, _e = (K.max.z - Se.z) * Ae) : (ve = (K.max.z - Se.z) * Ae, _e = (K.min.z - Se.z) * Ae), me > _e || ve > ge) || ((ve > me || me !== me) && (me = ve), (_e < ge || ge !== ge) && (ge = _e), ge < 0) ? null : this.at(me >= 0 ? me : ge, pe) } intersectsBox(K) { return this.intersectBox(K, _vector$a) !== null } intersectTriangle(K, pe, me, ge, xe) { _edge1.subVectors(pe, K), _edge2.subVectors(me, K), _normal$1.crossVectors(_edge1, _edge2); let ye = this.direction.dot(_normal$1), ve; if (ye > 0) { if (ge) return null; ve = 1 } else if (ye < 0) ve = -1, ye = -ye; else return null; _diff.subVectors(this.origin, K); const _e = ve * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); if (_e < 0) return null; const Ee = ve * this.direction.dot(_edge1.cross(_diff)); if (Ee < 0 || _e + Ee > ye) return null; const be = -ve * _diff.dot(_normal$1); return be < 0 ? null : this.at(be / ye, xe) } applyMatrix4(K) { return this.origin.applyMatrix4(K), this.direction.transformDirection(K), this } equals(K) { return K.origin.equals(this.origin) && K.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class Matrix4 { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) { Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], K !== void 0 && this.set(K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) } set(K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) { const Re = this.elements; return Re[0] = K, Re[4] = pe, Re[8] = me, Re[12] = ge, Re[1] = xe, Re[5] = ye, Re[9] = ve, Re[13] = _e, Re[2] = Ee, Re[6] = be, Re[10] = Ae, Re[14] = Se, Re[3] = Ce, Re[7] = we, Re[11] = Be, Re[15] = De, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new Matrix4().fromArray(this.elements) } copy(K) { const pe = this.elements, me = K.elements; return pe[0] = me[0], pe[1] = me[1], pe[2] = me[2], pe[3] = me[3], pe[4] = me[4], pe[5] = me[5], pe[6] = me[6], pe[7] = me[7], pe[8] = me[8], pe[9] = me[9], pe[10] = me[10], pe[11] = me[11], pe[12] = me[12], pe[13] = me[13], pe[14] = me[14], pe[15] = me[15], this } copyPosition(K) { const pe = this.elements, me = K.elements; return pe[12] = me[12], pe[13] = me[13], pe[14] = me[14], this } setFromMatrix3(K) { const pe = K.elements; return this.set(pe[0], pe[3], pe[6], 0, pe[1], pe[4], pe[7], 0, pe[2], pe[5], pe[8], 0, 0, 0, 0, 1), this } extractBasis(K, pe, me) { return K.setFromMatrixColumn(this, 0), pe.setFromMatrixColumn(this, 1), me.setFromMatrixColumn(this, 2), this } makeBasis(K, pe, me) { return this.set(K.x, pe.x, me.x, 0, K.y, pe.y, me.y, 0, K.z, pe.z, me.z, 0, 0, 0, 0, 1), this } extractRotation(K) { const pe = this.elements, me = K.elements, ge = 1 / _v1$5.setFromMatrixColumn(K, 0).length(), xe = 1 / _v1$5.setFromMatrixColumn(K, 1).length(), ye = 1 / _v1$5.setFromMatrixColumn(K, 2).length(); return pe[0] = me[0] * ge, pe[1] = me[1] * ge, pe[2] = me[2] * ge, pe[3] = 0, pe[4] = me[4] * xe, pe[5] = me[5] * xe, pe[6] = me[6] * xe, pe[7] = 0, pe[8] = me[8] * ye, pe[9] = me[9] * ye, pe[10] = me[10] * ye, pe[11] = 0, pe[12] = 0, pe[13] = 0, pe[14] = 0, pe[15] = 1, this } makeRotationFromEuler(K) { const pe = this.elements, me = K.x, ge = K.y, xe = K.z, ye = Math.cos(me), ve = Math.sin(me), _e = Math.cos(ge), Ee = Math.sin(ge), be = Math.cos(xe), Ae = Math.sin(xe); if (K.order === "XYZ") { const Se = ye * be, Ce = ye * Ae, we = ve * be, Be = ve * Ae; pe[0] = _e * be, pe[4] = -_e * Ae, pe[8] = Ee, pe[1] = Ce + we * Ee, pe[5] = Se - Be * Ee, pe[9] = -ve * _e, pe[2] = Be - Se * Ee, pe[6] = we + Ce * Ee, pe[10] = ye * _e } else if (K.order === "YXZ") { const Se = _e * be, Ce = _e * Ae, we = Ee * be, Be = Ee * Ae; pe[0] = Se + Be * ve, pe[4] = we * ve - Ce, pe[8] = ye * Ee, pe[1] = ye * Ae, pe[5] = ye * be, pe[9] = -ve, pe[2] = Ce * ve - we, pe[6] = Be + Se * ve, pe[10] = ye * _e } else if (K.order === "ZXY") { const Se = _e * be, Ce = _e * Ae, we = Ee * be, Be = Ee * Ae; pe[0] = Se - Be * ve, pe[4] = -ye * Ae, pe[8] = we + Ce * ve, pe[1] = Ce + we * ve, pe[5] = ye * be, pe[9] = Be - Se * ve, pe[2] = -ye * Ee, pe[6] = ve, pe[10] = ye * _e } else if (K.order === "ZYX") { const Se = ye * be, Ce = ye * Ae, we = ve * be, Be = ve * Ae; pe[0] = _e * be, pe[4] = we * Ee - Ce, pe[8] = Se * Ee + Be, pe[1] = _e * Ae, pe[5] = Be * Ee + Se, pe[9] = Ce * Ee - we, pe[2] = -Ee, pe[6] = ve * _e, pe[10] = ye * _e } else if (K.order === "YZX") { const Se = ye * _e, Ce = ye * Ee, we = ve * _e, Be = ve * Ee; pe[0] = _e * be, pe[4] = Be - Se * Ae, pe[8] = we * Ae + Ce, pe[1] = Ae, pe[5] = ye * be, pe[9] = -ve * be, pe[2] = -Ee * be, pe[6] = Ce * Ae + we, pe[10] = Se - Be * Ae } else if (K.order === "XZY") { const Se = ye * _e, Ce = ye * Ee, we = ve * _e, Be = ve * Ee; pe[0] = _e * be, pe[4] = -Ae, pe[8] = Ee * be, pe[1] = Se * Ae + Be, pe[5] = ye * be, pe[9] = Ce * Ae - we, pe[2] = we * Ae - Ce, pe[6] = ve * be, pe[10] = Be * Ae + Se } return pe[3] = 0, pe[7] = 0, pe[11] = 0, pe[12] = 0, pe[13] = 0, pe[14] = 0, pe[15] = 1, this } makeRotationFromQuaternion(K) { return this.compose(_zero, K, _one) } lookAt(K, pe, me) { const ge = this.elements; return _z.subVectors(K, pe), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(me, _z), _x.lengthSq() === 0 && (Math.abs(me.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(me, _z)), _x.normalize(), _y.crossVectors(_z, _x), ge[0] = _x.x, ge[4] = _y.x, ge[8] = _z.x, ge[1] = _x.y, ge[5] = _y.y, ge[9] = _z.y, ge[2] = _x.z, ge[6] = _y.z, ge[10] = _z.z, this } multiply(K) { return this.multiplyMatrices(this, K) } premultiply(K) { return this.multiplyMatrices(K, this) } multiplyMatrices(K, pe) { const me = K.elements, ge = pe.elements, xe = this.elements, ye = me[0], ve = me[4], _e = me[8], Ee = me[12], be = me[1], Ae = me[5], Se = me[9], Ce = me[13], we = me[2], Be = me[6], De = me[10], Re = me[14], Ie = me[3], Pe = me[7], Ne = me[11], ke = me[15], Oe = ge[0], Ue = ge[4], He = ge[8], Ge = ge[12], ze = ge[1], We = ge[5], Xe = ge[9], Ye = ge[13], Ze = ge[2], ot = ge[6], qe = ge[10], Qe = ge[14], st = ge[3], Nt = ge[7], Je = ge[11], jt = ge[15]; return xe[0] = ye * Oe + ve * ze + _e * Ze + Ee * st, xe[4] = ye * Ue + ve * We + _e * ot + Ee * Nt, xe[8] = ye * He + ve * Xe + _e * qe + Ee * Je, xe[12] = ye * Ge + ve * Ye + _e * Qe + Ee * jt, xe[1] = be * Oe + Ae * ze + Se * Ze + Ce * st, xe[5] = be * Ue + Ae * We + Se * ot + Ce * Nt, xe[9] = be * He + Ae * Xe + Se * qe + Ce * Je, xe[13] = be * Ge + Ae * Ye + Se * Qe + Ce * jt, xe[2] = we * Oe + Be * ze + De * Ze + Re * st, xe[6] = we * Ue + Be * We + De * ot + Re * Nt, xe[10] = we * He + Be * Xe + De * qe + Re * Je, xe[14] = we * Ge + Be * Ye + De * Qe + Re * jt, xe[3] = Ie * Oe + Pe * ze + Ne * Ze + ke * st, xe[7] = Ie * Ue + Pe * We + Ne * ot + ke * Nt, xe[11] = Ie * He + Pe * Xe + Ne * qe + ke * Je, xe[15] = Ie * Ge + Pe * Ye + Ne * Qe + ke * jt, this } multiplyScalar(K) { const pe = this.elements; return pe[0] *= K, pe[4] *= K, pe[8] *= K, pe[12] *= K, pe[1] *= K, pe[5] *= K, pe[9] *= K, pe[13] *= K, pe[2] *= K, pe[6] *= K, pe[10] *= K, pe[14] *= K, pe[3] *= K, pe[7] *= K, pe[11] *= K, pe[15] *= K, this } determinant() { const K = this.elements, pe = K[0], me = K[4], ge = K[8], xe = K[12], ye = K[1], ve = K[5], _e = K[9], Ee = K[13], be = K[2], Ae = K[6], Se = K[10], Ce = K[14], we = K[3], Be = K[7], De = K[11], Re = K[15]; return we * (+xe * _e * Ae - ge * Ee * Ae - xe * ve * Se + me * Ee * Se + ge * ve * Ce - me * _e * Ce) + Be * (+pe * _e * Ce - pe * Ee * Se + xe * ye * Se - ge * ye * Ce + ge * Ee * be - xe * _e * be) + De * (+pe * Ee * Ae - pe * ve * Ce - xe * ye * Ae + me * ye * Ce + xe * ve * be - me * Ee * be) + Re * (-ge * ve * be - pe * _e * Ae + pe * ve * Se + ge * ye * Ae - me * ye * Se + me * _e * be) } transpose() { const K = this.elements; let pe; return pe = K[1], K[1] = K[4], K[4] = pe, pe = K[2], K[2] = K[8], K[8] = pe, pe = K[6], K[6] = K[9], K[9] = pe, pe = K[3], K[3] = K[12], K[12] = pe, pe = K[7], K[7] = K[13], K[13] = pe, pe = K[11], K[11] = K[14], K[14] = pe, this } setPosition(K, pe, me) { const ge = this.elements; return K.isVector3 ? (ge[12] = K.x, ge[13] = K.y, ge[14] = K.z) : (ge[12] = K, ge[13] = pe, ge[14] = me), this } invert() { const K = this.elements, pe = K[0], me = K[1], ge = K[2], xe = K[3], ye = K[4], ve = K[5], _e = K[6], Ee = K[7], be = K[8], Ae = K[9], Se = K[10], Ce = K[11], we = K[12], Be = K[13], De = K[14], Re = K[15], Ie = Ae * De * Ee - Be * Se * Ee + Be * _e * Ce - ve * De * Ce - Ae * _e * Re + ve * Se * Re, Pe = we * Se * Ee - be * De * Ee - we * _e * Ce + ye * De * Ce + be * _e * Re - ye * Se * Re, Ne = be * Be * Ee - we * Ae * Ee + we * ve * Ce - ye * Be * Ce - be * ve * Re + ye * Ae * Re, ke = we * Ae * _e - be * Be * _e - we * ve * Se + ye * Be * Se + be * ve * De - ye * Ae * De, Oe = pe * Ie + me * Pe + ge * Ne + xe * ke; if (Oe === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const Ue = 1 / Oe; return K[0] = Ie * Ue, K[1] = (Be * Se * xe - Ae * De * xe - Be * ge * Ce + me * De * Ce + Ae * ge * Re - me * Se * Re) * Ue, K[2] = (ve * De * xe - Be * _e * xe + Be * ge * Ee - me * De * Ee - ve * ge * Re + me * _e * Re) * Ue, K[3] = (Ae * _e * xe - ve * Se * xe - Ae * ge * Ee + me * Se * Ee + ve * ge * Ce - me * _e * Ce) * Ue, K[4] = Pe * Ue, K[5] = (be * De * xe - we * Se * xe + we * ge * Ce - pe * De * Ce - be * ge * Re + pe * Se * Re) * Ue, K[6] = (we * _e * xe - ye * De * xe - we * ge * Ee + pe * De * Ee + ye * ge * Re - pe * _e * Re) * Ue, K[7] = (ye * Se * xe - be * _e * xe + be * ge * Ee - pe * Se * Ee - ye * ge * Ce + pe * _e * Ce) * Ue, K[8] = Ne * Ue, K[9] = (we * Ae * xe - be * Be * xe - we * me * Ce + pe * Be * Ce + be * me * Re - pe * Ae * Re) * Ue, K[10] = (ye * Be * xe - we * ve * xe + we * me * Ee - pe * Be * Ee - ye * me * Re + pe * ve * Re) * Ue, K[11] = (be * ve * xe - ye * Ae * xe - be * me * Ee + pe * Ae * Ee + ye * me * Ce - pe * ve * Ce) * Ue, K[12] = ke * Ue, K[13] = (be * Be * ge - we * Ae * ge + we * me * Se - pe * Be * Se - be * me * De + pe * Ae * De) * Ue, K[14] = (we * ve * ge - ye * Be * ge - we * me * _e + pe * Be * _e + ye * me * De - pe * ve * De) * Ue, K[15] = (ye * Ae * ge - be * ve * ge + be * me * _e - pe * Ae * _e - ye * me * Se + pe * ve * Se) * Ue, this } scale(K) { const pe = this.elements, me = K.x, ge = K.y, xe = K.z; return pe[0] *= me, pe[4] *= ge, pe[8] *= xe, pe[1] *= me, pe[5] *= ge, pe[9] *= xe, pe[2] *= me, pe[6] *= ge, pe[10] *= xe, pe[3] *= me, pe[7] *= ge, pe[11] *= xe, this } getMaxScaleOnAxis() { const K = this.elements, pe = K[0] * K[0] + K[1] * K[1] + K[2] * K[2], me = K[4] * K[4] + K[5] * K[5] + K[6] * K[6], ge = K[8] * K[8] + K[9] * K[9] + K[10] * K[10]; return Math.sqrt(Math.max(pe, me, ge)) } makeTranslation(K, pe, me) { return K.isVector3 ? this.set(1, 0, 0, K.x, 0, 1, 0, K.y, 0, 0, 1, K.z, 0, 0, 0, 1) : this.set(1, 0, 0, K, 0, 1, 0, pe, 0, 0, 1, me, 0, 0, 0, 1), this } makeRotationX(K) { const pe = Math.cos(K), me = Math.sin(K); return this.set(1, 0, 0, 0, 0, pe, -me, 0, 0, me, pe, 0, 0, 0, 0, 1), this } makeRotationY(K) { const pe = Math.cos(K), me = Math.sin(K); return this.set(pe, 0, me, 0, 0, 1, 0, 0, -me, 0, pe, 0, 0, 0, 0, 1), this } makeRotationZ(K) { const pe = Math.cos(K), me = Math.sin(K); return this.set(pe, -me, 0, 0, me, pe, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(K, pe) { const me = Math.cos(pe), ge = Math.sin(pe), xe = 1 - me, ye = K.x, ve = K.y, _e = K.z, Ee = xe * ye, be = xe * ve; return this.set(Ee * ye + me, Ee * ve - ge * _e, Ee * _e + ge * ve, 0, Ee * ve + ge * _e, be * ve + me, be * _e - ge * ye, 0, Ee * _e - ge * ve, be * _e + ge * ye, xe * _e * _e + me, 0, 0, 0, 0, 1), this } makeScale(K, pe, me) { return this.set(K, 0, 0, 0, 0, pe, 0, 0, 0, 0, me, 0, 0, 0, 0, 1), this } makeShear(K, pe, me, ge, xe, ye) { return this.set(1, me, xe, 0, K, 1, ye, 0, pe, ge, 1, 0, 0, 0, 0, 1), this } compose(K, pe, me) { const ge = this.elements, xe = pe._x, ye = pe._y, ve = pe._z, _e = pe._w, Ee = xe + xe, be = ye + ye, Ae = ve + ve, Se = xe * Ee, Ce = xe * be, we = xe * Ae, Be = ye * be, De = ye * Ae, Re = ve * Ae, Ie = _e * Ee, Pe = _e * be, Ne = _e * Ae, ke = me.x, Oe = me.y, Ue = me.z; return ge[0] = (1 - (Be + Re)) * ke, ge[1] = (Ce + Ne) * ke, ge[2] = (we - Pe) * ke, ge[3] = 0, ge[4] = (Ce - Ne) * Oe, ge[5] = (1 - (Se + Re)) * Oe, ge[6] = (De + Ie) * Oe, ge[7] = 0, ge[8] = (we + Pe) * Ue, ge[9] = (De - Ie) * Ue, ge[10] = (1 - (Se + Be)) * Ue, ge[11] = 0, ge[12] = K.x, ge[13] = K.y, ge[14] = K.z, ge[15] = 1, this } decompose(K, pe, me) { const ge = this.elements; let xe = _v1$5.set(ge[0], ge[1], ge[2]).length(); const ye = _v1$5.set(ge[4], ge[5], ge[6]).length(), ve = _v1$5.set(ge[8], ge[9], ge[10]).length(); this.determinant() < 0 && (xe = -xe), K.x = ge[12], K.y = ge[13], K.z = ge[14], _m1$2.copy(this); const Ee = 1 / xe, be = 1 / ye, Ae = 1 / ve; return _m1$2.elements[0] *= Ee, _m1$2.elements[1] *= Ee, _m1$2.elements[2] *= Ee, _m1$2.elements[4] *= be, _m1$2.elements[5] *= be, _m1$2.elements[6] *= be, _m1$2.elements[8] *= Ae, _m1$2.elements[9] *= Ae, _m1$2.elements[10] *= Ae, pe.setFromRotationMatrix(_m1$2), me.x = xe, me.y = ye, me.z = ve, this } makePerspective(K, pe, me, ge, xe, ye, ve = WebGLCoordinateSystem) { const _e = this.elements, Ee = 2 * xe / (pe - K), be = 2 * xe / (me - ge), Ae = (pe + K) / (pe - K), Se = (me + ge) / (me - ge); let Ce, we; if (ve === WebGLCoordinateSystem) Ce = -(ye + xe) / (ye - xe), we = -2 * ye * xe / (ye - xe); else if (ve === WebGPUCoordinateSystem) Ce = -ye / (ye - xe), we = -ye * xe / (ye - xe); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + ve); return _e[0] = Ee, _e[4] = 0, _e[8] = Ae, _e[12] = 0, _e[1] = 0, _e[5] = be, _e[9] = Se, _e[13] = 0, _e[2] = 0, _e[6] = 0, _e[10] = Ce, _e[14] = we, _e[3] = 0, _e[7] = 0, _e[11] = -1, _e[15] = 0, this } makeOrthographic(K, pe, me, ge, xe, ye, ve = WebGLCoordinateSystem) { const _e = this.elements, Ee = 1 / (pe - K), be = 1 / (me - ge), Ae = 1 / (ye - xe), Se = (pe + K) * Ee, Ce = (me + ge) * be; let we, Be; if (ve === WebGLCoordinateSystem) we = (ye + xe) * Ae, Be = -2 * Ae; else if (ve === WebGPUCoordinateSystem) we = xe * Ae, Be = -1 * Ae; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + ve); return _e[0] = 2 * Ee, _e[4] = 0, _e[8] = 0, _e[12] = -Se, _e[1] = 0, _e[5] = 2 * be, _e[9] = 0, _e[13] = -Ce, _e[2] = 0, _e[6] = 0, _e[10] = Be, _e[14] = -we, _e[3] = 0, _e[7] = 0, _e[11] = 0, _e[15] = 1, this } equals(K) { const pe = this.elements, me = K.elements; for (let ge = 0; ge < 16; ge++)if (pe[ge] !== me[ge]) return !1; return !0 } fromArray(K, pe = 0) { for (let me = 0; me < 16; me++)this.elements[me] = K[me + pe]; return this } toArray(K = [], pe = 0) { const me = this.elements; return K[pe] = me[0], K[pe + 1] = me[1], K[pe + 2] = me[2], K[pe + 3] = me[3], K[pe + 4] = me[4], K[pe + 5] = me[5], K[pe + 6] = me[6], K[pe + 7] = me[7], K[pe + 8] = me[8], K[pe + 9] = me[9], K[pe + 10] = me[10], K[pe + 11] = me[11], K[pe + 12] = me[12], K[pe + 13] = me[13], K[pe + 14] = me[14], K[pe + 15] = me[15], K } } const _v1$5 = new Vector3, _m1$2 = new Matrix4, _zero = new Vector3(0, 0, 0), _one = new Vector3(1, 1, 1), _x = new Vector3, _y = new Vector3, _z = new Vector3, _matrix$2 = new Matrix4, _quaternion$3 = new Quaternion; class Euler { constructor(K = 0, pe = 0, me = 0, ge = Euler.DEFAULT_ORDER) { this.isEuler = !0, this._x = K, this._y = pe, this._z = me, this._order = ge } get x() { return this._x } set x(K) { this._x = K, this._onChangeCallback() } get y() { return this._y } set y(K) { this._y = K, this._onChangeCallback() } get z() { return this._z } set z(K) { this._z = K, this._onChangeCallback() } get order() { return this._order } set order(K) { this._order = K, this._onChangeCallback() } set(K, pe, me, ge = this._order) { return this._x = K, this._y = pe, this._z = me, this._order = ge, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(K) { return this._x = K._x, this._y = K._y, this._z = K._z, this._order = K._order, this._onChangeCallback(), this } setFromRotationMatrix(K, pe = this._order, me = !0) { const ge = K.elements, xe = ge[0], ye = ge[4], ve = ge[8], _e = ge[1], Ee = ge[5], be = ge[9], Ae = ge[2], Se = ge[6], Ce = ge[10]; switch (pe) { case "XYZ": this._y = Math.asin(clamp$3(ve, -1, 1)), Math.abs(ve) < .9999999 ? (this._x = Math.atan2(-be, Ce), this._z = Math.atan2(-ye, xe)) : (this._x = Math.atan2(Se, Ee), this._z = 0); break; case "YXZ": this._x = Math.asin(-clamp$3(be, -1, 1)), Math.abs(be) < .9999999 ? (this._y = Math.atan2(ve, Ce), this._z = Math.atan2(_e, Ee)) : (this._y = Math.atan2(-Ae, xe), this._z = 0); break; case "ZXY": this._x = Math.asin(clamp$3(Se, -1, 1)), Math.abs(Se) < .9999999 ? (this._y = Math.atan2(-Ae, Ce), this._z = Math.atan2(-ye, Ee)) : (this._y = 0, this._z = Math.atan2(_e, xe)); break; case "ZYX": this._y = Math.asin(-clamp$3(Ae, -1, 1)), Math.abs(Ae) < .9999999 ? (this._x = Math.atan2(Se, Ce), this._z = Math.atan2(_e, xe)) : (this._x = 0, this._z = Math.atan2(-ye, Ee)); break; case "YZX": this._z = Math.asin(clamp$3(_e, -1, 1)), Math.abs(_e) < .9999999 ? (this._x = Math.atan2(-be, Ee), this._y = Math.atan2(-Ae, xe)) : (this._x = 0, this._y = Math.atan2(ve, Ce)); break; case "XZY": this._z = Math.asin(-clamp$3(ye, -1, 1)), Math.abs(ye) < .9999999 ? (this._x = Math.atan2(Se, Ee), this._y = Math.atan2(ve, xe)) : (this._x = Math.atan2(-be, Ce), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + pe) }return this._order = pe, me === !0 && this._onChangeCallback(), this } setFromQuaternion(K, pe, me) { return _matrix$2.makeRotationFromQuaternion(K), this.setFromRotationMatrix(_matrix$2, pe, me) } setFromVector3(K, pe = this._order) { return this.set(K.x, K.y, K.z, pe) } reorder(K) { return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, K) } equals(K) { return K._x === this._x && K._y === this._y && K._z === this._z && K._order === this._order } fromArray(K) { return this._x = K[0], this._y = K[1], this._z = K[2], K[3] !== void 0 && (this._order = K[3]), this._onChangeCallback(), this } toArray(K = [], pe = 0) { return K[pe] = this._x, K[pe + 1] = this._y, K[pe + 2] = this._z, K[pe + 3] = this._order, K } _onChange(K) { return this._onChangeCallback = K, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } Euler.DEFAULT_ORDER = "XYZ"; class Layers { constructor() { this.mask = 1 } set(K) { this.mask = (1 << K | 0) >>> 0 } enable(K) { this.mask |= 1 << K | 0 } enableAll() { this.mask = -1 } toggle(K) { this.mask ^= 1 << K | 0 } disable(K) { this.mask &= ~(1 << K | 0) } disableAll() { this.mask = 0 } test(K) { return (this.mask & K.mask) !== 0 } isEnabled(K) { return (this.mask & (1 << K | 0)) !== 0 } } let _object3DId = 0; const _v1$4 = new Vector3, _q1 = new Quaternion, _m1$1$1 = new Matrix4, _target = new Vector3, _position$3 = new Vector3, _scale$2 = new Vector3, _quaternion$2 = new Quaternion, _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" }, _childaddedEvent = { type: "childadded", child: null }, _childremovedEvent = { type: "childremoved", child: null }; class Object3D extends EventDispatcher$2 { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone(); const K = new Vector3, pe = new Euler, me = new Quaternion, ge = new Vector3(1, 1, 1); function xe() { me.setFromEuler(pe, !1) } function ye() { pe.setFromQuaternion(me, void 0, !1) } pe._onChange(xe), me._onChange(ye), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: K }, rotation: { configurable: !0, enumerable: !0, value: pe }, quaternion: { configurable: !0, enumerable: !0, value: me }, scale: { configurable: !0, enumerable: !0, value: ge }, modelViewMatrix: { value: new Matrix4 }, normalMatrix: { value: new Matrix3 } }), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(K) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(K), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(K) { return this.quaternion.premultiply(K), this } setRotationFromAxisAngle(K, pe) { this.quaternion.setFromAxisAngle(K, pe) } setRotationFromEuler(K) { this.quaternion.setFromEuler(K, !0) } setRotationFromMatrix(K) { this.quaternion.setFromRotationMatrix(K) } setRotationFromQuaternion(K) { this.quaternion.copy(K) } rotateOnAxis(K, pe) { return _q1.setFromAxisAngle(K, pe), this.quaternion.multiply(_q1), this } rotateOnWorldAxis(K, pe) { return _q1.setFromAxisAngle(K, pe), this.quaternion.premultiply(_q1), this } rotateX(K) { return this.rotateOnAxis(_xAxis, K) } rotateY(K) { return this.rotateOnAxis(_yAxis, K) } rotateZ(K) { return this.rotateOnAxis(_zAxis, K) } translateOnAxis(K, pe) { return _v1$4.copy(K).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(pe)), this } translateX(K) { return this.translateOnAxis(_xAxis, K) } translateY(K) { return this.translateOnAxis(_yAxis, K) } translateZ(K) { return this.translateOnAxis(_zAxis, K) } localToWorld(K) { return this.updateWorldMatrix(!0, !1), K.applyMatrix4(this.matrixWorld) } worldToLocal(K) { return this.updateWorldMatrix(!0, !1), K.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert()) } lookAt(K, pe, me) { K.isVector3 ? _target.copy(K) : _target.set(K, pe, me); const ge = this.parent; this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1$1.lookAt(_position$3, _target, this.up) : _m1$1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1$1), ge && (_m1$1$1.extractRotation(ge.matrixWorld), _q1.setFromRotationMatrix(_m1$1$1), this.quaternion.premultiply(_q1.invert())) } add(K) { if (arguments.length > 1) { for (let pe = 0; pe < arguments.length; pe++)this.add(arguments[pe]); return this } return K === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", K), this) : (K && K.isObject3D ? (K.removeFromParent(), K.parent = this, this.children.push(K), K.dispatchEvent(_addedEvent), _childaddedEvent.child = K, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", K), this) } remove(K) { if (arguments.length > 1) { for (let me = 0; me < arguments.length; me++)this.remove(arguments[me]); return this } const pe = this.children.indexOf(K); return pe !== -1 && (K.parent = null, this.children.splice(pe, 1), K.dispatchEvent(_removedEvent), _childremovedEvent.child = K, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child = null), this } removeFromParent() { const K = this.parent; return K !== null && K.remove(this), this } clear() { return this.remove(...this.children) } attach(K) { return this.updateWorldMatrix(!0, !1), _m1$1$1.copy(this.matrixWorld).invert(), K.parent !== null && (K.parent.updateWorldMatrix(!0, !1), _m1$1$1.multiply(K.parent.matrixWorld)), K.applyMatrix4(_m1$1$1), K.removeFromParent(), K.parent = this, this.children.push(K), K.updateWorldMatrix(!1, !0), K.dispatchEvent(_addedEvent), _childaddedEvent.child = K, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null, this } getObjectById(K) { return this.getObjectByProperty("id", K) } getObjectByName(K) { return this.getObjectByProperty("name", K) } getObjectByProperty(K, pe) { if (this[K] === pe) return this; for (let me = 0, ge = this.children.length; me < ge; me++) { const ye = this.children[me].getObjectByProperty(K, pe); if (ye !== void 0) return ye } } getObjectsByProperty(K, pe, me = []) { this[K] === pe && me.push(this); const ge = this.children; for (let xe = 0, ye = ge.length; xe < ye; xe++)ge[xe].getObjectsByProperty(K, pe, me); return me } getWorldPosition(K) { return this.updateWorldMatrix(!0, !1), K.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(K) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, K, _scale$2), K } getWorldScale(K) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, K), K } getWorldDirection(K) { this.updateWorldMatrix(!0, !1); const pe = this.matrixWorld.elements; return K.set(pe[8], pe[9], pe[10]).normalize() } raycast() { } traverse(K) { K(this); const pe = this.children; for (let me = 0, ge = pe.length; me < ge; me++)pe[me].traverse(K) } traverseVisible(K) { if (this.visible === !1) return; K(this); const pe = this.children; for (let me = 0, ge = pe.length; me < ge; me++)pe[me].traverseVisible(K) } traverseAncestors(K) { const pe = this.parent; pe !== null && (K(pe), pe.traverseAncestors(K)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(K) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || K) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, K = !0); const pe = this.children; for (let me = 0, ge = pe.length; me < ge; me++)pe[me].updateMatrixWorld(K) } updateWorldMatrix(K, pe) { const me = this.parent; if (K === !0 && me !== null && me.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), pe === !0) { const ge = this.children; for (let xe = 0, ye = ge.length; xe < ye; xe++)ge[xe].updateWorldMatrix(!1, !0) } } toJSON(K) { const pe = K === void 0 || typeof K == "string", me = {}; pe && (K = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, me.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const ge = {}; ge.uuid = this.uuid, ge.type = this.type, this.name !== "" && (ge.name = this.name), this.castShadow === !0 && (ge.castShadow = !0), this.receiveShadow === !0 && (ge.receiveShadow = !0), this.visible === !1 && (ge.visible = !1), this.frustumCulled === !1 && (ge.frustumCulled = !1), this.renderOrder !== 0 && (ge.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (ge.userData = this.userData), ge.layers = this.layers.mask, ge.matrix = this.matrix.toArray(), ge.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (ge.matrixAutoUpdate = !1), this.isInstancedMesh && (ge.type = "InstancedMesh", ge.count = this.count, ge.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (ge.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (ge.type = "BatchedMesh", ge.perObjectFrustumCulled = this.perObjectFrustumCulled, ge.sortObjects = this.sortObjects, ge.drawRanges = this._drawRanges, ge.reservedRanges = this._reservedRanges, ge.visibility = this._visibility, ge.active = this._active, ge.bounds = this._bounds.map(ve => ({ boxInitialized: ve.boxInitialized, boxMin: ve.box.min.toArray(), boxMax: ve.box.max.toArray(), sphereInitialized: ve.sphereInitialized, sphereRadius: ve.sphere.radius, sphereCenter: ve.sphere.center.toArray() })), ge.maxInstanceCount = this._maxInstanceCount, ge.maxVertexCount = this._maxVertexCount, ge.maxIndexCount = this._maxIndexCount, ge.geometryInitialized = this._geometryInitialized, ge.geometryCount = this._geometryCount, ge.matricesTexture = this._matricesTexture.toJSON(K), this._colorsTexture !== null && (ge.colorsTexture = this._colorsTexture.toJSON(K)), this.boundingSphere !== null && (ge.boundingSphere = { center: ge.boundingSphere.center.toArray(), radius: ge.boundingSphere.radius }), this.boundingBox !== null && (ge.boundingBox = { min: ge.boundingBox.min.toArray(), max: ge.boundingBox.max.toArray() })); function xe(ve, _e) { return ve[_e.uuid] === void 0 && (ve[_e.uuid] = _e.toJSON(K)), _e.uuid } if (this.isScene) this.background && (this.background.isColor ? ge.background = this.background.toJSON() : this.background.isTexture && (ge.background = this.background.toJSON(K).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (ge.environment = this.environment.toJSON(K).uuid); else if (this.isMesh || this.isLine || this.isPoints) { ge.geometry = xe(K.geometries, this.geometry); const ve = this.geometry.parameters; if (ve !== void 0 && ve.shapes !== void 0) { const _e = ve.shapes; if (Array.isArray(_e)) for (let Ee = 0, be = _e.length; Ee < be; Ee++) { const Ae = _e[Ee]; xe(K.shapes, Ae) } else xe(K.shapes, _e) } } if (this.isSkinnedMesh && (ge.bindMode = this.bindMode, ge.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (xe(K.skeletons, this.skeleton), ge.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const ve = []; for (let _e = 0, Ee = this.material.length; _e < Ee; _e++)ve.push(xe(K.materials, this.material[_e])); ge.material = ve } else ge.material = xe(K.materials, this.material); if (this.children.length > 0) { ge.children = []; for (let ve = 0; ve < this.children.length; ve++)ge.children.push(this.children[ve].toJSON(K).object) } if (this.animations.length > 0) { ge.animations = []; for (let ve = 0; ve < this.animations.length; ve++) { const _e = this.animations[ve]; ge.animations.push(xe(K.animations, _e)) } } if (pe) { const ve = ye(K.geometries), _e = ye(K.materials), Ee = ye(K.textures), be = ye(K.images), Ae = ye(K.shapes), Se = ye(K.skeletons), Ce = ye(K.animations), we = ye(K.nodes); ve.length > 0 && (me.geometries = ve), _e.length > 0 && (me.materials = _e), Ee.length > 0 && (me.textures = Ee), be.length > 0 && (me.images = be), Ae.length > 0 && (me.shapes = Ae), Se.length > 0 && (me.skeletons = Se), Ce.length > 0 && (me.animations = Ce), we.length > 0 && (me.nodes = we) } return me.object = ge, me; function ye(ve) { const _e = []; for (const Ee in ve) { const be = ve[Ee]; delete be.metadata, _e.push(be) } return _e } } clone(K) { return new this.constructor().copy(this, K) } copy(K, pe = !0) { if (this.name = K.name, this.up.copy(K.up), this.position.copy(K.position), this.rotation.order = K.rotation.order, this.quaternion.copy(K.quaternion), this.scale.copy(K.scale), this.matrix.copy(K.matrix), this.matrixWorld.copy(K.matrixWorld), this.matrixAutoUpdate = K.matrixAutoUpdate, this.matrixWorldAutoUpdate = K.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = K.matrixWorldNeedsUpdate, this.layers.mask = K.layers.mask, this.visible = K.visible, this.castShadow = K.castShadow, this.receiveShadow = K.receiveShadow, this.frustumCulled = K.frustumCulled, this.renderOrder = K.renderOrder, this.animations = K.animations.slice(), this.userData = JSON.parse(JSON.stringify(K.userData)), pe === !0) for (let me = 0; me < K.children.length; me++) { const ge = K.children[me]; this.add(ge.clone()) } return this } } Object3D.DEFAULT_UP = new Vector3(0, 1, 0); Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0; Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const _v0$1 = new Vector3, _v1$3 = new Vector3, _v2$2 = new Vector3, _v3$2 = new Vector3, _vab = new Vector3, _vac = new Vector3, _vbc = new Vector3, _vap = new Vector3, _vbp = new Vector3, _vcp = new Vector3, _v40 = new Vector4, _v41 = new Vector4, _v42 = new Vector4; class Triangle { constructor(K = new Vector3, pe = new Vector3, me = new Vector3) { this.a = K, this.b = pe, this.c = me } static getNormal(K, pe, me, ge) { ge.subVectors(me, pe), _v0$1.subVectors(K, pe), ge.cross(_v0$1); const xe = ge.lengthSq(); return xe > 0 ? ge.multiplyScalar(1 / Math.sqrt(xe)) : ge.set(0, 0, 0) } static getBarycoord(K, pe, me, ge, xe) { _v0$1.subVectors(ge, pe), _v1$3.subVectors(me, pe), _v2$2.subVectors(K, pe); const ye = _v0$1.dot(_v0$1), ve = _v0$1.dot(_v1$3), _e = _v0$1.dot(_v2$2), Ee = _v1$3.dot(_v1$3), be = _v1$3.dot(_v2$2), Ae = ye * Ee - ve * ve; if (Ae === 0) return xe.set(0, 0, 0), null; const Se = 1 / Ae, Ce = (Ee * _e - ve * be) * Se, we = (ye * be - ve * _e) * Se; return xe.set(1 - Ce - we, we, Ce) } static containsPoint(K, pe, me, ge) { return this.getBarycoord(K, pe, me, ge, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1 } static getInterpolation(K, pe, me, ge, xe, ye, ve, _e) { return this.getBarycoord(K, pe, me, ge, _v3$2) === null ? (_e.x = 0, _e.y = 0, "z" in _e && (_e.z = 0), "w" in _e && (_e.w = 0), null) : (_e.setScalar(0), _e.addScaledVector(xe, _v3$2.x), _e.addScaledVector(ye, _v3$2.y), _e.addScaledVector(ve, _v3$2.z), _e) } static getInterpolatedAttribute(K, pe, me, ge, xe, ye) { return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(K, pe), _v41.fromBufferAttribute(K, me), _v42.fromBufferAttribute(K, ge), ye.setScalar(0), ye.addScaledVector(_v40, xe.x), ye.addScaledVector(_v41, xe.y), ye.addScaledVector(_v42, xe.z), ye } static isFrontFacing(K, pe, me, ge) { return _v0$1.subVectors(me, pe), _v1$3.subVectors(K, pe), _v0$1.cross(_v1$3).dot(ge) < 0 } set(K, pe, me) { return this.a.copy(K), this.b.copy(pe), this.c.copy(me), this } setFromPointsAndIndices(K, pe, me, ge) { return this.a.copy(K[pe]), this.b.copy(K[me]), this.c.copy(K[ge]), this } setFromAttributeAndIndices(K, pe, me, ge) { return this.a.fromBufferAttribute(K, pe), this.b.fromBufferAttribute(K, me), this.c.fromBufferAttribute(K, ge), this } clone() { return new this.constructor().copy(this) } copy(K) { return this.a.copy(K.a), this.b.copy(K.b), this.c.copy(K.c), this } getArea() { return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * .5 } getMidpoint(K) { return K.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(K) { return Triangle.getNormal(this.a, this.b, this.c, K) } getPlane(K) { return K.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(K, pe) { return Triangle.getBarycoord(K, this.a, this.b, this.c, pe) } getInterpolation(K, pe, me, ge, xe) { return Triangle.getInterpolation(K, this.a, this.b, this.c, pe, me, ge, xe) } containsPoint(K) { return Triangle.containsPoint(K, this.a, this.b, this.c) } isFrontFacing(K) { return Triangle.isFrontFacing(this.a, this.b, this.c, K) } intersectsBox(K) { return K.intersectsTriangle(this) } closestPointToPoint(K, pe) { const me = this.a, ge = this.b, xe = this.c; let ye, ve; _vab.subVectors(ge, me), _vac.subVectors(xe, me), _vap.subVectors(K, me); const _e = _vab.dot(_vap), Ee = _vac.dot(_vap); if (_e <= 0 && Ee <= 0) return pe.copy(me); _vbp.subVectors(K, ge); const be = _vab.dot(_vbp), Ae = _vac.dot(_vbp); if (be >= 0 && Ae <= be) return pe.copy(ge); const Se = _e * Ae - be * Ee; if (Se <= 0 && _e >= 0 && be <= 0) return ye = _e / (_e - be), pe.copy(me).addScaledVector(_vab, ye); _vcp.subVectors(K, xe); const Ce = _vab.dot(_vcp), we = _vac.dot(_vcp); if (we >= 0 && Ce <= we) return pe.copy(xe); const Be = Ce * Ee - _e * we; if (Be <= 0 && Ee >= 0 && we <= 0) return ve = Ee / (Ee - we), pe.copy(me).addScaledVector(_vac, ve); const De = be * we - Ce * Ae; if (De <= 0 && Ae - be >= 0 && Ce - we >= 0) return _vbc.subVectors(xe, ge), ve = (Ae - be) / (Ae - be + (Ce - we)), pe.copy(ge).addScaledVector(_vbc, ve); const Re = 1 / (De + Be + Se); return ye = Be * Re, ve = Se * Re, pe.copy(me).addScaledVector(_vab, ye).addScaledVector(_vac, ve) } equals(K) { return K.a.equals(this.a) && K.b.equals(this.b) && K.c.equals(this.c) } } const _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 }; function hue2rgb(fe, K, pe) { return pe < 0 && (pe += 1), pe > 1 && (pe -= 1), pe < 1 / 6 ? fe + (K - fe) * 6 * pe : pe < 1 / 2 ? K : pe < 2 / 3 ? fe + (K - fe) * 6 * (2 / 3 - pe) : fe } let Color$1 = class { constructor(K, pe, me) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(K, pe, me) } set(K, pe, me) { if (pe === void 0 && me === void 0) { const ge = K; ge && ge.isColor ? this.copy(ge) : typeof ge == "number" ? this.setHex(ge) : typeof ge == "string" && this.setStyle(ge) } else this.setRGB(K, pe, me); return this } setScalar(K) { return this.r = K, this.g = K, this.b = K, this } setHex(K, pe = SRGBColorSpace) { return K = Math.floor(K), this.r = (K >> 16 & 255) / 255, this.g = (K >> 8 & 255) / 255, this.b = (K & 255) / 255, ColorManagement.toWorkingColorSpace(this, pe), this } setRGB(K, pe, me, ge = ColorManagement.workingColorSpace) { return this.r = K, this.g = pe, this.b = me, ColorManagement.toWorkingColorSpace(this, ge), this } setHSL(K, pe, me, ge = ColorManagement.workingColorSpace) { if (K = euclideanModulo(K, 1), pe = clamp$3(pe, 0, 1), me = clamp$3(me, 0, 1), pe === 0) this.r = this.g = this.b = me; else { const xe = me <= .5 ? me * (1 + pe) : me + pe - me * pe, ye = 2 * me - xe; this.r = hue2rgb(ye, xe, K + 1 / 3), this.g = hue2rgb(ye, xe, K), this.b = hue2rgb(ye, xe, K - 1 / 3) } return ColorManagement.toWorkingColorSpace(this, ge), this } setStyle(K, pe = SRGBColorSpace) { function me(xe) { xe !== void 0 && parseFloat(xe) < 1 && console.warn("THREE.Color: Alpha component of " + K + " will be ignored.") } let ge; if (ge = /^(\w+)\(([^\)]*)\)/.exec(K)) { let xe; const ye = ge[1], ve = ge[2]; switch (ye) { case "rgb": case "rgba": if (xe = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ve)) return me(xe[4]), this.setRGB(Math.min(255, parseInt(xe[1], 10)) / 255, Math.min(255, parseInt(xe[2], 10)) / 255, Math.min(255, parseInt(xe[3], 10)) / 255, pe); if (xe = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ve)) return me(xe[4]), this.setRGB(Math.min(100, parseInt(xe[1], 10)) / 100, Math.min(100, parseInt(xe[2], 10)) / 100, Math.min(100, parseInt(xe[3], 10)) / 100, pe); break; case "hsl": case "hsla": if (xe = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ve)) return me(xe[4]), this.setHSL(parseFloat(xe[1]) / 360, parseFloat(xe[2]) / 100, parseFloat(xe[3]) / 100, pe); break; default: console.warn("THREE.Color: Unknown color model " + K) } } else if (ge = /^\#([A-Fa-f\d]+)$/.exec(K)) { const xe = ge[1], ye = xe.length; if (ye === 3) return this.setRGB(parseInt(xe.charAt(0), 16) / 15, parseInt(xe.charAt(1), 16) / 15, parseInt(xe.charAt(2), 16) / 15, pe); if (ye === 6) return this.setHex(parseInt(xe, 16), pe); console.warn("THREE.Color: Invalid hex color " + K) } else if (K && K.length > 0) return this.setColorName(K, pe); return this } setColorName(K, pe = SRGBColorSpace) { const me = _colorKeywords[K.toLowerCase()]; return me !== void 0 ? this.setHex(me, pe) : console.warn("THREE.Color: Unknown color " + K), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(K) { return this.r = K.r, this.g = K.g, this.b = K.b, this } copySRGBToLinear(K) { return this.r = SRGBToLinear(K.r), this.g = SRGBToLinear(K.g), this.b = SRGBToLinear(K.b), this } copyLinearToSRGB(K) { return this.r = LinearToSRGB(K.r), this.g = LinearToSRGB(K.g), this.b = LinearToSRGB(K.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(K = SRGBColorSpace) { return ColorManagement.fromWorkingColorSpace(_color.copy(this), K), Math.round(clamp$3(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$3(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$3(_color.b * 255, 0, 255)) } getHexString(K = SRGBColorSpace) { return ("000000" + this.getHex(K).toString(16)).slice(-6) } getHSL(K, pe = ColorManagement.workingColorSpace) { ColorManagement.fromWorkingColorSpace(_color.copy(this), pe); const me = _color.r, ge = _color.g, xe = _color.b, ye = Math.max(me, ge, xe), ve = Math.min(me, ge, xe); let _e, Ee; const be = (ve + ye) / 2; if (ve === ye) _e = 0, Ee = 0; else { const Ae = ye - ve; switch (Ee = be <= .5 ? Ae / (ye + ve) : Ae / (2 - ye - ve), ye) { case me: _e = (ge - xe) / Ae + (ge < xe ? 6 : 0); break; case ge: _e = (xe - me) / Ae + 2; break; case xe: _e = (me - ge) / Ae + 4; break }_e /= 6 } return K.h = _e, K.s = Ee, K.l = be, K } getRGB(K, pe = ColorManagement.workingColorSpace) { return ColorManagement.fromWorkingColorSpace(_color.copy(this), pe), K.r = _color.r, K.g = _color.g, K.b = _color.b, K } getStyle(K = SRGBColorSpace) { ColorManagement.fromWorkingColorSpace(_color.copy(this), K); const pe = _color.r, me = _color.g, ge = _color.b; return K !== SRGBColorSpace ? `color(${K} ${pe.toFixed(3)} ${me.toFixed(3)} ${ge.toFixed(3)})` : `rgb(${Math.round(pe * 255)},${Math.round(me * 255)},${Math.round(ge * 255)})` } offsetHSL(K, pe, me) { return this.getHSL(_hslA), this.setHSL(_hslA.h + K, _hslA.s + pe, _hslA.l + me) } add(K) { return this.r += K.r, this.g += K.g, this.b += K.b, this } addColors(K, pe) { return this.r = K.r + pe.r, this.g = K.g + pe.g, this.b = K.b + pe.b, this } addScalar(K) { return this.r += K, this.g += K, this.b += K, this } sub(K) { return this.r = Math.max(0, this.r - K.r), this.g = Math.max(0, this.g - K.g), this.b = Math.max(0, this.b - K.b), this } multiply(K) { return this.r *= K.r, this.g *= K.g, this.b *= K.b, this } multiplyScalar(K) { return this.r *= K, this.g *= K, this.b *= K, this } lerp(K, pe) { return this.r += (K.r - this.r) * pe, this.g += (K.g - this.g) * pe, this.b += (K.b - this.b) * pe, this } lerpColors(K, pe, me) { return this.r = K.r + (pe.r - K.r) * me, this.g = K.g + (pe.g - K.g) * me, this.b = K.b + (pe.b - K.b) * me, this } lerpHSL(K, pe) { this.getHSL(_hslA), K.getHSL(_hslB); const me = lerp(_hslA.h, _hslB.h, pe), ge = lerp(_hslA.s, _hslB.s, pe), xe = lerp(_hslA.l, _hslB.l, pe); return this.setHSL(me, ge, xe), this } setFromVector3(K) { return this.r = K.x, this.g = K.y, this.b = K.z, this } applyMatrix3(K) { const pe = this.r, me = this.g, ge = this.b, xe = K.elements; return this.r = xe[0] * pe + xe[3] * me + xe[6] * ge, this.g = xe[1] * pe + xe[4] * me + xe[7] * ge, this.b = xe[2] * pe + xe[5] * me + xe[8] * ge, this } equals(K) { return K.r === this.r && K.g === this.g && K.b === this.b } fromArray(K, pe = 0) { return this.r = K[pe], this.g = K[pe + 1], this.b = K[pe + 2], this } toArray(K = [], pe = 0) { return K[pe] = this.r, K[pe + 1] = this.g, K[pe + 2] = this.b, K } fromBufferAttribute(K, pe) { return this.r = K.getX(pe), this.g = K.getY(pe), this.b = K.getZ(pe), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } }; const _color = new Color$1; Color$1.NAMES = _colorKeywords; let _materialId = 0; class Material extends EventDispatcher$2 { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: _materialId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color$1(0, 0, 0), this.blendAlpha = 0, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(K) { this._alphaTest > 0 != K > 0 && this.version++, this._alphaTest = K } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(K) { if (K !== void 0) for (const pe in K) { const me = K[pe]; if (me === void 0) { console.warn(`THREE.Material: parameter '${pe}' has value of undefined.`); continue } const ge = this[pe]; if (ge === void 0) { console.warn(`THREE.Material: '${pe}' is not a property of THREE.${this.type}.`); continue } ge && ge.isColor ? ge.set(me) : ge && ge.isVector3 && me && me.isVector3 ? ge.copy(me) : this[pe] = me } } toJSON(K) { const pe = K === void 0 || typeof K == "string"; pe && (K = { textures: {}, images: {} }); const me = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; me.uuid = this.uuid, me.type = this.type, this.name !== "" && (me.name = this.name), this.color && this.color.isColor && (me.color = this.color.getHex()), this.roughness !== void 0 && (me.roughness = this.roughness), this.metalness !== void 0 && (me.metalness = this.metalness), this.sheen !== void 0 && (me.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (me.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (me.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (me.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (me.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (me.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (me.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (me.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (me.shininess = this.shininess), this.clearcoat !== void 0 && (me.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (me.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (me.clearcoatMap = this.clearcoatMap.toJSON(K).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (me.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(K).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (me.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(K).uuid, me.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (me.dispersion = this.dispersion), this.iridescence !== void 0 && (me.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (me.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (me.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (me.iridescenceMap = this.iridescenceMap.toJSON(K).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (me.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(K).uuid), this.anisotropy !== void 0 && (me.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (me.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (me.anisotropyMap = this.anisotropyMap.toJSON(K).uuid), this.map && this.map.isTexture && (me.map = this.map.toJSON(K).uuid), this.matcap && this.matcap.isTexture && (me.matcap = this.matcap.toJSON(K).uuid), this.alphaMap && this.alphaMap.isTexture && (me.alphaMap = this.alphaMap.toJSON(K).uuid), this.lightMap && this.lightMap.isTexture && (me.lightMap = this.lightMap.toJSON(K).uuid, me.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (me.aoMap = this.aoMap.toJSON(K).uuid, me.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (me.bumpMap = this.bumpMap.toJSON(K).uuid, me.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (me.normalMap = this.normalMap.toJSON(K).uuid, me.normalMapType = this.normalMapType, me.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (me.displacementMap = this.displacementMap.toJSON(K).uuid, me.displacementScale = this.displacementScale, me.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (me.roughnessMap = this.roughnessMap.toJSON(K).uuid), this.metalnessMap && this.metalnessMap.isTexture && (me.metalnessMap = this.metalnessMap.toJSON(K).uuid), this.emissiveMap && this.emissiveMap.isTexture && (me.emissiveMap = this.emissiveMap.toJSON(K).uuid), this.specularMap && this.specularMap.isTexture && (me.specularMap = this.specularMap.toJSON(K).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (me.specularIntensityMap = this.specularIntensityMap.toJSON(K).uuid), this.specularColorMap && this.specularColorMap.isTexture && (me.specularColorMap = this.specularColorMap.toJSON(K).uuid), this.envMap && this.envMap.isTexture && (me.envMap = this.envMap.toJSON(K).uuid, this.combine !== void 0 && (me.combine = this.combine)), this.envMapRotation !== void 0 && (me.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (me.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (me.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (me.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (me.gradientMap = this.gradientMap.toJSON(K).uuid), this.transmission !== void 0 && (me.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (me.transmissionMap = this.transmissionMap.toJSON(K).uuid), this.thickness !== void 0 && (me.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (me.thicknessMap = this.thicknessMap.toJSON(K).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (me.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (me.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (me.size = this.size), this.shadowSide !== null && (me.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (me.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (me.blending = this.blending), this.side !== FrontSide && (me.side = this.side), this.vertexColors === !0 && (me.vertexColors = !0), this.opacity < 1 && (me.opacity = this.opacity), this.transparent === !0 && (me.transparent = !0), this.blendSrc !== SrcAlphaFactor && (me.blendSrc = this.blendSrc), this.blendDst !== OneMinusSrcAlphaFactor && (me.blendDst = this.blendDst), this.blendEquation !== AddEquation && (me.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (me.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (me.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (me.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (me.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (me.blendAlpha = this.blendAlpha), this.depthFunc !== LessEqualDepth && (me.depthFunc = this.depthFunc), this.depthTest === !1 && (me.depthTest = this.depthTest), this.depthWrite === !1 && (me.depthWrite = this.depthWrite), this.colorWrite === !1 && (me.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (me.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== AlwaysStencilFunc && (me.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (me.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (me.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== KeepStencilOp && (me.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (me.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (me.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (me.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (me.rotation = this.rotation), this.polygonOffset === !0 && (me.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (me.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (me.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (me.linewidth = this.linewidth), this.dashSize !== void 0 && (me.dashSize = this.dashSize), this.gapSize !== void 0 && (me.gapSize = this.gapSize), this.scale !== void 0 && (me.scale = this.scale), this.dithering === !0 && (me.dithering = !0), this.alphaTest > 0 && (me.alphaTest = this.alphaTest), this.alphaHash === !0 && (me.alphaHash = !0), this.alphaToCoverage === !0 && (me.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (me.premultipliedAlpha = !0), this.forceSinglePass === !0 && (me.forceSinglePass = !0), this.wireframe === !0 && (me.wireframe = !0), this.wireframeLinewidth > 1 && (me.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (me.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (me.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (me.flatShading = !0), this.visible === !1 && (me.visible = !1), this.toneMapped === !1 && (me.toneMapped = !1), this.fog === !1 && (me.fog = !1), Object.keys(this.userData).length > 0 && (me.userData = this.userData); function ge(xe) { const ye = []; for (const ve in xe) { const _e = xe[ve]; delete _e.metadata, ye.push(_e) } return ye } if (pe) { const xe = ge(K.textures), ye = ge(K.images); xe.length > 0 && (me.textures = xe), ye.length > 0 && (me.images = ye) } return me } clone() { return new this.constructor().copy(this) } copy(K) { this.name = K.name, this.blending = K.blending, this.side = K.side, this.vertexColors = K.vertexColors, this.opacity = K.opacity, this.transparent = K.transparent, this.blendSrc = K.blendSrc, this.blendDst = K.blendDst, this.blendEquation = K.blendEquation, this.blendSrcAlpha = K.blendSrcAlpha, this.blendDstAlpha = K.blendDstAlpha, this.blendEquationAlpha = K.blendEquationAlpha, this.blendColor.copy(K.blendColor), this.blendAlpha = K.blendAlpha, this.depthFunc = K.depthFunc, this.depthTest = K.depthTest, this.depthWrite = K.depthWrite, this.stencilWriteMask = K.stencilWriteMask, this.stencilFunc = K.stencilFunc, this.stencilRef = K.stencilRef, this.stencilFuncMask = K.stencilFuncMask, this.stencilFail = K.stencilFail, this.stencilZFail = K.stencilZFail, this.stencilZPass = K.stencilZPass, this.stencilWrite = K.stencilWrite; const pe = K.clippingPlanes; let me = null; if (pe !== null) { const ge = pe.length; me = new Array(ge); for (let xe = 0; xe !== ge; ++xe)me[xe] = pe[xe].clone() } return this.clippingPlanes = me, this.clipIntersection = K.clipIntersection, this.clipShadows = K.clipShadows, this.shadowSide = K.shadowSide, this.colorWrite = K.colorWrite, this.precision = K.precision, this.polygonOffset = K.polygonOffset, this.polygonOffsetFactor = K.polygonOffsetFactor, this.polygonOffsetUnits = K.polygonOffsetUnits, this.dithering = K.dithering, this.alphaTest = K.alphaTest, this.alphaHash = K.alphaHash, this.alphaToCoverage = K.alphaToCoverage, this.premultipliedAlpha = K.premultipliedAlpha, this.forceSinglePass = K.forceSinglePass, this.visible = K.visible, this.toneMapped = K.toneMapped, this.userData = JSON.parse(JSON.stringify(K.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(K) { K === !0 && this.version++ } onBuild() { console.warn("Material: onBuild() has been removed.") } } class MeshBasicMaterial extends Material { constructor(K) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color$1(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.lightMap = K.lightMap, this.lightMapIntensity = K.lightMapIntensity, this.aoMap = K.aoMap, this.aoMapIntensity = K.aoMapIntensity, this.specularMap = K.specularMap, this.alphaMap = K.alphaMap, this.envMap = K.envMap, this.envMapRotation.copy(K.envMapRotation), this.combine = K.combine, this.reflectivity = K.reflectivity, this.refractionRatio = K.refractionRatio, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.wireframeLinecap = K.wireframeLinecap, this.wireframeLinejoin = K.wireframeLinejoin, this.fog = K.fog, this } } const _tables = _generateTables(); function _generateTables() { const fe = new ArrayBuffer(4), K = new Float32Array(fe), pe = new Uint32Array(fe), me = new Uint32Array(512), ge = new Uint32Array(512); for (let _e = 0; _e < 256; ++_e) { const Ee = _e - 127; Ee < -27 ? (me[_e] = 0, me[_e | 256] = 32768, ge[_e] = 24, ge[_e | 256] = 24) : Ee < -14 ? (me[_e] = 1024 >> -Ee - 14, me[_e | 256] = 1024 >> -Ee - 14 | 32768, ge[_e] = -Ee - 1, ge[_e | 256] = -Ee - 1) : Ee <= 15 ? (me[_e] = Ee + 15 << 10, me[_e | 256] = Ee + 15 << 10 | 32768, ge[_e] = 13, ge[_e | 256] = 13) : Ee < 128 ? (me[_e] = 31744, me[_e | 256] = 64512, ge[_e] = 24, ge[_e | 256] = 24) : (me[_e] = 31744, me[_e | 256] = 64512, ge[_e] = 13, ge[_e | 256] = 13) } const xe = new Uint32Array(2048), ye = new Uint32Array(64), ve = new Uint32Array(64); for (let _e = 1; _e < 1024; ++_e) { let Ee = _e << 13, be = 0; for (; !(Ee & 8388608);)Ee <<= 1, be -= 8388608; Ee &= -8388609, be += 947912704, xe[_e] = Ee | be } for (let _e = 1024; _e < 2048; ++_e)xe[_e] = 939524096 + (_e - 1024 << 13); for (let _e = 1; _e < 31; ++_e)ye[_e] = _e << 23; ye[31] = 1199570944, ye[32] = 2147483648; for (let _e = 33; _e < 63; ++_e)ye[_e] = 2147483648 + (_e - 32 << 23); ye[63] = 3347054592; for (let _e = 1; _e < 64; ++_e)_e !== 32 && (ve[_e] = 1024); return { floatView: K, uint32View: pe, baseTable: me, shiftTable: ge, mantissaTable: xe, exponentTable: ye, offsetTable: ve } } function toHalfFloat(fe) { Math.abs(fe) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), fe = clamp$3(fe, -65504, 65504), _tables.floatView[0] = fe; const K = _tables.uint32View[0], pe = K >> 23 & 511; return _tables.baseTable[pe] + ((K & 8388607) >> _tables.shiftTable[pe]) } function fromHalfFloat(fe) { const K = fe >> 10; return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[K] + (fe & 1023)] + _tables.exponentTable[K], _tables.floatView[0] } class DataUtils { static toHalfFloat(K) { return toHalfFloat(K) } static fromHalfFloat(K) { return fromHalfFloat(K) } } const _vector$9 = new Vector3, _vector2$1 = new Vector2; let _id$2 = 0; class BufferAttribute { constructor(K, pe, me = !1) { if (Array.isArray(K)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: _id$2++ }), this.name = "", this.array = K, this.itemSize = pe, this.count = K !== void 0 ? K.length / pe : 0, this.normalized = me, this.usage = StaticDrawUsage, this.updateRanges = [], this.gpuType = FloatType, this.version = 0 } onUploadCallback() { } set needsUpdate(K) { K === !0 && this.version++ } setUsage(K) { return this.usage = K, this } addUpdateRange(K, pe) { this.updateRanges.push({ start: K, count: pe }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(K) { return this.name = K.name, this.array = new K.array.constructor(K.array), this.itemSize = K.itemSize, this.count = K.count, this.normalized = K.normalized, this.usage = K.usage, this.gpuType = K.gpuType, this } copyAt(K, pe, me) { K *= this.itemSize, me *= pe.itemSize; for (let ge = 0, xe = this.itemSize; ge < xe; ge++)this.array[K + ge] = pe.array[me + ge]; return this } copyArray(K) { return this.array.set(K), this } applyMatrix3(K) { if (this.itemSize === 2) for (let pe = 0, me = this.count; pe < me; pe++)_vector2$1.fromBufferAttribute(this, pe), _vector2$1.applyMatrix3(K), this.setXY(pe, _vector2$1.x, _vector2$1.y); else if (this.itemSize === 3) for (let pe = 0, me = this.count; pe < me; pe++)_vector$9.fromBufferAttribute(this, pe), _vector$9.applyMatrix3(K), this.setXYZ(pe, _vector$9.x, _vector$9.y, _vector$9.z); return this } applyMatrix4(K) { for (let pe = 0, me = this.count; pe < me; pe++)_vector$9.fromBufferAttribute(this, pe), _vector$9.applyMatrix4(K), this.setXYZ(pe, _vector$9.x, _vector$9.y, _vector$9.z); return this } applyNormalMatrix(K) { for (let pe = 0, me = this.count; pe < me; pe++)_vector$9.fromBufferAttribute(this, pe), _vector$9.applyNormalMatrix(K), this.setXYZ(pe, _vector$9.x, _vector$9.y, _vector$9.z); return this } transformDirection(K) { for (let pe = 0, me = this.count; pe < me; pe++)_vector$9.fromBufferAttribute(this, pe), _vector$9.transformDirection(K), this.setXYZ(pe, _vector$9.x, _vector$9.y, _vector$9.z); return this } set(K, pe = 0) { return this.array.set(K, pe), this } getComponent(K, pe) { let me = this.array[K * this.itemSize + pe]; return this.normalized && (me = denormalize(me, this.array)), me } setComponent(K, pe, me) { return this.normalized && (me = normalize$2(me, this.array)), this.array[K * this.itemSize + pe] = me, this } getX(K) { let pe = this.array[K * this.itemSize]; return this.normalized && (pe = denormalize(pe, this.array)), pe } setX(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize] = pe, this } getY(K) { let pe = this.array[K * this.itemSize + 1]; return this.normalized && (pe = denormalize(pe, this.array)), pe } setY(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 1] = pe, this } getZ(K) { let pe = this.array[K * this.itemSize + 2]; return this.normalized && (pe = denormalize(pe, this.array)), pe } setZ(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 2] = pe, this } getW(K) { let pe = this.array[K * this.itemSize + 3]; return this.normalized && (pe = denormalize(pe, this.array)), pe } setW(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 3] = pe, this } setXY(K, pe, me) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array)), this.array[K + 0] = pe, this.array[K + 1] = me, this } setXYZ(K, pe, me, ge) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array)), this.array[K + 0] = pe, this.array[K + 1] = me, this.array[K + 2] = ge, this } setXYZW(K, pe, me, ge, xe) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array), xe = normalize$2(xe, this.array)), this.array[K + 0] = pe, this.array[K + 1] = me, this.array[K + 2] = ge, this.array[K + 3] = xe, this } onUpload(K) { return this.onUploadCallback = K, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const K = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (K.name = this.name), this.usage !== StaticDrawUsage && (K.usage = this.usage), K } } class Int8BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Int8Array(K), pe, me) } } class Uint8BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Uint8Array(K), pe, me) } } class Uint8ClampedBufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Uint8ClampedArray(K), pe, me) } } class Int16BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Int16Array(K), pe, me) } } class Uint16BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Uint16Array(K), pe, me) } } class Int32BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Int32Array(K), pe, me) } } class Uint32BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Uint32Array(K), pe, me) } } class Float16BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Uint16Array(K), pe, me), this.isFloat16BufferAttribute = !0 } getX(K) { let pe = fromHalfFloat(this.array[K * this.itemSize]); return this.normalized && (pe = denormalize(pe, this.array)), pe } setX(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize] = toHalfFloat(pe), this } getY(K) { let pe = fromHalfFloat(this.array[K * this.itemSize + 1]); return this.normalized && (pe = denormalize(pe, this.array)), pe } setY(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 1] = toHalfFloat(pe), this } getZ(K) { let pe = fromHalfFloat(this.array[K * this.itemSize + 2]); return this.normalized && (pe = denormalize(pe, this.array)), pe } setZ(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 2] = toHalfFloat(pe), this } getW(K) { let pe = fromHalfFloat(this.array[K * this.itemSize + 3]); return this.normalized && (pe = denormalize(pe, this.array)), pe } setW(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.array[K * this.itemSize + 3] = toHalfFloat(pe), this } setXY(K, pe, me) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array)), this.array[K + 0] = toHalfFloat(pe), this.array[K + 1] = toHalfFloat(me), this } setXYZ(K, pe, me, ge) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array)), this.array[K + 0] = toHalfFloat(pe), this.array[K + 1] = toHalfFloat(me), this.array[K + 2] = toHalfFloat(ge), this } setXYZW(K, pe, me, ge, xe) { return K *= this.itemSize, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array), xe = normalize$2(xe, this.array)), this.array[K + 0] = toHalfFloat(pe), this.array[K + 1] = toHalfFloat(me), this.array[K + 2] = toHalfFloat(ge), this.array[K + 3] = toHalfFloat(xe), this } } class Float32BufferAttribute extends BufferAttribute { constructor(K, pe, me) { super(new Float32Array(K), pe, me) } } let _id$1 = 0; const _m1$3 = new Matrix4, _obj = new Object3D, _offset = new Vector3, _box$2 = new Box3, _boxMorphTargets = new Box3, _vector$8 = new Vector3; class BufferGeometry extends EventDispatcher$2 { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: _id$1++ }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(K) { return Array.isArray(K) ? this.index = new (arrayNeedsUint32(K) ? Uint32BufferAttribute : Uint16BufferAttribute)(K, 1) : this.index = K, this } setIndirect(K) { return this.indirect = K, this } getIndirect() { return this.indirect } getAttribute(K) { return this.attributes[K] } setAttribute(K, pe) { return this.attributes[K] = pe, this } deleteAttribute(K) { return delete this.attributes[K], this } hasAttribute(K) { return this.attributes[K] !== void 0 } addGroup(K, pe, me = 0) { this.groups.push({ start: K, count: pe, materialIndex: me }) } clearGroups() { this.groups = [] } setDrawRange(K, pe) { this.drawRange.start = K, this.drawRange.count = pe } applyMatrix4(K) { const pe = this.attributes.position; pe !== void 0 && (pe.applyMatrix4(K), pe.needsUpdate = !0); const me = this.attributes.normal; if (me !== void 0) { const xe = new Matrix3().getNormalMatrix(K); me.applyNormalMatrix(xe), me.needsUpdate = !0 } const ge = this.attributes.tangent; return ge !== void 0 && (ge.transformDirection(K), ge.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(K) { return _m1$3.makeRotationFromQuaternion(K), this.applyMatrix4(_m1$3), this } rotateX(K) { return _m1$3.makeRotationX(K), this.applyMatrix4(_m1$3), this } rotateY(K) { return _m1$3.makeRotationY(K), this.applyMatrix4(_m1$3), this } rotateZ(K) { return _m1$3.makeRotationZ(K), this.applyMatrix4(_m1$3), this } translate(K, pe, me) { return _m1$3.makeTranslation(K, pe, me), this.applyMatrix4(_m1$3), this } scale(K, pe, me) { return _m1$3.makeScale(K, pe, me), this.applyMatrix4(_m1$3), this } lookAt(K) { return _obj.lookAt(K), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this } setFromPoints(K) { const pe = this.getAttribute("position"); if (pe === void 0) { const me = []; for (let ge = 0, xe = K.length; ge < xe; ge++) { const ye = K[ge]; me.push(ye.x, ye.y, ye.z || 0) } this.setAttribute("position", new Float32BufferAttribute(me, 3)) } else { const me = Math.min(K.length, pe.count); for (let ge = 0; ge < me; ge++) { const xe = K[ge]; pe.setXYZ(ge, xe.x, xe.y, xe.z || 0) } K.length > pe.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), pe.needsUpdate = !0 } return this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Box3); const K = this.attributes.position, pe = this.morphAttributes.position; if (K && K.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0)); return } if (K !== void 0) { if (this.boundingBox.setFromBufferAttribute(K), pe) for (let me = 0, ge = pe.length; me < ge; me++) { const xe = pe[me]; _box$2.setFromBufferAttribute(xe), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Sphere); const K = this.attributes.position, pe = this.morphAttributes.position; if (K && K.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Vector3, 1 / 0); return } if (K) { const me = this.boundingSphere.center; if (_box$2.setFromBufferAttribute(K), pe) for (let xe = 0, ye = pe.length; xe < ye; xe++) { const ve = pe[xe]; _boxMorphTargets.setFromBufferAttribute(ve), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max)) } _box$2.getCenter(me); let ge = 0; for (let xe = 0, ye = K.count; xe < ye; xe++)_vector$8.fromBufferAttribute(K, xe), ge = Math.max(ge, me.distanceToSquared(_vector$8)); if (pe) for (let xe = 0, ye = pe.length; xe < ye; xe++) { const ve = pe[xe], _e = this.morphTargetsRelative; for (let Ee = 0, be = ve.count; Ee < be; Ee++)_vector$8.fromBufferAttribute(ve, Ee), _e && (_offset.fromBufferAttribute(K, Ee), _vector$8.add(_offset)), ge = Math.max(ge, me.distanceToSquared(_vector$8)) } this.boundingSphere.radius = Math.sqrt(ge), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const K = this.index, pe = this.attributes; if (K === null || pe.position === void 0 || pe.normal === void 0 || pe.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const me = pe.position, ge = pe.normal, xe = pe.uv; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * me.count), 4)); const ye = this.getAttribute("tangent"), ve = [], _e = []; for (let He = 0; He < me.count; He++)ve[He] = new Vector3, _e[He] = new Vector3; const Ee = new Vector3, be = new Vector3, Ae = new Vector3, Se = new Vector2, Ce = new Vector2, we = new Vector2, Be = new Vector3, De = new Vector3; function Re(He, Ge, ze) { Ee.fromBufferAttribute(me, He), be.fromBufferAttribute(me, Ge), Ae.fromBufferAttribute(me, ze), Se.fromBufferAttribute(xe, He), Ce.fromBufferAttribute(xe, Ge), we.fromBufferAttribute(xe, ze), be.sub(Ee), Ae.sub(Ee), Ce.sub(Se), we.sub(Se); const We = 1 / (Ce.x * we.y - we.x * Ce.y); isFinite(We) && (Be.copy(be).multiplyScalar(we.y).addScaledVector(Ae, -Ce.y).multiplyScalar(We), De.copy(Ae).multiplyScalar(Ce.x).addScaledVector(be, -we.x).multiplyScalar(We), ve[He].add(Be), ve[Ge].add(Be), ve[ze].add(Be), _e[He].add(De), _e[Ge].add(De), _e[ze].add(De)) } let Ie = this.groups; Ie.length === 0 && (Ie = [{ start: 0, count: K.count }]); for (let He = 0, Ge = Ie.length; He < Ge; ++He) { const ze = Ie[He], We = ze.start, Xe = ze.count; for (let Ye = We, Ze = We + Xe; Ye < Ze; Ye += 3)Re(K.getX(Ye + 0), K.getX(Ye + 1), K.getX(Ye + 2)) } const Pe = new Vector3, Ne = new Vector3, ke = new Vector3, Oe = new Vector3; function Ue(He) { ke.fromBufferAttribute(ge, He), Oe.copy(ke); const Ge = ve[He]; Pe.copy(Ge), Pe.sub(ke.multiplyScalar(ke.dot(Ge))).normalize(), Ne.crossVectors(Oe, Ge); const We = Ne.dot(_e[He]) < 0 ? -1 : 1; ye.setXYZW(He, Pe.x, Pe.y, Pe.z, We) } for (let He = 0, Ge = Ie.length; He < Ge; ++He) { const ze = Ie[He], We = ze.start, Xe = ze.count; for (let Ye = We, Ze = We + Xe; Ye < Ze; Ye += 3)Ue(K.getX(Ye + 0)), Ue(K.getX(Ye + 1)), Ue(K.getX(Ye + 2)) } } computeVertexNormals() { const K = this.index, pe = this.getAttribute("position"); if (pe !== void 0) { let me = this.getAttribute("normal"); if (me === void 0) me = new BufferAttribute(new Float32Array(pe.count * 3), 3), this.setAttribute("normal", me); else for (let Se = 0, Ce = me.count; Se < Ce; Se++)me.setXYZ(Se, 0, 0, 0); const ge = new Vector3, xe = new Vector3, ye = new Vector3, ve = new Vector3, _e = new Vector3, Ee = new Vector3, be = new Vector3, Ae = new Vector3; if (K) for (let Se = 0, Ce = K.count; Se < Ce; Se += 3) { const we = K.getX(Se + 0), Be = K.getX(Se + 1), De = K.getX(Se + 2); ge.fromBufferAttribute(pe, we), xe.fromBufferAttribute(pe, Be), ye.fromBufferAttribute(pe, De), be.subVectors(ye, xe), Ae.subVectors(ge, xe), be.cross(Ae), ve.fromBufferAttribute(me, we), _e.fromBufferAttribute(me, Be), Ee.fromBufferAttribute(me, De), ve.add(be), _e.add(be), Ee.add(be), me.setXYZ(we, ve.x, ve.y, ve.z), me.setXYZ(Be, _e.x, _e.y, _e.z), me.setXYZ(De, Ee.x, Ee.y, Ee.z) } else for (let Se = 0, Ce = pe.count; Se < Ce; Se += 3)ge.fromBufferAttribute(pe, Se + 0), xe.fromBufferAttribute(pe, Se + 1), ye.fromBufferAttribute(pe, Se + 2), be.subVectors(ye, xe), Ae.subVectors(ge, xe), be.cross(Ae), me.setXYZ(Se + 0, be.x, be.y, be.z), me.setXYZ(Se + 1, be.x, be.y, be.z), me.setXYZ(Se + 2, be.x, be.y, be.z); this.normalizeNormals(), me.needsUpdate = !0 } } normalizeNormals() { const K = this.attributes.normal; for (let pe = 0, me = K.count; pe < me; pe++)_vector$8.fromBufferAttribute(K, pe), _vector$8.normalize(), K.setXYZ(pe, _vector$8.x, _vector$8.y, _vector$8.z) } toNonIndexed() { function K(ve, _e) { const Ee = ve.array, be = ve.itemSize, Ae = ve.normalized, Se = new Ee.constructor(_e.length * be); let Ce = 0, we = 0; for (let Be = 0, De = _e.length; Be < De; Be++) { ve.isInterleavedBufferAttribute ? Ce = _e[Be] * ve.data.stride + ve.offset : Ce = _e[Be] * be; for (let Re = 0; Re < be; Re++)Se[we++] = Ee[Ce++] } return new BufferAttribute(Se, be, Ae) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const pe = new BufferGeometry, me = this.index.array, ge = this.attributes; for (const ve in ge) { const _e = ge[ve], Ee = K(_e, me); pe.setAttribute(ve, Ee) } const xe = this.morphAttributes; for (const ve in xe) { const _e = [], Ee = xe[ve]; for (let be = 0, Ae = Ee.length; be < Ae; be++) { const Se = Ee[be], Ce = K(Se, me); _e.push(Ce) } pe.morphAttributes[ve] = _e } pe.morphTargetsRelative = this.morphTargetsRelative; const ye = this.groups; for (let ve = 0, _e = ye.length; ve < _e; ve++) { const Ee = ye[ve]; pe.addGroup(Ee.start, Ee.count, Ee.materialIndex) } return pe } toJSON() { const K = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (K.uuid = this.uuid, K.type = this.type, this.name !== "" && (K.name = this.name), Object.keys(this.userData).length > 0 && (K.userData = this.userData), this.parameters !== void 0) { const _e = this.parameters; for (const Ee in _e) _e[Ee] !== void 0 && (K[Ee] = _e[Ee]); return K } K.data = { attributes: {} }; const pe = this.index; pe !== null && (K.data.index = { type: pe.array.constructor.name, array: Array.prototype.slice.call(pe.array) }); const me = this.attributes; for (const _e in me) { const Ee = me[_e]; K.data.attributes[_e] = Ee.toJSON(K.data) } const ge = {}; let xe = !1; for (const _e in this.morphAttributes) { const Ee = this.morphAttributes[_e], be = []; for (let Ae = 0, Se = Ee.length; Ae < Se; Ae++) { const Ce = Ee[Ae]; be.push(Ce.toJSON(K.data)) } be.length > 0 && (ge[_e] = be, xe = !0) } xe && (K.data.morphAttributes = ge, K.data.morphTargetsRelative = this.morphTargetsRelative); const ye = this.groups; ye.length > 0 && (K.data.groups = JSON.parse(JSON.stringify(ye))); const ve = this.boundingSphere; return ve !== null && (K.data.boundingSphere = { center: ve.center.toArray(), radius: ve.radius }), K } clone() { return new this.constructor().copy(this) } copy(K) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const pe = {}; this.name = K.name; const me = K.index; me !== null && this.setIndex(me.clone(pe)); const ge = K.attributes; for (const Ee in ge) { const be = ge[Ee]; this.setAttribute(Ee, be.clone(pe)) } const xe = K.morphAttributes; for (const Ee in xe) { const be = [], Ae = xe[Ee]; for (let Se = 0, Ce = Ae.length; Se < Ce; Se++)be.push(Ae[Se].clone(pe)); this.morphAttributes[Ee] = be } this.morphTargetsRelative = K.morphTargetsRelative; const ye = K.groups; for (let Ee = 0, be = ye.length; Ee < be; Ee++) { const Ae = ye[Ee]; this.addGroup(Ae.start, Ae.count, Ae.materialIndex) } const ve = K.boundingBox; ve !== null && (this.boundingBox = ve.clone()); const _e = K.boundingSphere; return _e !== null && (this.boundingSphere = _e.clone()), this.drawRange.start = K.drawRange.start, this.drawRange.count = K.drawRange.count, this.userData = K.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const _inverseMatrix$3 = new Matrix4, _ray$3 = new Ray, _sphere$6 = new Sphere, _sphereHitAt = new Vector3, _vA$1 = new Vector3, _vB$1 = new Vector3, _vC$1 = new Vector3, _tempA = new Vector3, _morphA = new Vector3, _intersectionPoint$1 = new Vector3, _intersectionPointWorld = new Vector3; class Mesh extends Object3D { constructor(K = new BufferGeometry, pe = new MeshBasicMaterial) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = K, this.material = pe, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(K, pe) { return super.copy(K, pe), K.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = K.morphTargetInfluences.slice()), K.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, K.morphTargetDictionary)), this.material = Array.isArray(K.material) ? K.material.slice() : K.material, this.geometry = K.geometry, this } updateMorphTargets() { const pe = this.geometry.morphAttributes, me = Object.keys(pe); if (me.length > 0) { const ge = pe[me[0]]; if (ge !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let xe = 0, ye = ge.length; xe < ye; xe++) { const ve = ge[xe].name || String(xe); this.morphTargetInfluences.push(0), this.morphTargetDictionary[ve] = xe } } } } getVertexPosition(K, pe) { const me = this.geometry, ge = me.attributes.position, xe = me.morphAttributes.position, ye = me.morphTargetsRelative; pe.fromBufferAttribute(ge, K); const ve = this.morphTargetInfluences; if (xe && ve) { _morphA.set(0, 0, 0); for (let _e = 0, Ee = xe.length; _e < Ee; _e++) { const be = ve[_e], Ae = xe[_e]; be !== 0 && (_tempA.fromBufferAttribute(Ae, K), ye ? _morphA.addScaledVector(_tempA, be) : _morphA.addScaledVector(_tempA.sub(pe), be)) } pe.add(_morphA) } return pe } raycast(K, pe) { const me = this.geometry, ge = this.material, xe = this.matrixWorld; ge !== void 0 && (me.boundingSphere === null && me.computeBoundingSphere(), _sphere$6.copy(me.boundingSphere), _sphere$6.applyMatrix4(xe), _ray$3.copy(K.ray).recast(K.near), !(_sphere$6.containsPoint(_ray$3.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3.origin.distanceToSquared(_sphereHitAt) > (K.far - K.near) ** 2)) && (_inverseMatrix$3.copy(xe).invert(), _ray$3.copy(K.ray).applyMatrix4(_inverseMatrix$3), !(me.boundingBox !== null && _ray$3.intersectsBox(me.boundingBox) === !1) && this._computeIntersections(K, pe, _ray$3))) } _computeIntersections(K, pe, me) { let ge; const xe = this.geometry, ye = this.material, ve = xe.index, _e = xe.attributes.position, Ee = xe.attributes.uv, be = xe.attributes.uv1, Ae = xe.attributes.normal, Se = xe.groups, Ce = xe.drawRange; if (ve !== null) if (Array.isArray(ye)) for (let we = 0, Be = Se.length; we < Be; we++) { const De = Se[we], Re = ye[De.materialIndex], Ie = Math.max(De.start, Ce.start), Pe = Math.min(ve.count, Math.min(De.start + De.count, Ce.start + Ce.count)); for (let Ne = Ie, ke = Pe; Ne < ke; Ne += 3) { const Oe = ve.getX(Ne), Ue = ve.getX(Ne + 1), He = ve.getX(Ne + 2); ge = checkGeometryIntersection(this, Re, K, me, Ee, be, Ae, Oe, Ue, He), ge && (ge.faceIndex = Math.floor(Ne / 3), ge.face.materialIndex = De.materialIndex, pe.push(ge)) } } else { const we = Math.max(0, Ce.start), Be = Math.min(ve.count, Ce.start + Ce.count); for (let De = we, Re = Be; De < Re; De += 3) { const Ie = ve.getX(De), Pe = ve.getX(De + 1), Ne = ve.getX(De + 2); ge = checkGeometryIntersection(this, ye, K, me, Ee, be, Ae, Ie, Pe, Ne), ge && (ge.faceIndex = Math.floor(De / 3), pe.push(ge)) } } else if (_e !== void 0) if (Array.isArray(ye)) for (let we = 0, Be = Se.length; we < Be; we++) { const De = Se[we], Re = ye[De.materialIndex], Ie = Math.max(De.start, Ce.start), Pe = Math.min(_e.count, Math.min(De.start + De.count, Ce.start + Ce.count)); for (let Ne = Ie, ke = Pe; Ne < ke; Ne += 3) { const Oe = Ne, Ue = Ne + 1, He = Ne + 2; ge = checkGeometryIntersection(this, Re, K, me, Ee, be, Ae, Oe, Ue, He), ge && (ge.faceIndex = Math.floor(Ne / 3), ge.face.materialIndex = De.materialIndex, pe.push(ge)) } } else { const we = Math.max(0, Ce.start), Be = Math.min(_e.count, Ce.start + Ce.count); for (let De = we, Re = Be; De < Re; De += 3) { const Ie = De, Pe = De + 1, Ne = De + 2; ge = checkGeometryIntersection(this, ye, K, me, Ee, be, Ae, Ie, Pe, Ne), ge && (ge.faceIndex = Math.floor(De / 3), pe.push(ge)) } } } } function checkIntersection$1(fe, K, pe, me, ge, xe, ye, ve) { let _e; if (K.side === BackSide ? _e = me.intersectTriangle(ye, xe, ge, !0, ve) : _e = me.intersectTriangle(ge, xe, ye, K.side === FrontSide, ve), _e === null) return null; _intersectionPointWorld.copy(ve), _intersectionPointWorld.applyMatrix4(fe.matrixWorld); const Ee = pe.ray.origin.distanceTo(_intersectionPointWorld); return Ee < pe.near || Ee > pe.far ? null : { distance: Ee, point: _intersectionPointWorld.clone(), object: fe } } function checkGeometryIntersection(fe, K, pe, me, ge, xe, ye, ve, _e, Ee) { fe.getVertexPosition(ve, _vA$1), fe.getVertexPosition(_e, _vB$1), fe.getVertexPosition(Ee, _vC$1); const be = checkIntersection$1(fe, K, pe, me, _vA$1, _vB$1, _vC$1, _intersectionPoint$1); if (be) { const Ae = new Vector3; Triangle.getBarycoord(_intersectionPoint$1, _vA$1, _vB$1, _vC$1, Ae), ge && (be.uv = Triangle.getInterpolatedAttribute(ge, ve, _e, Ee, Ae, new Vector2)), xe && (be.uv1 = Triangle.getInterpolatedAttribute(xe, ve, _e, Ee, Ae, new Vector2)), ye && (be.normal = Triangle.getInterpolatedAttribute(ye, ve, _e, Ee, Ae, new Vector3), be.normal.dot(me.direction) > 0 && be.normal.multiplyScalar(-1)); const Se = { a: ve, b: _e, c: Ee, normal: new Vector3, materialIndex: 0 }; Triangle.getNormal(_vA$1, _vB$1, _vC$1, Se.normal), be.face = Se, be.barycoord = Ae } return be } class BoxGeometry extends BufferGeometry { constructor(K = 1, pe = 1, me = 1, ge = 1, xe = 1, ye = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: K, height: pe, depth: me, widthSegments: ge, heightSegments: xe, depthSegments: ye }; const ve = this; ge = Math.floor(ge), xe = Math.floor(xe), ye = Math.floor(ye); const _e = [], Ee = [], be = [], Ae = []; let Se = 0, Ce = 0; we("z", "y", "x", -1, -1, me, pe, K, ye, xe, 0), we("z", "y", "x", 1, -1, me, pe, -K, ye, xe, 1), we("x", "z", "y", 1, 1, K, me, pe, ge, ye, 2), we("x", "z", "y", 1, -1, K, me, -pe, ge, ye, 3), we("x", "y", "z", 1, -1, K, pe, me, ge, xe, 4), we("x", "y", "z", -1, -1, K, pe, -me, ge, xe, 5), this.setIndex(_e), this.setAttribute("position", new Float32BufferAttribute(Ee, 3)), this.setAttribute("normal", new Float32BufferAttribute(be, 3)), this.setAttribute("uv", new Float32BufferAttribute(Ae, 2)); function we(Be, De, Re, Ie, Pe, Ne, ke, Oe, Ue, He, Ge) { const ze = Ne / Ue, We = ke / He, Xe = Ne / 2, Ye = ke / 2, Ze = Oe / 2, ot = Ue + 1, qe = He + 1; let Qe = 0, st = 0; const Nt = new Vector3; for (let Je = 0; Je < qe; Je++) { const jt = Je * We - Ye; for (let Xt = 0; Xt < ot; Xt++) { const ct = Xt * ze - Xe; Nt[Be] = ct * Ie, Nt[De] = jt * Pe, Nt[Re] = Ze, Ee.push(Nt.x, Nt.y, Nt.z), Nt[Be] = 0, Nt[De] = 0, Nt[Re] = Oe > 0 ? 1 : -1, be.push(Nt.x, Nt.y, Nt.z), Ae.push(Xt / Ue), Ae.push(1 - Je / He), Qe += 1 } } for (let Je = 0; Je < He; Je++)for (let jt = 0; jt < Ue; jt++) { const Xt = Se + jt + ot * Je, ct = Se + jt + ot * (Je + 1), nn = Se + (jt + 1) + ot * (Je + 1), $t = Se + (jt + 1) + ot * Je; _e.push(Xt, ct, $t), _e.push(ct, nn, $t), st += 6 } ve.addGroup(Ce, st, Ge), Ce += st, Se += Qe } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new BoxGeometry(K.width, K.height, K.depth, K.widthSegments, K.heightSegments, K.depthSegments) } } function cloneUniforms(fe) { const K = {}; for (const pe in fe) { K[pe] = {}; for (const me in fe[pe]) { const ge = fe[pe][me]; ge && (ge.isColor || ge.isMatrix3 || ge.isMatrix4 || ge.isVector2 || ge.isVector3 || ge.isVector4 || ge.isTexture || ge.isQuaternion) ? ge.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), K[pe][me] = null) : K[pe][me] = ge.clone() : Array.isArray(ge) ? K[pe][me] = ge.slice() : K[pe][me] = ge } } return K } function mergeUniforms(fe) { const K = {}; for (let pe = 0; pe < fe.length; pe++) { const me = cloneUniforms(fe[pe]); for (const ge in me) K[ge] = me[ge] } return K } function cloneUniformsGroups(fe) { const K = []; for (let pe = 0; pe < fe.length; pe++)K.push(fe[pe].clone()); return K } function getUnlitUniformColorSpace(fe) { const K = fe.getRenderTarget(); return K === null ? fe.outputColorSpace : K.isXRRenderTarget === !0 ? K.texture.colorSpace : ColorManagement.workingColorSpace } const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class ShaderMaterial extends Material { constructor(K) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, K !== void 0 && this.setValues(K) } copy(K) { return super.copy(K), this.fragmentShader = K.fragmentShader, this.vertexShader = K.vertexShader, this.uniforms = cloneUniforms(K.uniforms), this.uniformsGroups = cloneUniformsGroups(K.uniformsGroups), this.defines = Object.assign({}, K.defines), this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.fog = K.fog, this.lights = K.lights, this.clipping = K.clipping, this.extensions = Object.assign({}, K.extensions), this.glslVersion = K.glslVersion, this } toJSON(K) { const pe = super.toJSON(K); pe.glslVersion = this.glslVersion, pe.uniforms = {}; for (const ge in this.uniforms) { const ye = this.uniforms[ge].value; ye && ye.isTexture ? pe.uniforms[ge] = { type: "t", value: ye.toJSON(K).uuid } : ye && ye.isColor ? pe.uniforms[ge] = { type: "c", value: ye.getHex() } : ye && ye.isVector2 ? pe.uniforms[ge] = { type: "v2", value: ye.toArray() } : ye && ye.isVector3 ? pe.uniforms[ge] = { type: "v3", value: ye.toArray() } : ye && ye.isVector4 ? pe.uniforms[ge] = { type: "v4", value: ye.toArray() } : ye && ye.isMatrix3 ? pe.uniforms[ge] = { type: "m3", value: ye.toArray() } : ye && ye.isMatrix4 ? pe.uniforms[ge] = { type: "m4", value: ye.toArray() } : pe.uniforms[ge] = { value: ye } } Object.keys(this.defines).length > 0 && (pe.defines = this.defines), pe.vertexShader = this.vertexShader, pe.fragmentShader = this.fragmentShader, pe.lights = this.lights, pe.clipping = this.clipping; const me = {}; for (const ge in this.extensions) this.extensions[ge] === !0 && (me[ge] = !0); return Object.keys(me).length > 0 && (pe.extensions = me), pe } } class Camera extends Object3D { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.coordinateSystem = WebGLCoordinateSystem } copy(K, pe) { return super.copy(K, pe), this.matrixWorldInverse.copy(K.matrixWorldInverse), this.projectionMatrix.copy(K.projectionMatrix), this.projectionMatrixInverse.copy(K.projectionMatrixInverse), this.coordinateSystem = K.coordinateSystem, this } getWorldDirection(K) { return super.getWorldDirection(K).negate() } updateMatrixWorld(K) { super.updateMatrixWorld(K), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(K, pe) { super.updateWorldMatrix(K, pe), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } const _v3$1 = new Vector3, _minTarget = new Vector2, _maxTarget = new Vector2; class PerspectiveCamera extends Camera { constructor(K = 50, pe = 1, me = .1, ge = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = K, this.zoom = 1, this.near = me, this.far = ge, this.focus = 10, this.aspect = pe, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(K, pe) { return super.copy(K, pe), this.fov = K.fov, this.zoom = K.zoom, this.near = K.near, this.far = K.far, this.focus = K.focus, this.aspect = K.aspect, this.view = K.view === null ? null : Object.assign({}, K.view), this.filmGauge = K.filmGauge, this.filmOffset = K.filmOffset, this } setFocalLength(K) { const pe = .5 * this.getFilmHeight() / K; this.fov = RAD2DEG * 2 * Math.atan(pe), this.updateProjectionMatrix() } getFocalLength() { const K = Math.tan(DEG2RAD$1 * .5 * this.fov); return .5 * this.getFilmHeight() / K } getEffectiveFOV() { return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD$1 * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(K, pe, me) { _v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), pe.set(_v3$1.x, _v3$1.y).multiplyScalar(-K / _v3$1.z), _v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), me.set(_v3$1.x, _v3$1.y).multiplyScalar(-K / _v3$1.z) } getViewSize(K, pe) { return this.getViewBounds(K, _minTarget, _maxTarget), pe.subVectors(_maxTarget, _minTarget) } setViewOffset(K, pe, me, ge, xe, ye) { this.aspect = K / pe, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = K, this.view.fullHeight = pe, this.view.offsetX = me, this.view.offsetY = ge, this.view.width = xe, this.view.height = ye, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const K = this.near; let pe = K * Math.tan(DEG2RAD$1 * .5 * this.fov) / this.zoom, me = 2 * pe, ge = this.aspect * me, xe = -.5 * ge; const ye = this.view; if (this.view !== null && this.view.enabled) { const _e = ye.fullWidth, Ee = ye.fullHeight; xe += ye.offsetX * ge / _e, pe -= ye.offsetY * me / Ee, ge *= ye.width / _e, me *= ye.height / Ee } const ve = this.filmOffset; ve !== 0 && (xe += K * ve / this.getFilmWidth()), this.projectionMatrix.makePerspective(xe, xe + ge, pe, pe - me, K, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(K) { const pe = super.toJSON(K); return pe.object.fov = this.fov, pe.object.zoom = this.zoom, pe.object.near = this.near, pe.object.far = this.far, pe.object.focus = this.focus, pe.object.aspect = this.aspect, this.view !== null && (pe.object.view = Object.assign({}, this.view)), pe.object.filmGauge = this.filmGauge, pe.object.filmOffset = this.filmOffset, pe } } const fov = -90, aspect = 1; class CubeCamera extends Object3D { constructor(K, pe, me) { super(), this.type = "CubeCamera", this.renderTarget = me, this.coordinateSystem = null, this.activeMipmapLevel = 0; const ge = new PerspectiveCamera(fov, aspect, K, pe); ge.layers = this.layers, this.add(ge); const xe = new PerspectiveCamera(fov, aspect, K, pe); xe.layers = this.layers, this.add(xe); const ye = new PerspectiveCamera(fov, aspect, K, pe); ye.layers = this.layers, this.add(ye); const ve = new PerspectiveCamera(fov, aspect, K, pe); ve.layers = this.layers, this.add(ve); const _e = new PerspectiveCamera(fov, aspect, K, pe); _e.layers = this.layers, this.add(_e); const Ee = new PerspectiveCamera(fov, aspect, K, pe); Ee.layers = this.layers, this.add(Ee) } updateCoordinateSystem() { const K = this.coordinateSystem, pe = this.children.concat(), [me, ge, xe, ye, ve, _e] = pe; for (const Ee of pe) this.remove(Ee); if (K === WebGLCoordinateSystem) me.up.set(0, 1, 0), me.lookAt(1, 0, 0), ge.up.set(0, 1, 0), ge.lookAt(-1, 0, 0), xe.up.set(0, 0, -1), xe.lookAt(0, 1, 0), ye.up.set(0, 0, 1), ye.lookAt(0, -1, 0), ve.up.set(0, 1, 0), ve.lookAt(0, 0, 1), _e.up.set(0, 1, 0), _e.lookAt(0, 0, -1); else if (K === WebGPUCoordinateSystem) me.up.set(0, -1, 0), me.lookAt(-1, 0, 0), ge.up.set(0, -1, 0), ge.lookAt(1, 0, 0), xe.up.set(0, 0, 1), xe.lookAt(0, 1, 0), ye.up.set(0, 0, -1), ye.lookAt(0, -1, 0), ve.up.set(0, -1, 0), ve.lookAt(0, 0, 1), _e.up.set(0, -1, 0), _e.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + K); for (const Ee of pe) this.add(Ee), Ee.updateMatrixWorld() } update(K, pe) { this.parent === null && this.updateMatrixWorld(); const { renderTarget: me, activeMipmapLevel: ge } = this; this.coordinateSystem !== K.coordinateSystem && (this.coordinateSystem = K.coordinateSystem, this.updateCoordinateSystem()); const [xe, ye, ve, _e, Ee, be] = this.children, Ae = K.getRenderTarget(), Se = K.getActiveCubeFace(), Ce = K.getActiveMipmapLevel(), we = K.xr.enabled; K.xr.enabled = !1; const Be = me.texture.generateMipmaps; me.texture.generateMipmaps = !1, K.setRenderTarget(me, 0, ge), K.render(pe, xe), K.setRenderTarget(me, 1, ge), K.render(pe, ye), K.setRenderTarget(me, 2, ge), K.render(pe, ve), K.setRenderTarget(me, 3, ge), K.render(pe, _e), K.setRenderTarget(me, 4, ge), K.render(pe, Ee), me.texture.generateMipmaps = Be, K.setRenderTarget(me, 5, ge), K.render(pe, be), K.setRenderTarget(Ae, Se, Ce), K.xr.enabled = we, me.texture.needsPMREMUpdate = !0 } } class CubeTexture extends Texture { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee, be) { K = K !== void 0 ? K : [], pe = pe !== void 0 ? pe : CubeReflectionMapping, super(K, pe, me, ge, xe, ye, ve, _e, Ee, be), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(K) { this.image = K } } class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(K = 1, pe = {}) { super(K, K, pe), this.isWebGLCubeRenderTarget = !0; const me = { width: K, height: K, depth: 1 }, ge = [me, me, me, me, me, me]; this.texture = new CubeTexture(ge, pe.mapping, pe.wrapS, pe.wrapT, pe.magFilter, pe.minFilter, pe.format, pe.type, pe.anisotropy, pe.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = pe.generateMipmaps !== void 0 ? pe.generateMipmaps : !1, this.texture.minFilter = pe.minFilter !== void 0 ? pe.minFilter : LinearFilter } fromEquirectangularTexture(K, pe) {
		this.texture.type = pe.type, this.texture.colorSpace = pe.colorSpace, this.texture.generateMipmaps = pe.generateMipmaps, this.texture.minFilter = pe.minFilter, this.texture.magFilter = pe.magFilter; const me = {
			uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, ge = new BoxGeometry(5, 5, 5), xe = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(me.uniforms), vertexShader: me.vertexShader, fragmentShader: me.fragmentShader, side: BackSide, blending: NoBlending }); xe.uniforms.tEquirect.value = pe; const ye = new Mesh(ge, xe), ve = pe.minFilter; return pe.minFilter === LinearMipmapLinearFilter && (pe.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(K, ye), pe.minFilter = ve, ye.geometry.dispose(), ye.material.dispose(), this
	} clear(K, pe, me, ge) { const xe = K.getRenderTarget(); for (let ye = 0; ye < 6; ye++)K.setRenderTarget(this, ye), K.clear(pe, me, ge); K.setRenderTarget(xe) }
} class Group extends Object3D { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const _moveEvent = { type: "move" }; class WebXRController { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3), this._grip } dispatchEvent(K) { return this._targetRay !== null && this._targetRay.dispatchEvent(K), this._grip !== null && this._grip.dispatchEvent(K), this._hand !== null && this._hand.dispatchEvent(K), this } connect(K) { if (K && K.hand) { const pe = this._hand; if (pe) for (const me of K.hand.values()) this._getHandJoint(pe, me) } return this.dispatchEvent({ type: "connected", data: K }), this } disconnect(K) { return this.dispatchEvent({ type: "disconnected", data: K }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(K, pe, me) { let ge = null, xe = null, ye = null; const ve = this._targetRay, _e = this._grip, Ee = this._hand; if (K && pe.session.visibilityState !== "visible-blurred") { if (Ee && K.hand) { ye = !0; for (const Be of K.hand.values()) { const De = pe.getJointPose(Be, me), Re = this._getHandJoint(Ee, Be); De !== null && (Re.matrix.fromArray(De.transform.matrix), Re.matrix.decompose(Re.position, Re.rotation, Re.scale), Re.matrixWorldNeedsUpdate = !0, Re.jointRadius = De.radius), Re.visible = De !== null } const be = Ee.joints["index-finger-tip"], Ae = Ee.joints["thumb-tip"], Se = be.position.distanceTo(Ae.position), Ce = .02, we = .005; Ee.inputState.pinching && Se > Ce + we ? (Ee.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: K.handedness, target: this })) : !Ee.inputState.pinching && Se <= Ce - we && (Ee.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: K.handedness, target: this })) } else _e !== null && K.gripSpace && (xe = pe.getPose(K.gripSpace, me), xe !== null && (_e.matrix.fromArray(xe.transform.matrix), _e.matrix.decompose(_e.position, _e.rotation, _e.scale), _e.matrixWorldNeedsUpdate = !0, xe.linearVelocity ? (_e.hasLinearVelocity = !0, _e.linearVelocity.copy(xe.linearVelocity)) : _e.hasLinearVelocity = !1, xe.angularVelocity ? (_e.hasAngularVelocity = !0, _e.angularVelocity.copy(xe.angularVelocity)) : _e.hasAngularVelocity = !1)); ve !== null && (ge = pe.getPose(K.targetRaySpace, me), ge === null && xe !== null && (ge = xe), ge !== null && (ve.matrix.fromArray(ge.transform.matrix), ve.matrix.decompose(ve.position, ve.rotation, ve.scale), ve.matrixWorldNeedsUpdate = !0, ge.linearVelocity ? (ve.hasLinearVelocity = !0, ve.linearVelocity.copy(ge.linearVelocity)) : ve.hasLinearVelocity = !1, ge.angularVelocity ? (ve.hasAngularVelocity = !0, ve.angularVelocity.copy(ge.angularVelocity)) : ve.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent))) } return ve !== null && (ve.visible = ge !== null), _e !== null && (_e.visible = xe !== null), Ee !== null && (Ee.visible = ye !== null), this } _getHandJoint(K, pe) { if (K.joints[pe.jointName] === void 0) { const me = new Group; me.matrixAutoUpdate = !1, me.visible = !1, K.joints[pe.jointName] = me, K.add(me) } return K.joints[pe.jointName] } } class FogExp2 { constructor(K, pe = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new Color$1(K), this.density = pe } clone() { return new FogExp2(this.color, this.density) } toJSON() { return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density } } } class Fog { constructor(K, pe = 1, me = 1e3) { this.isFog = !0, this.name = "", this.color = new Color$1(K), this.near = pe, this.far = me } clone() { return new Fog(this.color, this.near, this.far) } toJSON() { return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far } } } class Scene extends Object3D { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler, this.environmentIntensity = 1, this.environmentRotation = new Euler, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(K, pe) { return super.copy(K, pe), K.background !== null && (this.background = K.background.clone()), K.environment !== null && (this.environment = K.environment.clone()), K.fog !== null && (this.fog = K.fog.clone()), this.backgroundBlurriness = K.backgroundBlurriness, this.backgroundIntensity = K.backgroundIntensity, this.backgroundRotation.copy(K.backgroundRotation), this.environmentIntensity = K.environmentIntensity, this.environmentRotation.copy(K.environmentRotation), K.overrideMaterial !== null && (this.overrideMaterial = K.overrideMaterial.clone()), this.matrixAutoUpdate = K.matrixAutoUpdate, this } toJSON(K) { const pe = super.toJSON(K); return this.fog !== null && (pe.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (pe.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (pe.object.backgroundIntensity = this.backgroundIntensity), pe.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (pe.object.environmentIntensity = this.environmentIntensity), pe.object.environmentRotation = this.environmentRotation.toArray(), pe } } class InterleavedBuffer { constructor(K, pe) { this.isInterleavedBuffer = !0, this.array = K, this.stride = pe, this.count = K !== void 0 ? K.length / pe : 0, this.usage = StaticDrawUsage, this.updateRanges = [], this.version = 0, this.uuid = generateUUID() } onUploadCallback() { } set needsUpdate(K) { K === !0 && this.version++ } setUsage(K) { return this.usage = K, this } addUpdateRange(K, pe) { this.updateRanges.push({ start: K, count: pe }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(K) { return this.array = new K.array.constructor(K.array), this.count = K.count, this.stride = K.stride, this.usage = K.usage, this } copyAt(K, pe, me) { K *= this.stride, me *= pe.stride; for (let ge = 0, xe = this.stride; ge < xe; ge++)this.array[K + ge] = pe.array[me + ge]; return this } set(K, pe = 0) { return this.array.set(K, pe), this } clone(K) { K.arrayBuffers === void 0 && (K.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), K.arrayBuffers[this.array.buffer._uuid] === void 0 && (K.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const pe = new this.array.constructor(K.arrayBuffers[this.array.buffer._uuid]), me = new this.constructor(pe, this.stride); return me.setUsage(this.usage), me } onUpload(K) { return this.onUploadCallback = K, this } toJSON(K) { return K.arrayBuffers === void 0 && (K.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), K.arrayBuffers[this.array.buffer._uuid] === void 0 && (K.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const _vector$7 = new Vector3; class InterleavedBufferAttribute { constructor(K, pe, me, ge = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = K, this.itemSize = pe, this.offset = me, this.normalized = ge } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(K) { this.data.needsUpdate = K } applyMatrix4(K) { for (let pe = 0, me = this.data.count; pe < me; pe++)_vector$7.fromBufferAttribute(this, pe), _vector$7.applyMatrix4(K), this.setXYZ(pe, _vector$7.x, _vector$7.y, _vector$7.z); return this } applyNormalMatrix(K) { for (let pe = 0, me = this.count; pe < me; pe++)_vector$7.fromBufferAttribute(this, pe), _vector$7.applyNormalMatrix(K), this.setXYZ(pe, _vector$7.x, _vector$7.y, _vector$7.z); return this } transformDirection(K) { for (let pe = 0, me = this.count; pe < me; pe++)_vector$7.fromBufferAttribute(this, pe), _vector$7.transformDirection(K), this.setXYZ(pe, _vector$7.x, _vector$7.y, _vector$7.z); return this } getComponent(K, pe) { let me = this.array[K * this.data.stride + this.offset + pe]; return this.normalized && (me = denormalize(me, this.array)), me } setComponent(K, pe, me) { return this.normalized && (me = normalize$2(me, this.array)), this.data.array[K * this.data.stride + this.offset + pe] = me, this } setX(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.data.array[K * this.data.stride + this.offset] = pe, this } setY(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.data.array[K * this.data.stride + this.offset + 1] = pe, this } setZ(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.data.array[K * this.data.stride + this.offset + 2] = pe, this } setW(K, pe) { return this.normalized && (pe = normalize$2(pe, this.array)), this.data.array[K * this.data.stride + this.offset + 3] = pe, this } getX(K) { let pe = this.data.array[K * this.data.stride + this.offset]; return this.normalized && (pe = denormalize(pe, this.array)), pe } getY(K) { let pe = this.data.array[K * this.data.stride + this.offset + 1]; return this.normalized && (pe = denormalize(pe, this.array)), pe } getZ(K) { let pe = this.data.array[K * this.data.stride + this.offset + 2]; return this.normalized && (pe = denormalize(pe, this.array)), pe } getW(K) { let pe = this.data.array[K * this.data.stride + this.offset + 3]; return this.normalized && (pe = denormalize(pe, this.array)), pe } setXY(K, pe, me) { return K = K * this.data.stride + this.offset, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array)), this.data.array[K + 0] = pe, this.data.array[K + 1] = me, this } setXYZ(K, pe, me, ge) { return K = K * this.data.stride + this.offset, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array)), this.data.array[K + 0] = pe, this.data.array[K + 1] = me, this.data.array[K + 2] = ge, this } setXYZW(K, pe, me, ge, xe) { return K = K * this.data.stride + this.offset, this.normalized && (pe = normalize$2(pe, this.array), me = normalize$2(me, this.array), ge = normalize$2(ge, this.array), xe = normalize$2(xe, this.array)), this.data.array[K + 0] = pe, this.data.array[K + 1] = me, this.data.array[K + 2] = ge, this.data.array[K + 3] = xe, this } clone(K) { if (K === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const pe = []; for (let me = 0; me < this.count; me++) { const ge = me * this.data.stride + this.offset; for (let xe = 0; xe < this.itemSize; xe++)pe.push(this.data.array[ge + xe]) } return new BufferAttribute(new this.array.constructor(pe), this.itemSize, this.normalized) } else return K.interleavedBuffers === void 0 && (K.interleavedBuffers = {}), K.interleavedBuffers[this.data.uuid] === void 0 && (K.interleavedBuffers[this.data.uuid] = this.data.clone(K)), new InterleavedBufferAttribute(K.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(K) { if (K === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const pe = []; for (let me = 0; me < this.count; me++) { const ge = me * this.data.stride + this.offset; for (let xe = 0; xe < this.itemSize; xe++)pe.push(this.data.array[ge + xe]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: pe, normalized: this.normalized } } else return K.interleavedBuffers === void 0 && (K.interleavedBuffers = {}), K.interleavedBuffers[this.data.uuid] === void 0 && (K.interleavedBuffers[this.data.uuid] = this.data.toJSON(K)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class SpriteMaterial extends Material { constructor(K) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Color$1(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.alphaMap = K.alphaMap, this.rotation = K.rotation, this.sizeAttenuation = K.sizeAttenuation, this.fog = K.fog, this } } let _geometry; const _intersectPoint = new Vector3, _worldScale$1 = new Vector3, _mvPosition = new Vector3, _alignedPosition = new Vector2, _rotatedPosition = new Vector2, _viewWorldMatrix = new Matrix4, _vA$2 = new Vector3, _vB$2 = new Vector3, _vC$2 = new Vector3, _uvA$1 = new Vector2, _uvB$1 = new Vector2, _uvC$1 = new Vector2; class Sprite extends Object3D { constructor(K = new SpriteMaterial) { if (super(), this.isSprite = !0, this.type = "Sprite", _geometry === void 0) { _geometry = new BufferGeometry; const pe = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), me = new InterleavedBuffer(pe, 5); _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(me, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(me, 2, 3, !1)) } this.geometry = _geometry, this.material = K, this.center = new Vector2(.5, .5) } raycast(K, pe) { K.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale$1.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(K.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(K.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), K.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale$1.multiplyScalar(-_mvPosition.z); const me = this.material.rotation; let ge, xe; me !== 0 && (xe = Math.cos(me), ge = Math.sin(me)); const ye = this.center; transformVertex(_vA$2.set(-.5, -.5, 0), _mvPosition, ye, _worldScale$1, ge, xe), transformVertex(_vB$2.set(.5, -.5, 0), _mvPosition, ye, _worldScale$1, ge, xe), transformVertex(_vC$2.set(.5, .5, 0), _mvPosition, ye, _worldScale$1, ge, xe), _uvA$1.set(0, 0), _uvB$1.set(1, 0), _uvC$1.set(1, 1); let ve = K.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, !1, _intersectPoint); if (ve === null && (transformVertex(_vB$2.set(-.5, .5, 0), _mvPosition, ye, _worldScale$1, ge, xe), _uvB$1.set(0, 1), ve = K.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, !1, _intersectPoint), ve === null)) return; const _e = K.ray.origin.distanceTo(_intersectPoint); _e < K.near || _e > K.far || pe.push({ distance: _e, point: _intersectPoint.clone(), uv: Triangle.getInterpolation(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA$1, _uvB$1, _uvC$1, new Vector2), face: null, object: this }) } copy(K, pe) { return super.copy(K, pe), K.center !== void 0 && this.center.copy(K.center), this.material = K.material, this } } function transformVertex(fe, K, pe, me, ge, xe) { _alignedPosition.subVectors(fe, pe).addScalar(.5).multiply(me), ge !== void 0 ? (_rotatedPosition.x = xe * _alignedPosition.x - ge * _alignedPosition.y, _rotatedPosition.y = ge * _alignedPosition.x + xe * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), fe.copy(K), fe.x += _rotatedPosition.x, fe.y += _rotatedPosition.y, fe.applyMatrix4(_viewWorldMatrix) } const _v1$2 = new Vector3, _v2$1 = new Vector3; class LOD extends Object3D { constructor() { super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } copy(K) { super.copy(K, !1); const pe = K.levels; for (let me = 0, ge = pe.length; me < ge; me++) { const xe = pe[me]; this.addLevel(xe.object.clone(), xe.distance, xe.hysteresis) } return this.autoUpdate = K.autoUpdate, this } addLevel(K, pe = 0, me = 0) { pe = Math.abs(pe); const ge = this.levels; let xe; for (xe = 0; xe < ge.length && !(pe < ge[xe].distance); xe++); return ge.splice(xe, 0, { distance: pe, hysteresis: me, object: K }), this.add(K), this } removeLevel(K) { const pe = this.levels; for (let me = 0; me < pe.length; me++)if (pe[me].distance === K) { const ge = pe.splice(me, 1); return this.remove(ge[0].object), !0 } return !1 } getCurrentLevel() { return this._currentLevel } getObjectForDistance(K) { const pe = this.levels; if (pe.length > 0) { let me, ge; for (me = 1, ge = pe.length; me < ge; me++) { let xe = pe[me].distance; if (pe[me].object.visible && (xe -= xe * pe[me].hysteresis), K < xe) break } return pe[me - 1].object } return null } raycast(K, pe) { if (this.levels.length > 0) { _v1$2.setFromMatrixPosition(this.matrixWorld); const ge = K.ray.origin.distanceTo(_v1$2); this.getObjectForDistance(ge).raycast(K, pe) } } update(K) { const pe = this.levels; if (pe.length > 1) { _v1$2.setFromMatrixPosition(K.matrixWorld), _v2$1.setFromMatrixPosition(this.matrixWorld); const me = _v1$2.distanceTo(_v2$1) / K.zoom; pe[0].object.visible = !0; let ge, xe; for (ge = 1, xe = pe.length; ge < xe; ge++) { let ye = pe[ge].distance; if (pe[ge].object.visible && (ye -= ye * pe[ge].hysteresis), me >= ye) pe[ge - 1].object.visible = !1, pe[ge].object.visible = !0; else break } for (this._currentLevel = ge - 1; ge < xe; ge++)pe[ge].object.visible = !1 } } toJSON(K) { const pe = super.toJSON(K); this.autoUpdate === !1 && (pe.object.autoUpdate = !1), pe.object.levels = []; const me = this.levels; for (let ge = 0, xe = me.length; ge < xe; ge++) { const ye = me[ge]; pe.object.levels.push({ object: ye.object.uuid, distance: ye.distance, hysteresis: ye.hysteresis }) } return pe } } const _basePosition = new Vector3, _skinIndex = new Vector4, _skinWeight = new Vector4, _vector3 = new Vector3, _matrix4 = new Matrix4, _vertex = new Vector3, _sphere$5 = new Sphere, _inverseMatrix$2 = new Matrix4, _ray$2 = new Ray; let SkinnedMesh$1 = class extends Mesh { constructor(K, pe) { super(K, pe), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const K = this.geometry; this.boundingBox === null && (this.boundingBox = new Box3), this.boundingBox.makeEmpty(); const pe = K.getAttribute("position"); for (let me = 0; me < pe.count; me++)this.getVertexPosition(me, _vertex), this.boundingBox.expandByPoint(_vertex) } computeBoundingSphere() { const K = this.geometry; this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingSphere.makeEmpty(); const pe = K.getAttribute("position"); for (let me = 0; me < pe.count; me++)this.getVertexPosition(me, _vertex), this.boundingSphere.expandByPoint(_vertex) } copy(K, pe) { return super.copy(K, pe), this.bindMode = K.bindMode, this.bindMatrix.copy(K.bindMatrix), this.bindMatrixInverse.copy(K.bindMatrixInverse), this.skeleton = K.skeleton, K.boundingBox !== null && (this.boundingBox = K.boundingBox.clone()), K.boundingSphere !== null && (this.boundingSphere = K.boundingSphere.clone()), this } raycast(K, pe) { const me = this.material, ge = this.matrixWorld; me !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$5.copy(this.boundingSphere), _sphere$5.applyMatrix4(ge), K.ray.intersectsSphere(_sphere$5) !== !1 && (_inverseMatrix$2.copy(ge).invert(), _ray$2.copy(K.ray).applyMatrix4(_inverseMatrix$2), !(this.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(K, pe, _ray$2))) } getVertexPosition(K, pe) { return super.getVertexPosition(K, pe), this.applyBoneTransform(K, pe), pe } bind(K, pe) { this.skeleton = K, pe === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), pe = this.matrixWorld), this.bindMatrix.copy(pe), this.bindMatrixInverse.copy(pe).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const K = new Vector4, pe = this.geometry.attributes.skinWeight; for (let me = 0, ge = pe.count; me < ge; me++) { K.fromBufferAttribute(pe, me); const xe = 1 / K.manhattanLength(); xe !== 1 / 0 ? K.multiplyScalar(xe) : K.set(1, 0, 0, 0), pe.setXYZW(me, K.x, K.y, K.z, K.w) } } updateMatrixWorld(K) { super.updateMatrixWorld(K), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(K, pe) { const me = this.skeleton, ge = this.geometry; _skinIndex.fromBufferAttribute(ge.attributes.skinIndex, K), _skinWeight.fromBufferAttribute(ge.attributes.skinWeight, K), _basePosition.copy(pe).applyMatrix4(this.bindMatrix), pe.set(0, 0, 0); for (let xe = 0; xe < 4; xe++) { const ye = _skinWeight.getComponent(xe); if (ye !== 0) { const ve = _skinIndex.getComponent(xe); _matrix4.multiplyMatrices(me.bones[ve].matrixWorld, me.boneInverses[ve]), pe.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), ye) } } return pe.applyMatrix4(this.bindMatrixInverse) } }; class Bone extends Object3D { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class DataTexture extends Texture { constructor(K = null, pe = 1, me = 1, ge, xe, ye, ve, _e, Ee = NearestFilter, be = NearestFilter, Ae, Se) { super(null, ye, ve, _e, Ee, be, ge, xe, Ae, Se), this.isDataTexture = !0, this.image = { data: K, width: pe, height: me }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const _offsetMatrix = new Matrix4, _identityMatrix$1 = new Matrix4; class Skeleton { constructor(K = [], pe = []) { this.uuid = generateUUID(), this.bones = K.slice(0), this.boneInverses = pe, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const K = this.bones, pe = this.boneInverses; if (this.boneMatrices = new Float32Array(K.length * 16), pe.length === 0) this.calculateInverses(); else if (K.length !== pe.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let me = 0, ge = this.bones.length; me < ge; me++)this.boneInverses.push(new Matrix4) } } calculateInverses() { this.boneInverses.length = 0; for (let K = 0, pe = this.bones.length; K < pe; K++) { const me = new Matrix4; this.bones[K] && me.copy(this.bones[K].matrixWorld).invert(), this.boneInverses.push(me) } } pose() { for (let K = 0, pe = this.bones.length; K < pe; K++) { const me = this.bones[K]; me && me.matrixWorld.copy(this.boneInverses[K]).invert() } for (let K = 0, pe = this.bones.length; K < pe; K++) { const me = this.bones[K]; me && (me.parent && me.parent.isBone ? (me.matrix.copy(me.parent.matrixWorld).invert(), me.matrix.multiply(me.matrixWorld)) : me.matrix.copy(me.matrixWorld), me.matrix.decompose(me.position, me.quaternion, me.scale)) } } update() { const K = this.bones, pe = this.boneInverses, me = this.boneMatrices, ge = this.boneTexture; for (let xe = 0, ye = K.length; xe < ye; xe++) { const ve = K[xe] ? K[xe].matrixWorld : _identityMatrix$1; _offsetMatrix.multiplyMatrices(ve, pe[xe]), _offsetMatrix.toArray(me, xe * 16) } ge !== null && (ge.needsUpdate = !0) } clone() { return new Skeleton(this.bones, this.boneInverses) } computeBoneTexture() { let K = Math.sqrt(this.bones.length * 4); K = Math.ceil(K / 4) * 4, K = Math.max(K, 4); const pe = new Float32Array(K * K * 4); pe.set(this.boneMatrices); const me = new DataTexture(pe, K, K, RGBAFormat, FloatType); return me.needsUpdate = !0, this.boneMatrices = pe, this.boneTexture = me, this } getBoneByName(K) { for (let pe = 0, me = this.bones.length; pe < me; pe++) { const ge = this.bones[pe]; if (ge.name === K) return ge } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(K, pe) { this.uuid = K.uuid; for (let me = 0, ge = K.bones.length; me < ge; me++) { const xe = K.bones[me]; let ye = pe[xe]; ye === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", xe), ye = new Bone), this.bones.push(ye), this.boneInverses.push(new Matrix4().fromArray(K.boneInverses[me])) } return this.init(), this } toJSON() { const K = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; K.uuid = this.uuid; const pe = this.bones, me = this.boneInverses; for (let ge = 0, xe = pe.length; ge < xe; ge++) { const ye = pe[ge]; K.bones.push(ye.uuid); const ve = me[ge]; K.boneInverses.push(ve.toArray()) } return K } } class InstancedBufferAttribute extends BufferAttribute { constructor(K, pe, me, ge = 1) { super(K, pe, me), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = ge } copy(K) { return super.copy(K), this.meshPerAttribute = K.meshPerAttribute, this } toJSON() { const K = super.toJSON(); return K.meshPerAttribute = this.meshPerAttribute, K.isInstancedBufferAttribute = !0, K } } const _instanceLocalMatrix$1 = new Matrix4, _instanceWorldMatrix$1 = new Matrix4, _instanceIntersects$1 = [], _box3 = new Box3, _identity = new Matrix4, _mesh$1$1 = new Mesh, _sphere$4 = new Sphere; class InstancedMesh extends Mesh { constructor(K, pe, me) { super(K, pe), this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(me * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = me, this.boundingBox = null, this.boundingSphere = null; for (let ge = 0; ge < me; ge++)this.setMatrixAt(ge, _identity) } computeBoundingBox() { const K = this.geometry, pe = this.count; this.boundingBox === null && (this.boundingBox = new Box3), K.boundingBox === null && K.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let me = 0; me < pe; me++)this.getMatrixAt(me, _instanceLocalMatrix$1), _box3.copy(K.boundingBox).applyMatrix4(_instanceLocalMatrix$1), this.boundingBox.union(_box3) } computeBoundingSphere() { const K = this.geometry, pe = this.count; this.boundingSphere === null && (this.boundingSphere = new Sphere), K.boundingSphere === null && K.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let me = 0; me < pe; me++)this.getMatrixAt(me, _instanceLocalMatrix$1), _sphere$4.copy(K.boundingSphere).applyMatrix4(_instanceLocalMatrix$1), this.boundingSphere.union(_sphere$4) } copy(K, pe) { return super.copy(K, pe), this.instanceMatrix.copy(K.instanceMatrix), K.morphTexture !== null && (this.morphTexture = K.morphTexture.clone()), K.instanceColor !== null && (this.instanceColor = K.instanceColor.clone()), this.count = K.count, K.boundingBox !== null && (this.boundingBox = K.boundingBox.clone()), K.boundingSphere !== null && (this.boundingSphere = K.boundingSphere.clone()), this } getColorAt(K, pe) { pe.fromArray(this.instanceColor.array, K * 3) } getMatrixAt(K, pe) { pe.fromArray(this.instanceMatrix.array, K * 16) } getMorphAt(K, pe) { const me = pe.morphTargetInfluences, ge = this.morphTexture.source.data.data, xe = me.length + 1, ye = K * xe + 1; for (let ve = 0; ve < me.length; ve++)me[ve] = ge[ye + ve] } raycast(K, pe) { const me = this.matrixWorld, ge = this.count; if (_mesh$1$1.geometry = this.geometry, _mesh$1$1.material = this.material, _mesh$1$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(me), K.ray.intersectsSphere(_sphere$4) !== !1)) for (let xe = 0; xe < ge; xe++) { this.getMatrixAt(xe, _instanceLocalMatrix$1), _instanceWorldMatrix$1.multiplyMatrices(me, _instanceLocalMatrix$1), _mesh$1$1.matrixWorld = _instanceWorldMatrix$1, _mesh$1$1.raycast(K, _instanceIntersects$1); for (let ye = 0, ve = _instanceIntersects$1.length; ye < ve; ye++) { const _e = _instanceIntersects$1[ye]; _e.instanceId = xe, _e.object = this, pe.push(_e) } _instanceIntersects$1.length = 0 } } setColorAt(K, pe) { this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), pe.toArray(this.instanceColor.array, K * 3) } setMatrixAt(K, pe) { pe.toArray(this.instanceMatrix.array, K * 16) } setMorphAt(K, pe) { const me = pe.morphTargetInfluences, ge = me.length + 1; this.morphTexture === null && (this.morphTexture = new DataTexture(new Float32Array(ge * this.count), ge, this.count, RedFormat, FloatType)); const xe = this.morphTexture.source.data.data; let ye = 0; for (let Ee = 0; Ee < me.length; Ee++)ye += me[Ee]; const ve = this.geometry.morphTargetsRelative ? 1 : 1 - ye, _e = ge * K; xe[_e] = ve, xe.set(me, _e + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null) } } const _vector1 = new Vector3, _vector2 = new Vector3, _normalMatrix = new Matrix3; class Plane { constructor(K = new Vector3(1, 0, 0), pe = 0) { this.isPlane = !0, this.normal = K, this.constant = pe } set(K, pe) { return this.normal.copy(K), this.constant = pe, this } setComponents(K, pe, me, ge) { return this.normal.set(K, pe, me), this.constant = ge, this } setFromNormalAndCoplanarPoint(K, pe) { return this.normal.copy(K), this.constant = -pe.dot(this.normal), this } setFromCoplanarPoints(K, pe, me) { const ge = _vector1.subVectors(me, pe).cross(_vector2.subVectors(K, pe)).normalize(); return this.setFromNormalAndCoplanarPoint(ge, K), this } copy(K) { return this.normal.copy(K.normal), this.constant = K.constant, this } normalize() { const K = 1 / this.normal.length(); return this.normal.multiplyScalar(K), this.constant *= K, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(K) { return this.normal.dot(K) + this.constant } distanceToSphere(K) { return this.distanceToPoint(K.center) - K.radius } projectPoint(K, pe) { return pe.copy(K).addScaledVector(this.normal, -this.distanceToPoint(K)) } intersectLine(K, pe) { const me = K.delta(_vector1), ge = this.normal.dot(me); if (ge === 0) return this.distanceToPoint(K.start) === 0 ? pe.copy(K.start) : null; const xe = -(K.start.dot(this.normal) + this.constant) / ge; return xe < 0 || xe > 1 ? null : pe.copy(K.start).addScaledVector(me, xe) } intersectsLine(K) { const pe = this.distanceToPoint(K.start), me = this.distanceToPoint(K.end); return pe < 0 && me > 0 || me < 0 && pe > 0 } intersectsBox(K) { return K.intersectsPlane(this) } intersectsSphere(K) { return K.intersectsPlane(this) } coplanarPoint(K) { return K.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(K, pe) { const me = pe || _normalMatrix.getNormalMatrix(K), ge = this.coplanarPoint(_vector1).applyMatrix4(K), xe = this.normal.applyMatrix3(me).normalize(); return this.constant = -ge.dot(xe), this } translate(K) { return this.constant -= K.dot(this.normal), this } equals(K) { return K.normal.equals(this.normal) && K.constant === this.constant } clone() { return new this.constructor().copy(this) } } const _sphere$3 = new Sphere, _vector$6 = new Vector3; class Frustum { constructor(K = new Plane, pe = new Plane, me = new Plane, ge = new Plane, xe = new Plane, ye = new Plane) { this.planes = [K, pe, me, ge, xe, ye] } set(K, pe, me, ge, xe, ye) { const ve = this.planes; return ve[0].copy(K), ve[1].copy(pe), ve[2].copy(me), ve[3].copy(ge), ve[4].copy(xe), ve[5].copy(ye), this } copy(K) { const pe = this.planes; for (let me = 0; me < 6; me++)pe[me].copy(K.planes[me]); return this } setFromProjectionMatrix(K, pe = WebGLCoordinateSystem) { const me = this.planes, ge = K.elements, xe = ge[0], ye = ge[1], ve = ge[2], _e = ge[3], Ee = ge[4], be = ge[5], Ae = ge[6], Se = ge[7], Ce = ge[8], we = ge[9], Be = ge[10], De = ge[11], Re = ge[12], Ie = ge[13], Pe = ge[14], Ne = ge[15]; if (me[0].setComponents(_e - xe, Se - Ee, De - Ce, Ne - Re).normalize(), me[1].setComponents(_e + xe, Se + Ee, De + Ce, Ne + Re).normalize(), me[2].setComponents(_e + ye, Se + be, De + we, Ne + Ie).normalize(), me[3].setComponents(_e - ye, Se - be, De - we, Ne - Ie).normalize(), me[4].setComponents(_e - ve, Se - Ae, De - Be, Ne - Pe).normalize(), pe === WebGLCoordinateSystem) me[5].setComponents(_e + ve, Se + Ae, De + Be, Ne + Pe).normalize(); else if (pe === WebGPUCoordinateSystem) me[5].setComponents(ve, Ae, Be, Pe).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + pe); return this } intersectsObject(K) { if (K.boundingSphere !== void 0) K.boundingSphere === null && K.computeBoundingSphere(), _sphere$3.copy(K.boundingSphere).applyMatrix4(K.matrixWorld); else { const pe = K.geometry; pe.boundingSphere === null && pe.computeBoundingSphere(), _sphere$3.copy(pe.boundingSphere).applyMatrix4(K.matrixWorld) } return this.intersectsSphere(_sphere$3) } intersectsSprite(K) { return _sphere$3.center.set(0, 0, 0), _sphere$3.radius = .7071067811865476, _sphere$3.applyMatrix4(K.matrixWorld), this.intersectsSphere(_sphere$3) } intersectsSphere(K) { const pe = this.planes, me = K.center, ge = -K.radius; for (let xe = 0; xe < 6; xe++)if (pe[xe].distanceToPoint(me) < ge) return !1; return !0 } intersectsBox(K) { const pe = this.planes; for (let me = 0; me < 6; me++) { const ge = pe[me]; if (_vector$6.x = ge.normal.x > 0 ? K.max.x : K.min.x, _vector$6.y = ge.normal.y > 0 ? K.max.y : K.min.y, _vector$6.z = ge.normal.z > 0 ? K.max.z : K.min.z, ge.distanceToPoint(_vector$6) < 0) return !1 } return !0 } containsPoint(K) { const pe = this.planes; for (let me = 0; me < 6; me++)if (pe[me].distanceToPoint(K) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function ascIdSort(fe, K) { return fe - K } function sortOpaque(fe, K) { return fe.z - K.z } function sortTransparent(fe, K) { return K.z - fe.z } class MultiDrawRenderList { constructor() { this.index = 0, this.pool = [], this.list = [] } push(K, pe, me, ge) { const xe = this.pool, ye = this.list; this.index >= xe.length && xe.push({ start: -1, count: -1, z: -1, index: -1 }); const ve = xe[this.index]; ye.push(ve), this.index++, ve.start = K, ve.count = pe, ve.z = me, ve.index = ge } reset() { this.list.length = 0, this.index = 0 } } const _matrix$1 = new Matrix4, _whiteColor = new Color$1(1, 1, 1), _frustum = new Frustum, _box$1$1 = new Box3, _sphere$2 = new Sphere, _vector$5 = new Vector3, _forward = new Vector3, _temp = new Vector3, _renderList = new MultiDrawRenderList, _mesh$2 = new Mesh, _batchIntersects$1 = []; function copyAttributeData(fe, K, pe = 0) { const me = K.itemSize; if (fe.isInterleavedBufferAttribute || fe.array.constructor !== K.array.constructor) { const ge = fe.count; for (let xe = 0; xe < ge; xe++)for (let ye = 0; ye < me; ye++)K.setComponent(xe + pe, ye, fe.getComponent(xe, ye)) } else K.array.set(fe.array, pe * me); K.needsUpdate = !0 } function copyArrayContents(fe, K) { if (fe.constructor !== K.constructor) { const pe = Math.min(fe.length, K.length); for (let me = 0; me < pe; me++)K[me] = fe[me] } else { const pe = Math.min(fe.length, K.length); K.set(new fe.constructor(fe.buffer, 0, pe)) } } let BatchedMesh$1 = class extends Mesh { constructor(K, pe, me = pe * 2, ge) { super(new BufferGeometry, ge), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = K, this._maxVertexCount = pe, this._maxIndexCount = me, this._multiDrawCounts = new Int32Array(K), this._multiDrawStarts = new Int32Array(K), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture() } get maxInstanceCount() { return this._maxInstanceCount } get instanceCount() { return this._instanceInfo.length - this._availableInstanceIds.length } get unusedVertexCount() { return this._maxVertexCount - this._nextVertexStart } get unusedIndexCount() { return this._maxIndexCount - this._nextIndexStart } _initMatricesTexture() { let K = Math.sqrt(this._maxInstanceCount * 4); K = Math.ceil(K / 4) * 4, K = Math.max(K, 4); const pe = new Float32Array(K * K * 4), me = new DataTexture(pe, K, K, RGBAFormat, FloatType); this._matricesTexture = me } _initIndirectTexture() { let K = Math.sqrt(this._maxInstanceCount); K = Math.ceil(K); const pe = new Uint32Array(K * K), me = new DataTexture(pe, K, K, RedIntegerFormat, UnsignedIntType); this._indirectTexture = me } _initColorsTexture() { let K = Math.sqrt(this._maxInstanceCount); K = Math.ceil(K); const pe = new Float32Array(K * K * 4).fill(1), me = new DataTexture(pe, K, K, RGBAFormat, FloatType); me.colorSpace = ColorManagement.workingColorSpace, this._colorsTexture = me } _initializeGeometry(K) { const pe = this.geometry, me = this._maxVertexCount, ge = this._maxIndexCount; if (this._geometryInitialized === !1) { for (const xe in K.attributes) { const ye = K.getAttribute(xe), { array: ve, itemSize: _e, normalized: Ee } = ye, be = new ve.constructor(me * _e), Ae = new BufferAttribute(be, _e, Ee); pe.setAttribute(xe, Ae) } if (K.getIndex() !== null) { const xe = me > 65535 ? new Uint32Array(ge) : new Uint16Array(ge); pe.setIndex(new BufferAttribute(xe, 1)) } this._geometryInitialized = !0 } } _validateGeometry(K) { const pe = this.geometry; if (!!K.getIndex() != !!pe.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".'); for (const me in pe.attributes) { if (!K.hasAttribute(me)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${me}". All geometries must have consistent attributes.`); const ge = K.getAttribute(me), xe = pe.getAttribute(me); if (ge.itemSize !== xe.itemSize || ge.normalized !== xe.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.") } } validateInstanceId(K) { const pe = this._instanceInfo; if (K < 0 || K >= pe.length || pe[K].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${K}. Instance is either out of range or has been deleted.`) } validateGeometryId(K) { const pe = this._geometryInfo; if (K < 0 || K >= pe.length || pe[K].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${K}. Geometry is either out of range or has been deleted.`) } setCustomSort(K) { return this.customSort = K, this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Box3); const K = this.boundingBox, pe = this._instanceInfo; K.makeEmpty(); for (let me = 0, ge = pe.length; me < ge; me++) { if (pe[me].active === !1) continue; const xe = pe[me].geometryIndex; this.getMatrixAt(me, _matrix$1), this.getBoundingBoxAt(xe, _box$1$1).applyMatrix4(_matrix$1), K.union(_box$1$1) } } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Sphere); const K = this.boundingSphere, pe = this._instanceInfo; K.makeEmpty(); for (let me = 0, ge = pe.length; me < ge; me++) { if (pe[me].active === !1) continue; const xe = pe[me].geometryIndex; this.getMatrixAt(me, _matrix$1), this.getBoundingSphereAt(xe, _sphere$2).applyMatrix4(_matrix$1), K.union(_sphere$2) } } addInstance(K) { if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached."); const me = { visible: !0, active: !0, geometryIndex: K }; let ge = null; this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(ascIdSort), ge = this._availableInstanceIds.shift(), this._instanceInfo[ge] = me) : (ge = this._instanceInfo.length, this._instanceInfo.push(me)); const xe = this._matricesTexture; _matrix$1.identity().toArray(xe.image.data, ge * 16), xe.needsUpdate = !0; const ye = this._colorsTexture; return ye && (_whiteColor.toArray(ye.image.data, ge * 4), ye.needsUpdate = !0), this._visibilityChanged = !0, ge } addGeometry(K, pe = -1, me = -1) { this._initializeGeometry(K), this._validateGeometry(K); const ge = { vertexStart: -1, vertexCount: -1, reservedVertexCount: -1, indexStart: -1, indexCount: -1, reservedIndexCount: -1, start: -1, count: -1, boundingBox: null, boundingSphere: null, active: !0 }, xe = this._geometryInfo; ge.vertexStart = this._nextVertexStart, ge.reservedVertexCount = pe === -1 ? K.getAttribute("position").count : pe; const ye = K.getIndex(); if (ye !== null && (ge.indexStart = this._nextIndexStart, ge.reservedIndexCount = me === -1 ? ye.count : me), ge.indexStart !== -1 && ge.indexStart + ge.reservedIndexCount > this._maxIndexCount || ge.vertexStart + ge.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."); let _e; return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(ascIdSort), _e = this._availableGeometryIds.shift(), xe[_e] = ge) : (_e = this._geometryCount, this._geometryCount++, xe.push(ge)), this.setGeometryAt(_e, K), this._nextIndexStart = ge.indexStart + ge.reservedIndexCount, this._nextVertexStart = ge.vertexStart + ge.reservedVertexCount, _e } setGeometryAt(K, pe) { if (K >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached."); this._validateGeometry(pe); const me = this.geometry, ge = me.getIndex() !== null, xe = me.getIndex(), ye = pe.getIndex(), ve = this._geometryInfo[K]; if (ge && ye.count > ve.reservedIndexCount || pe.attributes.position.count > ve.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry."); const _e = ve.vertexStart, Ee = ve.reservedVertexCount; ve.vertexCount = pe.getAttribute("position").count; for (const be in me.attributes) { const Ae = pe.getAttribute(be), Se = me.getAttribute(be); copyAttributeData(Ae, Se, _e); const Ce = Ae.itemSize; for (let we = Ae.count, Be = Ee; we < Be; we++) { const De = _e + we; for (let Re = 0; Re < Ce; Re++)Se.setComponent(De, Re, 0) } Se.needsUpdate = !0, Se.addUpdateRange(_e * Ce, Ee * Ce) } if (ge) { const be = ve.indexStart, Ae = ve.reservedIndexCount; ve.indexCount = pe.getIndex().count; for (let Se = 0; Se < ye.count; Se++)xe.setX(be + Se, _e + ye.getX(Se)); for (let Se = ye.count, Ce = Ae; Se < Ce; Se++)xe.setX(be + Se, _e); xe.needsUpdate = !0, xe.addUpdateRange(be, ve.reservedIndexCount) } return ve.start = ge ? ve.indexStart : ve.vertexStart, ve.count = ge ? ve.indexCount : ve.vertexCount, ve.boundingBox = null, pe.boundingBox !== null && (ve.boundingBox = pe.boundingBox.clone()), ve.boundingSphere = null, pe.boundingSphere !== null && (ve.boundingSphere = pe.boundingSphere.clone()), this._visibilityChanged = !0, K } deleteGeometry(K) { const pe = this._geometryInfo; if (K >= pe.length || pe[K].active === !1) return this; const me = this._instanceInfo; for (let ge = 0, xe = me.length; ge < xe; ge++)me[ge].active && me[ge].geometryIndex === K && this.deleteInstance(ge); return pe[K].active = !1, this._availableGeometryIds.push(K), this._visibilityChanged = !0, this } deleteInstance(K) { return this.validateInstanceId(K), this._instanceInfo[K].active = !1, this._availableInstanceIds.push(K), this._visibilityChanged = !0, this } optimize() { let K = 0, pe = 0; const me = this._geometryInfo, ge = me.map((ye, ve) => ve).sort((ye, ve) => me[ye].vertexStart - me[ve].vertexStart), xe = this.geometry; for (let ye = 0, ve = me.length; ye < ve; ye++) { const _e = ge[ye], Ee = me[_e]; if (Ee.active !== !1) { if (xe.index !== null) { if (Ee.indexStart !== pe) { const { indexStart: be, vertexStart: Ae, reservedIndexCount: Se } = Ee, Ce = xe.index, we = Ce.array, Be = K - Ae; for (let De = be; De < be + Se; De++)we[De] = we[De] + Be; Ce.array.copyWithin(pe, be, be + Se), Ce.addUpdateRange(pe, Se), Ee.indexStart = pe } pe += Ee.reservedIndexCount } if (Ee.vertexStart !== K) { const { vertexStart: be, reservedVertexCount: Ae } = Ee, Se = xe.attributes; for (const Ce in Se) { const we = Se[Ce], { array: Be, itemSize: De } = we; Be.copyWithin(K * De, be * De, (be + Ae) * De), we.addUpdateRange(K * De, Ae * De) } Ee.vertexStart = K } K += Ee.reservedVertexCount, Ee.start = xe.index ? Ee.indexStart : Ee.vertexStart, this._nextIndexStart = xe.index ? Ee.indexStart + Ee.reservedIndexCount : 0, this._nextVertexStart = Ee.vertexStart + Ee.reservedVertexCount } } return this } getBoundingBoxAt(K, pe) { if (K >= this._geometryCount) return null; const me = this.geometry, ge = this._geometryInfo[K]; if (ge.boundingBox === null) { const xe = new Box3, ye = me.index, ve = me.attributes.position; for (let _e = ge.start, Ee = ge.start + ge.count; _e < Ee; _e++) { let be = _e; ye && (be = ye.getX(be)), xe.expandByPoint(_vector$5.fromBufferAttribute(ve, be)) } ge.boundingBox = xe } return pe.copy(ge.boundingBox), pe } getBoundingSphereAt(K, pe) { if (K >= this._geometryCount) return null; const me = this.geometry, ge = this._geometryInfo[K]; if (ge.boundingSphere === null) { const xe = new Sphere; this.getBoundingBoxAt(K, _box$1$1), _box$1$1.getCenter(xe.center); const ye = me.index, ve = me.attributes.position; let _e = 0; for (let Ee = ge.start, be = ge.start + ge.count; Ee < be; Ee++) { let Ae = Ee; ye && (Ae = ye.getX(Ae)), _vector$5.fromBufferAttribute(ve, Ae), _e = Math.max(_e, xe.center.distanceToSquared(_vector$5)) } xe.radius = Math.sqrt(_e), ge.boundingSphere = xe } return pe.copy(ge.boundingSphere), pe } setMatrixAt(K, pe) { this.validateInstanceId(K); const me = this._matricesTexture, ge = this._matricesTexture.image.data; return pe.toArray(ge, K * 16), me.needsUpdate = !0, this } getMatrixAt(K, pe) { return this.validateInstanceId(K), pe.fromArray(this._matricesTexture.image.data, K * 16) } setColorAt(K, pe) { return this.validateInstanceId(K), this._colorsTexture === null && this._initColorsTexture(), pe.toArray(this._colorsTexture.image.data, K * 4), this._colorsTexture.needsUpdate = !0, this } getColorAt(K, pe) { return this.validateInstanceId(K), pe.fromArray(this._colorsTexture.image.data, K * 4) } setVisibleAt(K, pe) { return this.validateInstanceId(K), this._instanceInfo[K].visible === pe ? this : (this._instanceInfo[K].visible = pe, this._visibilityChanged = !0, this) } getVisibleAt(K) { return this.validateInstanceId(K), this._instanceInfo[K].visible } setGeometryIdAt(K, pe) { return this.validateInstanceId(K), this.validateGeometryId(pe), this._instanceInfo[K].geometryIndex = pe, this } getGeometryIdAt(K) { return this.validateInstanceId(K), this._instanceInfo[K].geometryIndex } getGeometryRangeAt(K, pe = {}) { this.validateGeometryId(K); const me = this._geometryInfo[K]; return pe.vertexStart = me.vertexStart, pe.vertexCount = me.vertexCount, pe.reservedVertexCount = me.reservedVertexCount, pe.indexStart = me.indexStart, pe.indexCount = me.indexCount, pe.reservedIndexCount = me.reservedIndexCount, pe.start = me.start, pe.count = me.count, pe } setInstanceCount(K) { const pe = this._availableInstanceIds, me = this._instanceInfo; for (pe.sort(ascIdSort); pe[pe.length - 1] === me.length;)me.pop(), pe.pop(); if (K < me.length) throw new Error(`BatchedMesh: Instance ids outside the range ${K} are being used. Cannot shrink instance count.`); const ge = new Int32Array(K), xe = new Int32Array(K); copyArrayContents(this._multiDrawCounts, ge), copyArrayContents(this._multiDrawStarts, xe), this._multiDrawCounts = ge, this._multiDrawStarts = xe, this._maxInstanceCount = K; const ye = this._indirectTexture, ve = this._matricesTexture, _e = this._colorsTexture; ye.dispose(), this._initIndirectTexture(), copyArrayContents(ye.image.data, this._indirectTexture.image.data), ve.dispose(), this._initMatricesTexture(), copyArrayContents(ve.image.data, this._matricesTexture.image.data), _e && (_e.dispose(), this._initColorsTexture(), copyArrayContents(_e.image.data, this._colorsTexture.image.data)) } setGeometrySize(K, pe) { const me = [...this._geometryInfo].filter(ve => ve.active); if (Math.max(...me.map(ve => ve.vertexStart + ve.reservedVertexCount)) > K) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${pe}. Cannot shrink further.`); if (this.geometry.index && Math.max(...me.map(_e => _e.indexStart + _e.reservedIndexCount)) > pe) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${pe}. Cannot shrink further.`); const xe = this.geometry; xe.dispose(), this._maxVertexCount = K, this._maxIndexCount = pe, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new BufferGeometry, this._initializeGeometry(xe)); const ye = this.geometry; xe.index && copyArrayContents(xe.index.array, ye.index.array); for (const ve in xe.attributes) copyArrayContents(xe.attributes[ve].array, ye.attributes[ve].array) } raycast(K, pe) { const me = this._instanceInfo, ge = this._geometryInfo, xe = this.matrixWorld, ye = this.geometry; _mesh$2.material = this.material, _mesh$2.geometry.index = ye.index, _mesh$2.geometry.attributes = ye.attributes, _mesh$2.geometry.boundingBox === null && (_mesh$2.geometry.boundingBox = new Box3), _mesh$2.geometry.boundingSphere === null && (_mesh$2.geometry.boundingSphere = new Sphere); for (let ve = 0, _e = me.length; ve < _e; ve++) { if (!me[ve].visible || !me[ve].active) continue; const Ee = me[ve].geometryIndex, be = ge[Ee]; _mesh$2.geometry.setDrawRange(be.start, be.count), this.getMatrixAt(ve, _mesh$2.matrixWorld).premultiply(xe), this.getBoundingBoxAt(Ee, _mesh$2.geometry.boundingBox), this.getBoundingSphereAt(Ee, _mesh$2.geometry.boundingSphere), _mesh$2.raycast(K, _batchIntersects$1); for (let Ae = 0, Se = _batchIntersects$1.length; Ae < Se; Ae++) { const Ce = _batchIntersects$1[Ae]; Ce.object = this, Ce.batchId = ve, pe.push(Ce) } _batchIntersects$1.length = 0 } _mesh$2.material = null, _mesh$2.geometry.index = null, _mesh$2.geometry.attributes = {}, _mesh$2.geometry.setDrawRange(0, 1 / 0) } copy(K) { return super.copy(K), this.geometry = K.geometry.clone(), this.perObjectFrustumCulled = K.perObjectFrustumCulled, this.sortObjects = K.sortObjects, this.boundingBox = K.boundingBox !== null ? K.boundingBox.clone() : null, this.boundingSphere = K.boundingSphere !== null ? K.boundingSphere.clone() : null, this._geometryInfo = K._geometryInfo.map(pe => ({ ...pe, boundingBox: pe.boundingBox !== null ? pe.boundingBox.clone() : null, boundingSphere: pe.boundingSphere !== null ? pe.boundingSphere.clone() : null })), this._instanceInfo = K._instanceInfo.map(pe => ({ ...pe })), this._maxInstanceCount = K._maxInstanceCount, this._maxVertexCount = K._maxVertexCount, this._maxIndexCount = K._maxIndexCount, this._geometryInitialized = K._geometryInitialized, this._geometryCount = K._geometryCount, this._multiDrawCounts = K._multiDrawCounts.slice(), this._multiDrawStarts = K._multiDrawStarts.slice(), this._matricesTexture = K._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = K._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this } dispose() { this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null) } onBeforeRender(K, pe, me, ge, xe) { if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return; const ye = ge.getIndex(), ve = ye === null ? 1 : ye.array.BYTES_PER_ELEMENT, _e = this._instanceInfo, Ee = this._multiDrawStarts, be = this._multiDrawCounts, Ae = this._geometryInfo, Se = this.perObjectFrustumCulled, Ce = this._indirectTexture, we = Ce.image.data; Se && (_matrix$1.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse).multiply(this.matrixWorld), _frustum.setFromProjectionMatrix(_matrix$1, K.coordinateSystem)); let Be = 0; if (this.sortObjects) { _matrix$1.copy(this.matrixWorld).invert(), _vector$5.setFromMatrixPosition(me.matrixWorld).applyMatrix4(_matrix$1), _forward.set(0, 0, -1).transformDirection(me.matrixWorld).transformDirection(_matrix$1); for (let Ie = 0, Pe = _e.length; Ie < Pe; Ie++)if (_e[Ie].visible && _e[Ie].active) { const Ne = _e[Ie].geometryIndex; this.getMatrixAt(Ie, _matrix$1), this.getBoundingSphereAt(Ne, _sphere$2).applyMatrix4(_matrix$1); let ke = !1; if (Se && (ke = !_frustum.intersectsSphere(_sphere$2)), !ke) { const Oe = Ae[Ne], Ue = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward); _renderList.push(Oe.start, Oe.count, Ue, Ie) } } const De = _renderList.list, Re = this.customSort; Re === null ? De.sort(xe.transparent ? sortTransparent : sortOpaque) : Re.call(this, De, me); for (let Ie = 0, Pe = De.length; Ie < Pe; Ie++) { const Ne = De[Ie]; Ee[Be] = Ne.start * ve, be[Be] = Ne.count, we[Be] = Ne.index, Be++ } _renderList.reset() } else for (let De = 0, Re = _e.length; De < Re; De++)if (_e[De].visible && _e[De].active) { const Ie = _e[De].geometryIndex; let Pe = !1; if (Se && (this.getMatrixAt(De, _matrix$1), this.getBoundingSphereAt(Ie, _sphere$2).applyMatrix4(_matrix$1), Pe = !_frustum.intersectsSphere(_sphere$2)), !Pe) { const Ne = Ae[Ie]; Ee[Be] = Ne.start * ve, be[Be] = Ne.count, we[Be] = De, Be++ } } Ce.needsUpdate = !0, this._multiDrawCount = Be, this._visibilityChanged = !1 } onBeforeShadow(K, pe, me, ge, xe, ye) { this.onBeforeRender(K, null, ge, xe, ye) } }; class LineBasicMaterial extends Material { constructor(K) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color$1(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.linewidth = K.linewidth, this.linecap = K.linecap, this.linejoin = K.linejoin, this.fog = K.fog, this } } const _vStart = new Vector3, _vEnd = new Vector3, _inverseMatrix$1 = new Matrix4, _ray$1 = new Ray, _sphere$1$1 = new Sphere, _intersectPointOnRay = new Vector3, _intersectPointOnSegment = new Vector3; let Line$2 = class extends Object3D { constructor(K = new BufferGeometry, pe = new LineBasicMaterial) { super(), this.isLine = !0, this.type = "Line", this.geometry = K, this.material = pe, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(K, pe) { return super.copy(K, pe), this.material = Array.isArray(K.material) ? K.material.slice() : K.material, this.geometry = K.geometry, this } computeLineDistances() { const K = this.geometry; if (K.index === null) { const pe = K.attributes.position, me = [0]; for (let ge = 1, xe = pe.count; ge < xe; ge++)_vStart.fromBufferAttribute(pe, ge - 1), _vEnd.fromBufferAttribute(pe, ge), me[ge] = me[ge - 1], me[ge] += _vStart.distanceTo(_vEnd); K.setAttribute("lineDistance", new Float32BufferAttribute(me, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(K, pe) { const me = this.geometry, ge = this.matrixWorld, xe = K.params.Line.threshold, ye = me.drawRange; if (me.boundingSphere === null && me.computeBoundingSphere(), _sphere$1$1.copy(me.boundingSphere), _sphere$1$1.applyMatrix4(ge), _sphere$1$1.radius += xe, K.ray.intersectsSphere(_sphere$1$1) === !1) return; _inverseMatrix$1.copy(ge).invert(), _ray$1.copy(K.ray).applyMatrix4(_inverseMatrix$1); const ve = xe / ((this.scale.x + this.scale.y + this.scale.z) / 3), _e = ve * ve, Ee = this.isLineSegments ? 2 : 1, be = me.index, Se = me.attributes.position; if (be !== null) { const Ce = Math.max(0, ye.start), we = Math.min(be.count, ye.start + ye.count); for (let Be = Ce, De = we - 1; Be < De; Be += Ee) { const Re = be.getX(Be), Ie = be.getX(Be + 1), Pe = checkIntersection$2(this, K, _ray$1, _e, Re, Ie, Be); Pe && pe.push(Pe) } if (this.isLineLoop) { const Be = be.getX(we - 1), De = be.getX(Ce), Re = checkIntersection$2(this, K, _ray$1, _e, Be, De, we - 1); Re && pe.push(Re) } } else { const Ce = Math.max(0, ye.start), we = Math.min(Se.count, ye.start + ye.count); for (let Be = Ce, De = we - 1; Be < De; Be += Ee) { const Re = checkIntersection$2(this, K, _ray$1, _e, Be, Be + 1, Be); Re && pe.push(Re) } if (this.isLineLoop) { const Be = checkIntersection$2(this, K, _ray$1, _e, we - 1, Ce, we - 1); Be && pe.push(Be) } } } updateMorphTargets() { const pe = this.geometry.morphAttributes, me = Object.keys(pe); if (me.length > 0) { const ge = pe[me[0]]; if (ge !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let xe = 0, ye = ge.length; xe < ye; xe++) { const ve = ge[xe].name || String(xe); this.morphTargetInfluences.push(0), this.morphTargetDictionary[ve] = xe } } } } }; function checkIntersection$2(fe, K, pe, me, ge, xe, ye) { const ve = fe.geometry.attributes.position; if (_vStart.fromBufferAttribute(ve, ge), _vEnd.fromBufferAttribute(ve, xe), pe.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > me) return; _intersectPointOnRay.applyMatrix4(fe.matrixWorld); const Ee = K.ray.origin.distanceTo(_intersectPointOnRay); if (!(Ee < K.near || Ee > K.far)) return { distance: Ee, point: _intersectPointOnSegment.clone().applyMatrix4(fe.matrixWorld), index: ye, face: null, faceIndex: null, barycoord: null, object: fe } } const _start$1 = new Vector3, _end$1 = new Vector3; class LineSegments extends Line$2 { constructor(K, pe) { super(K, pe), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const K = this.geometry; if (K.index === null) { const pe = K.attributes.position, me = []; for (let ge = 0, xe = pe.count; ge < xe; ge += 2)_start$1.fromBufferAttribute(pe, ge), _end$1.fromBufferAttribute(pe, ge + 1), me[ge] = ge === 0 ? 0 : me[ge - 1], me[ge + 1] = me[ge] + _start$1.distanceTo(_end$1); K.setAttribute("lineDistance", new Float32BufferAttribute(me, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class LineLoop extends Line$2 { constructor(K, pe) { super(K, pe), this.isLineLoop = !0, this.type = "LineLoop" } } class PointsMaterial extends Material { constructor(K) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color$1(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.alphaMap = K.alphaMap, this.size = K.size, this.sizeAttenuation = K.sizeAttenuation, this.fog = K.fog, this } } const _inverseMatrix = new Matrix4, _ray$4 = new Ray, _sphere$7 = new Sphere, _position$2 = new Vector3; class Points extends Object3D { constructor(K = new BufferGeometry, pe = new PointsMaterial) { super(), this.isPoints = !0, this.type = "Points", this.geometry = K, this.material = pe, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(K, pe) { return super.copy(K, pe), this.material = Array.isArray(K.material) ? K.material.slice() : K.material, this.geometry = K.geometry, this } raycast(K, pe) { const me = this.geometry, ge = this.matrixWorld, xe = K.params.Points.threshold, ye = me.drawRange; if (me.boundingSphere === null && me.computeBoundingSphere(), _sphere$7.copy(me.boundingSphere), _sphere$7.applyMatrix4(ge), _sphere$7.radius += xe, K.ray.intersectsSphere(_sphere$7) === !1) return; _inverseMatrix.copy(ge).invert(), _ray$4.copy(K.ray).applyMatrix4(_inverseMatrix); const ve = xe / ((this.scale.x + this.scale.y + this.scale.z) / 3), _e = ve * ve, Ee = me.index, Ae = me.attributes.position; if (Ee !== null) { const Se = Math.max(0, ye.start), Ce = Math.min(Ee.count, ye.start + ye.count); for (let we = Se, Be = Ce; we < Be; we++) { const De = Ee.getX(we); _position$2.fromBufferAttribute(Ae, De), testPoint(_position$2, De, _e, ge, K, pe, this) } } else { const Se = Math.max(0, ye.start), Ce = Math.min(Ae.count, ye.start + ye.count); for (let we = Se, Be = Ce; we < Be; we++)_position$2.fromBufferAttribute(Ae, we), testPoint(_position$2, we, _e, ge, K, pe, this) } } updateMorphTargets() { const pe = this.geometry.morphAttributes, me = Object.keys(pe); if (me.length > 0) { const ge = pe[me[0]]; if (ge !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let xe = 0, ye = ge.length; xe < ye; xe++) { const ve = ge[xe].name || String(xe); this.morphTargetInfluences.push(0), this.morphTargetDictionary[ve] = xe } } } } } function testPoint(fe, K, pe, me, ge, xe, ye) { const ve = _ray$4.distanceSqToPoint(fe); if (ve < pe) { const _e = new Vector3; _ray$4.closestPointToPoint(fe, _e), _e.applyMatrix4(me); const Ee = ge.ray.origin.distanceTo(_e); if (Ee < ge.near || Ee > ge.far) return; xe.push({ distance: Ee, distanceToRay: Math.sqrt(ve), point: _e, index: K, face: null, faceIndex: null, barycoord: null, object: ye }) } } class VideoTexture extends Texture { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee) { super(K, pe, me, ge, xe, ye, ve, _e, Ee), this.isVideoTexture = !0, this.minFilter = ye !== void 0 ? ye : LinearFilter, this.magFilter = xe !== void 0 ? xe : LinearFilter, this.generateMipmaps = !1; const be = this; function Ae() { be.needsUpdate = !0, K.requestVideoFrameCallback(Ae) } "requestVideoFrameCallback" in K && K.requestVideoFrameCallback(Ae) } clone() { return new this.constructor(this.image).copy(this) } update() { const K = this.image; "requestVideoFrameCallback" in K === !1 && K.readyState >= K.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class VideoFrameTexture extends VideoTexture { constructor(K, pe, me, ge, xe, ye, ve, _e) { super({}, K, pe, me, ge, xe, ye, ve, _e), this.isVideoFrameTexture = !0 } update() { } clone() { return new this.constructor().copy(this) } setFrame(K) { this.image = K, this.needsUpdate = !0 } } class FramebufferTexture extends Texture { constructor(K, pe) { super({ width: K, height: pe }), this.isFramebufferTexture = !0, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.generateMipmaps = !1, this.needsUpdate = !0 } } class CompressedTexture extends Texture { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se) { super(null, ye, ve, _e, Ee, be, ge, xe, Ae, Se), this.isCompressedTexture = !0, this.image = { width: pe, height: me }, this.mipmaps = K, this.flipY = !1, this.generateMipmaps = !1 } } class CompressedArrayTexture extends CompressedTexture { constructor(K, pe, me, ge, xe, ye) { super(K, pe, me, xe, ye), this.isCompressedArrayTexture = !0, this.image.depth = ge, this.wrapR = ClampToEdgeWrapping, this.layerUpdates = new Set } addLayerUpdate(K) { this.layerUpdates.add(K) } clearLayerUpdates() { this.layerUpdates.clear() } } class CompressedCubeTexture extends CompressedTexture { constructor(K, pe, me) { super(void 0, K[0].width, K[0].height, pe, me, CubeReflectionMapping), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = K } } class CanvasTexture extends Texture { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee) { super(K, pe, me, ge, xe, ye, ve, _e, Ee), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class DepthTexture extends Texture { constructor(K, pe, me, ge, xe, ye, ve, _e, Ee, be = DepthFormat) { if (be !== DepthFormat && be !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); me === void 0 && be === DepthFormat && (me = UnsignedIntType), me === void 0 && be === DepthStencilFormat && (me = UnsignedInt248Type), super(null, ge, xe, ye, ve, _e, be, me, Ee), this.isDepthTexture = !0, this.image = { width: K, height: pe }, this.magFilter = ve !== void 0 ? ve : NearestFilter, this.minFilter = _e !== void 0 ? _e : NearestFilter, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(K) { return super.copy(K), this.source = new Source(Object.assign({}, K.image)), this.compareFunction = K.compareFunction, this } toJSON(K) { const pe = super.toJSON(K); return this.compareFunction !== null && (pe.compareFunction = this.compareFunction), pe } } class Curve { constructor() { this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null } getPoint() { console.warn("THREE.Curve: .getPoint() not implemented.") } getPointAt(K, pe) { const me = this.getUtoTmapping(K); return this.getPoint(me, pe) } getPoints(K = 5) { const pe = []; for (let me = 0; me <= K; me++)pe.push(this.getPoint(me / K)); return pe } getSpacedPoints(K = 5) { const pe = []; for (let me = 0; me <= K; me++)pe.push(this.getPointAt(me / K)); return pe } getLength() { const K = this.getLengths(); return K[K.length - 1] } getLengths(K = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === K + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const pe = []; let me, ge = this.getPoint(0), xe = 0; pe.push(0); for (let ye = 1; ye <= K; ye++)me = this.getPoint(ye / K), xe += me.distanceTo(ge), pe.push(xe), ge = me; return this.cacheArcLengths = pe, pe } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(K, pe = null) { const me = this.getLengths(); let ge = 0; const xe = me.length; let ye; pe ? ye = pe : ye = K * me[xe - 1]; let ve = 0, _e = xe - 1, Ee; for (; ve <= _e;)if (ge = Math.floor(ve + (_e - ve) / 2), Ee = me[ge] - ye, Ee < 0) ve = ge + 1; else if (Ee > 0) _e = ge - 1; else { _e = ge; break } if (ge = _e, me[ge] === ye) return ge / (xe - 1); const be = me[ge], Se = me[ge + 1] - be, Ce = (ye - be) / Se; return (ge + Ce) / (xe - 1) } getTangent(K, pe) { let ge = K - 1e-4, xe = K + 1e-4; ge < 0 && (ge = 0), xe > 1 && (xe = 1); const ye = this.getPoint(ge), ve = this.getPoint(xe), _e = pe || (ye.isVector2 ? new Vector2 : new Vector3); return _e.copy(ve).sub(ye).normalize(), _e } getTangentAt(K, pe) { const me = this.getUtoTmapping(K); return this.getTangent(me, pe) } computeFrenetFrames(K, pe = !1) { const me = new Vector3, ge = [], xe = [], ye = [], ve = new Vector3, _e = new Matrix4; for (let Ce = 0; Ce <= K; Ce++) { const we = Ce / K; ge[Ce] = this.getTangentAt(we, new Vector3) } xe[0] = new Vector3, ye[0] = new Vector3; let Ee = Number.MAX_VALUE; const be = Math.abs(ge[0].x), Ae = Math.abs(ge[0].y), Se = Math.abs(ge[0].z); be <= Ee && (Ee = be, me.set(1, 0, 0)), Ae <= Ee && (Ee = Ae, me.set(0, 1, 0)), Se <= Ee && me.set(0, 0, 1), ve.crossVectors(ge[0], me).normalize(), xe[0].crossVectors(ge[0], ve), ye[0].crossVectors(ge[0], xe[0]); for (let Ce = 1; Ce <= K; Ce++) { if (xe[Ce] = xe[Ce - 1].clone(), ye[Ce] = ye[Ce - 1].clone(), ve.crossVectors(ge[Ce - 1], ge[Ce]), ve.length() > Number.EPSILON) { ve.normalize(); const we = Math.acos(clamp$3(ge[Ce - 1].dot(ge[Ce]), -1, 1)); xe[Ce].applyMatrix4(_e.makeRotationAxis(ve, we)) } ye[Ce].crossVectors(ge[Ce], xe[Ce]) } if (pe === !0) { let Ce = Math.acos(clamp$3(xe[0].dot(xe[K]), -1, 1)); Ce /= K, ge[0].dot(ve.crossVectors(xe[0], xe[K])) > 0 && (Ce = -Ce); for (let we = 1; we <= K; we++)xe[we].applyMatrix4(_e.makeRotationAxis(ge[we], Ce * we)), ye[we].crossVectors(ge[we], xe[we]) } return { tangents: ge, normals: xe, binormals: ye } } clone() { return new this.constructor().copy(this) } copy(K) { return this.arcLengthDivisions = K.arcLengthDivisions, this } toJSON() { const K = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return K.arcLengthDivisions = this.arcLengthDivisions, K.type = this.type, K } fromJSON(K) { return this.arcLengthDivisions = K.arcLengthDivisions, this } } class EllipseCurve extends Curve { constructor(K = 0, pe = 0, me = 1, ge = 1, xe = 0, ye = Math.PI * 2, ve = !1, _e = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = K, this.aY = pe, this.xRadius = me, this.yRadius = ge, this.aStartAngle = xe, this.aEndAngle = ye, this.aClockwise = ve, this.aRotation = _e } getPoint(K, pe = new Vector2) { const me = pe, ge = Math.PI * 2; let xe = this.aEndAngle - this.aStartAngle; const ye = Math.abs(xe) < Number.EPSILON; for (; xe < 0;)xe += ge; for (; xe > ge;)xe -= ge; xe < Number.EPSILON && (ye ? xe = 0 : xe = ge), this.aClockwise === !0 && !ye && (xe === ge ? xe = -ge : xe = xe - ge); const ve = this.aStartAngle + K * xe; let _e = this.aX + this.xRadius * Math.cos(ve), Ee = this.aY + this.yRadius * Math.sin(ve); if (this.aRotation !== 0) { const be = Math.cos(this.aRotation), Ae = Math.sin(this.aRotation), Se = _e - this.aX, Ce = Ee - this.aY; _e = Se * be - Ce * Ae + this.aX, Ee = Se * Ae + Ce * be + this.aY } return me.set(_e, Ee) } copy(K) { return super.copy(K), this.aX = K.aX, this.aY = K.aY, this.xRadius = K.xRadius, this.yRadius = K.yRadius, this.aStartAngle = K.aStartAngle, this.aEndAngle = K.aEndAngle, this.aClockwise = K.aClockwise, this.aRotation = K.aRotation, this } toJSON() { const K = super.toJSON(); return K.aX = this.aX, K.aY = this.aY, K.xRadius = this.xRadius, K.yRadius = this.yRadius, K.aStartAngle = this.aStartAngle, K.aEndAngle = this.aEndAngle, K.aClockwise = this.aClockwise, K.aRotation = this.aRotation, K } fromJSON(K) { return super.fromJSON(K), this.aX = K.aX, this.aY = K.aY, this.xRadius = K.xRadius, this.yRadius = K.yRadius, this.aStartAngle = K.aStartAngle, this.aEndAngle = K.aEndAngle, this.aClockwise = K.aClockwise, this.aRotation = K.aRotation, this } } class ArcCurve extends EllipseCurve { constructor(K, pe, me, ge, xe, ye) { super(K, pe, me, me, ge, xe, ye), this.isArcCurve = !0, this.type = "ArcCurve" } } function CubicPoly() { let fe = 0, K = 0, pe = 0, me = 0; function ge(xe, ye, ve, _e) { fe = xe, K = ve, pe = -3 * xe + 3 * ye - 2 * ve - _e, me = 2 * xe - 2 * ye + ve + _e } return { initCatmullRom: function (xe, ye, ve, _e, Ee) { ge(ye, ve, Ee * (ve - xe), Ee * (_e - ye)) }, initNonuniformCatmullRom: function (xe, ye, ve, _e, Ee, be, Ae) { let Se = (ye - xe) / Ee - (ve - xe) / (Ee + be) + (ve - ye) / be, Ce = (ve - ye) / be - (_e - ye) / (be + Ae) + (_e - ve) / Ae; Se *= be, Ce *= be, ge(ye, ve, Se, Ce) }, calc: function (xe) { const ye = xe * xe, ve = ye * xe; return fe + K * xe + pe * ye + me * ve } } } const tmp = new Vector3, px = new CubicPoly, py = new CubicPoly, pz = new CubicPoly; class CatmullRomCurve3 extends Curve { constructor(K = [], pe = !1, me = "centripetal", ge = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = K, this.closed = pe, this.curveType = me, this.tension = ge } getPoint(K, pe = new Vector3) { const me = pe, ge = this.points, xe = ge.length, ye = (xe - (this.closed ? 0 : 1)) * K; let ve = Math.floor(ye), _e = ye - ve; this.closed ? ve += ve > 0 ? 0 : (Math.floor(Math.abs(ve) / xe) + 1) * xe : _e === 0 && ve === xe - 1 && (ve = xe - 2, _e = 1); let Ee, be; this.closed || ve > 0 ? Ee = ge[(ve - 1) % xe] : (tmp.subVectors(ge[0], ge[1]).add(ge[0]), Ee = tmp); const Ae = ge[ve % xe], Se = ge[(ve + 1) % xe]; if (this.closed || ve + 2 < xe ? be = ge[(ve + 2) % xe] : (tmp.subVectors(ge[xe - 1], ge[xe - 2]).add(ge[xe - 1]), be = tmp), this.curveType === "centripetal" || this.curveType === "chordal") { const Ce = this.curveType === "chordal" ? .5 : .25; let we = Math.pow(Ee.distanceToSquared(Ae), Ce), Be = Math.pow(Ae.distanceToSquared(Se), Ce), De = Math.pow(Se.distanceToSquared(be), Ce); Be < 1e-4 && (Be = 1), we < 1e-4 && (we = Be), De < 1e-4 && (De = Be), px.initNonuniformCatmullRom(Ee.x, Ae.x, Se.x, be.x, we, Be, De), py.initNonuniformCatmullRom(Ee.y, Ae.y, Se.y, be.y, we, Be, De), pz.initNonuniformCatmullRom(Ee.z, Ae.z, Se.z, be.z, we, Be, De) } else this.curveType === "catmullrom" && (px.initCatmullRom(Ee.x, Ae.x, Se.x, be.x, this.tension), py.initCatmullRom(Ee.y, Ae.y, Se.y, be.y, this.tension), pz.initCatmullRom(Ee.z, Ae.z, Se.z, be.z, this.tension)); return me.set(px.calc(_e), py.calc(_e), pz.calc(_e)), me } copy(K) { super.copy(K), this.points = []; for (let pe = 0, me = K.points.length; pe < me; pe++) { const ge = K.points[pe]; this.points.push(ge.clone()) } return this.closed = K.closed, this.curveType = K.curveType, this.tension = K.tension, this } toJSON() { const K = super.toJSON(); K.points = []; for (let pe = 0, me = this.points.length; pe < me; pe++) { const ge = this.points[pe]; K.points.push(ge.toArray()) } return K.closed = this.closed, K.curveType = this.curveType, K.tension = this.tension, K } fromJSON(K) { super.fromJSON(K), this.points = []; for (let pe = 0, me = K.points.length; pe < me; pe++) { const ge = K.points[pe]; this.points.push(new Vector3().fromArray(ge)) } return this.closed = K.closed, this.curveType = K.curveType, this.tension = K.tension, this } } function CatmullRom(fe, K, pe, me, ge) { const xe = (me - K) * .5, ye = (ge - pe) * .5, ve = fe * fe, _e = fe * ve; return (2 * pe - 2 * me + xe + ye) * _e + (-3 * pe + 3 * me - 2 * xe - ye) * ve + xe * fe + pe } function QuadraticBezierP0(fe, K) { const pe = 1 - fe; return pe * pe * K } function QuadraticBezierP1(fe, K) { return 2 * (1 - fe) * fe * K } function QuadraticBezierP2(fe, K) { return fe * fe * K } function QuadraticBezier(fe, K, pe, me) { return QuadraticBezierP0(fe, K) + QuadraticBezierP1(fe, pe) + QuadraticBezierP2(fe, me) } function CubicBezierP0(fe, K) { const pe = 1 - fe; return pe * pe * pe * K } function CubicBezierP1(fe, K) { const pe = 1 - fe; return 3 * pe * pe * fe * K } function CubicBezierP2(fe, K) { return 3 * (1 - fe) * fe * fe * K } function CubicBezierP3(fe, K) { return fe * fe * fe * K } function CubicBezier(fe, K, pe, me, ge) { return CubicBezierP0(fe, K) + CubicBezierP1(fe, pe) + CubicBezierP2(fe, me) + CubicBezierP3(fe, ge) } class CubicBezierCurve extends Curve { constructor(K = new Vector2, pe = new Vector2, me = new Vector2, ge = new Vector2) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = K, this.v1 = pe, this.v2 = me, this.v3 = ge } getPoint(K, pe = new Vector2) { const me = pe, ge = this.v0, xe = this.v1, ye = this.v2, ve = this.v3; return me.set(CubicBezier(K, ge.x, xe.x, ye.x, ve.x), CubicBezier(K, ge.y, xe.y, ye.y, ve.y)), me } copy(K) { return super.copy(K), this.v0.copy(K.v0), this.v1.copy(K.v1), this.v2.copy(K.v2), this.v3.copy(K.v3), this } toJSON() { const K = super.toJSON(); return K.v0 = this.v0.toArray(), K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K.v3 = this.v3.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v0.fromArray(K.v0), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this.v3.fromArray(K.v3), this } } class CubicBezierCurve3 extends Curve { constructor(K = new Vector3, pe = new Vector3, me = new Vector3, ge = new Vector3) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = K, this.v1 = pe, this.v2 = me, this.v3 = ge } getPoint(K, pe = new Vector3) { const me = pe, ge = this.v0, xe = this.v1, ye = this.v2, ve = this.v3; return me.set(CubicBezier(K, ge.x, xe.x, ye.x, ve.x), CubicBezier(K, ge.y, xe.y, ye.y, ve.y), CubicBezier(K, ge.z, xe.z, ye.z, ve.z)), me } copy(K) { return super.copy(K), this.v0.copy(K.v0), this.v1.copy(K.v1), this.v2.copy(K.v2), this.v3.copy(K.v3), this } toJSON() { const K = super.toJSON(); return K.v0 = this.v0.toArray(), K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K.v3 = this.v3.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v0.fromArray(K.v0), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this.v3.fromArray(K.v3), this } } class LineCurve extends Curve { constructor(K = new Vector2, pe = new Vector2) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = K, this.v2 = pe } getPoint(K, pe = new Vector2) { const me = pe; return K === 1 ? me.copy(this.v2) : (me.copy(this.v2).sub(this.v1), me.multiplyScalar(K).add(this.v1)), me } getPointAt(K, pe) { return this.getPoint(K, pe) } getTangent(K, pe = new Vector2) { return pe.subVectors(this.v2, this.v1).normalize() } getTangentAt(K, pe) { return this.getTangent(K, pe) } copy(K) { return super.copy(K), this.v1.copy(K.v1), this.v2.copy(K.v2), this } toJSON() { const K = super.toJSON(); return K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this } } class LineCurve3 extends Curve { constructor(K = new Vector3, pe = new Vector3) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = K, this.v2 = pe } getPoint(K, pe = new Vector3) { const me = pe; return K === 1 ? me.copy(this.v2) : (me.copy(this.v2).sub(this.v1), me.multiplyScalar(K).add(this.v1)), me } getPointAt(K, pe) { return this.getPoint(K, pe) } getTangent(K, pe = new Vector3) { return pe.subVectors(this.v2, this.v1).normalize() } getTangentAt(K, pe) { return this.getTangent(K, pe) } copy(K) { return super.copy(K), this.v1.copy(K.v1), this.v2.copy(K.v2), this } toJSON() { const K = super.toJSON(); return K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this } } class QuadraticBezierCurve extends Curve { constructor(K = new Vector2, pe = new Vector2, me = new Vector2) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = K, this.v1 = pe, this.v2 = me } getPoint(K, pe = new Vector2) { const me = pe, ge = this.v0, xe = this.v1, ye = this.v2; return me.set(QuadraticBezier(K, ge.x, xe.x, ye.x), QuadraticBezier(K, ge.y, xe.y, ye.y)), me } copy(K) { return super.copy(K), this.v0.copy(K.v0), this.v1.copy(K.v1), this.v2.copy(K.v2), this } toJSON() { const K = super.toJSON(); return K.v0 = this.v0.toArray(), K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v0.fromArray(K.v0), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this } } class QuadraticBezierCurve3 extends Curve { constructor(K = new Vector3, pe = new Vector3, me = new Vector3) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = K, this.v1 = pe, this.v2 = me } getPoint(K, pe = new Vector3) { const me = pe, ge = this.v0, xe = this.v1, ye = this.v2; return me.set(QuadraticBezier(K, ge.x, xe.x, ye.x), QuadraticBezier(K, ge.y, xe.y, ye.y), QuadraticBezier(K, ge.z, xe.z, ye.z)), me } copy(K) { return super.copy(K), this.v0.copy(K.v0), this.v1.copy(K.v1), this.v2.copy(K.v2), this } toJSON() { const K = super.toJSON(); return K.v0 = this.v0.toArray(), K.v1 = this.v1.toArray(), K.v2 = this.v2.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.v0.fromArray(K.v0), this.v1.fromArray(K.v1), this.v2.fromArray(K.v2), this } } class SplineCurve extends Curve { constructor(K = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = K } getPoint(K, pe = new Vector2) { const me = pe, ge = this.points, xe = (ge.length - 1) * K, ye = Math.floor(xe), ve = xe - ye, _e = ge[ye === 0 ? ye : ye - 1], Ee = ge[ye], be = ge[ye > ge.length - 2 ? ge.length - 1 : ye + 1], Ae = ge[ye > ge.length - 3 ? ge.length - 1 : ye + 2]; return me.set(CatmullRom(ve, _e.x, Ee.x, be.x, Ae.x), CatmullRom(ve, _e.y, Ee.y, be.y, Ae.y)), me } copy(K) { super.copy(K), this.points = []; for (let pe = 0, me = K.points.length; pe < me; pe++) { const ge = K.points[pe]; this.points.push(ge.clone()) } return this } toJSON() { const K = super.toJSON(); K.points = []; for (let pe = 0, me = this.points.length; pe < me; pe++) { const ge = this.points[pe]; K.points.push(ge.toArray()) } return K } fromJSON(K) { super.fromJSON(K), this.points = []; for (let pe = 0, me = K.points.length; pe < me; pe++) { const ge = K.points[pe]; this.points.push(new Vector2().fromArray(ge)) } return this } } var Curves = Object.freeze({ __proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve }); class CurvePath extends Curve { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(K) { this.curves.push(K) } closePath() { const K = this.curves[0].getPoint(0), pe = this.curves[this.curves.length - 1].getPoint(1); if (!K.equals(pe)) { const me = K.isVector2 === !0 ? "LineCurve" : "LineCurve3"; this.curves.push(new Curves[me](pe, K)) } return this } getPoint(K, pe) { const me = K * this.getLength(), ge = this.getCurveLengths(); let xe = 0; for (; xe < ge.length;) { if (ge[xe] >= me) { const ye = ge[xe] - me, ve = this.curves[xe], _e = ve.getLength(), Ee = _e === 0 ? 0 : 1 - ye / _e; return ve.getPointAt(Ee, pe) } xe++ } return null } getLength() { const K = this.getCurveLengths(); return K[K.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const K = []; let pe = 0; for (let me = 0, ge = this.curves.length; me < ge; me++)pe += this.curves[me].getLength(), K.push(pe); return this.cacheLengths = K, K } getSpacedPoints(K = 40) { const pe = []; for (let me = 0; me <= K; me++)pe.push(this.getPoint(me / K)); return this.autoClose && pe.push(pe[0]), pe } getPoints(K = 12) { const pe = []; let me; for (let ge = 0, xe = this.curves; ge < xe.length; ge++) { const ye = xe[ge], ve = ye.isEllipseCurve ? K * 2 : ye.isLineCurve || ye.isLineCurve3 ? 1 : ye.isSplineCurve ? K * ye.points.length : K, _e = ye.getPoints(ve); for (let Ee = 0; Ee < _e.length; Ee++) { const be = _e[Ee]; me && me.equals(be) || (pe.push(be), me = be) } } return this.autoClose && pe.length > 1 && !pe[pe.length - 1].equals(pe[0]) && pe.push(pe[0]), pe } copy(K) { super.copy(K), this.curves = []; for (let pe = 0, me = K.curves.length; pe < me; pe++) { const ge = K.curves[pe]; this.curves.push(ge.clone()) } return this.autoClose = K.autoClose, this } toJSON() { const K = super.toJSON(); K.autoClose = this.autoClose, K.curves = []; for (let pe = 0, me = this.curves.length; pe < me; pe++) { const ge = this.curves[pe]; K.curves.push(ge.toJSON()) } return K } fromJSON(K) { super.fromJSON(K), this.autoClose = K.autoClose, this.curves = []; for (let pe = 0, me = K.curves.length; pe < me; pe++) { const ge = K.curves[pe]; this.curves.push(new Curves[ge.type]().fromJSON(ge)) } return this } } class Path extends CurvePath { constructor(K) { super(), this.type = "Path", this.currentPoint = new Vector2, K && this.setFromPoints(K) } setFromPoints(K) { this.moveTo(K[0].x, K[0].y); for (let pe = 1, me = K.length; pe < me; pe++)this.lineTo(K[pe].x, K[pe].y); return this } moveTo(K, pe) { return this.currentPoint.set(K, pe), this } lineTo(K, pe) { const me = new LineCurve(this.currentPoint.clone(), new Vector2(K, pe)); return this.curves.push(me), this.currentPoint.set(K, pe), this } quadraticCurveTo(K, pe, me, ge) { const xe = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(K, pe), new Vector2(me, ge)); return this.curves.push(xe), this.currentPoint.set(me, ge), this } bezierCurveTo(K, pe, me, ge, xe, ye) { const ve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(K, pe), new Vector2(me, ge), new Vector2(xe, ye)); return this.curves.push(ve), this.currentPoint.set(xe, ye), this } splineThru(K) { const pe = [this.currentPoint.clone()].concat(K), me = new SplineCurve(pe); return this.curves.push(me), this.currentPoint.copy(K[K.length - 1]), this } arc(K, pe, me, ge, xe, ye) { const ve = this.currentPoint.x, _e = this.currentPoint.y; return this.absarc(K + ve, pe + _e, me, ge, xe, ye), this } absarc(K, pe, me, ge, xe, ye) { return this.absellipse(K, pe, me, me, ge, xe, ye), this } ellipse(K, pe, me, ge, xe, ye, ve, _e) { const Ee = this.currentPoint.x, be = this.currentPoint.y; return this.absellipse(K + Ee, pe + be, me, ge, xe, ye, ve, _e), this } absellipse(K, pe, me, ge, xe, ye, ve, _e) { const Ee = new EllipseCurve(K, pe, me, ge, xe, ye, ve, _e); if (this.curves.length > 0) { const Ae = Ee.getPoint(0); Ae.equals(this.currentPoint) || this.lineTo(Ae.x, Ae.y) } this.curves.push(Ee); const be = Ee.getPoint(1); return this.currentPoint.copy(be), this } copy(K) { return super.copy(K), this.currentPoint.copy(K.currentPoint), this } toJSON() { const K = super.toJSON(); return K.currentPoint = this.currentPoint.toArray(), K } fromJSON(K) { return super.fromJSON(K), this.currentPoint.fromArray(K.currentPoint), this } } class LatheGeometry extends BufferGeometry { constructor(K = [new Vector2(0, -.5), new Vector2(.5, 0), new Vector2(0, .5)], pe = 12, me = 0, ge = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: K, segments: pe, phiStart: me, phiLength: ge }, pe = Math.floor(pe), ge = clamp$3(ge, 0, Math.PI * 2); const xe = [], ye = [], ve = [], _e = [], Ee = [], be = 1 / pe, Ae = new Vector3, Se = new Vector2, Ce = new Vector3, we = new Vector3, Be = new Vector3; let De = 0, Re = 0; for (let Ie = 0; Ie <= K.length - 1; Ie++)switch (Ie) { case 0: De = K[Ie + 1].x - K[Ie].x, Re = K[Ie + 1].y - K[Ie].y, Ce.x = Re * 1, Ce.y = -De, Ce.z = Re * 0, Be.copy(Ce), Ce.normalize(), _e.push(Ce.x, Ce.y, Ce.z); break; case K.length - 1: _e.push(Be.x, Be.y, Be.z); break; default: De = K[Ie + 1].x - K[Ie].x, Re = K[Ie + 1].y - K[Ie].y, Ce.x = Re * 1, Ce.y = -De, Ce.z = Re * 0, we.copy(Ce), Ce.x += Be.x, Ce.y += Be.y, Ce.z += Be.z, Ce.normalize(), _e.push(Ce.x, Ce.y, Ce.z), Be.copy(we) }for (let Ie = 0; Ie <= pe; Ie++) { const Pe = me + Ie * be * ge, Ne = Math.sin(Pe), ke = Math.cos(Pe); for (let Oe = 0; Oe <= K.length - 1; Oe++) { Ae.x = K[Oe].x * Ne, Ae.y = K[Oe].y, Ae.z = K[Oe].x * ke, ye.push(Ae.x, Ae.y, Ae.z), Se.x = Ie / pe, Se.y = Oe / (K.length - 1), ve.push(Se.x, Se.y); const Ue = _e[3 * Oe + 0] * Ne, He = _e[3 * Oe + 1], Ge = _e[3 * Oe + 0] * ke; Ee.push(Ue, He, Ge) } } for (let Ie = 0; Ie < pe; Ie++)for (let Pe = 0; Pe < K.length - 1; Pe++) { const Ne = Pe + Ie * K.length, ke = Ne, Oe = Ne + K.length, Ue = Ne + K.length + 1, He = Ne + 1; xe.push(ke, Oe, He), xe.push(Ue, He, Oe) } this.setIndex(xe), this.setAttribute("position", new Float32BufferAttribute(ye, 3)), this.setAttribute("uv", new Float32BufferAttribute(ve, 2)), this.setAttribute("normal", new Float32BufferAttribute(Ee, 3)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new LatheGeometry(K.points, K.segments, K.phiStart, K.phiLength) } } class CapsuleGeometry extends LatheGeometry { constructor(K = 1, pe = 1, me = 4, ge = 8) { const xe = new Path; xe.absarc(0, -pe / 2, K, Math.PI * 1.5, 0), xe.absarc(0, pe / 2, K, 0, Math.PI * .5), super(xe.getPoints(me), ge), this.type = "CapsuleGeometry", this.parameters = { radius: K, length: pe, capSegments: me, radialSegments: ge } } static fromJSON(K) { return new CapsuleGeometry(K.radius, K.length, K.capSegments, K.radialSegments) } } class CircleGeometry extends BufferGeometry { constructor(K = 1, pe = 32, me = 0, ge = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: K, segments: pe, thetaStart: me, thetaLength: ge }, pe = Math.max(3, pe); const xe = [], ye = [], ve = [], _e = [], Ee = new Vector3, be = new Vector2; ye.push(0, 0, 0), ve.push(0, 0, 1), _e.push(.5, .5); for (let Ae = 0, Se = 3; Ae <= pe; Ae++, Se += 3) { const Ce = me + Ae / pe * ge; Ee.x = K * Math.cos(Ce), Ee.y = K * Math.sin(Ce), ye.push(Ee.x, Ee.y, Ee.z), ve.push(0, 0, 1), be.x = (ye[Se] / K + 1) / 2, be.y = (ye[Se + 1] / K + 1) / 2, _e.push(be.x, be.y) } for (let Ae = 1; Ae <= pe; Ae++)xe.push(Ae, Ae + 1, 0); this.setIndex(xe), this.setAttribute("position", new Float32BufferAttribute(ye, 3)), this.setAttribute("normal", new Float32BufferAttribute(ve, 3)), this.setAttribute("uv", new Float32BufferAttribute(_e, 2)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new CircleGeometry(K.radius, K.segments, K.thetaStart, K.thetaLength) } } class CylinderGeometry extends BufferGeometry { constructor(K = 1, pe = 1, me = 1, ge = 32, xe = 1, ye = !1, ve = 0, _e = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: K, radiusBottom: pe, height: me, radialSegments: ge, heightSegments: xe, openEnded: ye, thetaStart: ve, thetaLength: _e }; const Ee = this; ge = Math.floor(ge), xe = Math.floor(xe); const be = [], Ae = [], Se = [], Ce = []; let we = 0; const Be = [], De = me / 2; let Re = 0; Ie(), ye === !1 && (K > 0 && Pe(!0), pe > 0 && Pe(!1)), this.setIndex(be), this.setAttribute("position", new Float32BufferAttribute(Ae, 3)), this.setAttribute("normal", new Float32BufferAttribute(Se, 3)), this.setAttribute("uv", new Float32BufferAttribute(Ce, 2)); function Ie() { const Ne = new Vector3, ke = new Vector3; let Oe = 0; const Ue = (pe - K) / me; for (let He = 0; He <= xe; He++) { const Ge = [], ze = He / xe, We = ze * (pe - K) + K; for (let Xe = 0; Xe <= ge; Xe++) { const Ye = Xe / ge, Ze = Ye * _e + ve, ot = Math.sin(Ze), qe = Math.cos(Ze); ke.x = We * ot, ke.y = -ze * me + De, ke.z = We * qe, Ae.push(ke.x, ke.y, ke.z), Ne.set(ot, Ue, qe).normalize(), Se.push(Ne.x, Ne.y, Ne.z), Ce.push(Ye, 1 - ze), Ge.push(we++) } Be.push(Ge) } for (let He = 0; He < ge; He++)for (let Ge = 0; Ge < xe; Ge++) { const ze = Be[Ge][He], We = Be[Ge + 1][He], Xe = Be[Ge + 1][He + 1], Ye = Be[Ge][He + 1]; (K > 0 || Ge !== 0) && (be.push(ze, We, Ye), Oe += 3), (pe > 0 || Ge !== xe - 1) && (be.push(We, Xe, Ye), Oe += 3) } Ee.addGroup(Re, Oe, 0), Re += Oe } function Pe(Ne) { const ke = we, Oe = new Vector2, Ue = new Vector3; let He = 0; const Ge = Ne === !0 ? K : pe, ze = Ne === !0 ? 1 : -1; for (let Xe = 1; Xe <= ge; Xe++)Ae.push(0, De * ze, 0), Se.push(0, ze, 0), Ce.push(.5, .5), we++; const We = we; for (let Xe = 0; Xe <= ge; Xe++) { const Ze = Xe / ge * _e + ve, ot = Math.cos(Ze), qe = Math.sin(Ze); Ue.x = Ge * qe, Ue.y = De * ze, Ue.z = Ge * ot, Ae.push(Ue.x, Ue.y, Ue.z), Se.push(0, ze, 0), Oe.x = ot * .5 + .5, Oe.y = qe * .5 * ze + .5, Ce.push(Oe.x, Oe.y), we++ } for (let Xe = 0; Xe < ge; Xe++) { const Ye = ke + Xe, Ze = We + Xe; Ne === !0 ? be.push(Ze, Ze + 1, Ye) : be.push(Ze + 1, Ze, Ye), He += 3 } Ee.addGroup(Re, He, Ne === !0 ? 1 : 2), Re += He } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new CylinderGeometry(K.radiusTop, K.radiusBottom, K.height, K.radialSegments, K.heightSegments, K.openEnded, K.thetaStart, K.thetaLength) } } class ConeGeometry extends CylinderGeometry { constructor(K = 1, pe = 1, me = 32, ge = 1, xe = !1, ye = 0, ve = Math.PI * 2) { super(0, K, pe, me, ge, xe, ye, ve), this.type = "ConeGeometry", this.parameters = { radius: K, height: pe, radialSegments: me, heightSegments: ge, openEnded: xe, thetaStart: ye, thetaLength: ve } } static fromJSON(K) { return new ConeGeometry(K.radius, K.height, K.radialSegments, K.heightSegments, K.openEnded, K.thetaStart, K.thetaLength) } } class PolyhedronGeometry extends BufferGeometry { constructor(K = [], pe = [], me = 1, ge = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: K, indices: pe, radius: me, detail: ge }; const xe = [], ye = []; ve(ge), Ee(me), be(), this.setAttribute("position", new Float32BufferAttribute(xe, 3)), this.setAttribute("normal", new Float32BufferAttribute(xe.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(ye, 2)), ge === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function ve(Ie) { const Pe = new Vector3, Ne = new Vector3, ke = new Vector3; for (let Oe = 0; Oe < pe.length; Oe += 3)Ce(pe[Oe + 0], Pe), Ce(pe[Oe + 1], Ne), Ce(pe[Oe + 2], ke), _e(Pe, Ne, ke, Ie) } function _e(Ie, Pe, Ne, ke) { const Oe = ke + 1, Ue = []; for (let He = 0; He <= Oe; He++) { Ue[He] = []; const Ge = Ie.clone().lerp(Ne, He / Oe), ze = Pe.clone().lerp(Ne, He / Oe), We = Oe - He; for (let Xe = 0; Xe <= We; Xe++)Xe === 0 && He === Oe ? Ue[He][Xe] = Ge : Ue[He][Xe] = Ge.clone().lerp(ze, Xe / We) } for (let He = 0; He < Oe; He++)for (let Ge = 0; Ge < 2 * (Oe - He) - 1; Ge++) { const ze = Math.floor(Ge / 2); Ge % 2 === 0 ? (Se(Ue[He][ze + 1]), Se(Ue[He + 1][ze]), Se(Ue[He][ze])) : (Se(Ue[He][ze + 1]), Se(Ue[He + 1][ze + 1]), Se(Ue[He + 1][ze])) } } function Ee(Ie) { const Pe = new Vector3; for (let Ne = 0; Ne < xe.length; Ne += 3)Pe.x = xe[Ne + 0], Pe.y = xe[Ne + 1], Pe.z = xe[Ne + 2], Pe.normalize().multiplyScalar(Ie), xe[Ne + 0] = Pe.x, xe[Ne + 1] = Pe.y, xe[Ne + 2] = Pe.z } function be() { const Ie = new Vector3; for (let Pe = 0; Pe < xe.length; Pe += 3) { Ie.x = xe[Pe + 0], Ie.y = xe[Pe + 1], Ie.z = xe[Pe + 2]; const Ne = De(Ie) / 2 / Math.PI + .5, ke = Re(Ie) / Math.PI + .5; ye.push(Ne, 1 - ke) } we(), Ae() } function Ae() { for (let Ie = 0; Ie < ye.length; Ie += 6) { const Pe = ye[Ie + 0], Ne = ye[Ie + 2], ke = ye[Ie + 4], Oe = Math.max(Pe, Ne, ke), Ue = Math.min(Pe, Ne, ke); Oe > .9 && Ue < .1 && (Pe < .2 && (ye[Ie + 0] += 1), Ne < .2 && (ye[Ie + 2] += 1), ke < .2 && (ye[Ie + 4] += 1)) } } function Se(Ie) { xe.push(Ie.x, Ie.y, Ie.z) } function Ce(Ie, Pe) { const Ne = Ie * 3; Pe.x = K[Ne + 0], Pe.y = K[Ne + 1], Pe.z = K[Ne + 2] } function we() { const Ie = new Vector3, Pe = new Vector3, Ne = new Vector3, ke = new Vector3, Oe = new Vector2, Ue = new Vector2, He = new Vector2; for (let Ge = 0, ze = 0; Ge < xe.length; Ge += 9, ze += 6) { Ie.set(xe[Ge + 0], xe[Ge + 1], xe[Ge + 2]), Pe.set(xe[Ge + 3], xe[Ge + 4], xe[Ge + 5]), Ne.set(xe[Ge + 6], xe[Ge + 7], xe[Ge + 8]), Oe.set(ye[ze + 0], ye[ze + 1]), Ue.set(ye[ze + 2], ye[ze + 3]), He.set(ye[ze + 4], ye[ze + 5]), ke.copy(Ie).add(Pe).add(Ne).divideScalar(3); const We = De(ke); Be(Oe, ze + 0, Ie, We), Be(Ue, ze + 2, Pe, We), Be(He, ze + 4, Ne, We) } } function Be(Ie, Pe, Ne, ke) { ke < 0 && Ie.x === 1 && (ye[Pe] = Ie.x - 1), Ne.x === 0 && Ne.z === 0 && (ye[Pe] = ke / 2 / Math.PI + .5) } function De(Ie) { return Math.atan2(Ie.z, -Ie.x) } function Re(Ie) { return Math.atan2(-Ie.y, Math.sqrt(Ie.x * Ie.x + Ie.z * Ie.z)) } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new PolyhedronGeometry(K.vertices, K.indices, K.radius, K.details) } } class DodecahedronGeometry extends PolyhedronGeometry { constructor(K = 1, pe = 0) { const me = (1 + Math.sqrt(5)) / 2, ge = 1 / me, xe = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -ge, -me, 0, -ge, me, 0, ge, -me, 0, ge, me, -ge, -me, 0, -ge, me, 0, ge, -me, 0, ge, me, 0, -me, 0, -ge, me, 0, -ge, -me, 0, ge, me, 0, ge], ye = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(xe, ye, K, pe), this.type = "DodecahedronGeometry", this.parameters = { radius: K, detail: pe } } static fromJSON(K) { return new DodecahedronGeometry(K.radius, K.detail) } } const _v0$3 = new Vector3, _v1$1 = new Vector3, _normal = new Vector3, _triangle = new Triangle; class EdgesGeometry extends BufferGeometry { constructor(K = null, pe = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: K, thresholdAngle: pe }, K !== null) { const ge = Math.pow(10, 4), xe = Math.cos(DEG2RAD$1 * pe), ye = K.getIndex(), ve = K.getAttribute("position"), _e = ye ? ye.count : ve.count, Ee = [0, 0, 0], be = ["a", "b", "c"], Ae = new Array(3), Se = {}, Ce = []; for (let we = 0; we < _e; we += 3) { ye ? (Ee[0] = ye.getX(we), Ee[1] = ye.getX(we + 1), Ee[2] = ye.getX(we + 2)) : (Ee[0] = we, Ee[1] = we + 1, Ee[2] = we + 2); const { a: Be, b: De, c: Re } = _triangle; if (Be.fromBufferAttribute(ve, Ee[0]), De.fromBufferAttribute(ve, Ee[1]), Re.fromBufferAttribute(ve, Ee[2]), _triangle.getNormal(_normal), Ae[0] = `${Math.round(Be.x * ge)},${Math.round(Be.y * ge)},${Math.round(Be.z * ge)}`, Ae[1] = `${Math.round(De.x * ge)},${Math.round(De.y * ge)},${Math.round(De.z * ge)}`, Ae[2] = `${Math.round(Re.x * ge)},${Math.round(Re.y * ge)},${Math.round(Re.z * ge)}`, !(Ae[0] === Ae[1] || Ae[1] === Ae[2] || Ae[2] === Ae[0])) for (let Ie = 0; Ie < 3; Ie++) { const Pe = (Ie + 1) % 3, Ne = Ae[Ie], ke = Ae[Pe], Oe = _triangle[be[Ie]], Ue = _triangle[be[Pe]], He = `${Ne}_${ke}`, Ge = `${ke}_${Ne}`; Ge in Se && Se[Ge] ? (_normal.dot(Se[Ge].normal) <= xe && (Ce.push(Oe.x, Oe.y, Oe.z), Ce.push(Ue.x, Ue.y, Ue.z)), Se[Ge] = null) : He in Se || (Se[He] = { index0: Ee[Ie], index1: Ee[Pe], normal: _normal.clone() }) } } for (const we in Se) if (Se[we]) { const { index0: Be, index1: De } = Se[we]; _v0$3.fromBufferAttribute(ve, Be), _v1$1.fromBufferAttribute(ve, De), Ce.push(_v0$3.x, _v0$3.y, _v0$3.z), Ce.push(_v1$1.x, _v1$1.y, _v1$1.z) } this.setAttribute("position", new Float32BufferAttribute(Ce, 3)) } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } } class Shape extends Path { constructor(K) { super(K), this.uuid = generateUUID(), this.type = "Shape", this.holes = [] } getPointsHoles(K) { const pe = []; for (let me = 0, ge = this.holes.length; me < ge; me++)pe[me] = this.holes[me].getPoints(K); return pe } extractPoints(K) { return { shape: this.getPoints(K), holes: this.getPointsHoles(K) } } copy(K) { super.copy(K), this.holes = []; for (let pe = 0, me = K.holes.length; pe < me; pe++) { const ge = K.holes[pe]; this.holes.push(ge.clone()) } return this } toJSON() { const K = super.toJSON(); K.uuid = this.uuid, K.holes = []; for (let pe = 0, me = this.holes.length; pe < me; pe++) { const ge = this.holes[pe]; K.holes.push(ge.toJSON()) } return K } fromJSON(K) { super.fromJSON(K), this.uuid = K.uuid, this.holes = []; for (let pe = 0, me = K.holes.length; pe < me; pe++) { const ge = K.holes[pe]; this.holes.push(new Path().fromJSON(ge)) } return this } } class Earcut { static triangulate(K, pe, me = 2) { const ge = pe && pe.length, xe = ge ? pe[0] * me : K.length; let ye = linkedList(K, 0, xe, me, !0); const ve = []; if (!ye || ye.next === ye.prev) return ve; let _e, Ee, be, Ae, Se, Ce, we; if (ge && (ye = eliminateHoles(K, pe, ye, me)), K.length > 80 * me) { _e = be = K[0], Ee = Ae = K[1]; for (let Be = me; Be < xe; Be += me)Se = K[Be], Ce = K[Be + 1], Se < _e && (_e = Se), Ce < Ee && (Ee = Ce), Se > be && (be = Se), Ce > Ae && (Ae = Ce); we = Math.max(be - _e, Ae - Ee), we = we !== 0 ? 32767 / we : 0 } return earcutLinked(ye, ve, me, _e, Ee, we, 0), ve } } function linkedList(fe, K, pe, me, ge) { let xe, ye; if (ge === signedArea(fe, K, pe, me) > 0) for (xe = K; xe < pe; xe += me)ye = insertNode(xe, fe[xe], fe[xe + 1], ye); else for (xe = pe - me; xe >= K; xe -= me)ye = insertNode(xe, fe[xe], fe[xe + 1], ye); return ye && equals(ye, ye.next) && (removeNode(ye), ye = ye.next), ye } function filterPoints(fe, K) { if (!fe) return fe; K || (K = fe); let pe = fe, me; do if (me = !1, !pe.steiner && (equals(pe, pe.next) || area(pe.prev, pe, pe.next) === 0)) { if (removeNode(pe), pe = K = pe.prev, pe === pe.next) break; me = !0 } else pe = pe.next; while (me || pe !== K); return K } function earcutLinked(fe, K, pe, me, ge, xe, ye) { if (!fe) return; !ye && xe && indexCurve(fe, me, ge, xe); let ve = fe, _e, Ee; for (; fe.prev !== fe.next;) { if (_e = fe.prev, Ee = fe.next, xe ? isEarHashed(fe, me, ge, xe) : isEar(fe)) { K.push(_e.i / pe | 0), K.push(fe.i / pe | 0), K.push(Ee.i / pe | 0), removeNode(fe), fe = Ee.next, ve = Ee.next; continue } if (fe = Ee, fe === ve) { ye ? ye === 1 ? (fe = cureLocalIntersections(filterPoints(fe), K, pe), earcutLinked(fe, K, pe, me, ge, xe, 2)) : ye === 2 && splitEarcut(fe, K, pe, me, ge, xe) : earcutLinked(filterPoints(fe), K, pe, me, ge, xe, 1); break } } } function isEar(fe) { const K = fe.prev, pe = fe, me = fe.next; if (area(K, pe, me) >= 0) return !1; const ge = K.x, xe = pe.x, ye = me.x, ve = K.y, _e = pe.y, Ee = me.y, be = ge < xe ? ge < ye ? ge : ye : xe < ye ? xe : ye, Ae = ve < _e ? ve < Ee ? ve : Ee : _e < Ee ? _e : Ee, Se = ge > xe ? ge > ye ? ge : ye : xe > ye ? xe : ye, Ce = ve > _e ? ve > Ee ? ve : Ee : _e > Ee ? _e : Ee; let we = me.next; for (; we !== K;) { if (we.x >= be && we.x <= Se && we.y >= Ae && we.y <= Ce && pointInTriangle(ge, ve, xe, _e, ye, Ee, we.x, we.y) && area(we.prev, we, we.next) >= 0) return !1; we = we.next } return !0 } function isEarHashed(fe, K, pe, me) { const ge = fe.prev, xe = fe, ye = fe.next; if (area(ge, xe, ye) >= 0) return !1; const ve = ge.x, _e = xe.x, Ee = ye.x, be = ge.y, Ae = xe.y, Se = ye.y, Ce = ve < _e ? ve < Ee ? ve : Ee : _e < Ee ? _e : Ee, we = be < Ae ? be < Se ? be : Se : Ae < Se ? Ae : Se, Be = ve > _e ? ve > Ee ? ve : Ee : _e > Ee ? _e : Ee, De = be > Ae ? be > Se ? be : Se : Ae > Se ? Ae : Se, Re = zOrder(Ce, we, K, pe, me), Ie = zOrder(Be, De, K, pe, me); let Pe = fe.prevZ, Ne = fe.nextZ; for (; Pe && Pe.z >= Re && Ne && Ne.z <= Ie;) { if (Pe.x >= Ce && Pe.x <= Be && Pe.y >= we && Pe.y <= De && Pe !== ge && Pe !== ye && pointInTriangle(ve, be, _e, Ae, Ee, Se, Pe.x, Pe.y) && area(Pe.prev, Pe, Pe.next) >= 0 || (Pe = Pe.prevZ, Ne.x >= Ce && Ne.x <= Be && Ne.y >= we && Ne.y <= De && Ne !== ge && Ne !== ye && pointInTriangle(ve, be, _e, Ae, Ee, Se, Ne.x, Ne.y) && area(Ne.prev, Ne, Ne.next) >= 0)) return !1; Ne = Ne.nextZ } for (; Pe && Pe.z >= Re;) { if (Pe.x >= Ce && Pe.x <= Be && Pe.y >= we && Pe.y <= De && Pe !== ge && Pe !== ye && pointInTriangle(ve, be, _e, Ae, Ee, Se, Pe.x, Pe.y) && area(Pe.prev, Pe, Pe.next) >= 0) return !1; Pe = Pe.prevZ } for (; Ne && Ne.z <= Ie;) { if (Ne.x >= Ce && Ne.x <= Be && Ne.y >= we && Ne.y <= De && Ne !== ge && Ne !== ye && pointInTriangle(ve, be, _e, Ae, Ee, Se, Ne.x, Ne.y) && area(Ne.prev, Ne, Ne.next) >= 0) return !1; Ne = Ne.nextZ } return !0 } function cureLocalIntersections(fe, K, pe) { let me = fe; do { const ge = me.prev, xe = me.next.next; !equals(ge, xe) && intersects(ge, me, me.next, xe) && locallyInside(ge, xe) && locallyInside(xe, ge) && (K.push(ge.i / pe | 0), K.push(me.i / pe | 0), K.push(xe.i / pe | 0), removeNode(me), removeNode(me.next), me = fe = xe), me = me.next } while (me !== fe); return filterPoints(me) } function splitEarcut(fe, K, pe, me, ge, xe) { let ye = fe; do { let ve = ye.next.next; for (; ve !== ye.prev;) { if (ye.i !== ve.i && isValidDiagonal(ye, ve)) { let _e = splitPolygon(ye, ve); ye = filterPoints(ye, ye.next), _e = filterPoints(_e, _e.next), earcutLinked(ye, K, pe, me, ge, xe, 0), earcutLinked(_e, K, pe, me, ge, xe, 0); return } ve = ve.next } ye = ye.next } while (ye !== fe) } function eliminateHoles(fe, K, pe, me) { const ge = []; let xe, ye, ve, _e, Ee; for (xe = 0, ye = K.length; xe < ye; xe++)ve = K[xe] * me, _e = xe < ye - 1 ? K[xe + 1] * me : fe.length, Ee = linkedList(fe, ve, _e, me, !1), Ee === Ee.next && (Ee.steiner = !0), ge.push(getLeftmost(Ee)); for (ge.sort(compareX), xe = 0; xe < ge.length; xe++)pe = eliminateHole(ge[xe], pe); return pe } function compareX(fe, K) { return fe.x - K.x } function eliminateHole(fe, K) { const pe = findHoleBridge(fe, K); if (!pe) return K; const me = splitPolygon(pe, fe); return filterPoints(me, me.next), filterPoints(pe, pe.next) } function findHoleBridge(fe, K) { let pe = K, me = -1 / 0, ge; const xe = fe.x, ye = fe.y; do { if (ye <= pe.y && ye >= pe.next.y && pe.next.y !== pe.y) { const Se = pe.x + (ye - pe.y) * (pe.next.x - pe.x) / (pe.next.y - pe.y); if (Se <= xe && Se > me && (me = Se, ge = pe.x < pe.next.x ? pe : pe.next, Se === xe)) return ge } pe = pe.next } while (pe !== K); if (!ge) return null; const ve = ge, _e = ge.x, Ee = ge.y; let be = 1 / 0, Ae; pe = ge; do xe >= pe.x && pe.x >= _e && xe !== pe.x && pointInTriangle(ye < Ee ? xe : me, ye, _e, Ee, ye < Ee ? me : xe, ye, pe.x, pe.y) && (Ae = Math.abs(ye - pe.y) / (xe - pe.x), locallyInside(pe, fe) && (Ae < be || Ae === be && (pe.x > ge.x || pe.x === ge.x && sectorContainsSector(ge, pe))) && (ge = pe, be = Ae)), pe = pe.next; while (pe !== ve); return ge } function sectorContainsSector(fe, K) { return area(fe.prev, fe, K.prev) < 0 && area(K.next, fe, fe.next) < 0 } function indexCurve(fe, K, pe, me) { let ge = fe; do ge.z === 0 && (ge.z = zOrder(ge.x, ge.y, K, pe, me)), ge.prevZ = ge.prev, ge.nextZ = ge.next, ge = ge.next; while (ge !== fe); ge.prevZ.nextZ = null, ge.prevZ = null, sortLinked(ge) } function sortLinked(fe) { let K, pe, me, ge, xe, ye, ve, _e, Ee = 1; do { for (pe = fe, fe = null, xe = null, ye = 0; pe;) { for (ye++, me = pe, ve = 0, K = 0; K < Ee && (ve++, me = me.nextZ, !!me); K++); for (_e = Ee; ve > 0 || _e > 0 && me;)ve !== 0 && (_e === 0 || !me || pe.z <= me.z) ? (ge = pe, pe = pe.nextZ, ve--) : (ge = me, me = me.nextZ, _e--), xe ? xe.nextZ = ge : fe = ge, ge.prevZ = xe, xe = ge; pe = me } xe.nextZ = null, Ee *= 2 } while (ye > 1); return fe } function zOrder(fe, K, pe, me, ge) { return fe = (fe - pe) * ge | 0, K = (K - me) * ge | 0, fe = (fe | fe << 8) & 16711935, fe = (fe | fe << 4) & 252645135, fe = (fe | fe << 2) & 858993459, fe = (fe | fe << 1) & 1431655765, K = (K | K << 8) & 16711935, K = (K | K << 4) & 252645135, K = (K | K << 2) & 858993459, K = (K | K << 1) & 1431655765, fe | K << 1 } function getLeftmost(fe) { let K = fe, pe = fe; do (K.x < pe.x || K.x === pe.x && K.y < pe.y) && (pe = K), K = K.next; while (K !== fe); return pe } function pointInTriangle(fe, K, pe, me, ge, xe, ye, ve) { return (ge - ye) * (K - ve) >= (fe - ye) * (xe - ve) && (fe - ye) * (me - ve) >= (pe - ye) * (K - ve) && (pe - ye) * (xe - ve) >= (ge - ye) * (me - ve) } function isValidDiagonal(fe, K) { return fe.next.i !== K.i && fe.prev.i !== K.i && !intersectsPolygon(fe, K) && (locallyInside(fe, K) && locallyInside(K, fe) && middleInside(fe, K) && (area(fe.prev, fe, K.prev) || area(fe, K.prev, K)) || equals(fe, K) && area(fe.prev, fe, fe.next) > 0 && area(K.prev, K, K.next) > 0) } function area(fe, K, pe) { return (K.y - fe.y) * (pe.x - K.x) - (K.x - fe.x) * (pe.y - K.y) } function equals(fe, K) { return fe.x === K.x && fe.y === K.y } function intersects(fe, K, pe, me) { const ge = sign$1(area(fe, K, pe)), xe = sign$1(area(fe, K, me)), ye = sign$1(area(pe, me, fe)), ve = sign$1(area(pe, me, K)); return !!(ge !== xe && ye !== ve || ge === 0 && onSegment(fe, pe, K) || xe === 0 && onSegment(fe, me, K) || ye === 0 && onSegment(pe, fe, me) || ve === 0 && onSegment(pe, K, me)) } function onSegment(fe, K, pe) { return K.x <= Math.max(fe.x, pe.x) && K.x >= Math.min(fe.x, pe.x) && K.y <= Math.max(fe.y, pe.y) && K.y >= Math.min(fe.y, pe.y) } function sign$1(fe) { return fe > 0 ? 1 : fe < 0 ? -1 : 0 } function intersectsPolygon(fe, K) { let pe = fe; do { if (pe.i !== fe.i && pe.next.i !== fe.i && pe.i !== K.i && pe.next.i !== K.i && intersects(pe, pe.next, fe, K)) return !0; pe = pe.next } while (pe !== fe); return !1 } function locallyInside(fe, K) { return area(fe.prev, fe, fe.next) < 0 ? area(fe, K, fe.next) >= 0 && area(fe, fe.prev, K) >= 0 : area(fe, K, fe.prev) < 0 || area(fe, fe.next, K) < 0 } function middleInside(fe, K) { let pe = fe, me = !1; const ge = (fe.x + K.x) / 2, xe = (fe.y + K.y) / 2; do pe.y > xe != pe.next.y > xe && pe.next.y !== pe.y && ge < (pe.next.x - pe.x) * (xe - pe.y) / (pe.next.y - pe.y) + pe.x && (me = !me), pe = pe.next; while (pe !== fe); return me } function splitPolygon(fe, K) { const pe = new Node$1(fe.i, fe.x, fe.y), me = new Node$1(K.i, K.x, K.y), ge = fe.next, xe = K.prev; return fe.next = K, K.prev = fe, pe.next = ge, ge.prev = pe, me.next = pe, pe.prev = me, xe.next = me, me.prev = xe, me } function insertNode(fe, K, pe, me) { const ge = new Node$1(fe, K, pe); return me ? (ge.next = me.next, ge.prev = me, me.next.prev = ge, me.next = ge) : (ge.prev = ge, ge.next = ge), ge } function removeNode(fe) { fe.next.prev = fe.prev, fe.prev.next = fe.next, fe.prevZ && (fe.prevZ.nextZ = fe.nextZ), fe.nextZ && (fe.nextZ.prevZ = fe.prevZ) } function Node$1(fe, K, pe) { this.i = fe, this.x = K, this.y = pe, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function signedArea(fe, K, pe, me) { let ge = 0; for (let xe = K, ye = pe - me; xe < pe; xe += me)ge += (fe[ye] - fe[xe]) * (fe[xe + 1] + fe[ye + 1]), ye = xe; return ge } class ShapeUtils { static area(K) { const pe = K.length; let me = 0; for (let ge = pe - 1, xe = 0; xe < pe; ge = xe++)me += K[ge].x * K[xe].y - K[xe].x * K[ge].y; return me * .5 } static isClockWise(K) { return ShapeUtils.area(K) < 0 } static triangulateShape(K, pe) { const me = [], ge = [], xe = []; removeDupEndPts(K), addContour(me, K); let ye = K.length; pe.forEach(removeDupEndPts); for (let _e = 0; _e < pe.length; _e++)ge.push(ye), ye += pe[_e].length, addContour(me, pe[_e]); const ve = Earcut.triangulate(me, ge); for (let _e = 0; _e < ve.length; _e += 3)xe.push(ve.slice(_e, _e + 3)); return xe } } function removeDupEndPts(fe) { const K = fe.length; K > 2 && fe[K - 1].equals(fe[0]) && fe.pop() } function addContour(fe, K) { for (let pe = 0; pe < K.length; pe++)fe.push(K[pe].x), fe.push(K[pe].y) } class ExtrudeGeometry extends BufferGeometry { constructor(K = new Shape([new Vector2(.5, .5), new Vector2(-.5, .5), new Vector2(-.5, -.5), new Vector2(.5, -.5)]), pe = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: K, options: pe }, K = Array.isArray(K) ? K : [K]; const me = this, ge = [], xe = []; for (let ve = 0, _e = K.length; ve < _e; ve++) { const Ee = K[ve]; ye(Ee) } this.setAttribute("position", new Float32BufferAttribute(ge, 3)), this.setAttribute("uv", new Float32BufferAttribute(xe, 2)), this.computeVertexNormals(); function ye(ve) { const _e = [], Ee = pe.curveSegments !== void 0 ? pe.curveSegments : 12, be = pe.steps !== void 0 ? pe.steps : 1, Ae = pe.depth !== void 0 ? pe.depth : 1; let Se = pe.bevelEnabled !== void 0 ? pe.bevelEnabled : !0, Ce = pe.bevelThickness !== void 0 ? pe.bevelThickness : .2, we = pe.bevelSize !== void 0 ? pe.bevelSize : Ce - .1, Be = pe.bevelOffset !== void 0 ? pe.bevelOffset : 0, De = pe.bevelSegments !== void 0 ? pe.bevelSegments : 3; const Re = pe.extrudePath, Ie = pe.UVGenerator !== void 0 ? pe.UVGenerator : WorldUVGenerator; let Pe, Ne = !1, ke, Oe, Ue, He; Re && (Pe = Re.getSpacedPoints(be), Ne = !0, Se = !1, ke = Re.computeFrenetFrames(be, !1), Oe = new Vector3, Ue = new Vector3, He = new Vector3), Se || (De = 0, Ce = 0, we = 0, Be = 0); const Ge = ve.extractPoints(Ee); let ze = Ge.shape; const We = Ge.holes; if (!ShapeUtils.isClockWise(ze)) { ze = ze.reverse(); for (let wn = 0, Bn = We.length; wn < Bn; wn++) { const Gt = We[wn]; ShapeUtils.isClockWise(Gt) && (We[wn] = Gt.reverse()) } } const Ye = ShapeUtils.triangulateShape(ze, We), Ze = ze; for (let wn = 0, Bn = We.length; wn < Bn; wn++) { const Gt = We[wn]; ze = ze.concat(Gt) } function ot(wn, Bn, Gt) { return Bn || console.error("THREE.ExtrudeGeometry: vec does not exist"), wn.clone().addScaledVector(Bn, Gt) } const qe = ze.length, Qe = Ye.length; function st(wn, Bn, Gt) { let nr, Kn, vn; const yn = wn.x - Bn.x, Hn = wn.y - Bn.y, kn = Gt.x - wn.x, Ht = Gt.y - wn.y, Dt = yn * yn + Hn * Hn, fn = yn * Ht - Hn * kn; if (Math.abs(fn) > Number.EPSILON) { const en = Math.sqrt(Dt), cn = Math.sqrt(kn * kn + Ht * Ht), Wt = Bn.x - Hn / en, un = Bn.y + yn / en, Ft = Gt.x - Ht / cn, Sn = Gt.y + kn / cn, lr = ((Ft - Wt) * Ht - (Sn - un) * kn) / (yn * Ht - Hn * kn); nr = Wt + yn * lr - wn.x, Kn = un + Hn * lr - wn.y; const jn = nr * nr + Kn * Kn; if (jn <= 2) return new Vector2(nr, Kn); vn = Math.sqrt(jn / 2) } else { let en = !1; yn > Number.EPSILON ? kn > Number.EPSILON && (en = !0) : yn < -Number.EPSILON ? kn < -Number.EPSILON && (en = !0) : Math.sign(Hn) === Math.sign(Ht) && (en = !0), en ? (nr = -Hn, Kn = yn, vn = Math.sqrt(Dt)) : (nr = yn, Kn = Hn, vn = Math.sqrt(Dt / 2)) } return new Vector2(nr / vn, Kn / vn) } const Nt = []; for (let wn = 0, Bn = Ze.length, Gt = Bn - 1, nr = wn + 1; wn < Bn; wn++, Gt++, nr++)Gt === Bn && (Gt = 0), nr === Bn && (nr = 0), Nt[wn] = st(Ze[wn], Ze[Gt], Ze[nr]); const Je = []; let jt, Xt = Nt.concat(); for (let wn = 0, Bn = We.length; wn < Bn; wn++) { const Gt = We[wn]; jt = []; for (let nr = 0, Kn = Gt.length, vn = Kn - 1, yn = nr + 1; nr < Kn; nr++, vn++, yn++)vn === Kn && (vn = 0), yn === Kn && (yn = 0), jt[nr] = st(Gt[nr], Gt[vn], Gt[yn]); Je.push(jt), Xt = Xt.concat(jt) } for (let wn = 0; wn < De; wn++) { const Bn = wn / De, Gt = Ce * Math.cos(Bn * Math.PI / 2), nr = we * Math.sin(Bn * Math.PI / 2) + Be; for (let Kn = 0, vn = Ze.length; Kn < vn; Kn++) { const yn = ot(Ze[Kn], Nt[Kn], nr); gn(yn.x, yn.y, -Gt) } for (let Kn = 0, vn = We.length; Kn < vn; Kn++) { const yn = We[Kn]; jt = Je[Kn]; for (let Hn = 0, kn = yn.length; Hn < kn; Hn++) { const Ht = ot(yn[Hn], jt[Hn], nr); gn(Ht.x, Ht.y, -Gt) } } } const ct = we + Be; for (let wn = 0; wn < qe; wn++) { const Bn = Se ? ot(ze[wn], Xt[wn], ct) : ze[wn]; Ne ? (Ue.copy(ke.normals[0]).multiplyScalar(Bn.x), Oe.copy(ke.binormals[0]).multiplyScalar(Bn.y), He.copy(Pe[0]).add(Ue).add(Oe), gn(He.x, He.y, He.z)) : gn(Bn.x, Bn.y, 0) } for (let wn = 1; wn <= be; wn++)for (let Bn = 0; Bn < qe; Bn++) { const Gt = Se ? ot(ze[Bn], Xt[Bn], ct) : ze[Bn]; Ne ? (Ue.copy(ke.normals[wn]).multiplyScalar(Gt.x), Oe.copy(ke.binormals[wn]).multiplyScalar(Gt.y), He.copy(Pe[wn]).add(Ue).add(Oe), gn(He.x, He.y, He.z)) : gn(Gt.x, Gt.y, Ae / be * wn) } for (let wn = De - 1; wn >= 0; wn--) { const Bn = wn / De, Gt = Ce * Math.cos(Bn * Math.PI / 2), nr = we * Math.sin(Bn * Math.PI / 2) + Be; for (let Kn = 0, vn = Ze.length; Kn < vn; Kn++) { const yn = ot(Ze[Kn], Nt[Kn], nr); gn(yn.x, yn.y, Ae + Gt) } for (let Kn = 0, vn = We.length; Kn < vn; Kn++) { const yn = We[Kn]; jt = Je[Kn]; for (let Hn = 0, kn = yn.length; Hn < kn; Hn++) { const Ht = ot(yn[Hn], jt[Hn], nr); Ne ? gn(Ht.x, Ht.y + Pe[be - 1].y, Pe[be - 1].x + Gt) : gn(Ht.x, Ht.y, Ae + Gt) } } } nn(), $t(); function nn() { const wn = ge.length / 3; if (Se) { let Bn = 0, Gt = qe * Bn; for (let nr = 0; nr < Qe; nr++) { const Kn = Ye[nr]; Mn(Kn[2] + Gt, Kn[1] + Gt, Kn[0] + Gt) } Bn = be + De * 2, Gt = qe * Bn; for (let nr = 0; nr < Qe; nr++) { const Kn = Ye[nr]; Mn(Kn[0] + Gt, Kn[1] + Gt, Kn[2] + Gt) } } else { for (let Bn = 0; Bn < Qe; Bn++) { const Gt = Ye[Bn]; Mn(Gt[2], Gt[1], Gt[0]) } for (let Bn = 0; Bn < Qe; Bn++) { const Gt = Ye[Bn]; Mn(Gt[0] + qe * be, Gt[1] + qe * be, Gt[2] + qe * be) } } me.addGroup(wn, ge.length / 3 - wn, 0) } function $t() { const wn = ge.length / 3; let Bn = 0; an(Ze, Bn), Bn += Ze.length; for (let Gt = 0, nr = We.length; Gt < nr; Gt++) { const Kn = We[Gt]; an(Kn, Bn), Bn += Kn.length } me.addGroup(wn, ge.length / 3 - wn, 1) } function an(wn, Bn) { let Gt = wn.length; for (; --Gt >= 0;) { const nr = Gt; let Kn = Gt - 1; Kn < 0 && (Kn = wn.length - 1); for (let vn = 0, yn = be + De * 2; vn < yn; vn++) { const Hn = qe * vn, kn = qe * (vn + 1), Ht = Bn + nr + Hn, Dt = Bn + Kn + Hn, fn = Bn + Kn + kn, en = Bn + nr + kn; Xn(Ht, Dt, fn, en) } } } function gn(wn, Bn, Gt) { _e.push(wn), _e.push(Bn), _e.push(Gt) } function Mn(wn, Bn, Gt) { Ln(wn), Ln(Bn), Ln(Gt); const nr = ge.length / 3, Kn = Ie.generateTopUV(me, ge, nr - 3, nr - 2, nr - 1); Gn(Kn[0]), Gn(Kn[1]), Gn(Kn[2]) } function Xn(wn, Bn, Gt, nr) { Ln(wn), Ln(Bn), Ln(nr), Ln(Bn), Ln(Gt), Ln(nr); const Kn = ge.length / 3, vn = Ie.generateSideWallUV(me, ge, Kn - 6, Kn - 3, Kn - 2, Kn - 1); Gn(vn[0]), Gn(vn[1]), Gn(vn[3]), Gn(vn[1]), Gn(vn[2]), Gn(vn[3]) } function Ln(wn) { ge.push(_e[wn * 3 + 0]), ge.push(_e[wn * 3 + 1]), ge.push(_e[wn * 3 + 2]) } function Gn(wn) { xe.push(wn.x), xe.push(wn.y) } } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } toJSON() { const K = super.toJSON(), pe = this.parameters.shapes, me = this.parameters.options; return toJSON$1(pe, me, K) } static fromJSON(K, pe) { const me = []; for (let xe = 0, ye = K.shapes.length; xe < ye; xe++) { const ve = pe[K.shapes[xe]]; me.push(ve) } const ge = K.options.extrudePath; return ge !== void 0 && (K.options.extrudePath = new Curves[ge.type]().fromJSON(ge)), new ExtrudeGeometry(me, K.options) } } const WorldUVGenerator = { generateTopUV: function (fe, K, pe, me, ge) { const xe = K[pe * 3], ye = K[pe * 3 + 1], ve = K[me * 3], _e = K[me * 3 + 1], Ee = K[ge * 3], be = K[ge * 3 + 1]; return [new Vector2(xe, ye), new Vector2(ve, _e), new Vector2(Ee, be)] }, generateSideWallUV: function (fe, K, pe, me, ge, xe) { const ye = K[pe * 3], ve = K[pe * 3 + 1], _e = K[pe * 3 + 2], Ee = K[me * 3], be = K[me * 3 + 1], Ae = K[me * 3 + 2], Se = K[ge * 3], Ce = K[ge * 3 + 1], we = K[ge * 3 + 2], Be = K[xe * 3], De = K[xe * 3 + 1], Re = K[xe * 3 + 2]; return Math.abs(ve - be) < Math.abs(ye - Ee) ? [new Vector2(ye, 1 - _e), new Vector2(Ee, 1 - Ae), new Vector2(Se, 1 - we), new Vector2(Be, 1 - Re)] : [new Vector2(ve, 1 - _e), new Vector2(be, 1 - Ae), new Vector2(Ce, 1 - we), new Vector2(De, 1 - Re)] } }; function toJSON$1(fe, K, pe) { if (pe.shapes = [], Array.isArray(fe)) for (let me = 0, ge = fe.length; me < ge; me++) { const xe = fe[me]; pe.shapes.push(xe.uuid) } else pe.shapes.push(fe.uuid); return pe.options = Object.assign({}, K), K.extrudePath !== void 0 && (pe.options.extrudePath = K.extrudePath.toJSON()), pe } class IcosahedronGeometry extends PolyhedronGeometry { constructor(K = 1, pe = 0) { const me = (1 + Math.sqrt(5)) / 2, ge = [-1, me, 0, 1, me, 0, -1, -me, 0, 1, -me, 0, 0, -1, me, 0, 1, me, 0, -1, -me, 0, 1, -me, me, 0, -1, me, 0, 1, -me, 0, -1, -me, 0, 1], xe = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(ge, xe, K, pe), this.type = "IcosahedronGeometry", this.parameters = { radius: K, detail: pe } } static fromJSON(K) { return new IcosahedronGeometry(K.radius, K.detail) } } class OctahedronGeometry extends PolyhedronGeometry { constructor(K = 1, pe = 0) { const me = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], ge = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(me, ge, K, pe), this.type = "OctahedronGeometry", this.parameters = { radius: K, detail: pe } } static fromJSON(K) { return new OctahedronGeometry(K.radius, K.detail) } } class PlaneGeometry extends BufferGeometry { constructor(K = 1, pe = 1, me = 1, ge = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: K, height: pe, widthSegments: me, heightSegments: ge }; const xe = K / 2, ye = pe / 2, ve = Math.floor(me), _e = Math.floor(ge), Ee = ve + 1, be = _e + 1, Ae = K / ve, Se = pe / _e, Ce = [], we = [], Be = [], De = []; for (let Re = 0; Re < be; Re++) { const Ie = Re * Se - ye; for (let Pe = 0; Pe < Ee; Pe++) { const Ne = Pe * Ae - xe; we.push(Ne, -Ie, 0), Be.push(0, 0, 1), De.push(Pe / ve), De.push(1 - Re / _e) } } for (let Re = 0; Re < _e; Re++)for (let Ie = 0; Ie < ve; Ie++) { const Pe = Ie + Ee * Re, Ne = Ie + Ee * (Re + 1), ke = Ie + 1 + Ee * (Re + 1), Oe = Ie + 1 + Ee * Re; Ce.push(Pe, Ne, Oe), Ce.push(Ne, ke, Oe) } this.setIndex(Ce), this.setAttribute("position", new Float32BufferAttribute(we, 3)), this.setAttribute("normal", new Float32BufferAttribute(Be, 3)), this.setAttribute("uv", new Float32BufferAttribute(De, 2)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new PlaneGeometry(K.width, K.height, K.widthSegments, K.heightSegments) } } class RingGeometry extends BufferGeometry { constructor(K = .5, pe = 1, me = 32, ge = 1, xe = 0, ye = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: K, outerRadius: pe, thetaSegments: me, phiSegments: ge, thetaStart: xe, thetaLength: ye }, me = Math.max(3, me), ge = Math.max(1, ge); const ve = [], _e = [], Ee = [], be = []; let Ae = K; const Se = (pe - K) / ge, Ce = new Vector3, we = new Vector2; for (let Be = 0; Be <= ge; Be++) { for (let De = 0; De <= me; De++) { const Re = xe + De / me * ye; Ce.x = Ae * Math.cos(Re), Ce.y = Ae * Math.sin(Re), _e.push(Ce.x, Ce.y, Ce.z), Ee.push(0, 0, 1), we.x = (Ce.x / pe + 1) / 2, we.y = (Ce.y / pe + 1) / 2, be.push(we.x, we.y) } Ae += Se } for (let Be = 0; Be < ge; Be++) { const De = Be * (me + 1); for (let Re = 0; Re < me; Re++) { const Ie = Re + De, Pe = Ie, Ne = Ie + me + 1, ke = Ie + me + 2, Oe = Ie + 1; ve.push(Pe, Ne, Oe), ve.push(Ne, ke, Oe) } } this.setIndex(ve), this.setAttribute("position", new Float32BufferAttribute(_e, 3)), this.setAttribute("normal", new Float32BufferAttribute(Ee, 3)), this.setAttribute("uv", new Float32BufferAttribute(be, 2)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new RingGeometry(K.innerRadius, K.outerRadius, K.thetaSegments, K.phiSegments, K.thetaStart, K.thetaLength) } } class ShapeGeometry extends BufferGeometry { constructor(K = new Shape([new Vector2(0, .5), new Vector2(-.5, -.5), new Vector2(.5, -.5)]), pe = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: K, curveSegments: pe }; const me = [], ge = [], xe = [], ye = []; let ve = 0, _e = 0; if (Array.isArray(K) === !1) Ee(K); else for (let be = 0; be < K.length; be++)Ee(K[be]), this.addGroup(ve, _e, be), ve += _e, _e = 0; this.setIndex(me), this.setAttribute("position", new Float32BufferAttribute(ge, 3)), this.setAttribute("normal", new Float32BufferAttribute(xe, 3)), this.setAttribute("uv", new Float32BufferAttribute(ye, 2)); function Ee(be) { const Ae = ge.length / 3, Se = be.extractPoints(pe); let Ce = Se.shape; const we = Se.holes; ShapeUtils.isClockWise(Ce) === !1 && (Ce = Ce.reverse()); for (let De = 0, Re = we.length; De < Re; De++) { const Ie = we[De]; ShapeUtils.isClockWise(Ie) === !0 && (we[De] = Ie.reverse()) } const Be = ShapeUtils.triangulateShape(Ce, we); for (let De = 0, Re = we.length; De < Re; De++) { const Ie = we[De]; Ce = Ce.concat(Ie) } for (let De = 0, Re = Ce.length; De < Re; De++) { const Ie = Ce[De]; ge.push(Ie.x, Ie.y, 0), xe.push(0, 0, 1), ye.push(Ie.x, Ie.y) } for (let De = 0, Re = Be.length; De < Re; De++) { const Ie = Be[De], Pe = Ie[0] + Ae, Ne = Ie[1] + Ae, ke = Ie[2] + Ae; me.push(Pe, Ne, ke), _e += 3 } } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } toJSON() { const K = super.toJSON(), pe = this.parameters.shapes; return toJSON(pe, K) } static fromJSON(K, pe) { const me = []; for (let ge = 0, xe = K.shapes.length; ge < xe; ge++) { const ye = pe[K.shapes[ge]]; me.push(ye) } return new ShapeGeometry(me, K.curveSegments) } } function toJSON(fe, K) { if (K.shapes = [], Array.isArray(fe)) for (let pe = 0, me = fe.length; pe < me; pe++) { const ge = fe[pe]; K.shapes.push(ge.uuid) } else K.shapes.push(fe.uuid); return K } class SphereGeometry extends BufferGeometry { constructor(K = 1, pe = 32, me = 16, ge = 0, xe = Math.PI * 2, ye = 0, ve = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: K, widthSegments: pe, heightSegments: me, phiStart: ge, phiLength: xe, thetaStart: ye, thetaLength: ve }, pe = Math.max(3, Math.floor(pe)), me = Math.max(2, Math.floor(me)); const _e = Math.min(ye + ve, Math.PI); let Ee = 0; const be = [], Ae = new Vector3, Se = new Vector3, Ce = [], we = [], Be = [], De = []; for (let Re = 0; Re <= me; Re++) { const Ie = [], Pe = Re / me; let Ne = 0; Re === 0 && ye === 0 ? Ne = .5 / pe : Re === me && _e === Math.PI && (Ne = -.5 / pe); for (let ke = 0; ke <= pe; ke++) { const Oe = ke / pe; Ae.x = -K * Math.cos(ge + Oe * xe) * Math.sin(ye + Pe * ve), Ae.y = K * Math.cos(ye + Pe * ve), Ae.z = K * Math.sin(ge + Oe * xe) * Math.sin(ye + Pe * ve), we.push(Ae.x, Ae.y, Ae.z), Se.copy(Ae).normalize(), Be.push(Se.x, Se.y, Se.z), De.push(Oe + Ne, 1 - Pe), Ie.push(Ee++) } be.push(Ie) } for (let Re = 0; Re < me; Re++)for (let Ie = 0; Ie < pe; Ie++) { const Pe = be[Re][Ie + 1], Ne = be[Re][Ie], ke = be[Re + 1][Ie], Oe = be[Re + 1][Ie + 1]; (Re !== 0 || ye > 0) && Ce.push(Pe, Ne, Oe), (Re !== me - 1 || _e < Math.PI) && Ce.push(Ne, ke, Oe) } this.setIndex(Ce), this.setAttribute("position", new Float32BufferAttribute(we, 3)), this.setAttribute("normal", new Float32BufferAttribute(Be, 3)), this.setAttribute("uv", new Float32BufferAttribute(De, 2)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new SphereGeometry(K.radius, K.widthSegments, K.heightSegments, K.phiStart, K.phiLength, K.thetaStart, K.thetaLength) } } class TetrahedronGeometry extends PolyhedronGeometry { constructor(K = 1, pe = 0) { const me = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], ge = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(me, ge, K, pe), this.type = "TetrahedronGeometry", this.parameters = { radius: K, detail: pe } } static fromJSON(K) { return new TetrahedronGeometry(K.radius, K.detail) } } class TorusGeometry extends BufferGeometry { constructor(K = 1, pe = .4, me = 12, ge = 48, xe = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: K, tube: pe, radialSegments: me, tubularSegments: ge, arc: xe }, me = Math.floor(me), ge = Math.floor(ge); const ye = [], ve = [], _e = [], Ee = [], be = new Vector3, Ae = new Vector3, Se = new Vector3; for (let Ce = 0; Ce <= me; Ce++)for (let we = 0; we <= ge; we++) { const Be = we / ge * xe, De = Ce / me * Math.PI * 2; Ae.x = (K + pe * Math.cos(De)) * Math.cos(Be), Ae.y = (K + pe * Math.cos(De)) * Math.sin(Be), Ae.z = pe * Math.sin(De), ve.push(Ae.x, Ae.y, Ae.z), be.x = K * Math.cos(Be), be.y = K * Math.sin(Be), Se.subVectors(Ae, be).normalize(), _e.push(Se.x, Se.y, Se.z), Ee.push(we / ge), Ee.push(Ce / me) } for (let Ce = 1; Ce <= me; Ce++)for (let we = 1; we <= ge; we++) { const Be = (ge + 1) * Ce + we - 1, De = (ge + 1) * (Ce - 1) + we - 1, Re = (ge + 1) * (Ce - 1) + we, Ie = (ge + 1) * Ce + we; ye.push(Be, De, Ie), ye.push(De, Re, Ie) } this.setIndex(ye), this.setAttribute("position", new Float32BufferAttribute(ve, 3)), this.setAttribute("normal", new Float32BufferAttribute(_e, 3)), this.setAttribute("uv", new Float32BufferAttribute(Ee, 2)) } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new TorusGeometry(K.radius, K.tube, K.radialSegments, K.tubularSegments, K.arc) } } class TorusKnotGeometry extends BufferGeometry { constructor(K = 1, pe = .4, me = 64, ge = 8, xe = 2, ye = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: K, tube: pe, tubularSegments: me, radialSegments: ge, p: xe, q: ye }, me = Math.floor(me), ge = Math.floor(ge); const ve = [], _e = [], Ee = [], be = [], Ae = new Vector3, Se = new Vector3, Ce = new Vector3, we = new Vector3, Be = new Vector3, De = new Vector3, Re = new Vector3; for (let Pe = 0; Pe <= me; ++Pe) { const Ne = Pe / me * xe * Math.PI * 2; Ie(Ne, xe, ye, K, Ce), Ie(Ne + .01, xe, ye, K, we), De.subVectors(we, Ce), Re.addVectors(we, Ce), Be.crossVectors(De, Re), Re.crossVectors(Be, De), Be.normalize(), Re.normalize(); for (let ke = 0; ke <= ge; ++ke) { const Oe = ke / ge * Math.PI * 2, Ue = -pe * Math.cos(Oe), He = pe * Math.sin(Oe); Ae.x = Ce.x + (Ue * Re.x + He * Be.x), Ae.y = Ce.y + (Ue * Re.y + He * Be.y), Ae.z = Ce.z + (Ue * Re.z + He * Be.z), _e.push(Ae.x, Ae.y, Ae.z), Se.subVectors(Ae, Ce).normalize(), Ee.push(Se.x, Se.y, Se.z), be.push(Pe / me), be.push(ke / ge) } } for (let Pe = 1; Pe <= me; Pe++)for (let Ne = 1; Ne <= ge; Ne++) { const ke = (ge + 1) * (Pe - 1) + (Ne - 1), Oe = (ge + 1) * Pe + (Ne - 1), Ue = (ge + 1) * Pe + Ne, He = (ge + 1) * (Pe - 1) + Ne; ve.push(ke, Oe, He), ve.push(Oe, Ue, He) } this.setIndex(ve), this.setAttribute("position", new Float32BufferAttribute(_e, 3)), this.setAttribute("normal", new Float32BufferAttribute(Ee, 3)), this.setAttribute("uv", new Float32BufferAttribute(be, 2)); function Ie(Pe, Ne, ke, Oe, Ue) { const He = Math.cos(Pe), Ge = Math.sin(Pe), ze = ke / Ne * Pe, We = Math.cos(ze); Ue.x = Oe * (2 + We) * .5 * He, Ue.y = Oe * (2 + We) * Ge * .5, Ue.z = Oe * Math.sin(ze) * .5 } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } static fromJSON(K) { return new TorusKnotGeometry(K.radius, K.tube, K.tubularSegments, K.radialSegments, K.p, K.q) } } class TubeGeometry extends BufferGeometry { constructor(K = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), pe = 64, me = 1, ge = 8, xe = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: K, tubularSegments: pe, radius: me, radialSegments: ge, closed: xe }; const ye = K.computeFrenetFrames(pe, xe); this.tangents = ye.tangents, this.normals = ye.normals, this.binormals = ye.binormals; const ve = new Vector3, _e = new Vector3, Ee = new Vector2; let be = new Vector3; const Ae = [], Se = [], Ce = [], we = []; Be(), this.setIndex(we), this.setAttribute("position", new Float32BufferAttribute(Ae, 3)), this.setAttribute("normal", new Float32BufferAttribute(Se, 3)), this.setAttribute("uv", new Float32BufferAttribute(Ce, 2)); function Be() { for (let Pe = 0; Pe < pe; Pe++)De(Pe); De(xe === !1 ? pe : 0), Ie(), Re() } function De(Pe) { be = K.getPointAt(Pe / pe, be); const Ne = ye.normals[Pe], ke = ye.binormals[Pe]; for (let Oe = 0; Oe <= ge; Oe++) { const Ue = Oe / ge * Math.PI * 2, He = Math.sin(Ue), Ge = -Math.cos(Ue); _e.x = Ge * Ne.x + He * ke.x, _e.y = Ge * Ne.y + He * ke.y, _e.z = Ge * Ne.z + He * ke.z, _e.normalize(), Se.push(_e.x, _e.y, _e.z), ve.x = be.x + me * _e.x, ve.y = be.y + me * _e.y, ve.z = be.z + me * _e.z, Ae.push(ve.x, ve.y, ve.z) } } function Re() { for (let Pe = 1; Pe <= pe; Pe++)for (let Ne = 1; Ne <= ge; Ne++) { const ke = (ge + 1) * (Pe - 1) + (Ne - 1), Oe = (ge + 1) * Pe + (Ne - 1), Ue = (ge + 1) * Pe + Ne, He = (ge + 1) * (Pe - 1) + Ne; we.push(ke, Oe, He), we.push(Oe, Ue, He) } } function Ie() { for (let Pe = 0; Pe <= pe; Pe++)for (let Ne = 0; Ne <= ge; Ne++)Ee.x = Pe / pe, Ee.y = Ne / ge, Ce.push(Ee.x, Ee.y) } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } toJSON() { const K = super.toJSON(); return K.path = this.parameters.path.toJSON(), K } static fromJSON(K) { return new TubeGeometry(new Curves[K.path.type]().fromJSON(K.path), K.tubularSegments, K.radius, K.radialSegments, K.closed) } } class WireframeGeometry extends BufferGeometry { constructor(K = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: K }, K !== null) { const pe = [], me = new Set, ge = new Vector3, xe = new Vector3; if (K.index !== null) { const ye = K.attributes.position, ve = K.index; let _e = K.groups; _e.length === 0 && (_e = [{ start: 0, count: ve.count, materialIndex: 0 }]); for (let Ee = 0, be = _e.length; Ee < be; ++Ee) { const Ae = _e[Ee], Se = Ae.start, Ce = Ae.count; for (let we = Se, Be = Se + Ce; we < Be; we += 3)for (let De = 0; De < 3; De++) { const Re = ve.getX(we + De), Ie = ve.getX(we + (De + 1) % 3); ge.fromBufferAttribute(ye, Re), xe.fromBufferAttribute(ye, Ie), isUniqueEdge(ge, xe, me) === !0 && (pe.push(ge.x, ge.y, ge.z), pe.push(xe.x, xe.y, xe.z)) } } } else { const ye = K.attributes.position; for (let ve = 0, _e = ye.count / 3; ve < _e; ve++)for (let Ee = 0; Ee < 3; Ee++) { const be = 3 * ve + Ee, Ae = 3 * ve + (Ee + 1) % 3; ge.fromBufferAttribute(ye, be), xe.fromBufferAttribute(ye, Ae), isUniqueEdge(ge, xe, me) === !0 && (pe.push(ge.x, ge.y, ge.z), pe.push(xe.x, xe.y, xe.z)) } } this.setAttribute("position", new Float32BufferAttribute(pe, 3)) } } copy(K) { return super.copy(K), this.parameters = Object.assign({}, K.parameters), this } } function isUniqueEdge(fe, K, pe) { const me = `${fe.x},${fe.y},${fe.z}-${K.x},${K.y},${K.z}`, ge = `${K.x},${K.y},${K.z}-${fe.x},${fe.y},${fe.z}`; return pe.has(me) === !0 || pe.has(ge) === !0 ? !1 : (pe.add(me), pe.add(ge), !0) } var Geometries = Object.freeze({ __proto__: null, BoxGeometry, CapsuleGeometry, CircleGeometry, ConeGeometry, CylinderGeometry, DodecahedronGeometry, EdgesGeometry, ExtrudeGeometry, IcosahedronGeometry, LatheGeometry, OctahedronGeometry, PlaneGeometry, PolyhedronGeometry, RingGeometry, ShapeGeometry, SphereGeometry, TetrahedronGeometry, TorusGeometry, TorusKnotGeometry, TubeGeometry, WireframeGeometry }); class ShadowMaterial extends Material { constructor(K) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Color$1(0), this.transparent = !0, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.fog = K.fog, this } } class RawShaderMaterial extends ShaderMaterial { constructor(K) { super(K), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class MeshStandardMaterial extends Material { constructor(K) { super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Color$1(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.defines = { STANDARD: "" }, this.color.copy(K.color), this.roughness = K.roughness, this.metalness = K.metalness, this.map = K.map, this.lightMap = K.lightMap, this.lightMapIntensity = K.lightMapIntensity, this.aoMap = K.aoMap, this.aoMapIntensity = K.aoMapIntensity, this.emissive.copy(K.emissive), this.emissiveMap = K.emissiveMap, this.emissiveIntensity = K.emissiveIntensity, this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.roughnessMap = K.roughnessMap, this.metalnessMap = K.metalnessMap, this.alphaMap = K.alphaMap, this.envMap = K.envMap, this.envMapRotation.copy(K.envMapRotation), this.envMapIntensity = K.envMapIntensity, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.wireframeLinecap = K.wireframeLinecap, this.wireframeLinejoin = K.wireframeLinejoin, this.flatShading = K.flatShading, this.fog = K.fog, this } } class MeshPhysicalMaterial extends MeshStandardMaterial { constructor(K) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return clamp$3(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (pe) { this.ior = (1 + .4 * pe) / (1 - .4 * pe) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Color$1(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color$1(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color$1(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(K) } get anisotropy() { return this._anisotropy } set anisotropy(K) { this._anisotropy > 0 != K > 0 && this.version++, this._anisotropy = K } get clearcoat() { return this._clearcoat } set clearcoat(K) { this._clearcoat > 0 != K > 0 && this.version++, this._clearcoat = K } get iridescence() { return this._iridescence } set iridescence(K) { this._iridescence > 0 != K > 0 && this.version++, this._iridescence = K } get dispersion() { return this._dispersion } set dispersion(K) { this._dispersion > 0 != K > 0 && this.version++, this._dispersion = K } get sheen() { return this._sheen } set sheen(K) { this._sheen > 0 != K > 0 && this.version++, this._sheen = K } get transmission() { return this._transmission } set transmission(K) { this._transmission > 0 != K > 0 && this.version++, this._transmission = K } copy(K) { return super.copy(K), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = K.anisotropy, this.anisotropyRotation = K.anisotropyRotation, this.anisotropyMap = K.anisotropyMap, this.clearcoat = K.clearcoat, this.clearcoatMap = K.clearcoatMap, this.clearcoatRoughness = K.clearcoatRoughness, this.clearcoatRoughnessMap = K.clearcoatRoughnessMap, this.clearcoatNormalMap = K.clearcoatNormalMap, this.clearcoatNormalScale.copy(K.clearcoatNormalScale), this.dispersion = K.dispersion, this.ior = K.ior, this.iridescence = K.iridescence, this.iridescenceMap = K.iridescenceMap, this.iridescenceIOR = K.iridescenceIOR, this.iridescenceThicknessRange = [...K.iridescenceThicknessRange], this.iridescenceThicknessMap = K.iridescenceThicknessMap, this.sheen = K.sheen, this.sheenColor.copy(K.sheenColor), this.sheenColorMap = K.sheenColorMap, this.sheenRoughness = K.sheenRoughness, this.sheenRoughnessMap = K.sheenRoughnessMap, this.transmission = K.transmission, this.transmissionMap = K.transmissionMap, this.thickness = K.thickness, this.thicknessMap = K.thicknessMap, this.attenuationDistance = K.attenuationDistance, this.attenuationColor.copy(K.attenuationColor), this.specularIntensity = K.specularIntensity, this.specularIntensityMap = K.specularIntensityMap, this.specularColor.copy(K.specularColor), this.specularColorMap = K.specularColorMap, this } } class MeshPhongMaterial extends Material { constructor(K) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Color$1(16777215), this.specular = new Color$1(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.specular.copy(K.specular), this.shininess = K.shininess, this.map = K.map, this.lightMap = K.lightMap, this.lightMapIntensity = K.lightMapIntensity, this.aoMap = K.aoMap, this.aoMapIntensity = K.aoMapIntensity, this.emissive.copy(K.emissive), this.emissiveMap = K.emissiveMap, this.emissiveIntensity = K.emissiveIntensity, this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.specularMap = K.specularMap, this.alphaMap = K.alphaMap, this.envMap = K.envMap, this.envMapRotation.copy(K.envMapRotation), this.combine = K.combine, this.reflectivity = K.reflectivity, this.refractionRatio = K.refractionRatio, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.wireframeLinecap = K.wireframeLinecap, this.wireframeLinejoin = K.wireframeLinejoin, this.flatShading = K.flatShading, this.fog = K.fog, this } } class MeshToonMaterial extends Material { constructor(K) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color$1(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.gradientMap = K.gradientMap, this.lightMap = K.lightMap, this.lightMapIntensity = K.lightMapIntensity, this.aoMap = K.aoMap, this.aoMapIntensity = K.aoMapIntensity, this.emissive.copy(K.emissive), this.emissiveMap = K.emissiveMap, this.emissiveIntensity = K.emissiveIntensity, this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.alphaMap = K.alphaMap, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.wireframeLinecap = K.wireframeLinecap, this.wireframeLinejoin = K.wireframeLinejoin, this.fog = K.fog, this } } class MeshNormalMaterial extends Material { constructor(K) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(K) } copy(K) { return super.copy(K), this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.flatShading = K.flatShading, this } } class MeshLambertMaterial extends Material { constructor(K) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Color$1(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.color.copy(K.color), this.map = K.map, this.lightMap = K.lightMap, this.lightMapIntensity = K.lightMapIntensity, this.aoMap = K.aoMap, this.aoMapIntensity = K.aoMapIntensity, this.emissive.copy(K.emissive), this.emissiveMap = K.emissiveMap, this.emissiveIntensity = K.emissiveIntensity, this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.specularMap = K.specularMap, this.alphaMap = K.alphaMap, this.envMap = K.envMap, this.envMapRotation.copy(K.envMapRotation), this.combine = K.combine, this.reflectivity = K.reflectivity, this.refractionRatio = K.refractionRatio, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this.wireframeLinecap = K.wireframeLinecap, this.wireframeLinejoin = K.wireframeLinejoin, this.flatShading = K.flatShading, this.fog = K.fog, this } } class MeshDepthMaterial extends Material { constructor(K) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(K) } copy(K) { return super.copy(K), this.depthPacking = K.depthPacking, this.map = K.map, this.alphaMap = K.alphaMap, this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.wireframe = K.wireframe, this.wireframeLinewidth = K.wireframeLinewidth, this } } class MeshDistanceMaterial extends Material { constructor(K) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(K) } copy(K) { return super.copy(K), this.map = K.map, this.alphaMap = K.alphaMap, this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this } } class MeshMatcapMaterial extends Material { constructor(K) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color$1(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(K) } copy(K) { return super.copy(K), this.defines = { MATCAP: "" }, this.color.copy(K.color), this.matcap = K.matcap, this.map = K.map, this.bumpMap = K.bumpMap, this.bumpScale = K.bumpScale, this.normalMap = K.normalMap, this.normalMapType = K.normalMapType, this.normalScale.copy(K.normalScale), this.displacementMap = K.displacementMap, this.displacementScale = K.displacementScale, this.displacementBias = K.displacementBias, this.alphaMap = K.alphaMap, this.flatShading = K.flatShading, this.fog = K.fog, this } } class LineDashedMaterial extends LineBasicMaterial { constructor(K) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(K) } copy(K) { return super.copy(K), this.scale = K.scale, this.dashSize = K.dashSize, this.gapSize = K.gapSize, this } } function convertArray(fe, K, pe) { return !fe || !pe && fe.constructor === K ? fe : typeof K.BYTES_PER_ELEMENT == "number" ? new K(fe) : Array.prototype.slice.call(fe) } function isTypedArray(fe) { return ArrayBuffer.isView(fe) && !(fe instanceof DataView) } function getKeyframeOrder(fe) { function K(ge, xe) { return fe[ge] - fe[xe] } const pe = fe.length, me = new Array(pe); for (let ge = 0; ge !== pe; ++ge)me[ge] = ge; return me.sort(K), me } function sortedArray(fe, K, pe) { const me = fe.length, ge = new fe.constructor(me); for (let xe = 0, ye = 0; ye !== me; ++xe) { const ve = pe[xe] * K; for (let _e = 0; _e !== K; ++_e)ge[ye++] = fe[ve + _e] } return ge } function flattenJSON(fe, K, pe, me) { let ge = 1, xe = fe[0]; for (; xe !== void 0 && xe[me] === void 0;)xe = fe[ge++]; if (xe === void 0) return; let ye = xe[me]; if (ye !== void 0) if (Array.isArray(ye)) do ye = xe[me], ye !== void 0 && (K.push(xe.time), pe.push(...ye)), xe = fe[ge++]; while (xe !== void 0); else if (ye.toArray !== void 0) do ye = xe[me], ye !== void 0 && (K.push(xe.time), ye.toArray(pe, pe.length)), xe = fe[ge++]; while (xe !== void 0); else do ye = xe[me], ye !== void 0 && (K.push(xe.time), pe.push(ye)), xe = fe[ge++]; while (xe !== void 0) } function subclip(fe, K, pe, me, ge = 30) { const xe = fe.clone(); xe.name = K; const ye = []; for (let _e = 0; _e < xe.tracks.length; ++_e) { const Ee = xe.tracks[_e], be = Ee.getValueSize(), Ae = [], Se = []; for (let Ce = 0; Ce < Ee.times.length; ++Ce) { const we = Ee.times[Ce] * ge; if (!(we < pe || we >= me)) { Ae.push(Ee.times[Ce]); for (let Be = 0; Be < be; ++Be)Se.push(Ee.values[Ce * be + Be]) } } Ae.length !== 0 && (Ee.times = convertArray(Ae, Ee.times.constructor), Ee.values = convertArray(Se, Ee.values.constructor), ye.push(Ee)) } xe.tracks = ye; let ve = 1 / 0; for (let _e = 0; _e < xe.tracks.length; ++_e)ve > xe.tracks[_e].times[0] && (ve = xe.tracks[_e].times[0]); for (let _e = 0; _e < xe.tracks.length; ++_e)xe.tracks[_e].shift(-1 * ve); return xe.resetDuration(), xe } function makeClipAdditive(fe, K = 0, pe = fe, me = 30) { me <= 0 && (me = 30); const ge = pe.tracks.length, xe = K / me; for (let ye = 0; ye < ge; ++ye) { const ve = pe.tracks[ye], _e = ve.ValueTypeName; if (_e === "bool" || _e === "string") continue; const Ee = fe.tracks.find(function (Re) { return Re.name === ve.name && Re.ValueTypeName === _e }); if (Ee === void 0) continue; let be = 0; const Ae = ve.getValueSize(); ve.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (be = Ae / 3); let Se = 0; const Ce = Ee.getValueSize(); Ee.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (Se = Ce / 3); const we = ve.times.length - 1; let Be; if (xe <= ve.times[0]) { const Re = be, Ie = Ae - be; Be = ve.values.slice(Re, Ie) } else if (xe >= ve.times[we]) { const Re = we * Ae + be, Ie = Re + Ae - be; Be = ve.values.slice(Re, Ie) } else { const Re = ve.createInterpolant(), Ie = be, Pe = Ae - be; Re.evaluate(xe), Be = Re.resultBuffer.slice(Ie, Pe) } _e === "quaternion" && new Quaternion().fromArray(Be).normalize().conjugate().toArray(Be); const De = Ee.times.length; for (let Re = 0; Re < De; ++Re) { const Ie = Re * Ce + Se; if (_e === "quaternion") Quaternion.multiplyQuaternionsFlat(Ee.values, Ie, Be, 0, Ee.values, Ie); else { const Pe = Ce - Se * 2; for (let Ne = 0; Ne < Pe; ++Ne)Ee.values[Ie + Ne] -= Be[Ne] } } } return fe.blendMode = AdditiveAnimationBlendMode, fe } const AnimationUtils = { convertArray, isTypedArray, getKeyframeOrder, sortedArray, flattenJSON, subclip, makeClipAdditive }; class Interpolant { constructor(K, pe, me, ge) { this.parameterPositions = K, this._cachedIndex = 0, this.resultBuffer = ge !== void 0 ? ge : new pe.constructor(me), this.sampleValues = pe, this.valueSize = me, this.settings = null, this.DefaultSettings_ = {} } evaluate(K) { const pe = this.parameterPositions; let me = this._cachedIndex, ge = pe[me], xe = pe[me - 1]; e: { t: { let ye; n: { r: if (!(K < ge)) { for (let ve = me + 2; ;) { if (ge === void 0) { if (K < xe) break r; return me = pe.length, this._cachedIndex = me, this.copySampleValue_(me - 1) } if (me === ve) break; if (xe = ge, ge = pe[++me], K < ge) break t } ye = pe.length; break n } if (!(K >= xe)) { const ve = pe[1]; K < ve && (me = 2, xe = ve); for (let _e = me - 2; ;) { if (xe === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (me === _e) break; if (ge = xe, xe = pe[--me - 1], K >= xe) break t } ye = me, me = 0; break n } break e } for (; me < ye;) { const ve = me + ye >>> 1; K < pe[ve] ? ye = ve : me = ve + 1 } if (ge = pe[me], xe = pe[me - 1], xe === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (ge === void 0) return me = pe.length, this._cachedIndex = me, this.copySampleValue_(me - 1) } this._cachedIndex = me, this.intervalChanged_(me, xe, ge) } return this.interpolate_(me, xe, K, ge) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(K) { const pe = this.resultBuffer, me = this.sampleValues, ge = this.valueSize, xe = K * ge; for (let ye = 0; ye !== ge; ++ye)pe[ye] = me[xe + ye]; return pe } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class CubicInterpolant extends Interpolant { constructor(K, pe, me, ge) { super(K, pe, me, ge), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding } } intervalChanged_(K, pe, me) { const ge = this.parameterPositions; let xe = K - 2, ye = K + 1, ve = ge[xe], _e = ge[ye]; if (ve === void 0) switch (this.getSettings_().endingStart) { case ZeroSlopeEnding: xe = K, ve = 2 * pe - me; break; case WrapAroundEnding: xe = ge.length - 2, ve = pe + ge[xe] - ge[xe + 1]; break; default: xe = K, ve = me }if (_e === void 0) switch (this.getSettings_().endingEnd) { case ZeroSlopeEnding: ye = K, _e = 2 * me - pe; break; case WrapAroundEnding: ye = 1, _e = me + ge[1] - ge[0]; break; default: ye = K - 1, _e = pe }const Ee = (me - pe) * .5, be = this.valueSize; this._weightPrev = Ee / (pe - ve), this._weightNext = Ee / (_e - me), this._offsetPrev = xe * be, this._offsetNext = ye * be } interpolate_(K, pe, me, ge) { const xe = this.resultBuffer, ye = this.sampleValues, ve = this.valueSize, _e = K * ve, Ee = _e - ve, be = this._offsetPrev, Ae = this._offsetNext, Se = this._weightPrev, Ce = this._weightNext, we = (me - pe) / (ge - pe), Be = we * we, De = Be * we, Re = -Se * De + 2 * Se * Be - Se * we, Ie = (1 + Se) * De + (-1.5 - 2 * Se) * Be + (-.5 + Se) * we + 1, Pe = (-1 - Ce) * De + (1.5 + Ce) * Be + .5 * we, Ne = Ce * De - Ce * Be; for (let ke = 0; ke !== ve; ++ke)xe[ke] = Re * ye[be + ke] + Ie * ye[Ee + ke] + Pe * ye[_e + ke] + Ne * ye[Ae + ke]; return xe } } class LinearInterpolant extends Interpolant { constructor(K, pe, me, ge) { super(K, pe, me, ge) } interpolate_(K, pe, me, ge) { const xe = this.resultBuffer, ye = this.sampleValues, ve = this.valueSize, _e = K * ve, Ee = _e - ve, be = (me - pe) / (ge - pe), Ae = 1 - be; for (let Se = 0; Se !== ve; ++Se)xe[Se] = ye[Ee + Se] * Ae + ye[_e + Se] * be; return xe } } class DiscreteInterpolant extends Interpolant { constructor(K, pe, me, ge) { super(K, pe, me, ge) } interpolate_(K) { return this.copySampleValue_(K - 1) } } class KeyframeTrack { constructor(K, pe, me, ge) { if (K === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (pe === void 0 || pe.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + K); this.name = K, this.times = convertArray(pe, this.TimeBufferType), this.values = convertArray(me, this.ValueBufferType), this.setInterpolation(ge || this.DefaultInterpolation) } static toJSON(K) { const pe = K.constructor; let me; if (pe.toJSON !== this.toJSON) me = pe.toJSON(K); else { me = { name: K.name, times: convertArray(K.times, Array), values: convertArray(K.values, Array) }; const ge = K.getInterpolation(); ge !== K.DefaultInterpolation && (me.interpolation = ge) } return me.type = K.ValueTypeName, me } InterpolantFactoryMethodDiscrete(K) { return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), K) } InterpolantFactoryMethodLinear(K) { return new LinearInterpolant(this.times, this.values, this.getValueSize(), K) } InterpolantFactoryMethodSmooth(K) { return new CubicInterpolant(this.times, this.values, this.getValueSize(), K) } setInterpolation(K) { let pe; switch (K) { case InterpolateDiscrete: pe = this.InterpolantFactoryMethodDiscrete; break; case InterpolateLinear: pe = this.InterpolantFactoryMethodLinear; break; case InterpolateSmooth: pe = this.InterpolantFactoryMethodSmooth; break }if (pe === void 0) { const me = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (K !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(me); return console.warn("THREE.KeyframeTrack:", me), this } return this.createInterpolant = pe, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return InterpolateDiscrete; case this.InterpolantFactoryMethodLinear: return InterpolateLinear; case this.InterpolantFactoryMethodSmooth: return InterpolateSmooth } } getValueSize() { return this.values.length / this.times.length } shift(K) { if (K !== 0) { const pe = this.times; for (let me = 0, ge = pe.length; me !== ge; ++me)pe[me] += K } return this } scale(K) { if (K !== 1) { const pe = this.times; for (let me = 0, ge = pe.length; me !== ge; ++me)pe[me] *= K } return this } trim(K, pe) { const me = this.times, ge = me.length; let xe = 0, ye = ge - 1; for (; xe !== ge && me[xe] < K;)++xe; for (; ye !== -1 && me[ye] > pe;)--ye; if (++ye, xe !== 0 || ye !== ge) { xe >= ye && (ye = Math.max(ye, 1), xe = ye - 1); const ve = this.getValueSize(); this.times = me.slice(xe, ye), this.values = this.values.slice(xe * ve, ye * ve) } return this } validate() { let K = !0; const pe = this.getValueSize(); pe - Math.floor(pe) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), K = !1); const me = this.times, ge = this.values, xe = me.length; xe === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), K = !1); let ye = null; for (let ve = 0; ve !== xe; ve++) { const _e = me[ve]; if (typeof _e == "number" && isNaN(_e)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, ve, _e), K = !1; break } if (ye !== null && ye > _e) { console.error("THREE.KeyframeTrack: Out of order keys.", this, ve, _e, ye), K = !1; break } ye = _e } if (ge !== void 0 && isTypedArray(ge)) for (let ve = 0, _e = ge.length; ve !== _e; ++ve) { const Ee = ge[ve]; if (isNaN(Ee)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, ve, Ee), K = !1; break } } return K } optimize() { const K = this.times.slice(), pe = this.values.slice(), me = this.getValueSize(), ge = this.getInterpolation() === InterpolateSmooth, xe = K.length - 1; let ye = 1; for (let ve = 1; ve < xe; ++ve) { let _e = !1; const Ee = K[ve], be = K[ve + 1]; if (Ee !== be && (ve !== 1 || Ee !== K[0])) if (ge) _e = !0; else { const Ae = ve * me, Se = Ae - me, Ce = Ae + me; for (let we = 0; we !== me; ++we) { const Be = pe[Ae + we]; if (Be !== pe[Se + we] || Be !== pe[Ce + we]) { _e = !0; break } } } if (_e) { if (ve !== ye) { K[ye] = K[ve]; const Ae = ve * me, Se = ye * me; for (let Ce = 0; Ce !== me; ++Ce)pe[Se + Ce] = pe[Ae + Ce] } ++ye } } if (xe > 0) { K[ye] = K[xe]; for (let ve = xe * me, _e = ye * me, Ee = 0; Ee !== me; ++Ee)pe[_e + Ee] = pe[ve + Ee]; ++ye } return ye !== K.length ? (this.times = K.slice(0, ye), this.values = pe.slice(0, ye * me)) : (this.times = K, this.values = pe), this } clone() { const K = this.times.slice(), pe = this.values.slice(), me = this.constructor, ge = new me(this.name, K, pe); return ge.createInterpolant = this.createInterpolant, ge } } KeyframeTrack.prototype.TimeBufferType = Float32Array; KeyframeTrack.prototype.ValueBufferType = Float32Array; KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear; class BooleanKeyframeTrack extends KeyframeTrack { constructor(K, pe, me) { super(K, pe, me) } } BooleanKeyframeTrack.prototype.ValueTypeName = "bool"; BooleanKeyframeTrack.prototype.ValueBufferType = Array; BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete; BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0; BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class ColorKeyframeTrack extends KeyframeTrack { } ColorKeyframeTrack.prototype.ValueTypeName = "color"; class NumberKeyframeTrack extends KeyframeTrack { } NumberKeyframeTrack.prototype.ValueTypeName = "number"; class QuaternionLinearInterpolant extends Interpolant { constructor(K, pe, me, ge) { super(K, pe, me, ge) } interpolate_(K, pe, me, ge) { const xe = this.resultBuffer, ye = this.sampleValues, ve = this.valueSize, _e = (me - pe) / (ge - pe); let Ee = K * ve; for (let be = Ee + ve; Ee !== be; Ee += 4)Quaternion.slerpFlat(xe, 0, ye, Ee - ve, ye, Ee, _e); return xe } } class QuaternionKeyframeTrack extends KeyframeTrack { InterpolantFactoryMethodLinear(K) { return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), K) } } QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion"; QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class StringKeyframeTrack extends KeyframeTrack { constructor(K, pe, me) { super(K, pe, me) } } StringKeyframeTrack.prototype.ValueTypeName = "string"; StringKeyframeTrack.prototype.ValueBufferType = Array; StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete; StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0; StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class VectorKeyframeTrack extends KeyframeTrack { } VectorKeyframeTrack.prototype.ValueTypeName = "vector"; class AnimationClip { constructor(K = "", pe = -1, me = [], ge = NormalAnimationBlendMode) { this.name = K, this.tracks = me, this.duration = pe, this.blendMode = ge, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration() } static parse(K) { const pe = [], me = K.tracks, ge = 1 / (K.fps || 1); for (let ye = 0, ve = me.length; ye !== ve; ++ye)pe.push(parseKeyframeTrack(me[ye]).scale(ge)); const xe = new this(K.name, K.duration, pe, K.blendMode); return xe.uuid = K.uuid, xe } static toJSON(K) { const pe = [], me = K.tracks, ge = { name: K.name, duration: K.duration, tracks: pe, uuid: K.uuid, blendMode: K.blendMode }; for (let xe = 0, ye = me.length; xe !== ye; ++xe)pe.push(KeyframeTrack.toJSON(me[xe])); return ge } static CreateFromMorphTargetSequence(K, pe, me, ge) { const xe = pe.length, ye = []; for (let ve = 0; ve < xe; ve++) { let _e = [], Ee = []; _e.push((ve + xe - 1) % xe, ve, (ve + 1) % xe), Ee.push(0, 1, 0); const be = getKeyframeOrder(_e); _e = sortedArray(_e, 1, be), Ee = sortedArray(Ee, 1, be), !ge && _e[0] === 0 && (_e.push(xe), Ee.push(Ee[0])), ye.push(new NumberKeyframeTrack(".morphTargetInfluences[" + pe[ve].name + "]", _e, Ee).scale(1 / me)) } return new this(K, -1, ye) } static findByName(K, pe) { let me = K; if (!Array.isArray(K)) { const ge = K; me = ge.geometry && ge.geometry.animations || ge.animations } for (let ge = 0; ge < me.length; ge++)if (me[ge].name === pe) return me[ge]; return null } static CreateClipsFromMorphTargetSequences(K, pe, me) { const ge = {}, xe = /^([\w-]*?)([\d]+)$/; for (let ve = 0, _e = K.length; ve < _e; ve++) { const Ee = K[ve], be = Ee.name.match(xe); if (be && be.length > 1) { const Ae = be[1]; let Se = ge[Ae]; Se || (ge[Ae] = Se = []), Se.push(Ee) } } const ye = []; for (const ve in ge) ye.push(this.CreateFromMorphTargetSequence(ve, ge[ve], pe, me)); return ye } static parseAnimation(K, pe) { if (!K) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const me = function (Ae, Se, Ce, we, Be) { if (Ce.length !== 0) { const De = [], Re = []; flattenJSON(Ce, De, Re, we), De.length !== 0 && Be.push(new Ae(Se, De, Re)) } }, ge = [], xe = K.name || "default", ye = K.fps || 30, ve = K.blendMode; let _e = K.length || -1; const Ee = K.hierarchy || []; for (let Ae = 0; Ae < Ee.length; Ae++) { const Se = Ee[Ae].keys; if (!(!Se || Se.length === 0)) if (Se[0].morphTargets) { const Ce = {}; let we; for (we = 0; we < Se.length; we++)if (Se[we].morphTargets) for (let Be = 0; Be < Se[we].morphTargets.length; Be++)Ce[Se[we].morphTargets[Be]] = -1; for (const Be in Ce) { const De = [], Re = []; for (let Ie = 0; Ie !== Se[we].morphTargets.length; ++Ie) { const Pe = Se[we]; De.push(Pe.time), Re.push(Pe.morphTarget === Be ? 1 : 0) } ge.push(new NumberKeyframeTrack(".morphTargetInfluence[" + Be + "]", De, Re)) } _e = Ce.length * ye } else { const Ce = ".bones[" + pe[Ae].name + "]"; me(VectorKeyframeTrack, Ce + ".position", Se, "pos", ge), me(QuaternionKeyframeTrack, Ce + ".quaternion", Se, "rot", ge), me(VectorKeyframeTrack, Ce + ".scale", Se, "scl", ge) } } return ge.length === 0 ? null : new this(xe, _e, ge, ve) } resetDuration() { const K = this.tracks; let pe = 0; for (let me = 0, ge = K.length; me !== ge; ++me) { const xe = this.tracks[me]; pe = Math.max(pe, xe.times[xe.times.length - 1]) } return this.duration = pe, this } trim() { for (let K = 0; K < this.tracks.length; K++)this.tracks[K].trim(0, this.duration); return this } validate() { let K = !0; for (let pe = 0; pe < this.tracks.length; pe++)K = K && this.tracks[pe].validate(); return K } optimize() { for (let K = 0; K < this.tracks.length; K++)this.tracks[K].optimize(); return this } clone() { const K = []; for (let pe = 0; pe < this.tracks.length; pe++)K.push(this.tracks[pe].clone()); return new this.constructor(this.name, this.duration, K, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function getTrackTypeForValueTypeName(fe) { switch (fe.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return NumberKeyframeTrack; case "vector": case "vector2": case "vector3": case "vector4": return VectorKeyframeTrack; case "color": return ColorKeyframeTrack; case "quaternion": return QuaternionKeyframeTrack; case "bool": case "boolean": return BooleanKeyframeTrack; case "string": return StringKeyframeTrack }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + fe) } function parseKeyframeTrack(fe) { if (fe.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const K = getTrackTypeForValueTypeName(fe.type); if (fe.times === void 0) { const pe = [], me = []; flattenJSON(fe.keys, pe, me, "value"), fe.times = pe, fe.values = me } return K.parse !== void 0 ? K.parse(fe) : new K(fe.name, fe.times, fe.values, fe.interpolation) } const Cache = { enabled: !1, files: {}, add: function (fe, K) { this.enabled !== !1 && (this.files[fe] = K) }, get: function (fe) { if (this.enabled !== !1) return this.files[fe] }, remove: function (fe) { delete this.files[fe] }, clear: function () { this.files = {} } }; class LoadingManager { constructor(K, pe, me) { const ge = this; let xe = !1, ye = 0, ve = 0, _e; const Ee = []; this.onStart = void 0, this.onLoad = K, this.onProgress = pe, this.onError = me, this.itemStart = function (be) { ve++, xe === !1 && ge.onStart !== void 0 && ge.onStart(be, ye, ve), xe = !0 }, this.itemEnd = function (be) { ye++, ge.onProgress !== void 0 && ge.onProgress(be, ye, ve), ye === ve && (xe = !1, ge.onLoad !== void 0 && ge.onLoad()) }, this.itemError = function (be) { ge.onError !== void 0 && ge.onError(be) }, this.resolveURL = function (be) { return _e ? _e(be) : be }, this.setURLModifier = function (be) { return _e = be, this }, this.addHandler = function (be, Ae) { return Ee.push(be, Ae), this }, this.removeHandler = function (be) { const Ae = Ee.indexOf(be); return Ae !== -1 && Ee.splice(Ae, 2), this }, this.getHandler = function (be) { for (let Ae = 0, Se = Ee.length; Ae < Se; Ae += 2) { const Ce = Ee[Ae], we = Ee[Ae + 1]; if (Ce.global && (Ce.lastIndex = 0), Ce.test(be)) return we } return null } } } const DefaultLoadingManager = new LoadingManager; class Loader { constructor(K) { this.manager = K !== void 0 ? K : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(K, pe) { const me = this; return new Promise(function (ge, xe) { me.load(K, ge, pe, xe) }) } parse() { } setCrossOrigin(K) { return this.crossOrigin = K, this } setWithCredentials(K) { return this.withCredentials = K, this } setPath(K) { return this.path = K, this } setResourcePath(K) { return this.resourcePath = K, this } setRequestHeader(K) { return this.requestHeader = K, this } } Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const loading = {}; class HttpError extends Error { constructor(K, pe) { super(K), this.response = pe } } class FileLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { K === void 0 && (K = ""), this.path !== void 0 && (K = this.path + K), K = this.manager.resolveURL(K); const xe = Cache.get(K); if (xe !== void 0) return this.manager.itemStart(K), setTimeout(() => { pe && pe(xe), this.manager.itemEnd(K) }, 0), xe; if (loading[K] !== void 0) { loading[K].push({ onLoad: pe, onProgress: me, onError: ge }); return } loading[K] = [], loading[K].push({ onLoad: pe, onProgress: me, onError: ge }); const ye = new Request(K, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), ve = this.mimeType, _e = this.responseType; fetch(ye).then(Ee => { if (Ee.status === 200 || Ee.status === 0) { if (Ee.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || Ee.body === void 0 || Ee.body.getReader === void 0) return Ee; const be = loading[K], Ae = Ee.body.getReader(), Se = Ee.headers.get("X-File-Size") || Ee.headers.get("Content-Length"), Ce = Se ? parseInt(Se) : 0, we = Ce !== 0; let Be = 0; const De = new ReadableStream({ start(Re) { Ie(); function Ie() { Ae.read().then(({ done: Pe, value: Ne }) => { if (Pe) Re.close(); else { Be += Ne.byteLength; const ke = new ProgressEvent("progress", { lengthComputable: we, loaded: Be, total: Ce }); for (let Oe = 0, Ue = be.length; Oe < Ue; Oe++) { const He = be[Oe]; He.onProgress && He.onProgress(ke) } Re.enqueue(Ne), Ie() } }, Pe => { Re.error(Pe) }) } } }); return new Response(De) } else throw new HttpError(`fetch for "${Ee.url}" responded with ${Ee.status}: ${Ee.statusText}`, Ee) }).then(Ee => { switch (_e) { case "arraybuffer": return Ee.arrayBuffer(); case "blob": return Ee.blob(); case "document": return Ee.text().then(be => new DOMParser().parseFromString(be, ve)); case "json": return Ee.json(); default: if (ve === void 0) return Ee.text(); { const Ae = /charset="?([^;"\s]*)"?/i.exec(ve), Se = Ae && Ae[1] ? Ae[1].toLowerCase() : void 0, Ce = new TextDecoder(Se); return Ee.arrayBuffer().then(we => Ce.decode(we)) } } }).then(Ee => { Cache.add(K, Ee); const be = loading[K]; delete loading[K]; for (let Ae = 0, Se = be.length; Ae < Se; Ae++) { const Ce = be[Ae]; Ce.onLoad && Ce.onLoad(Ee) } }).catch(Ee => { const be = loading[K]; if (be === void 0) throw this.manager.itemError(K), Ee; delete loading[K]; for (let Ae = 0, Se = be.length; Ae < Se; Ae++) { const Ce = be[Ae]; Ce.onError && Ce.onError(Ee) } this.manager.itemError(K) }).finally(() => { this.manager.itemEnd(K) }), this.manager.itemStart(K) } setResponseType(K) { return this.responseType = K, this } setMimeType(K) { return this.mimeType = K, this } } class AnimationLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = new FileLoader(this.manager); ye.setPath(this.path), ye.setRequestHeader(this.requestHeader), ye.setWithCredentials(this.withCredentials), ye.load(K, function (ve) { try { pe(xe.parse(JSON.parse(ve))) } catch (_e) { ge ? ge(_e) : console.error(_e), xe.manager.itemError(K) } }, me, ge) } parse(K) { const pe = []; for (let me = 0; me < K.length; me++) { const ge = AnimationClip.parse(K[me]); pe.push(ge) } return pe } } class CompressedTextureLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = [], ve = new CompressedTexture, _e = new FileLoader(this.manager); _e.setPath(this.path), _e.setResponseType("arraybuffer"), _e.setRequestHeader(this.requestHeader), _e.setWithCredentials(xe.withCredentials); let Ee = 0; function be(Ae) { _e.load(K[Ae], function (Se) { const Ce = xe.parse(Se, !0); ye[Ae] = { width: Ce.width, height: Ce.height, format: Ce.format, mipmaps: Ce.mipmaps }, Ee += 1, Ee === 6 && (Ce.mipmapCount === 1 && (ve.minFilter = LinearFilter), ve.image = ye, ve.format = Ce.format, ve.needsUpdate = !0, pe && pe(ve)) }, me, ge) } if (Array.isArray(K)) for (let Ae = 0, Se = K.length; Ae < Se; ++Ae)be(Ae); else _e.load(K, function (Ae) { const Se = xe.parse(Ae, !0); if (Se.isCubemap) { const Ce = Se.mipmaps.length / Se.mipmapCount; for (let we = 0; we < Ce; we++) { ye[we] = { mipmaps: [] }; for (let Be = 0; Be < Se.mipmapCount; Be++)ye[we].mipmaps.push(Se.mipmaps[we * Se.mipmapCount + Be]), ye[we].format = Se.format, ye[we].width = Se.width, ye[we].height = Se.height } ve.image = ye } else ve.image.width = Se.width, ve.image.height = Se.height, ve.mipmaps = Se.mipmaps; Se.mipmapCount === 1 && (ve.minFilter = LinearFilter), ve.format = Se.format, ve.needsUpdate = !0, pe && pe(ve) }, me, ge); return ve } } class ImageLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { this.path !== void 0 && (K = this.path + K), K = this.manager.resolveURL(K); const xe = this, ye = Cache.get(K); if (ye !== void 0) return xe.manager.itemStart(K), setTimeout(function () { pe && pe(ye), xe.manager.itemEnd(K) }, 0), ye; const ve = createElementNS("img"); function _e() { be(), Cache.add(K, this), pe && pe(this), xe.manager.itemEnd(K) } function Ee(Ae) { be(), ge && ge(Ae), xe.manager.itemError(K), xe.manager.itemEnd(K) } function be() { ve.removeEventListener("load", _e, !1), ve.removeEventListener("error", Ee, !1) } return ve.addEventListener("load", _e, !1), ve.addEventListener("error", Ee, !1), K.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (ve.crossOrigin = this.crossOrigin), xe.manager.itemStart(K), ve.src = K, ve } } class CubeTextureLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = new CubeTexture; xe.colorSpace = SRGBColorSpace; const ye = new ImageLoader(this.manager); ye.setCrossOrigin(this.crossOrigin), ye.setPath(this.path); let ve = 0; function _e(Ee) { ye.load(K[Ee], function (be) { xe.images[Ee] = be, ve++, ve === 6 && (xe.needsUpdate = !0, pe && pe(xe)) }, void 0, ge) } for (let Ee = 0; Ee < K.length; ++Ee)_e(Ee); return xe } } class DataTextureLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = new DataTexture, ve = new FileLoader(this.manager); return ve.setResponseType("arraybuffer"), ve.setRequestHeader(this.requestHeader), ve.setPath(this.path), ve.setWithCredentials(xe.withCredentials), ve.load(K, function (_e) { let Ee; try { Ee = xe.parse(_e) } catch (be) { if (ge !== void 0) ge(be); else { console.error(be); return } } Ee.image !== void 0 ? ye.image = Ee.image : Ee.data !== void 0 && (ye.image.width = Ee.width, ye.image.height = Ee.height, ye.image.data = Ee.data), ye.wrapS = Ee.wrapS !== void 0 ? Ee.wrapS : ClampToEdgeWrapping, ye.wrapT = Ee.wrapT !== void 0 ? Ee.wrapT : ClampToEdgeWrapping, ye.magFilter = Ee.magFilter !== void 0 ? Ee.magFilter : LinearFilter, ye.minFilter = Ee.minFilter !== void 0 ? Ee.minFilter : LinearFilter, ye.anisotropy = Ee.anisotropy !== void 0 ? Ee.anisotropy : 1, Ee.colorSpace !== void 0 && (ye.colorSpace = Ee.colorSpace), Ee.flipY !== void 0 && (ye.flipY = Ee.flipY), Ee.format !== void 0 && (ye.format = Ee.format), Ee.type !== void 0 && (ye.type = Ee.type), Ee.mipmaps !== void 0 && (ye.mipmaps = Ee.mipmaps, ye.minFilter = LinearMipmapLinearFilter), Ee.mipmapCount === 1 && (ye.minFilter = LinearFilter), Ee.generateMipmaps !== void 0 && (ye.generateMipmaps = Ee.generateMipmaps), ye.needsUpdate = !0, pe && pe(ye, Ee) }, me, ge), ye } } class TextureLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = new Texture, ye = new ImageLoader(this.manager); return ye.setCrossOrigin(this.crossOrigin), ye.setPath(this.path), ye.load(K, function (ve) { xe.image = ve, xe.needsUpdate = !0, pe !== void 0 && pe(xe) }, me, ge), xe } } class Light extends Object3D { constructor(K, pe = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Color$1(K), this.intensity = pe } dispose() { } copy(K, pe) { return super.copy(K, pe), this.color.copy(K.color), this.intensity = K.intensity, this } toJSON(K) { const pe = super.toJSON(K); return pe.object.color = this.color.getHex(), pe.object.intensity = this.intensity, this.groundColor !== void 0 && (pe.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (pe.object.distance = this.distance), this.angle !== void 0 && (pe.object.angle = this.angle), this.decay !== void 0 && (pe.object.decay = this.decay), this.penumbra !== void 0 && (pe.object.penumbra = this.penumbra), this.shadow !== void 0 && (pe.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (pe.object.target = this.target.uuid), pe } } class HemisphereLight extends Light { constructor(K, pe, me) { super(K, me), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Color$1(pe) } copy(K, pe) { return super.copy(K, pe), this.groundColor.copy(K.groundColor), this } } const _projScreenMatrix$1 = new Matrix4, _lightPositionWorld$1 = new Vector3, _lookTarget$1 = new Vector3; class LightShadow { constructor(K) { this.camera = K, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(K) { const pe = this.camera, me = this.matrix; _lightPositionWorld$1.setFromMatrixPosition(K.matrixWorld), pe.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(K.target.matrixWorld), pe.lookAt(_lookTarget$1), pe.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(pe.projectionMatrix, pe.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), me.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), me.multiply(_projScreenMatrix$1) } getViewport(K) { return this._viewports[K] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(K) { return this.camera = K.camera.clone(), this.intensity = K.intensity, this.bias = K.bias, this.radius = K.radius, this.mapSize.copy(K.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const K = {}; return this.intensity !== 1 && (K.intensity = this.intensity), this.bias !== 0 && (K.bias = this.bias), this.normalBias !== 0 && (K.normalBias = this.normalBias), this.radius !== 1 && (K.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (K.mapSize = this.mapSize.toArray()), K.camera = this.camera.toJSON(!1).object, delete K.camera.matrix, K } } class SpotLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(K) { const pe = this.camera, me = RAD2DEG * 2 * K.angle * this.focus, ge = this.mapSize.width / this.mapSize.height, xe = K.distance || pe.far; (me !== pe.fov || ge !== pe.aspect || xe !== pe.far) && (pe.fov = me, pe.aspect = ge, pe.far = xe, pe.updateProjectionMatrix()), super.updateMatrices(K) } copy(K) { return super.copy(K), this.focus = K.focus, this } } class SpotLight extends Light { constructor(K, pe, me = 0, ge = Math.PI / 3, xe = 0, ye = 2) { super(K, pe), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.distance = me, this.angle = ge, this.penumbra = xe, this.decay = ye, this.map = null, this.shadow = new SpotLightShadow } get power() { return this.intensity * Math.PI } set power(K) { this.intensity = K / Math.PI } dispose() { this.shadow.dispose() } copy(K, pe) { return super.copy(K, pe), this.distance = K.distance, this.angle = K.angle, this.penumbra = K.penumbra, this.decay = K.decay, this.target = K.target.clone(), this.shadow = K.shadow.clone(), this } } const _projScreenMatrix = new Matrix4, _lightPositionWorld = new Vector3, _lookTarget = new Vector3; class PointLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)] } updateMatrices(K, pe = 0) { const me = this.camera, ge = this.matrix, xe = K.distance || me.far; xe !== me.far && (me.far = xe, me.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(K.matrixWorld), me.position.copy(_lightPositionWorld), _lookTarget.copy(me.position), _lookTarget.add(this._cubeDirections[pe]), me.up.copy(this._cubeUps[pe]), me.lookAt(_lookTarget), me.updateMatrixWorld(), ge.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix) } } class PointLight extends Light { constructor(K, pe, me = 0, ge = 2) { super(K, pe), this.isPointLight = !0, this.type = "PointLight", this.distance = me, this.decay = ge, this.shadow = new PointLightShadow } get power() { return this.intensity * 4 * Math.PI } set power(K) { this.intensity = K / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(K, pe) { return super.copy(K, pe), this.distance = K.distance, this.decay = K.decay, this.shadow = K.shadow.clone(), this } } class OrthographicCamera extends Camera { constructor(K = -1, pe = 1, me = 1, ge = -1, xe = .1, ye = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = K, this.right = pe, this.top = me, this.bottom = ge, this.near = xe, this.far = ye, this.updateProjectionMatrix() } copy(K, pe) { return super.copy(K, pe), this.left = K.left, this.right = K.right, this.top = K.top, this.bottom = K.bottom, this.near = K.near, this.far = K.far, this.zoom = K.zoom, this.view = K.view === null ? null : Object.assign({}, K.view), this } setViewOffset(K, pe, me, ge, xe, ye) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = K, this.view.fullHeight = pe, this.view.offsetX = me, this.view.offsetY = ge, this.view.width = xe, this.view.height = ye, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const K = (this.right - this.left) / (2 * this.zoom), pe = (this.top - this.bottom) / (2 * this.zoom), me = (this.right + this.left) / 2, ge = (this.top + this.bottom) / 2; let xe = me - K, ye = me + K, ve = ge + pe, _e = ge - pe; if (this.view !== null && this.view.enabled) { const Ee = (this.right - this.left) / this.view.fullWidth / this.zoom, be = (this.top - this.bottom) / this.view.fullHeight / this.zoom; xe += Ee * this.view.offsetX, ye = xe + Ee * this.view.width, ve -= be * this.view.offsetY, _e = ve - be * this.view.height } this.projectionMatrix.makeOrthographic(xe, ye, ve, _e, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(K) { const pe = super.toJSON(K); return pe.object.zoom = this.zoom, pe.object.left = this.left, pe.object.right = this.right, pe.object.top = this.top, pe.object.bottom = this.bottom, pe.object.near = this.near, pe.object.far = this.far, this.view !== null && (pe.object.view = Object.assign({}, this.view)), pe } } class DirectionalLightShadow extends LightShadow { constructor() { super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class DirectionalLight extends Light { constructor(K, pe) { super(K, pe), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow } dispose() { this.shadow.dispose() } copy(K) { return super.copy(K), this.target = K.target.clone(), this.shadow = K.shadow.clone(), this } } class AmbientLight extends Light { constructor(K, pe) { super(K, pe), this.isAmbientLight = !0, this.type = "AmbientLight" } } class RectAreaLight extends Light { constructor(K, pe, me = 10, ge = 10) { super(K, pe), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = me, this.height = ge } get power() { return this.intensity * this.width * this.height * Math.PI } set power(K) { this.intensity = K / (this.width * this.height * Math.PI) } copy(K) { return super.copy(K), this.width = K.width, this.height = K.height, this } toJSON(K) { const pe = super.toJSON(K); return pe.object.width = this.width, pe.object.height = this.height, pe } } class SphericalHarmonics3 { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let K = 0; K < 9; K++)this.coefficients.push(new Vector3) } set(K) { for (let pe = 0; pe < 9; pe++)this.coefficients[pe].copy(K[pe]); return this } zero() { for (let K = 0; K < 9; K++)this.coefficients[K].set(0, 0, 0); return this } getAt(K, pe) { const me = K.x, ge = K.y, xe = K.z, ye = this.coefficients; return pe.copy(ye[0]).multiplyScalar(.282095), pe.addScaledVector(ye[1], .488603 * ge), pe.addScaledVector(ye[2], .488603 * xe), pe.addScaledVector(ye[3], .488603 * me), pe.addScaledVector(ye[4], 1.092548 * (me * ge)), pe.addScaledVector(ye[5], 1.092548 * (ge * xe)), pe.addScaledVector(ye[6], .315392 * (3 * xe * xe - 1)), pe.addScaledVector(ye[7], 1.092548 * (me * xe)), pe.addScaledVector(ye[8], .546274 * (me * me - ge * ge)), pe } getIrradianceAt(K, pe) { const me = K.x, ge = K.y, xe = K.z, ye = this.coefficients; return pe.copy(ye[0]).multiplyScalar(.886227), pe.addScaledVector(ye[1], 2 * .511664 * ge), pe.addScaledVector(ye[2], 2 * .511664 * xe), pe.addScaledVector(ye[3], 2 * .511664 * me), pe.addScaledVector(ye[4], 2 * .429043 * me * ge), pe.addScaledVector(ye[5], 2 * .429043 * ge * xe), pe.addScaledVector(ye[6], .743125 * xe * xe - .247708), pe.addScaledVector(ye[7], 2 * .429043 * me * xe), pe.addScaledVector(ye[8], .429043 * (me * me - ge * ge)), pe } add(K) { for (let pe = 0; pe < 9; pe++)this.coefficients[pe].add(K.coefficients[pe]); return this } addScaledSH(K, pe) { for (let me = 0; me < 9; me++)this.coefficients[me].addScaledVector(K.coefficients[me], pe); return this } scale(K) { for (let pe = 0; pe < 9; pe++)this.coefficients[pe].multiplyScalar(K); return this } lerp(K, pe) { for (let me = 0; me < 9; me++)this.coefficients[me].lerp(K.coefficients[me], pe); return this } equals(K) { for (let pe = 0; pe < 9; pe++)if (!this.coefficients[pe].equals(K.coefficients[pe])) return !1; return !0 } copy(K) { return this.set(K.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(K, pe = 0) { const me = this.coefficients; for (let ge = 0; ge < 9; ge++)me[ge].fromArray(K, pe + ge * 3); return this } toArray(K = [], pe = 0) { const me = this.coefficients; for (let ge = 0; ge < 9; ge++)me[ge].toArray(K, pe + ge * 3); return K } static getBasisAt(K, pe) { const me = K.x, ge = K.y, xe = K.z; pe[0] = .282095, pe[1] = .488603 * ge, pe[2] = .488603 * xe, pe[3] = .488603 * me, pe[4] = 1.092548 * me * ge, pe[5] = 1.092548 * ge * xe, pe[6] = .315392 * (3 * xe * xe - 1), pe[7] = 1.092548 * me * xe, pe[8] = .546274 * (me * me - ge * ge) } } class LightProbe extends Light { constructor(K = new SphericalHarmonics3, pe = 1) { super(void 0, pe), this.isLightProbe = !0, this.sh = K } copy(K) { return super.copy(K), this.sh.copy(K.sh), this } fromJSON(K) { return this.intensity = K.intensity, this.sh.fromArray(K.sh), this } toJSON(K) { const pe = super.toJSON(K); return pe.object.sh = this.sh.toArray(), pe } } class MaterialLoader extends Loader { constructor(K) { super(K), this.textures = {} } load(K, pe, me, ge) { const xe = this, ye = new FileLoader(xe.manager); ye.setPath(xe.path), ye.setRequestHeader(xe.requestHeader), ye.setWithCredentials(xe.withCredentials), ye.load(K, function (ve) { try { pe(xe.parse(JSON.parse(ve))) } catch (_e) { ge ? ge(_e) : console.error(_e), xe.manager.itemError(K) } }, me, ge) } parse(K) { const pe = this.textures; function me(xe) { return pe[xe] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", xe), pe[xe] } const ge = this.createMaterialFromType(K.type); if (K.uuid !== void 0 && (ge.uuid = K.uuid), K.name !== void 0 && (ge.name = K.name), K.color !== void 0 && ge.color !== void 0 && ge.color.setHex(K.color), K.roughness !== void 0 && (ge.roughness = K.roughness), K.metalness !== void 0 && (ge.metalness = K.metalness), K.sheen !== void 0 && (ge.sheen = K.sheen), K.sheenColor !== void 0 && (ge.sheenColor = new Color$1().setHex(K.sheenColor)), K.sheenRoughness !== void 0 && (ge.sheenRoughness = K.sheenRoughness), K.emissive !== void 0 && ge.emissive !== void 0 && ge.emissive.setHex(K.emissive), K.specular !== void 0 && ge.specular !== void 0 && ge.specular.setHex(K.specular), K.specularIntensity !== void 0 && (ge.specularIntensity = K.specularIntensity), K.specularColor !== void 0 && ge.specularColor !== void 0 && ge.specularColor.setHex(K.specularColor), K.shininess !== void 0 && (ge.shininess = K.shininess), K.clearcoat !== void 0 && (ge.clearcoat = K.clearcoat), K.clearcoatRoughness !== void 0 && (ge.clearcoatRoughness = K.clearcoatRoughness), K.dispersion !== void 0 && (ge.dispersion = K.dispersion), K.iridescence !== void 0 && (ge.iridescence = K.iridescence), K.iridescenceIOR !== void 0 && (ge.iridescenceIOR = K.iridescenceIOR), K.iridescenceThicknessRange !== void 0 && (ge.iridescenceThicknessRange = K.iridescenceThicknessRange), K.transmission !== void 0 && (ge.transmission = K.transmission), K.thickness !== void 0 && (ge.thickness = K.thickness), K.attenuationDistance !== void 0 && (ge.attenuationDistance = K.attenuationDistance), K.attenuationColor !== void 0 && ge.attenuationColor !== void 0 && ge.attenuationColor.setHex(K.attenuationColor), K.anisotropy !== void 0 && (ge.anisotropy = K.anisotropy), K.anisotropyRotation !== void 0 && (ge.anisotropyRotation = K.anisotropyRotation), K.fog !== void 0 && (ge.fog = K.fog), K.flatShading !== void 0 && (ge.flatShading = K.flatShading), K.blending !== void 0 && (ge.blending = K.blending), K.combine !== void 0 && (ge.combine = K.combine), K.side !== void 0 && (ge.side = K.side), K.shadowSide !== void 0 && (ge.shadowSide = K.shadowSide), K.opacity !== void 0 && (ge.opacity = K.opacity), K.transparent !== void 0 && (ge.transparent = K.transparent), K.alphaTest !== void 0 && (ge.alphaTest = K.alphaTest), K.alphaHash !== void 0 && (ge.alphaHash = K.alphaHash), K.depthFunc !== void 0 && (ge.depthFunc = K.depthFunc), K.depthTest !== void 0 && (ge.depthTest = K.depthTest), K.depthWrite !== void 0 && (ge.depthWrite = K.depthWrite), K.colorWrite !== void 0 && (ge.colorWrite = K.colorWrite), K.blendSrc !== void 0 && (ge.blendSrc = K.blendSrc), K.blendDst !== void 0 && (ge.blendDst = K.blendDst), K.blendEquation !== void 0 && (ge.blendEquation = K.blendEquation), K.blendSrcAlpha !== void 0 && (ge.blendSrcAlpha = K.blendSrcAlpha), K.blendDstAlpha !== void 0 && (ge.blendDstAlpha = K.blendDstAlpha), K.blendEquationAlpha !== void 0 && (ge.blendEquationAlpha = K.blendEquationAlpha), K.blendColor !== void 0 && ge.blendColor !== void 0 && ge.blendColor.setHex(K.blendColor), K.blendAlpha !== void 0 && (ge.blendAlpha = K.blendAlpha), K.stencilWriteMask !== void 0 && (ge.stencilWriteMask = K.stencilWriteMask), K.stencilFunc !== void 0 && (ge.stencilFunc = K.stencilFunc), K.stencilRef !== void 0 && (ge.stencilRef = K.stencilRef), K.stencilFuncMask !== void 0 && (ge.stencilFuncMask = K.stencilFuncMask), K.stencilFail !== void 0 && (ge.stencilFail = K.stencilFail), K.stencilZFail !== void 0 && (ge.stencilZFail = K.stencilZFail), K.stencilZPass !== void 0 && (ge.stencilZPass = K.stencilZPass), K.stencilWrite !== void 0 && (ge.stencilWrite = K.stencilWrite), K.wireframe !== void 0 && (ge.wireframe = K.wireframe), K.wireframeLinewidth !== void 0 && (ge.wireframeLinewidth = K.wireframeLinewidth), K.wireframeLinecap !== void 0 && (ge.wireframeLinecap = K.wireframeLinecap), K.wireframeLinejoin !== void 0 && (ge.wireframeLinejoin = K.wireframeLinejoin), K.rotation !== void 0 && (ge.rotation = K.rotation), K.linewidth !== void 0 && (ge.linewidth = K.linewidth), K.dashSize !== void 0 && (ge.dashSize = K.dashSize), K.gapSize !== void 0 && (ge.gapSize = K.gapSize), K.scale !== void 0 && (ge.scale = K.scale), K.polygonOffset !== void 0 && (ge.polygonOffset = K.polygonOffset), K.polygonOffsetFactor !== void 0 && (ge.polygonOffsetFactor = K.polygonOffsetFactor), K.polygonOffsetUnits !== void 0 && (ge.polygonOffsetUnits = K.polygonOffsetUnits), K.dithering !== void 0 && (ge.dithering = K.dithering), K.alphaToCoverage !== void 0 && (ge.alphaToCoverage = K.alphaToCoverage), K.premultipliedAlpha !== void 0 && (ge.premultipliedAlpha = K.premultipliedAlpha), K.forceSinglePass !== void 0 && (ge.forceSinglePass = K.forceSinglePass), K.visible !== void 0 && (ge.visible = K.visible), K.toneMapped !== void 0 && (ge.toneMapped = K.toneMapped), K.userData !== void 0 && (ge.userData = K.userData), K.vertexColors !== void 0 && (typeof K.vertexColors == "number" ? ge.vertexColors = K.vertexColors > 0 : ge.vertexColors = K.vertexColors), K.uniforms !== void 0) for (const xe in K.uniforms) { const ye = K.uniforms[xe]; switch (ge.uniforms[xe] = {}, ye.type) { case "t": ge.uniforms[xe].value = me(ye.value); break; case "c": ge.uniforms[xe].value = new Color$1().setHex(ye.value); break; case "v2": ge.uniforms[xe].value = new Vector2().fromArray(ye.value); break; case "v3": ge.uniforms[xe].value = new Vector3().fromArray(ye.value); break; case "v4": ge.uniforms[xe].value = new Vector4().fromArray(ye.value); break; case "m3": ge.uniforms[xe].value = new Matrix3().fromArray(ye.value); break; case "m4": ge.uniforms[xe].value = new Matrix4().fromArray(ye.value); break; default: ge.uniforms[xe].value = ye.value } } if (K.defines !== void 0 && (ge.defines = K.defines), K.vertexShader !== void 0 && (ge.vertexShader = K.vertexShader), K.fragmentShader !== void 0 && (ge.fragmentShader = K.fragmentShader), K.glslVersion !== void 0 && (ge.glslVersion = K.glslVersion), K.extensions !== void 0) for (const xe in K.extensions) ge.extensions[xe] = K.extensions[xe]; if (K.lights !== void 0 && (ge.lights = K.lights), K.clipping !== void 0 && (ge.clipping = K.clipping), K.size !== void 0 && (ge.size = K.size), K.sizeAttenuation !== void 0 && (ge.sizeAttenuation = K.sizeAttenuation), K.map !== void 0 && (ge.map = me(K.map)), K.matcap !== void 0 && (ge.matcap = me(K.matcap)), K.alphaMap !== void 0 && (ge.alphaMap = me(K.alphaMap)), K.bumpMap !== void 0 && (ge.bumpMap = me(K.bumpMap)), K.bumpScale !== void 0 && (ge.bumpScale = K.bumpScale), K.normalMap !== void 0 && (ge.normalMap = me(K.normalMap)), K.normalMapType !== void 0 && (ge.normalMapType = K.normalMapType), K.normalScale !== void 0) { let xe = K.normalScale; Array.isArray(xe) === !1 && (xe = [xe, xe]), ge.normalScale = new Vector2().fromArray(xe) } return K.displacementMap !== void 0 && (ge.displacementMap = me(K.displacementMap)), K.displacementScale !== void 0 && (ge.displacementScale = K.displacementScale), K.displacementBias !== void 0 && (ge.displacementBias = K.displacementBias), K.roughnessMap !== void 0 && (ge.roughnessMap = me(K.roughnessMap)), K.metalnessMap !== void 0 && (ge.metalnessMap = me(K.metalnessMap)), K.emissiveMap !== void 0 && (ge.emissiveMap = me(K.emissiveMap)), K.emissiveIntensity !== void 0 && (ge.emissiveIntensity = K.emissiveIntensity), K.specularMap !== void 0 && (ge.specularMap = me(K.specularMap)), K.specularIntensityMap !== void 0 && (ge.specularIntensityMap = me(K.specularIntensityMap)), K.specularColorMap !== void 0 && (ge.specularColorMap = me(K.specularColorMap)), K.envMap !== void 0 && (ge.envMap = me(K.envMap)), K.envMapRotation !== void 0 && ge.envMapRotation.fromArray(K.envMapRotation), K.envMapIntensity !== void 0 && (ge.envMapIntensity = K.envMapIntensity), K.reflectivity !== void 0 && (ge.reflectivity = K.reflectivity), K.refractionRatio !== void 0 && (ge.refractionRatio = K.refractionRatio), K.lightMap !== void 0 && (ge.lightMap = me(K.lightMap)), K.lightMapIntensity !== void 0 && (ge.lightMapIntensity = K.lightMapIntensity), K.aoMap !== void 0 && (ge.aoMap = me(K.aoMap)), K.aoMapIntensity !== void 0 && (ge.aoMapIntensity = K.aoMapIntensity), K.gradientMap !== void 0 && (ge.gradientMap = me(K.gradientMap)), K.clearcoatMap !== void 0 && (ge.clearcoatMap = me(K.clearcoatMap)), K.clearcoatRoughnessMap !== void 0 && (ge.clearcoatRoughnessMap = me(K.clearcoatRoughnessMap)), K.clearcoatNormalMap !== void 0 && (ge.clearcoatNormalMap = me(K.clearcoatNormalMap)), K.clearcoatNormalScale !== void 0 && (ge.clearcoatNormalScale = new Vector2().fromArray(K.clearcoatNormalScale)), K.iridescenceMap !== void 0 && (ge.iridescenceMap = me(K.iridescenceMap)), K.iridescenceThicknessMap !== void 0 && (ge.iridescenceThicknessMap = me(K.iridescenceThicknessMap)), K.transmissionMap !== void 0 && (ge.transmissionMap = me(K.transmissionMap)), K.thicknessMap !== void 0 && (ge.thicknessMap = me(K.thicknessMap)), K.anisotropyMap !== void 0 && (ge.anisotropyMap = me(K.anisotropyMap)), K.sheenColorMap !== void 0 && (ge.sheenColorMap = me(K.sheenColorMap)), K.sheenRoughnessMap !== void 0 && (ge.sheenRoughnessMap = me(K.sheenRoughnessMap)), ge } setTextures(K) { return this.textures = K, this } createMaterialFromType(K) { return MaterialLoader.createMaterialFromType(K) } static createMaterialFromType(K) { const pe = { ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshBasicMaterial, MeshMatcapMaterial, LineDashedMaterial, LineBasicMaterial, Material }; return new pe[K] } } class LoaderUtils { static decodeText(K) { if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(K); let pe = ""; for (let me = 0, ge = K.length; me < ge; me++)pe += String.fromCharCode(K[me]); try { return decodeURIComponent(escape(pe)) } catch { return pe } } static extractUrlBase(K) { const pe = K.lastIndexOf("/"); return pe === -1 ? "./" : K.slice(0, pe + 1) } static resolveURL(K, pe) { return typeof K != "string" || K === "" ? "" : (/^https?:\/\//i.test(pe) && /^\//.test(K) && (pe = pe.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(K) || /^data:.*,.*$/i.test(K) || /^blob:.*$/i.test(K) ? K : pe + K) } } class InstancedBufferGeometry extends BufferGeometry { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(K) { return super.copy(K), this.instanceCount = K.instanceCount, this } toJSON() { const K = super.toJSON(); return K.instanceCount = this.instanceCount, K.isInstancedBufferGeometry = !0, K } } class BufferGeometryLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = new FileLoader(xe.manager); ye.setPath(xe.path), ye.setRequestHeader(xe.requestHeader), ye.setWithCredentials(xe.withCredentials), ye.load(K, function (ve) { try { pe(xe.parse(JSON.parse(ve))) } catch (_e) { ge ? ge(_e) : console.error(_e), xe.manager.itemError(K) } }, me, ge) } parse(K) { const pe = {}, me = {}; function ge(Ce, we) { if (pe[we] !== void 0) return pe[we]; const De = Ce.interleavedBuffers[we], Re = xe(Ce, De.buffer), Ie = getTypedArray(De.type, Re), Pe = new InterleavedBuffer(Ie, De.stride); return Pe.uuid = De.uuid, pe[we] = Pe, Pe } function xe(Ce, we) { if (me[we] !== void 0) return me[we]; const De = Ce.arrayBuffers[we], Re = new Uint32Array(De).buffer; return me[we] = Re, Re } const ye = K.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry, ve = K.data.index; if (ve !== void 0) { const Ce = getTypedArray(ve.type, ve.array); ye.setIndex(new BufferAttribute(Ce, 1)) } const _e = K.data.attributes; for (const Ce in _e) { const we = _e[Ce]; let Be; if (we.isInterleavedBufferAttribute) { const De = ge(K.data, we.data); Be = new InterleavedBufferAttribute(De, we.itemSize, we.offset, we.normalized) } else { const De = getTypedArray(we.type, we.array), Re = we.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute; Be = new Re(De, we.itemSize, we.normalized) } we.name !== void 0 && (Be.name = we.name), we.usage !== void 0 && Be.setUsage(we.usage), ye.setAttribute(Ce, Be) } const Ee = K.data.morphAttributes; if (Ee) for (const Ce in Ee) { const we = Ee[Ce], Be = []; for (let De = 0, Re = we.length; De < Re; De++) { const Ie = we[De]; let Pe; if (Ie.isInterleavedBufferAttribute) { const Ne = ge(K.data, Ie.data); Pe = new InterleavedBufferAttribute(Ne, Ie.itemSize, Ie.offset, Ie.normalized) } else { const Ne = getTypedArray(Ie.type, Ie.array); Pe = new BufferAttribute(Ne, Ie.itemSize, Ie.normalized) } Ie.name !== void 0 && (Pe.name = Ie.name), Be.push(Pe) } ye.morphAttributes[Ce] = Be } K.data.morphTargetsRelative && (ye.morphTargetsRelative = !0); const Ae = K.data.groups || K.data.drawcalls || K.data.offsets; if (Ae !== void 0) for (let Ce = 0, we = Ae.length; Ce !== we; ++Ce) { const Be = Ae[Ce]; ye.addGroup(Be.start, Be.count, Be.materialIndex) } const Se = K.data.boundingSphere; if (Se !== void 0) { const Ce = new Vector3; Se.center !== void 0 && Ce.fromArray(Se.center), ye.boundingSphere = new Sphere(Ce, Se.radius) } return K.name && (ye.name = K.name), K.userData && (ye.userData = K.userData), ye } } class ObjectLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = this.path === "" ? LoaderUtils.extractUrlBase(K) : this.path; this.resourcePath = this.resourcePath || ye; const ve = new FileLoader(this.manager); ve.setPath(this.path), ve.setRequestHeader(this.requestHeader), ve.setWithCredentials(this.withCredentials), ve.load(K, function (_e) { let Ee = null; try { Ee = JSON.parse(_e) } catch (Ae) { ge !== void 0 && ge(Ae), console.error("THREE:ObjectLoader: Can't parse " + K + ".", Ae.message); return } const be = Ee.metadata; if (be === void 0 || be.type === void 0 || be.type.toLowerCase() === "geometry") { ge !== void 0 && ge(new Error("THREE.ObjectLoader: Can't load " + K)), console.error("THREE.ObjectLoader: Can't load " + K); return } xe.parse(Ee, pe) }, me, ge) } async loadAsync(K, pe) { const me = this, ge = this.path === "" ? LoaderUtils.extractUrlBase(K) : this.path; this.resourcePath = this.resourcePath || ge; const xe = new FileLoader(this.manager); xe.setPath(this.path), xe.setRequestHeader(this.requestHeader), xe.setWithCredentials(this.withCredentials); const ye = await xe.loadAsync(K, pe), ve = JSON.parse(ye), _e = ve.metadata; if (_e === void 0 || _e.type === void 0 || _e.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + K); return await me.parseAsync(ve) } parse(K, pe) { const me = this.parseAnimations(K.animations), ge = this.parseShapes(K.shapes), xe = this.parseGeometries(K.geometries, ge), ye = this.parseImages(K.images, function () { pe !== void 0 && pe(Ee) }), ve = this.parseTextures(K.textures, ye), _e = this.parseMaterials(K.materials, ve), Ee = this.parseObject(K.object, xe, _e, ve, me), be = this.parseSkeletons(K.skeletons, Ee); if (this.bindSkeletons(Ee, be), this.bindLightTargets(Ee), pe !== void 0) { let Ae = !1; for (const Se in ye) if (ye[Se].data instanceof HTMLImageElement) { Ae = !0; break } Ae === !1 && pe(Ee) } return Ee } async parseAsync(K) { const pe = this.parseAnimations(K.animations), me = this.parseShapes(K.shapes), ge = this.parseGeometries(K.geometries, me), xe = await this.parseImagesAsync(K.images), ye = this.parseTextures(K.textures, xe), ve = this.parseMaterials(K.materials, ye), _e = this.parseObject(K.object, ge, ve, ye, pe), Ee = this.parseSkeletons(K.skeletons, _e); return this.bindSkeletons(_e, Ee), this.bindLightTargets(_e), _e } parseShapes(K) { const pe = {}; if (K !== void 0) for (let me = 0, ge = K.length; me < ge; me++) { const xe = new Shape().fromJSON(K[me]); pe[xe.uuid] = xe } return pe } parseSkeletons(K, pe) { const me = {}, ge = {}; if (pe.traverse(function (xe) { xe.isBone && (ge[xe.uuid] = xe) }), K !== void 0) for (let xe = 0, ye = K.length; xe < ye; xe++) { const ve = new Skeleton().fromJSON(K[xe], ge); me[ve.uuid] = ve } return me } parseGeometries(K, pe) { const me = {}; if (K !== void 0) { const ge = new BufferGeometryLoader; for (let xe = 0, ye = K.length; xe < ye; xe++) { let ve; const _e = K[xe]; switch (_e.type) { case "BufferGeometry": case "InstancedBufferGeometry": ve = ge.parse(_e); break; default: _e.type in Geometries ? ve = Geometries[_e.type].fromJSON(_e, pe) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${_e.type}"`) }ve.uuid = _e.uuid, _e.name !== void 0 && (ve.name = _e.name), _e.userData !== void 0 && (ve.userData = _e.userData), me[_e.uuid] = ve } } return me } parseMaterials(K, pe) { const me = {}, ge = {}; if (K !== void 0) { const xe = new MaterialLoader; xe.setTextures(pe); for (let ye = 0, ve = K.length; ye < ve; ye++) { const _e = K[ye]; me[_e.uuid] === void 0 && (me[_e.uuid] = xe.parse(_e)), ge[_e.uuid] = me[_e.uuid] } } return ge } parseAnimations(K) { const pe = {}; if (K !== void 0) for (let me = 0; me < K.length; me++) { const ge = K[me], xe = AnimationClip.parse(ge); pe[xe.uuid] = xe } return pe } parseImages(K, pe) { const me = this, ge = {}; let xe; function ye(_e) { return me.manager.itemStart(_e), xe.load(_e, function () { me.manager.itemEnd(_e) }, void 0, function () { me.manager.itemError(_e), me.manager.itemEnd(_e) }) } function ve(_e) { if (typeof _e == "string") { const Ee = _e, be = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(Ee) ? Ee : me.resourcePath + Ee; return ye(be) } else return _e.data ? { data: getTypedArray(_e.type, _e.data), width: _e.width, height: _e.height } : null } if (K !== void 0 && K.length > 0) { const _e = new LoadingManager(pe); xe = new ImageLoader(_e), xe.setCrossOrigin(this.crossOrigin); for (let Ee = 0, be = K.length; Ee < be; Ee++) { const Ae = K[Ee], Se = Ae.url; if (Array.isArray(Se)) { const Ce = []; for (let we = 0, Be = Se.length; we < Be; we++) { const De = Se[we], Re = ve(De); Re !== null && (Re instanceof HTMLImageElement ? Ce.push(Re) : Ce.push(new DataTexture(Re.data, Re.width, Re.height))) } ge[Ae.uuid] = new Source(Ce) } else { const Ce = ve(Ae.url); ge[Ae.uuid] = new Source(Ce) } } } return ge } async parseImagesAsync(K) { const pe = this, me = {}; let ge; async function xe(ye) { if (typeof ye == "string") { const ve = ye, _e = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(ve) ? ve : pe.resourcePath + ve; return await ge.loadAsync(_e) } else return ye.data ? { data: getTypedArray(ye.type, ye.data), width: ye.width, height: ye.height } : null } if (K !== void 0 && K.length > 0) { ge = new ImageLoader(this.manager), ge.setCrossOrigin(this.crossOrigin); for (let ye = 0, ve = K.length; ye < ve; ye++) { const _e = K[ye], Ee = _e.url; if (Array.isArray(Ee)) { const be = []; for (let Ae = 0, Se = Ee.length; Ae < Se; Ae++) { const Ce = Ee[Ae], we = await xe(Ce); we !== null && (we instanceof HTMLImageElement ? be.push(we) : be.push(new DataTexture(we.data, we.width, we.height))) } me[_e.uuid] = new Source(be) } else { const be = await xe(_e.url); me[_e.uuid] = new Source(be) } } } return me } parseTextures(K, pe) { function me(xe, ye) { return typeof xe == "number" ? xe : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", xe), ye[xe]) } const ge = {}; if (K !== void 0) for (let xe = 0, ye = K.length; xe < ye; xe++) { const ve = K[xe]; ve.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', ve.uuid), pe[ve.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", ve.image); const _e = pe[ve.image], Ee = _e.data; let be; Array.isArray(Ee) ? (be = new CubeTexture, Ee.length === 6 && (be.needsUpdate = !0)) : (Ee && Ee.data ? be = new DataTexture : be = new Texture, Ee && (be.needsUpdate = !0)), be.source = _e, be.uuid = ve.uuid, ve.name !== void 0 && (be.name = ve.name), ve.mapping !== void 0 && (be.mapping = me(ve.mapping, TEXTURE_MAPPING)), ve.channel !== void 0 && (be.channel = ve.channel), ve.offset !== void 0 && be.offset.fromArray(ve.offset), ve.repeat !== void 0 && be.repeat.fromArray(ve.repeat), ve.center !== void 0 && be.center.fromArray(ve.center), ve.rotation !== void 0 && (be.rotation = ve.rotation), ve.wrap !== void 0 && (be.wrapS = me(ve.wrap[0], TEXTURE_WRAPPING), be.wrapT = me(ve.wrap[1], TEXTURE_WRAPPING)), ve.format !== void 0 && (be.format = ve.format), ve.internalFormat !== void 0 && (be.internalFormat = ve.internalFormat), ve.type !== void 0 && (be.type = ve.type), ve.colorSpace !== void 0 && (be.colorSpace = ve.colorSpace), ve.minFilter !== void 0 && (be.minFilter = me(ve.minFilter, TEXTURE_FILTER)), ve.magFilter !== void 0 && (be.magFilter = me(ve.magFilter, TEXTURE_FILTER)), ve.anisotropy !== void 0 && (be.anisotropy = ve.anisotropy), ve.flipY !== void 0 && (be.flipY = ve.flipY), ve.generateMipmaps !== void 0 && (be.generateMipmaps = ve.generateMipmaps), ve.premultiplyAlpha !== void 0 && (be.premultiplyAlpha = ve.premultiplyAlpha), ve.unpackAlignment !== void 0 && (be.unpackAlignment = ve.unpackAlignment), ve.compareFunction !== void 0 && (be.compareFunction = ve.compareFunction), ve.userData !== void 0 && (be.userData = ve.userData), ge[ve.uuid] = be } return ge } parseObject(K, pe, me, ge, xe) { let ye; function ve(Se) { return pe[Se] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", Se), pe[Se] } function _e(Se) { if (Se !== void 0) { if (Array.isArray(Se)) { const Ce = []; for (let we = 0, Be = Se.length; we < Be; we++) { const De = Se[we]; me[De] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", De), Ce.push(me[De]) } return Ce } return me[Se] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", Se), me[Se] } } function Ee(Se) { return ge[Se] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", Se), ge[Se] } let be, Ae; switch (K.type) { case "Scene": ye = new Scene, K.background !== void 0 && (Number.isInteger(K.background) ? ye.background = new Color$1(K.background) : ye.background = Ee(K.background)), K.environment !== void 0 && (ye.environment = Ee(K.environment)), K.fog !== void 0 && (K.fog.type === "Fog" ? ye.fog = new Fog(K.fog.color, K.fog.near, K.fog.far) : K.fog.type === "FogExp2" && (ye.fog = new FogExp2(K.fog.color, K.fog.density)), K.fog.name !== "" && (ye.fog.name = K.fog.name)), K.backgroundBlurriness !== void 0 && (ye.backgroundBlurriness = K.backgroundBlurriness), K.backgroundIntensity !== void 0 && (ye.backgroundIntensity = K.backgroundIntensity), K.backgroundRotation !== void 0 && ye.backgroundRotation.fromArray(K.backgroundRotation), K.environmentIntensity !== void 0 && (ye.environmentIntensity = K.environmentIntensity), K.environmentRotation !== void 0 && ye.environmentRotation.fromArray(K.environmentRotation); break; case "PerspectiveCamera": ye = new PerspectiveCamera(K.fov, K.aspect, K.near, K.far), K.focus !== void 0 && (ye.focus = K.focus), K.zoom !== void 0 && (ye.zoom = K.zoom), K.filmGauge !== void 0 && (ye.filmGauge = K.filmGauge), K.filmOffset !== void 0 && (ye.filmOffset = K.filmOffset), K.view !== void 0 && (ye.view = Object.assign({}, K.view)); break; case "OrthographicCamera": ye = new OrthographicCamera(K.left, K.right, K.top, K.bottom, K.near, K.far), K.zoom !== void 0 && (ye.zoom = K.zoom), K.view !== void 0 && (ye.view = Object.assign({}, K.view)); break; case "AmbientLight": ye = new AmbientLight(K.color, K.intensity); break; case "DirectionalLight": ye = new DirectionalLight(K.color, K.intensity), ye.target = K.target || ""; break; case "PointLight": ye = new PointLight(K.color, K.intensity, K.distance, K.decay); break; case "RectAreaLight": ye = new RectAreaLight(K.color, K.intensity, K.width, K.height); break; case "SpotLight": ye = new SpotLight(K.color, K.intensity, K.distance, K.angle, K.penumbra, K.decay), ye.target = K.target || ""; break; case "HemisphereLight": ye = new HemisphereLight(K.color, K.groundColor, K.intensity); break; case "LightProbe": ye = new LightProbe().fromJSON(K); break; case "SkinnedMesh": be = ve(K.geometry), Ae = _e(K.material), ye = new SkinnedMesh$1(be, Ae), K.bindMode !== void 0 && (ye.bindMode = K.bindMode), K.bindMatrix !== void 0 && ye.bindMatrix.fromArray(K.bindMatrix), K.skeleton !== void 0 && (ye.skeleton = K.skeleton); break; case "Mesh": be = ve(K.geometry), Ae = _e(K.material), ye = new Mesh(be, Ae); break; case "InstancedMesh": be = ve(K.geometry), Ae = _e(K.material); const Se = K.count, Ce = K.instanceMatrix, we = K.instanceColor; ye = new InstancedMesh(be, Ae, Se), ye.instanceMatrix = new InstancedBufferAttribute(new Float32Array(Ce.array), 16), we !== void 0 && (ye.instanceColor = new InstancedBufferAttribute(new Float32Array(we.array), we.itemSize)); break; case "BatchedMesh": be = ve(K.geometry), Ae = _e(K.material), ye = new BatchedMesh$1(K.maxInstanceCount, K.maxVertexCount, K.maxIndexCount, Ae), ye.geometry = be, ye.perObjectFrustumCulled = K.perObjectFrustumCulled, ye.sortObjects = K.sortObjects, ye._drawRanges = K.drawRanges, ye._reservedRanges = K.reservedRanges, ye._visibility = K.visibility, ye._active = K.active, ye._bounds = K.bounds.map(Be => { const De = new Box3; De.min.fromArray(Be.boxMin), De.max.fromArray(Be.boxMax); const Re = new Sphere; return Re.radius = Be.sphereRadius, Re.center.fromArray(Be.sphereCenter), { boxInitialized: Be.boxInitialized, box: De, sphereInitialized: Be.sphereInitialized, sphere: Re } }), ye._maxInstanceCount = K.maxInstanceCount, ye._maxVertexCount = K.maxVertexCount, ye._maxIndexCount = K.maxIndexCount, ye._geometryInitialized = K.geometryInitialized, ye._geometryCount = K.geometryCount, ye._matricesTexture = Ee(K.matricesTexture.uuid), K.colorsTexture !== void 0 && (ye._colorsTexture = Ee(K.colorsTexture.uuid)); break; case "LOD": ye = new LOD; break; case "Line": ye = new Line$2(ve(K.geometry), _e(K.material)); break; case "LineLoop": ye = new LineLoop(ve(K.geometry), _e(K.material)); break; case "LineSegments": ye = new LineSegments(ve(K.geometry), _e(K.material)); break; case "PointCloud": case "Points": ye = new Points(ve(K.geometry), _e(K.material)); break; case "Sprite": ye = new Sprite(_e(K.material)); break; case "Group": ye = new Group; break; case "Bone": ye = new Bone; break; default: ye = new Object3D }if (ye.uuid = K.uuid, K.name !== void 0 && (ye.name = K.name), K.matrix !== void 0 ? (ye.matrix.fromArray(K.matrix), K.matrixAutoUpdate !== void 0 && (ye.matrixAutoUpdate = K.matrixAutoUpdate), ye.matrixAutoUpdate && ye.matrix.decompose(ye.position, ye.quaternion, ye.scale)) : (K.position !== void 0 && ye.position.fromArray(K.position), K.rotation !== void 0 && ye.rotation.fromArray(K.rotation), K.quaternion !== void 0 && ye.quaternion.fromArray(K.quaternion), K.scale !== void 0 && ye.scale.fromArray(K.scale)), K.up !== void 0 && ye.up.fromArray(K.up), K.castShadow !== void 0 && (ye.castShadow = K.castShadow), K.receiveShadow !== void 0 && (ye.receiveShadow = K.receiveShadow), K.shadow && (K.shadow.intensity !== void 0 && (ye.shadow.intensity = K.shadow.intensity), K.shadow.bias !== void 0 && (ye.shadow.bias = K.shadow.bias), K.shadow.normalBias !== void 0 && (ye.shadow.normalBias = K.shadow.normalBias), K.shadow.radius !== void 0 && (ye.shadow.radius = K.shadow.radius), K.shadow.mapSize !== void 0 && ye.shadow.mapSize.fromArray(K.shadow.mapSize), K.shadow.camera !== void 0 && (ye.shadow.camera = this.parseObject(K.shadow.camera))), K.visible !== void 0 && (ye.visible = K.visible), K.frustumCulled !== void 0 && (ye.frustumCulled = K.frustumCulled), K.renderOrder !== void 0 && (ye.renderOrder = K.renderOrder), K.userData !== void 0 && (ye.userData = K.userData), K.layers !== void 0 && (ye.layers.mask = K.layers), K.children !== void 0) { const Se = K.children; for (let Ce = 0; Ce < Se.length; Ce++)ye.add(this.parseObject(Se[Ce], pe, me, ge, xe)) } if (K.animations !== void 0) { const Se = K.animations; for (let Ce = 0; Ce < Se.length; Ce++) { const we = Se[Ce]; ye.animations.push(xe[we]) } } if (K.type === "LOD") { K.autoUpdate !== void 0 && (ye.autoUpdate = K.autoUpdate); const Se = K.levels; for (let Ce = 0; Ce < Se.length; Ce++) { const we = Se[Ce], Be = ye.getObjectByProperty("uuid", we.object); Be !== void 0 && ye.addLevel(Be, we.distance, we.hysteresis) } } return ye } bindSkeletons(K, pe) { Object.keys(pe).length !== 0 && K.traverse(function (me) { if (me.isSkinnedMesh === !0 && me.skeleton !== void 0) { const ge = pe[me.skeleton]; ge === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", me.skeleton) : me.bind(ge, me.bindMatrix) } }) } bindLightTargets(K) { K.traverse(function (pe) { if (pe.isDirectionalLight || pe.isSpotLight) { const me = pe.target, ge = K.getObjectByProperty("uuid", me); ge !== void 0 ? pe.target = ge : pe.target = new Object3D } }) } } const TEXTURE_MAPPING = { UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping }, TEXTURE_WRAPPING = { RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping }, TEXTURE_FILTER = { NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter }; class ImageBitmapLoader extends Loader { constructor(K) { super(K), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(K) { return this.options = K, this } load(K, pe, me, ge) { K === void 0 && (K = ""), this.path !== void 0 && (K = this.path + K), K = this.manager.resolveURL(K); const xe = this, ye = Cache.get(K); if (ye !== void 0) { if (xe.manager.itemStart(K), ye.then) { ye.then(Ee => { pe && pe(Ee), xe.manager.itemEnd(K) }).catch(Ee => { ge && ge(Ee) }); return } return setTimeout(function () { pe && pe(ye), xe.manager.itemEnd(K) }, 0), ye } const ve = {}; ve.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", ve.headers = this.requestHeader; const _e = fetch(K, ve).then(function (Ee) { return Ee.blob() }).then(function (Ee) { return createImageBitmap(Ee, Object.assign(xe.options, { colorSpaceConversion: "none" })) }).then(function (Ee) { return Cache.add(K, Ee), pe && pe(Ee), xe.manager.itemEnd(K), Ee }).catch(function (Ee) { ge && ge(Ee), Cache.remove(K), xe.manager.itemError(K), xe.manager.itemEnd(K) }); Cache.add(K, _e), xe.manager.itemStart(K) } } let _context; class AudioContext { static getContext() { return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)), _context } static setContext(K) { _context = K } } class AudioLoader extends Loader { constructor(K) { super(K) } load(K, pe, me, ge) { const xe = this, ye = new FileLoader(this.manager); ye.setResponseType("arraybuffer"), ye.setPath(this.path), ye.setRequestHeader(this.requestHeader), ye.setWithCredentials(this.withCredentials), ye.load(K, function (_e) { try { const Ee = _e.slice(0); AudioContext.getContext().decodeAudioData(Ee, function (Ae) { pe(Ae) }).catch(ve) } catch (Ee) { ve(Ee) } }, me, ge); function ve(_e) { ge ? ge(_e) : console.error(_e), xe.manager.itemError(K) } } } const _eyeRight = new Matrix4, _eyeLeft = new Matrix4, _projectionMatrix = new Matrix4; class StereoCamera { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(K) { const pe = this._cache; if (pe.focus !== K.focus || pe.fov !== K.fov || pe.aspect !== K.aspect * this.aspect || pe.near !== K.near || pe.far !== K.far || pe.zoom !== K.zoom || pe.eyeSep !== this.eyeSep) { pe.focus = K.focus, pe.fov = K.fov, pe.aspect = K.aspect * this.aspect, pe.near = K.near, pe.far = K.far, pe.zoom = K.zoom, pe.eyeSep = this.eyeSep, _projectionMatrix.copy(K.projectionMatrix); const ge = pe.eyeSep / 2, xe = ge * pe.near / pe.focus, ye = pe.near * Math.tan(DEG2RAD$1 * pe.fov * .5) / pe.zoom; let ve, _e; _eyeLeft.elements[12] = -ge, _eyeRight.elements[12] = ge, ve = -ye * pe.aspect + xe, _e = ye * pe.aspect + xe, _projectionMatrix.elements[0] = 2 * pe.near / (_e - ve), _projectionMatrix.elements[8] = (_e + ve) / (_e - ve), this.cameraL.projectionMatrix.copy(_projectionMatrix), ve = -ye * pe.aspect - xe, _e = ye * pe.aspect - xe, _projectionMatrix.elements[0] = 2 * pe.near / (_e - ve), _projectionMatrix.elements[8] = (_e + ve) / (_e - ve), this.cameraR.projectionMatrix.copy(_projectionMatrix) } this.cameraL.matrixWorld.copy(K.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(K.matrixWorld).multiply(_eyeRight) } } class ArrayCamera extends PerspectiveCamera { constructor(K = []) { super(), this.isArrayCamera = !0, this.cameras = K, this.index = 0 } } class Clock { constructor(K = !0) { this.autoStart = K, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let K = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const pe = now(); K = (pe - this.oldTime) / 1e3, this.oldTime = pe, this.elapsedTime += K } return K } } function now() { return performance.now() } const _position$1 = new Vector3, _quaternion$1 = new Quaternion, _scale$1 = new Vector3, _orientation$1 = new Vector3; class AudioListener extends Object3D { constructor() { super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(K) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = K, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(K) { return this.gain.gain.setTargetAtTime(K, this.context.currentTime, .01), this } updateMatrixWorld(K) { super.updateMatrixWorld(K); const pe = this.context.listener, me = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1), _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1), pe.positionX) { const ge = this.context.currentTime + this.timeDelta; pe.positionX.linearRampToValueAtTime(_position$1.x, ge), pe.positionY.linearRampToValueAtTime(_position$1.y, ge), pe.positionZ.linearRampToValueAtTime(_position$1.z, ge), pe.forwardX.linearRampToValueAtTime(_orientation$1.x, ge), pe.forwardY.linearRampToValueAtTime(_orientation$1.y, ge), pe.forwardZ.linearRampToValueAtTime(_orientation$1.z, ge), pe.upX.linearRampToValueAtTime(me.x, ge), pe.upY.linearRampToValueAtTime(me.y, ge), pe.upZ.linearRampToValueAtTime(me.z, ge) } else pe.setPosition(_position$1.x, _position$1.y, _position$1.z), pe.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, me.x, me.y, me.z) } } class Audio extends Object3D { constructor(K) { super(), this.type = "Audio", this.listener = K, this.context = K.context, this.gain = this.context.createGain(), this.gain.connect(K.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(K) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = K, this.connect(), this } setMediaElementSource(K) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(K), this.connect(), this } setMediaStreamSource(K) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(K), this.connect(), this } setBuffer(K) { return this.buffer = K, this.sourceType = "buffer", this.autoplay && this.play(), this } play(K = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + K; const pe = this.context.createBufferSource(); return pe.buffer = this.buffer, pe.loop = this.loop, pe.loopStart = this.loopStart, pe.loopEnd = this.loopEnd, pe.onended = this.onEnded.bind(this), pe.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = pe, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop(K = 0) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + K), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let K = 1, pe = this.filters.length; K < pe; K++)this.filters[K - 1].connect(this.filters[K]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this._connected !== !1) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let K = 1, pe = this.filters.length; K < pe; K++)this.filters[K - 1].disconnect(this.filters[K]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(K) { return K || (K = []), this._connected === !0 ? (this.disconnect(), this.filters = K.slice(), this.connect()) : this.filters = K.slice(), this } setDetune(K) { return this.detune = K, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(K) { return this.setFilters(K ? [K] : []) } setPlaybackRate(K) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = K, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1, this._progress = 0 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(K) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = K, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(K) { return this.loopStart = K, this } setLoopEnd(K) { return this.loopEnd = K, this } getVolume() { return this.gain.gain.value } setVolume(K) { return this.gain.gain.setTargetAtTime(K, this.context.currentTime, .01), this } copy(K, pe) { return super.copy(K, pe), K.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = K.autoplay, this.buffer = K.buffer, this.detune = K.detune, this.loop = K.loop, this.loopStart = K.loopStart, this.loopEnd = K.loopEnd, this.offset = K.offset, this.duration = K.duration, this.playbackRate = K.playbackRate, this.hasPlaybackControl = K.hasPlaybackControl, this.sourceType = K.sourceType, this.filters = K.filters.slice(), this) } clone(K) { return new this.constructor(this.listener).copy(this, K) } } const _position = new Vector3, _quaternion = new Quaternion, _scale = new Vector3, _orientation = new Vector3; class PositionalAudio extends Audio { constructor(K) { super(K), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { return super.connect(), this.panner.connect(this.gain), this } disconnect() { return super.disconnect(), this.panner.disconnect(this.gain), this } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(K) { return this.panner.refDistance = K, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(K) { return this.panner.rolloffFactor = K, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(K) { return this.panner.distanceModel = K, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(K) { return this.panner.maxDistance = K, this } setDirectionalCone(K, pe, me) { return this.panner.coneInnerAngle = K, this.panner.coneOuterAngle = pe, this.panner.coneOuterGain = me, this } updateMatrixWorld(K) { if (super.updateMatrixWorld(K), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(_position, _quaternion, _scale), _orientation.set(0, 0, 1).applyQuaternion(_quaternion); const pe = this.panner; if (pe.positionX) { const me = this.context.currentTime + this.listener.timeDelta; pe.positionX.linearRampToValueAtTime(_position.x, me), pe.positionY.linearRampToValueAtTime(_position.y, me), pe.positionZ.linearRampToValueAtTime(_position.z, me), pe.orientationX.linearRampToValueAtTime(_orientation.x, me), pe.orientationY.linearRampToValueAtTime(_orientation.y, me), pe.orientationZ.linearRampToValueAtTime(_orientation.z, me) } else pe.setPosition(_position.x, _position.y, _position.z), pe.setOrientation(_orientation.x, _orientation.y, _orientation.z) } } class AudioAnalyser { constructor(K, pe = 2048) { this.analyser = K.context.createAnalyser(), this.analyser.fftSize = pe, this.data = new Uint8Array(this.analyser.frequencyBinCount), K.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let K = 0; const pe = this.getFrequencyData(); for (let me = 0; me < pe.length; me++)K += pe[me]; return K / pe.length } } class PropertyMixer { constructor(K, pe, me) { this.binding = K, this.valueSize = me; let ge, xe, ye; switch (pe) { case "quaternion": ge = this._slerp, xe = this._slerpAdditive, ye = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(me * 6), this._workIndex = 5; break; case "string": case "bool": ge = this._select, xe = this._select, ye = this._setAdditiveIdentityOther, this.buffer = new Array(me * 5); break; default: ge = this._lerp, xe = this._lerpAdditive, ye = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(me * 5) }this._mixBufferRegion = ge, this._mixBufferRegionAdditive = xe, this._setIdentity = ye, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(K, pe) { const me = this.buffer, ge = this.valueSize, xe = K * ge + ge; let ye = this.cumulativeWeight; if (ye === 0) { for (let ve = 0; ve !== ge; ++ve)me[xe + ve] = me[ve]; ye = pe } else { ye += pe; const ve = pe / ye; this._mixBufferRegion(me, xe, 0, ve, ge) } this.cumulativeWeight = ye } accumulateAdditive(K) { const pe = this.buffer, me = this.valueSize, ge = me * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(pe, ge, 0, K, me), this.cumulativeWeightAdditive += K } apply(K) { const pe = this.valueSize, me = this.buffer, ge = K * pe + pe, xe = this.cumulativeWeight, ye = this.cumulativeWeightAdditive, ve = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, xe < 1) { const _e = pe * this._origIndex; this._mixBufferRegion(me, ge, _e, 1 - xe, pe) } ye > 0 && this._mixBufferRegionAdditive(me, ge, this._addIndex * pe, 1, pe); for (let _e = pe, Ee = pe + pe; _e !== Ee; ++_e)if (me[_e] !== me[_e + pe]) { ve.setValue(me, ge); break } } saveOriginalState() { const K = this.binding, pe = this.buffer, me = this.valueSize, ge = me * this._origIndex; K.getValue(pe, ge); for (let xe = me, ye = ge; xe !== ye; ++xe)pe[xe] = pe[ge + xe % me]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const K = this.valueSize * 3; this.binding.setValue(this.buffer, K) } _setAdditiveIdentityNumeric() { const K = this._addIndex * this.valueSize, pe = K + this.valueSize; for (let me = K; me < pe; me++)this.buffer[me] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const K = this._origIndex * this.valueSize, pe = this._addIndex * this.valueSize; for (let me = 0; me < this.valueSize; me++)this.buffer[pe + me] = this.buffer[K + me] } _select(K, pe, me, ge, xe) { if (ge >= .5) for (let ye = 0; ye !== xe; ++ye)K[pe + ye] = K[me + ye] } _slerp(K, pe, me, ge) { Quaternion.slerpFlat(K, pe, K, pe, K, me, ge) } _slerpAdditive(K, pe, me, ge, xe) { const ye = this._workIndex * xe; Quaternion.multiplyQuaternionsFlat(K, ye, K, pe, K, me), Quaternion.slerpFlat(K, pe, K, pe, K, ye, ge) } _lerp(K, pe, me, ge, xe) { const ye = 1 - ge; for (let ve = 0; ve !== xe; ++ve) { const _e = pe + ve; K[_e] = K[_e] * ye + K[me + ve] * ge } } _lerpAdditive(K, pe, me, ge, xe) { for (let ye = 0; ye !== xe; ++ye) { const ve = pe + ye; K[ve] = K[ve] + K[me + ye] * ge } } } const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"), _supportedObjectNames = ["material", "materials", "bones", "map"]; class Composite { constructor(K, pe, me) { const ge = me || PropertyBinding.parseTrackName(pe); this._targetGroup = K, this._bindings = K.subscribe_(pe, ge) } getValue(K, pe) { this.bind(); const me = this._targetGroup.nCachedObjects_, ge = this._bindings[me]; ge !== void 0 && ge.getValue(K, pe) } setValue(K, pe) { const me = this._bindings; for (let ge = this._targetGroup.nCachedObjects_, xe = me.length; ge !== xe; ++ge)me[ge].setValue(K, pe) } bind() { const K = this._bindings; for (let pe = this._targetGroup.nCachedObjects_, me = K.length; pe !== me; ++pe)K[pe].bind() } unbind() { const K = this._bindings; for (let pe = this._targetGroup.nCachedObjects_, me = K.length; pe !== me; ++pe)K[pe].unbind() } } class PropertyBinding { constructor(K, pe, me) { this.path = pe, this.parsedPath = me || PropertyBinding.parseTrackName(pe), this.node = PropertyBinding.findNode(K, this.parsedPath.nodeName), this.rootNode = K, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(K, pe, me) { return K && K.isAnimationObjectGroup ? new PropertyBinding.Composite(K, pe, me) : new PropertyBinding(K, pe, me) } static sanitizeNodeName(K) { return K.replace(/\s/g, "_").replace(_reservedRe, "") } static parseTrackName(K) { const pe = _trackRe.exec(K); if (pe === null) throw new Error("PropertyBinding: Cannot parse trackName: " + K); const me = { nodeName: pe[2], objectName: pe[3], objectIndex: pe[4], propertyName: pe[5], propertyIndex: pe[6] }, ge = me.nodeName && me.nodeName.lastIndexOf("."); if (ge !== void 0 && ge !== -1) { const xe = me.nodeName.substring(ge + 1); _supportedObjectNames.indexOf(xe) !== -1 && (me.nodeName = me.nodeName.substring(0, ge), me.objectName = xe) } if (me.propertyName === null || me.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + K); return me } static findNode(K, pe) { if (pe === void 0 || pe === "" || pe === "." || pe === -1 || pe === K.name || pe === K.uuid) return K; if (K.skeleton) { const me = K.skeleton.getBoneByName(pe); if (me !== void 0) return me } if (K.children) { const me = function (xe) { for (let ye = 0; ye < xe.length; ye++) { const ve = xe[ye]; if (ve.name === pe || ve.uuid === pe) return ve; const _e = me(ve.children); if (_e) return _e } return null }, ge = me(K.children); if (ge) return ge } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(K, pe) { K[pe] = this.targetObject[this.propertyName] } _getValue_array(K, pe) { const me = this.resolvedProperty; for (let ge = 0, xe = me.length; ge !== xe; ++ge)K[pe++] = me[ge] } _getValue_arrayElement(K, pe) { K[pe] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(K, pe) { this.resolvedProperty.toArray(K, pe) } _setValue_direct(K, pe) { this.targetObject[this.propertyName] = K[pe] } _setValue_direct_setNeedsUpdate(K, pe) { this.targetObject[this.propertyName] = K[pe], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(K, pe) { this.targetObject[this.propertyName] = K[pe], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(K, pe) { const me = this.resolvedProperty; for (let ge = 0, xe = me.length; ge !== xe; ++ge)me[ge] = K[pe++] } _setValue_array_setNeedsUpdate(K, pe) { const me = this.resolvedProperty; for (let ge = 0, xe = me.length; ge !== xe; ++ge)me[ge] = K[pe++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(K, pe) { const me = this.resolvedProperty; for (let ge = 0, xe = me.length; ge !== xe; ++ge)me[ge] = K[pe++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(K, pe) { this.resolvedProperty[this.propertyIndex] = K[pe] } _setValue_arrayElement_setNeedsUpdate(K, pe) { this.resolvedProperty[this.propertyIndex] = K[pe], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(K, pe) { this.resolvedProperty[this.propertyIndex] = K[pe], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(K, pe) { this.resolvedProperty.fromArray(K, pe) } _setValue_fromArray_setNeedsUpdate(K, pe) { this.resolvedProperty.fromArray(K, pe), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(K, pe) { this.resolvedProperty.fromArray(K, pe), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(K, pe) { this.bind(), this.getValue(K, pe) } _setValue_unbound(K, pe) { this.bind(), this.setValue(K, pe) } bind() { let K = this.node; const pe = this.parsedPath, me = pe.objectName, ge = pe.propertyName; let xe = pe.propertyIndex; if (K || (K = PropertyBinding.findNode(this.rootNode, pe.nodeName), this.node = K), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !K) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (me) { let Ee = pe.objectIndex; switch (me) { case "materials": if (!K.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!K.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } K = K.material.materials; break; case "bones": if (!K.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } K = K.skeleton.bones; for (let be = 0; be < K.length; be++)if (K[be].name === Ee) { Ee = be; break } break; case "map": if ("map" in K) { K = K.map; break } if (!K.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!K.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } K = K.material.map; break; default: if (K[me] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } K = K[me] }if (Ee !== void 0) { if (K[Ee] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, K); return } K = K[Ee] } } const ye = K[ge]; if (ye === void 0) { const Ee = pe.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + Ee + "." + ge + " but it wasn't found.", K); return } let ve = this.Versioning.None; this.targetObject = K, K.isMaterial === !0 ? ve = this.Versioning.NeedsUpdate : K.isObject3D === !0 && (ve = this.Versioning.MatrixWorldNeedsUpdate); let _e = this.BindingType.Direct; if (xe !== void 0) { if (ge === "morphTargetInfluences") { if (!K.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!K.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } K.morphTargetDictionary[xe] !== void 0 && (xe = K.morphTargetDictionary[xe]) } _e = this.BindingType.ArrayElement, this.resolvedProperty = ye, this.propertyIndex = xe } else ye.fromArray !== void 0 && ye.toArray !== void 0 ? (_e = this.BindingType.HasFromToArray, this.resolvedProperty = ye) : Array.isArray(ye) ? (_e = this.BindingType.EntireArray, this.resolvedProperty = ye) : this.propertyName = ge; this.getValue = this.GetterByBindingType[_e], this.setValue = this.SetterByBindingTypeAndVersioning[_e][ve] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } PropertyBinding.Composite = Composite; PropertyBinding.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; PropertyBinding.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray]; PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class AnimationObjectGroup { constructor() { this.isAnimationObjectGroup = !0, this.uuid = generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const K = {}; this._indicesByUUID = K; for (let me = 0, ge = arguments.length; me !== ge; ++me)K[arguments[me].uuid] = me; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const pe = this; this.stats = { objects: { get total() { return pe._objects.length }, get inUse() { return this.total - pe.nCachedObjects_ } }, get bindingsPerObject() { return pe._bindings.length } } } add() { const K = this._objects, pe = this._indicesByUUID, me = this._paths, ge = this._parsedPaths, xe = this._bindings, ye = xe.length; let ve, _e = K.length, Ee = this.nCachedObjects_; for (let be = 0, Ae = arguments.length; be !== Ae; ++be) { const Se = arguments[be], Ce = Se.uuid; let we = pe[Ce]; if (we === void 0) { we = _e++, pe[Ce] = we, K.push(Se); for (let Be = 0, De = ye; Be !== De; ++Be)xe[Be].push(new PropertyBinding(Se, me[Be], ge[Be])) } else if (we < Ee) { ve = K[we]; const Be = --Ee, De = K[Be]; pe[De.uuid] = we, K[we] = De, pe[Ce] = Be, K[Be] = Se; for (let Re = 0, Ie = ye; Re !== Ie; ++Re) { const Pe = xe[Re], Ne = Pe[Be]; let ke = Pe[we]; Pe[we] = Ne, ke === void 0 && (ke = new PropertyBinding(Se, me[Re], ge[Re])), Pe[Be] = ke } } else K[we] !== ve && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = Ee } remove() { const K = this._objects, pe = this._indicesByUUID, me = this._bindings, ge = me.length; let xe = this.nCachedObjects_; for (let ye = 0, ve = arguments.length; ye !== ve; ++ye) { const _e = arguments[ye], Ee = _e.uuid, be = pe[Ee]; if (be !== void 0 && be >= xe) { const Ae = xe++, Se = K[Ae]; pe[Se.uuid] = be, K[be] = Se, pe[Ee] = Ae, K[Ae] = _e; for (let Ce = 0, we = ge; Ce !== we; ++Ce) { const Be = me[Ce], De = Be[Ae], Re = Be[be]; Be[be] = De, Be[Ae] = Re } } } this.nCachedObjects_ = xe } uncache() { const K = this._objects, pe = this._indicesByUUID, me = this._bindings, ge = me.length; let xe = this.nCachedObjects_, ye = K.length; for (let ve = 0, _e = arguments.length; ve !== _e; ++ve) { const Ee = arguments[ve], be = Ee.uuid, Ae = pe[be]; if (Ae !== void 0) if (delete pe[be], Ae < xe) { const Se = --xe, Ce = K[Se], we = --ye, Be = K[we]; pe[Ce.uuid] = Ae, K[Ae] = Ce, pe[Be.uuid] = Se, K[Se] = Be, K.pop(); for (let De = 0, Re = ge; De !== Re; ++De) { const Ie = me[De], Pe = Ie[Se], Ne = Ie[we]; Ie[Ae] = Pe, Ie[Se] = Ne, Ie.pop() } } else { const Se = --ye, Ce = K[Se]; Se > 0 && (pe[Ce.uuid] = Ae), K[Ae] = Ce, K.pop(); for (let we = 0, Be = ge; we !== Be; ++we) { const De = me[we]; De[Ae] = De[Se], De.pop() } } } this.nCachedObjects_ = xe } subscribe_(K, pe) { const me = this._bindingsIndicesByPath; let ge = me[K]; const xe = this._bindings; if (ge !== void 0) return xe[ge]; const ye = this._paths, ve = this._parsedPaths, _e = this._objects, Ee = _e.length, be = this.nCachedObjects_, Ae = new Array(Ee); ge = xe.length, me[K] = ge, ye.push(K), ve.push(pe), xe.push(Ae); for (let Se = be, Ce = _e.length; Se !== Ce; ++Se) { const we = _e[Se]; Ae[Se] = new PropertyBinding(we, K, pe) } return Ae } unsubscribe_(K) { const pe = this._bindingsIndicesByPath, me = pe[K]; if (me !== void 0) { const ge = this._paths, xe = this._parsedPaths, ye = this._bindings, ve = ye.length - 1, _e = ye[ve], Ee = K[ve]; pe[Ee] = me, ye[me] = _e, ye.pop(), xe[me] = xe[ve], xe.pop(), ge[me] = ge[ve], ge.pop() } } } class AnimationAction { constructor(K, pe, me = null, ge = pe.blendMode) { this._mixer = K, this._clip = pe, this._localRoot = me, this.blendMode = ge; const xe = pe.tracks, ye = xe.length, ve = new Array(ye), _e = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for (let Ee = 0; Ee !== ye; ++Ee) { const be = xe[Ee].createInterpolant(null); ve[Ee] = be, be.settings = _e } this._interpolantSettings = _e, this._interpolants = ve, this._propertyBindings = new Array(ye), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(K) { return this._startTime = K, this } setLoop(K, pe) { return this.loop = K, this.repetitions = pe, this } setEffectiveWeight(K) { return this.weight = K, this._effectiveWeight = this.enabled ? K : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(K) { return this._scheduleFading(K, 0, 1) } fadeOut(K) { return this._scheduleFading(K, 1, 0) } crossFadeFrom(K, pe, me) { if (K.fadeOut(pe), this.fadeIn(pe), me) { const ge = this._clip.duration, xe = K._clip.duration, ye = xe / ge, ve = ge / xe; K.warp(1, ye, pe), this.warp(ve, 1, pe) } return this } crossFadeTo(K, pe, me) { return K.crossFadeFrom(this, pe, me) } stopFading() { const K = this._weightInterpolant; return K !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(K)), this } setEffectiveTimeScale(K) { return this.timeScale = K, this._effectiveTimeScale = this.paused ? 0 : K, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(K) { return this.timeScale = this._clip.duration / K, this.stopWarping() } syncWith(K) { return this.time = K.time, this.timeScale = K.timeScale, this.stopWarping() } halt(K) { return this.warp(this._effectiveTimeScale, 0, K) } warp(K, pe, me) { const ge = this._mixer, xe = ge.time, ye = this.timeScale; let ve = this._timeScaleInterpolant; ve === null && (ve = ge._lendControlInterpolant(), this._timeScaleInterpolant = ve); const _e = ve.parameterPositions, Ee = ve.sampleValues; return _e[0] = xe, _e[1] = xe + me, Ee[0] = K / ye, Ee[1] = pe / ye, this } stopWarping() { const K = this._timeScaleInterpolant; return K !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(K)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(K, pe, me, ge) { if (!this.enabled) { this._updateWeight(K); return } const xe = this._startTime; if (xe !== null) { const _e = (K - xe) * me; _e < 0 || me === 0 ? pe = 0 : (this._startTime = null, pe = me * _e) } pe *= this._updateTimeScale(K); const ye = this._updateTime(pe), ve = this._updateWeight(K); if (ve > 0) { const _e = this._interpolants, Ee = this._propertyBindings; switch (this.blendMode) { case AdditiveAnimationBlendMode: for (let be = 0, Ae = _e.length; be !== Ae; ++be)_e[be].evaluate(ye), Ee[be].accumulateAdditive(ve); break; case NormalAnimationBlendMode: default: for (let be = 0, Ae = _e.length; be !== Ae; ++be)_e[be].evaluate(ye), Ee[be].accumulate(ge, ve) } } } _updateWeight(K) { let pe = 0; if (this.enabled) { pe = this.weight; const me = this._weightInterpolant; if (me !== null) { const ge = me.evaluate(K)[0]; pe *= ge, K > me.parameterPositions[1] && (this.stopFading(), ge === 0 && (this.enabled = !1)) } } return this._effectiveWeight = pe, pe } _updateTimeScale(K) { let pe = 0; if (!this.paused) { pe = this.timeScale; const me = this._timeScaleInterpolant; if (me !== null) { const ge = me.evaluate(K)[0]; pe *= ge, K > me.parameterPositions[1] && (this.stopWarping(), pe === 0 ? this.paused = !0 : this.timeScale = pe) } } return this._effectiveTimeScale = pe, pe } _updateTime(K) { const pe = this._clip.duration, me = this.loop; let ge = this.time + K, xe = this._loopCount; const ye = me === LoopPingPong; if (K === 0) return xe === -1 ? ge : ye && (xe & 1) === 1 ? pe - ge : ge; if (me === LoopOnce) { xe === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (ge >= pe) ge = pe; else if (ge < 0) ge = 0; else { this.time = ge; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = ge, this._mixer.dispatchEvent({ type: "finished", action: this, direction: K < 0 ? -1 : 1 }) } } else { if (xe === -1 && (K >= 0 ? (xe = 0, this._setEndings(!0, this.repetitions === 0, ye)) : this._setEndings(this.repetitions === 0, !0, ye)), ge >= pe || ge < 0) { const ve = Math.floor(ge / pe); ge -= pe * ve, xe += Math.abs(ve); const _e = this.repetitions - xe; if (_e <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, ge = K > 0 ? pe : 0, this.time = ge, this._mixer.dispatchEvent({ type: "finished", action: this, direction: K > 0 ? 1 : -1 }); else { if (_e === 1) { const Ee = K < 0; this._setEndings(Ee, !Ee, ye) } else this._setEndings(!1, !1, ye); this._loopCount = xe, this.time = ge, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: ve }) } } else this.time = ge; if (ye && (xe & 1) === 1) return pe - ge } return ge } _setEndings(K, pe, me) { const ge = this._interpolantSettings; me ? (ge.endingStart = ZeroSlopeEnding, ge.endingEnd = ZeroSlopeEnding) : (K ? ge.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : ge.endingStart = WrapAroundEnding, pe ? ge.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : ge.endingEnd = WrapAroundEnding) } _scheduleFading(K, pe, me) { const ge = this._mixer, xe = ge.time; let ye = this._weightInterpolant; ye === null && (ye = ge._lendControlInterpolant(), this._weightInterpolant = ye); const ve = ye.parameterPositions, _e = ye.sampleValues; return ve[0] = xe, _e[0] = pe, ve[1] = xe + K, _e[1] = me, this } } const _controlInterpolantsResultBuffer = new Float32Array(1); class AnimationMixer extends EventDispatcher$2 { constructor(K) { super(), this._root = K, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(K, pe) { const me = K._localRoot || this._root, ge = K._clip.tracks, xe = ge.length, ye = K._propertyBindings, ve = K._interpolants, _e = me.uuid, Ee = this._bindingsByRootAndName; let be = Ee[_e]; be === void 0 && (be = {}, Ee[_e] = be); for (let Ae = 0; Ae !== xe; ++Ae) { const Se = ge[Ae], Ce = Se.name; let we = be[Ce]; if (we !== void 0) ++we.referenceCount, ye[Ae] = we; else { if (we = ye[Ae], we !== void 0) { we._cacheIndex === null && (++we.referenceCount, this._addInactiveBinding(we, _e, Ce)); continue } const Be = pe && pe._propertyBindings[Ae].binding.parsedPath; we = new PropertyMixer(PropertyBinding.create(me, Ce, Be), Se.ValueTypeName, Se.getValueSize()), ++we.referenceCount, this._addInactiveBinding(we, _e, Ce), ye[Ae] = we } ve[Ae].resultBuffer = we.buffer } } _activateAction(K) { if (!this._isActiveAction(K)) { if (K._cacheIndex === null) { const me = (K._localRoot || this._root).uuid, ge = K._clip.uuid, xe = this._actionsByClip[ge]; this._bindAction(K, xe && xe.knownActions[0]), this._addInactiveAction(K, ge, me) } const pe = K._propertyBindings; for (let me = 0, ge = pe.length; me !== ge; ++me) { const xe = pe[me]; xe.useCount++ === 0 && (this._lendBinding(xe), xe.saveOriginalState()) } this._lendAction(K) } } _deactivateAction(K) { if (this._isActiveAction(K)) { const pe = K._propertyBindings; for (let me = 0, ge = pe.length; me !== ge; ++me) { const xe = pe[me]; --xe.useCount === 0 && (xe.restoreOriginalState(), this._takeBackBinding(xe)) } this._takeBackAction(K) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const K = this; this.stats = { actions: { get total() { return K._actions.length }, get inUse() { return K._nActiveActions } }, bindings: { get total() { return K._bindings.length }, get inUse() { return K._nActiveBindings } }, controlInterpolants: { get total() { return K._controlInterpolants.length }, get inUse() { return K._nActiveControlInterpolants } } } } _isActiveAction(K) { const pe = K._cacheIndex; return pe !== null && pe < this._nActiveActions } _addInactiveAction(K, pe, me) { const ge = this._actions, xe = this._actionsByClip; let ye = xe[pe]; if (ye === void 0) ye = { knownActions: [K], actionByRoot: {} }, K._byClipCacheIndex = 0, xe[pe] = ye; else { const ve = ye.knownActions; K._byClipCacheIndex = ve.length, ve.push(K) } K._cacheIndex = ge.length, ge.push(K), ye.actionByRoot[me] = K } _removeInactiveAction(K) { const pe = this._actions, me = pe[pe.length - 1], ge = K._cacheIndex; me._cacheIndex = ge, pe[ge] = me, pe.pop(), K._cacheIndex = null; const xe = K._clip.uuid, ye = this._actionsByClip, ve = ye[xe], _e = ve.knownActions, Ee = _e[_e.length - 1], be = K._byClipCacheIndex; Ee._byClipCacheIndex = be, _e[be] = Ee, _e.pop(), K._byClipCacheIndex = null; const Ae = ve.actionByRoot, Se = (K._localRoot || this._root).uuid; delete Ae[Se], _e.length === 0 && delete ye[xe], this._removeInactiveBindingsForAction(K) } _removeInactiveBindingsForAction(K) { const pe = K._propertyBindings; for (let me = 0, ge = pe.length; me !== ge; ++me) { const xe = pe[me]; --xe.referenceCount === 0 && this._removeInactiveBinding(xe) } } _lendAction(K) { const pe = this._actions, me = K._cacheIndex, ge = this._nActiveActions++, xe = pe[ge]; K._cacheIndex = ge, pe[ge] = K, xe._cacheIndex = me, pe[me] = xe } _takeBackAction(K) { const pe = this._actions, me = K._cacheIndex, ge = --this._nActiveActions, xe = pe[ge]; K._cacheIndex = ge, pe[ge] = K, xe._cacheIndex = me, pe[me] = xe } _addInactiveBinding(K, pe, me) { const ge = this._bindingsByRootAndName, xe = this._bindings; let ye = ge[pe]; ye === void 0 && (ye = {}, ge[pe] = ye), ye[me] = K, K._cacheIndex = xe.length, xe.push(K) } _removeInactiveBinding(K) { const pe = this._bindings, me = K.binding, ge = me.rootNode.uuid, xe = me.path, ye = this._bindingsByRootAndName, ve = ye[ge], _e = pe[pe.length - 1], Ee = K._cacheIndex; _e._cacheIndex = Ee, pe[Ee] = _e, pe.pop(), delete ve[xe], Object.keys(ve).length === 0 && delete ye[ge] } _lendBinding(K) { const pe = this._bindings, me = K._cacheIndex, ge = this._nActiveBindings++, xe = pe[ge]; K._cacheIndex = ge, pe[ge] = K, xe._cacheIndex = me, pe[me] = xe } _takeBackBinding(K) { const pe = this._bindings, me = K._cacheIndex, ge = --this._nActiveBindings, xe = pe[ge]; K._cacheIndex = ge, pe[ge] = K, xe._cacheIndex = me, pe[me] = xe } _lendControlInterpolant() { const K = this._controlInterpolants, pe = this._nActiveControlInterpolants++; let me = K[pe]; return me === void 0 && (me = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer), me.__cacheIndex = pe, K[pe] = me), me } _takeBackControlInterpolant(K) { const pe = this._controlInterpolants, me = K.__cacheIndex, ge = --this._nActiveControlInterpolants, xe = pe[ge]; K.__cacheIndex = ge, pe[ge] = K, xe.__cacheIndex = me, pe[me] = xe } clipAction(K, pe, me) { const ge = pe || this._root, xe = ge.uuid; let ye = typeof K == "string" ? AnimationClip.findByName(ge, K) : K; const ve = ye !== null ? ye.uuid : K, _e = this._actionsByClip[ve]; let Ee = null; if (me === void 0 && (ye !== null ? me = ye.blendMode : me = NormalAnimationBlendMode), _e !== void 0) { const Ae = _e.actionByRoot[xe]; if (Ae !== void 0 && Ae.blendMode === me) return Ae; Ee = _e.knownActions[0], ye === null && (ye = Ee._clip) } if (ye === null) return null; const be = new AnimationAction(this, ye, pe, me); return this._bindAction(be, Ee), this._addInactiveAction(be, ve, xe), be } existingAction(K, pe) { const me = pe || this._root, ge = me.uuid, xe = typeof K == "string" ? AnimationClip.findByName(me, K) : K, ye = xe ? xe.uuid : K, ve = this._actionsByClip[ye]; return ve !== void 0 && ve.actionByRoot[ge] || null } stopAllAction() { const K = this._actions, pe = this._nActiveActions; for (let me = pe - 1; me >= 0; --me)K[me].stop(); return this } update(K) { K *= this.timeScale; const pe = this._actions, me = this._nActiveActions, ge = this.time += K, xe = Math.sign(K), ye = this._accuIndex ^= 1; for (let Ee = 0; Ee !== me; ++Ee)pe[Ee]._update(ge, K, xe, ye); const ve = this._bindings, _e = this._nActiveBindings; for (let Ee = 0; Ee !== _e; ++Ee)ve[Ee].apply(ye); return this } setTime(K) { this.time = 0; for (let pe = 0; pe < this._actions.length; pe++)this._actions[pe].time = 0; return this.update(K) } getRoot() { return this._root } uncacheClip(K) { const pe = this._actions, me = K.uuid, ge = this._actionsByClip, xe = ge[me]; if (xe !== void 0) { const ye = xe.knownActions; for (let ve = 0, _e = ye.length; ve !== _e; ++ve) { const Ee = ye[ve]; this._deactivateAction(Ee); const be = Ee._cacheIndex, Ae = pe[pe.length - 1]; Ee._cacheIndex = null, Ee._byClipCacheIndex = null, Ae._cacheIndex = be, pe[be] = Ae, pe.pop(), this._removeInactiveBindingsForAction(Ee) } delete ge[me] } } uncacheRoot(K) { const pe = K.uuid, me = this._actionsByClip; for (const ye in me) { const ve = me[ye].actionByRoot, _e = ve[pe]; _e !== void 0 && (this._deactivateAction(_e), this._removeInactiveAction(_e)) } const ge = this._bindingsByRootAndName, xe = ge[pe]; if (xe !== void 0) for (const ye in xe) { const ve = xe[ye]; ve.restoreOriginalState(), this._removeInactiveBinding(ve) } } uncacheAction(K, pe) { const me = this.existingAction(K, pe); me !== null && (this._deactivateAction(me), this._removeInactiveAction(me)) } } class RenderTarget3D extends RenderTarget { constructor(K = 1, pe = 1, me = 1, ge = {}) { super(K, pe, ge), this.isRenderTarget3D = !0, this.depth = me, this.texture = new Data3DTexture(null, K, pe, me), this.texture.isRenderTargetTexture = !0 } } class RenderTargetArray extends RenderTarget { constructor(K = 1, pe = 1, me = 1, ge = {}) { super(K, pe, ge), this.isRenderTargetArray = !0, this.depth = me, this.texture = new DataArrayTexture(null, K, pe, me), this.texture.isRenderTargetTexture = !0 } } class Uniform { constructor(K) { this.value = K } clone() { return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone()) } } let _id$3 = 0; class UniformsGroup extends EventDispatcher$2 { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: _id$3++ }), this.name = "", this.usage = StaticDrawUsage, this.uniforms = [] } add(K) { return this.uniforms.push(K), this } remove(K) { const pe = this.uniforms.indexOf(K); return pe !== -1 && this.uniforms.splice(pe, 1), this } setName(K) { return this.name = K, this } setUsage(K) { return this.usage = K, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(K) { this.name = K.name, this.usage = K.usage; const pe = K.uniforms; this.uniforms.length = 0; for (let me = 0, ge = pe.length; me < ge; me++) { const xe = Array.isArray(pe[me]) ? pe[me] : [pe[me]]; for (let ye = 0; ye < xe.length; ye++)this.uniforms.push(xe[ye].clone()) } return this } clone() { return new this.constructor().copy(this) } } class InstancedInterleavedBuffer extends InterleavedBuffer { constructor(K, pe, me = 1) { super(K, pe), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = me } copy(K) { return super.copy(K), this.meshPerAttribute = K.meshPerAttribute, this } clone(K) { const pe = super.clone(K); return pe.meshPerAttribute = this.meshPerAttribute, pe } toJSON(K) { const pe = super.toJSON(K); return pe.isInstancedInterleavedBuffer = !0, pe.meshPerAttribute = this.meshPerAttribute, pe } } class GLBufferAttribute { constructor(K, pe, me, ge, xe) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = K, this.type = pe, this.itemSize = me, this.elementSize = ge, this.count = xe, this.version = 0 } set needsUpdate(K) { K === !0 && this.version++ } setBuffer(K) { return this.buffer = K, this } setType(K, pe) { return this.type = K, this.elementSize = pe, this } setItemSize(K) { return this.itemSize = K, this } setCount(K) { return this.count = K, this } } const _matrix = new Matrix4; class Raycaster { constructor(K, pe, me = 0, ge = 1 / 0) { this.ray = new Ray(K, pe), this.near = me, this.far = ge, this.camera = null, this.layers = new Layers, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(K, pe) { this.ray.set(K, pe) } setFromCamera(K, pe) { pe.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(pe.matrixWorld), this.ray.direction.set(K.x, K.y, .5).unproject(pe).sub(this.ray.origin).normalize(), this.camera = pe) : pe.isOrthographicCamera ? (this.ray.origin.set(K.x, K.y, (pe.near + pe.far) / (pe.near - pe.far)).unproject(pe), this.ray.direction.set(0, 0, -1).transformDirection(pe.matrixWorld), this.camera = pe) : console.error("THREE.Raycaster: Unsupported camera type: " + pe.type) } setFromXRController(K) { return _matrix.identity().extractRotation(K.matrixWorld), this.ray.origin.setFromMatrixPosition(K.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix), this } intersectObject(K, pe = !0, me = []) { return intersect(K, this, me, pe), me.sort(ascSort), me } intersectObjects(K, pe = !0, me = []) { for (let ge = 0, xe = K.length; ge < xe; ge++)intersect(K[ge], this, me, pe); return me.sort(ascSort), me } } function ascSort(fe, K) { return fe.distance - K.distance } function intersect(fe, K, pe, me) { let ge = !0; if (fe.layers.test(K.layers) && fe.raycast(K, pe) === !1 && (ge = !1), ge === !0 && me === !0) { const xe = fe.children; for (let ye = 0, ve = xe.length; ye < ve; ye++)intersect(xe[ye], K, pe, !0) } } class Spherical { constructor(K = 1, pe = 0, me = 0) { this.radius = K, this.phi = pe, this.theta = me } set(K, pe, me) { return this.radius = K, this.phi = pe, this.theta = me, this } copy(K) { return this.radius = K.radius, this.phi = K.phi, this.theta = K.theta, this } makeSafe() { return this.phi = clamp$3(this.phi, 1e-6, Math.PI - 1e-6), this } setFromVector3(K) { return this.setFromCartesianCoords(K.x, K.y, K.z) } setFromCartesianCoords(K, pe, me) { return this.radius = Math.sqrt(K * K + pe * pe + me * me), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(K, me), this.phi = Math.acos(clamp$3(pe / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class Cylindrical { constructor(K = 1, pe = 0, me = 0) { this.radius = K, this.theta = pe, this.y = me } set(K, pe, me) { return this.radius = K, this.theta = pe, this.y = me, this } copy(K) { return this.radius = K.radius, this.theta = K.theta, this.y = K.y, this } setFromVector3(K) { return this.setFromCartesianCoords(K.x, K.y, K.z) } setFromCartesianCoords(K, pe, me) { return this.radius = Math.sqrt(K * K + me * me), this.theta = Math.atan2(K, me), this.y = pe, this } clone() { return new this.constructor().copy(this) } } class Matrix2 { constructor(K, pe, me, ge) { Matrix2.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], K !== void 0 && this.set(K, pe, me, ge) } identity() { return this.set(1, 0, 0, 1), this } fromArray(K, pe = 0) { for (let me = 0; me < 4; me++)this.elements[me] = K[me + pe]; return this } set(K, pe, me, ge) { const xe = this.elements; return xe[0] = K, xe[2] = pe, xe[1] = me, xe[3] = ge, this } } const _vector$4 = new Vector2; class Box2 { constructor(K = new Vector2(1 / 0, 1 / 0), pe = new Vector2(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = K, this.max = pe } set(K, pe) { return this.min.copy(K), this.max.copy(pe), this } setFromPoints(K) { this.makeEmpty(); for (let pe = 0, me = K.length; pe < me; pe++)this.expandByPoint(K[pe]); return this } setFromCenterAndSize(K, pe) { const me = _vector$4.copy(pe).multiplyScalar(.5); return this.min.copy(K).sub(me), this.max.copy(K).add(me), this } clone() { return new this.constructor().copy(this) } copy(K) { return this.min.copy(K.min), this.max.copy(K.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(K) { return this.isEmpty() ? K.set(0, 0) : K.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(K) { return this.isEmpty() ? K.set(0, 0) : K.subVectors(this.max, this.min) } expandByPoint(K) { return this.min.min(K), this.max.max(K), this } expandByVector(K) { return this.min.sub(K), this.max.add(K), this } expandByScalar(K) { return this.min.addScalar(-K), this.max.addScalar(K), this } containsPoint(K) { return K.x >= this.min.x && K.x <= this.max.x && K.y >= this.min.y && K.y <= this.max.y } containsBox(K) { return this.min.x <= K.min.x && K.max.x <= this.max.x && this.min.y <= K.min.y && K.max.y <= this.max.y } getParameter(K, pe) { return pe.set((K.x - this.min.x) / (this.max.x - this.min.x), (K.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(K) { return K.max.x >= this.min.x && K.min.x <= this.max.x && K.max.y >= this.min.y && K.min.y <= this.max.y } clampPoint(K, pe) { return pe.copy(K).clamp(this.min, this.max) } distanceToPoint(K) { return this.clampPoint(K, _vector$4).distanceTo(K) } intersect(K) { return this.min.max(K.min), this.max.min(K.max), this.isEmpty() && this.makeEmpty(), this } union(K) { return this.min.min(K.min), this.max.max(K.max), this } translate(K) { return this.min.add(K), this.max.add(K), this } equals(K) { return K.min.equals(this.min) && K.max.equals(this.max) } } const _startP = new Vector3, _startEnd = new Vector3; class Line3 { constructor(K = new Vector3, pe = new Vector3) { this.start = K, this.end = pe } set(K, pe) { return this.start.copy(K), this.end.copy(pe), this } copy(K) { return this.start.copy(K.start), this.end.copy(K.end), this } getCenter(K) { return K.addVectors(this.start, this.end).multiplyScalar(.5) } delta(K) { return K.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(K, pe) { return this.delta(pe).multiplyScalar(K).add(this.start) } closestPointToPointParameter(K, pe) { _startP.subVectors(K, this.start), _startEnd.subVectors(this.end, this.start); const me = _startEnd.dot(_startEnd); let xe = _startEnd.dot(_startP) / me; return pe && (xe = clamp$3(xe, 0, 1)), xe } closestPointToPoint(K, pe, me) { const ge = this.closestPointToPointParameter(K, pe); return this.delta(me).multiplyScalar(ge).add(this.start) } applyMatrix4(K) { return this.start.applyMatrix4(K), this.end.applyMatrix4(K), this } equals(K) { return K.start.equals(this.start) && K.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const _vector$3 = new Vector3; class SpotLightHelper extends Object3D { constructor(K, pe) { super(), this.light = K, this.matrixAutoUpdate = !1, this.color = pe, this.type = "SpotLightHelper"; const me = new BufferGeometry, ge = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let ye = 0, ve = 1, _e = 32; ye < _e; ye++, ve++) { const Ee = ye / _e * Math.PI * 2, be = ve / _e * Math.PI * 2; ge.push(Math.cos(Ee), Math.sin(Ee), 1, Math.cos(be), Math.sin(be), 1) } me.setAttribute("position", new Float32BufferAttribute(ge, 3)); const xe = new LineBasicMaterial({ fog: !1, toneMapped: !1 }); this.cone = new LineSegments(me, xe), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld); const K = this.light.distance ? this.light.distance : 1e3, pe = K * Math.tan(this.light.angle); this.cone.scale.set(pe, pe, K), _vector$3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const _vector$2 = new Vector3, _boneMatrix = new Matrix4, _matrixWorldInv = new Matrix4; class SkeletonHelper extends LineSegments { constructor(K) { const pe = getBoneList(K), me = new BufferGeometry, ge = [], xe = [], ye = new Color$1(0, 0, 1), ve = new Color$1(0, 1, 0); for (let Ee = 0; Ee < pe.length; Ee++) { const be = pe[Ee]; be.parent && be.parent.isBone && (ge.push(0, 0, 0), ge.push(0, 0, 0), xe.push(ye.r, ye.g, ye.b), xe.push(ve.r, ve.g, ve.b)) } me.setAttribute("position", new Float32BufferAttribute(ge, 3)), me.setAttribute("color", new Float32BufferAttribute(xe, 3)); const _e = new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(me, _e), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = K, this.bones = pe, this.matrix = K.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(K) { const pe = this.bones, me = this.geometry, ge = me.getAttribute("position"); _matrixWorldInv.copy(this.root.matrixWorld).invert(); for (let xe = 0, ye = 0; xe < pe.length; xe++) { const ve = pe[xe]; ve.parent && ve.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, ve.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), ge.setXYZ(ye, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, ve.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), ge.setXYZ(ye + 1, _vector$2.x, _vector$2.y, _vector$2.z), ye += 2) } me.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(K) } dispose() { this.geometry.dispose(), this.material.dispose() } } function getBoneList(fe) { const K = []; fe.isBone === !0 && K.push(fe); for (let pe = 0; pe < fe.children.length; pe++)K.push(...getBoneList(fe.children[pe])); return K } class PointLightHelper extends Mesh { constructor(K, pe, me) { const ge = new SphereGeometry(pe, 4, 2), xe = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }); super(ge, xe), this.light = K, this.color = me, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const _vector$1 = new Vector3, _color1 = new Color$1, _color2 = new Color$1; class HemisphereLightHelper extends Object3D { constructor(K, pe, me) { super(), this.light = K, this.matrix = K.matrixWorld, this.matrixAutoUpdate = !1, this.color = me, this.type = "HemisphereLightHelper"; const ge = new OctahedronGeometry(pe); ge.rotateY(Math.PI * .5), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const xe = ge.getAttribute("position"), ye = new Float32Array(xe.count * 3); ge.setAttribute("color", new BufferAttribute(ye, 3)), this.add(new Mesh(ge, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const K = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const pe = K.geometry.getAttribute("color"); _color1.copy(this.light.color), _color2.copy(this.light.groundColor); for (let me = 0, ge = pe.count; me < ge; me++) { const xe = me < ge / 2 ? _color1 : _color2; pe.setXYZ(me, xe.r, xe.g, xe.b) } pe.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), K.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class GridHelper extends LineSegments { constructor(K = 10, pe = 10, me = 4473924, ge = 8947848) { me = new Color$1(me), ge = new Color$1(ge); const xe = pe / 2, ye = K / pe, ve = K / 2, _e = [], Ee = []; for (let Se = 0, Ce = 0, we = -ve; Se <= pe; Se++, we += ye) { _e.push(-ve, 0, we, ve, 0, we), _e.push(we, 0, -ve, we, 0, ve); const Be = Se === xe ? me : ge; Be.toArray(Ee, Ce), Ce += 3, Be.toArray(Ee, Ce), Ce += 3, Be.toArray(Ee, Ce), Ce += 3, Be.toArray(Ee, Ce), Ce += 3 } const be = new BufferGeometry; be.setAttribute("position", new Float32BufferAttribute(_e, 3)), be.setAttribute("color", new Float32BufferAttribute(Ee, 3)); const Ae = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 }); super(be, Ae), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class PolarGridHelper extends LineSegments { constructor(K = 10, pe = 16, me = 8, ge = 64, xe = 4473924, ye = 8947848) { xe = new Color$1(xe), ye = new Color$1(ye); const ve = [], _e = []; if (pe > 1) for (let Ae = 0; Ae < pe; Ae++) { const Se = Ae / pe * (Math.PI * 2), Ce = Math.sin(Se) * K, we = Math.cos(Se) * K; ve.push(0, 0, 0), ve.push(Ce, 0, we); const Be = Ae & 1 ? xe : ye; _e.push(Be.r, Be.g, Be.b), _e.push(Be.r, Be.g, Be.b) } for (let Ae = 0; Ae < me; Ae++) { const Se = Ae & 1 ? xe : ye, Ce = K - K / me * Ae; for (let we = 0; we < ge; we++) { let Be = we / ge * (Math.PI * 2), De = Math.sin(Be) * Ce, Re = Math.cos(Be) * Ce; ve.push(De, 0, Re), _e.push(Se.r, Se.g, Se.b), Be = (we + 1) / ge * (Math.PI * 2), De = Math.sin(Be) * Ce, Re = Math.cos(Be) * Ce, ve.push(De, 0, Re), _e.push(Se.r, Se.g, Se.b) } } const Ee = new BufferGeometry; Ee.setAttribute("position", new Float32BufferAttribute(ve, 3)), Ee.setAttribute("color", new Float32BufferAttribute(_e, 3)); const be = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 }); super(Ee, be), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const _v1 = new Vector3, _v2$5 = new Vector3, _v3 = new Vector3; class DirectionalLightHelper extends Object3D { constructor(K, pe, me) { super(), this.light = K, this.matrix = K.matrixWorld, this.matrixAutoUpdate = !1, this.color = me, this.type = "DirectionalLightHelper", pe === void 0 && (pe = 1); let ge = new BufferGeometry; ge.setAttribute("position", new Float32BufferAttribute([-pe, pe, 0, pe, pe, 0, pe, -pe, 0, -pe, -pe, 0, -pe, pe, 0], 3)); const xe = new LineBasicMaterial({ fog: !1, toneMapped: !1 }); this.lightPlane = new Line$2(ge, xe), this.add(this.lightPlane), ge = new BufferGeometry, ge.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line$2(ge, xe), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), _v1.setFromMatrixPosition(this.light.matrixWorld), _v2$5.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2$5, _v1), this.lightPlane.lookAt(_v2$5), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2$5), this.targetLine.scale.z = _v3.length() } } const _vector$d = new Vector3, _camera = new Camera; class CameraHelper extends LineSegments { constructor(K) { const pe = new BufferGeometry, me = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), ge = [], xe = [], ye = {}; ve("n1", "n2"), ve("n2", "n4"), ve("n4", "n3"), ve("n3", "n1"), ve("f1", "f2"), ve("f2", "f4"), ve("f4", "f3"), ve("f3", "f1"), ve("n1", "f1"), ve("n2", "f2"), ve("n3", "f3"), ve("n4", "f4"), ve("p", "n1"), ve("p", "n2"), ve("p", "n3"), ve("p", "n4"), ve("u1", "u2"), ve("u2", "u3"), ve("u3", "u1"), ve("c", "t"), ve("p", "c"), ve("cn1", "cn2"), ve("cn3", "cn4"), ve("cf1", "cf2"), ve("cf3", "cf4"); function ve(we, Be) { _e(we), _e(Be) } function _e(we) { ge.push(0, 0, 0), xe.push(0, 0, 0), ye[we] === void 0 && (ye[we] = []), ye[we].push(ge.length / 3 - 1) } pe.setAttribute("position", new Float32BufferAttribute(ge, 3)), pe.setAttribute("color", new Float32BufferAttribute(xe, 3)), super(pe, me), this.type = "CameraHelper", this.camera = K, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = K.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = ye, this.update(); const Ee = new Color$1(16755200), be = new Color$1(16711680), Ae = new Color$1(43775), Se = new Color$1(16777215), Ce = new Color$1(3355443); this.setColors(Ee, be, Ae, Se, Ce) } setColors(K, pe, me, ge, xe) { const ve = this.geometry.getAttribute("color"); ve.setXYZ(0, K.r, K.g, K.b), ve.setXYZ(1, K.r, K.g, K.b), ve.setXYZ(2, K.r, K.g, K.b), ve.setXYZ(3, K.r, K.g, K.b), ve.setXYZ(4, K.r, K.g, K.b), ve.setXYZ(5, K.r, K.g, K.b), ve.setXYZ(6, K.r, K.g, K.b), ve.setXYZ(7, K.r, K.g, K.b), ve.setXYZ(8, K.r, K.g, K.b), ve.setXYZ(9, K.r, K.g, K.b), ve.setXYZ(10, K.r, K.g, K.b), ve.setXYZ(11, K.r, K.g, K.b), ve.setXYZ(12, K.r, K.g, K.b), ve.setXYZ(13, K.r, K.g, K.b), ve.setXYZ(14, K.r, K.g, K.b), ve.setXYZ(15, K.r, K.g, K.b), ve.setXYZ(16, K.r, K.g, K.b), ve.setXYZ(17, K.r, K.g, K.b), ve.setXYZ(18, K.r, K.g, K.b), ve.setXYZ(19, K.r, K.g, K.b), ve.setXYZ(20, K.r, K.g, K.b), ve.setXYZ(21, K.r, K.g, K.b), ve.setXYZ(22, K.r, K.g, K.b), ve.setXYZ(23, K.r, K.g, K.b), ve.setXYZ(24, pe.r, pe.g, pe.b), ve.setXYZ(25, pe.r, pe.g, pe.b), ve.setXYZ(26, pe.r, pe.g, pe.b), ve.setXYZ(27, pe.r, pe.g, pe.b), ve.setXYZ(28, pe.r, pe.g, pe.b), ve.setXYZ(29, pe.r, pe.g, pe.b), ve.setXYZ(30, pe.r, pe.g, pe.b), ve.setXYZ(31, pe.r, pe.g, pe.b), ve.setXYZ(32, me.r, me.g, me.b), ve.setXYZ(33, me.r, me.g, me.b), ve.setXYZ(34, me.r, me.g, me.b), ve.setXYZ(35, me.r, me.g, me.b), ve.setXYZ(36, me.r, me.g, me.b), ve.setXYZ(37, me.r, me.g, me.b), ve.setXYZ(38, ge.r, ge.g, ge.b), ve.setXYZ(39, ge.r, ge.g, ge.b), ve.setXYZ(40, xe.r, xe.g, xe.b), ve.setXYZ(41, xe.r, xe.g, xe.b), ve.setXYZ(42, xe.r, xe.g, xe.b), ve.setXYZ(43, xe.r, xe.g, xe.b), ve.setXYZ(44, xe.r, xe.g, xe.b), ve.setXYZ(45, xe.r, xe.g, xe.b), ve.setXYZ(46, xe.r, xe.g, xe.b), ve.setXYZ(47, xe.r, xe.g, xe.b), ve.setXYZ(48, xe.r, xe.g, xe.b), ve.setXYZ(49, xe.r, xe.g, xe.b), ve.needsUpdate = !0 } update() { const K = this.geometry, pe = this.pointMap, me = 1, ge = 1; _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); const xe = this.camera.coordinateSystem === WebGLCoordinateSystem ? -1 : 0; setPoint("c", pe, K, _camera, 0, 0, xe), setPoint("t", pe, K, _camera, 0, 0, 1), setPoint("n1", pe, K, _camera, -1, -1, xe), setPoint("n2", pe, K, _camera, me, -1, xe), setPoint("n3", pe, K, _camera, -1, ge, xe), setPoint("n4", pe, K, _camera, me, ge, xe), setPoint("f1", pe, K, _camera, -1, -1, 1), setPoint("f2", pe, K, _camera, me, -1, 1), setPoint("f3", pe, K, _camera, -1, ge, 1), setPoint("f4", pe, K, _camera, me, ge, 1), setPoint("u1", pe, K, _camera, me * .7, ge * 1.1, xe), setPoint("u2", pe, K, _camera, -1 * .7, ge * 1.1, xe), setPoint("u3", pe, K, _camera, 0, ge * 2, xe), setPoint("cf1", pe, K, _camera, -1, 0, 1), setPoint("cf2", pe, K, _camera, me, 0, 1), setPoint("cf3", pe, K, _camera, 0, -1, 1), setPoint("cf4", pe, K, _camera, 0, ge, 1), setPoint("cn1", pe, K, _camera, -1, 0, xe), setPoint("cn2", pe, K, _camera, me, 0, xe), setPoint("cn3", pe, K, _camera, 0, -1, xe), setPoint("cn4", pe, K, _camera, 0, ge, xe), K.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function setPoint(fe, K, pe, me, ge, xe, ye) { _vector$d.set(ge, xe, ye).unproject(me); const ve = K[fe]; if (ve !== void 0) { const _e = pe.getAttribute("position"); for (let Ee = 0, be = ve.length; Ee < be; Ee++)_e.setXYZ(ve[Ee], _vector$d.x, _vector$d.y, _vector$d.z) } } const _box$5 = new Box3; class BoxHelper extends LineSegments { constructor(K, pe = 16776960) { const me = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), ge = new Float32Array(8 * 3), xe = new BufferGeometry; xe.setIndex(new BufferAttribute(me, 1)), xe.setAttribute("position", new BufferAttribute(ge, 3)), super(xe, new LineBasicMaterial({ color: pe, toneMapped: !1 })), this.object = K, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update() { if (this.object !== void 0 && _box$5.setFromObject(this.object), _box$5.isEmpty()) return; const K = _box$5.min, pe = _box$5.max, me = this.geometry.attributes.position, ge = me.array; ge[0] = pe.x, ge[1] = pe.y, ge[2] = pe.z, ge[3] = K.x, ge[4] = pe.y, ge[5] = pe.z, ge[6] = K.x, ge[7] = K.y, ge[8] = pe.z, ge[9] = pe.x, ge[10] = K.y, ge[11] = pe.z, ge[12] = pe.x, ge[13] = pe.y, ge[14] = K.z, ge[15] = K.x, ge[16] = pe.y, ge[17] = K.z, ge[18] = K.x, ge[19] = K.y, ge[20] = K.z, ge[21] = pe.x, ge[22] = K.y, ge[23] = K.z, me.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(K) { return this.object = K, this.update(), this } copy(K, pe) { return super.copy(K, pe), this.object = K.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class Box3Helper extends LineSegments { constructor(K, pe = 16776960) { const me = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), ge = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], xe = new BufferGeometry; xe.setIndex(new BufferAttribute(me, 1)), xe.setAttribute("position", new Float32BufferAttribute(ge, 3)), super(xe, new LineBasicMaterial({ color: pe, toneMapped: !1 })), this.box = K, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(K) { const pe = this.box; pe.isEmpty() || (pe.getCenter(this.position), pe.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(K)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class PlaneHelper extends Line$2 { constructor(K, pe = 1, me = 16776960) { const ge = me, xe = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], ye = new BufferGeometry; ye.setAttribute("position", new Float32BufferAttribute(xe, 3)), ye.computeBoundingSphere(), super(ye, new LineBasicMaterial({ color: ge, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = K, this.size = pe; const ve = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], _e = new BufferGeometry; _e.setAttribute("position", new Float32BufferAttribute(ve, 3)), _e.computeBoundingSphere(), this.add(new Mesh(_e, new MeshBasicMaterial({ color: ge, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(K) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(K) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const _axis = new Vector3; let _lineGeometry, _coneGeometry; class ArrowHelper extends Object3D { constructor(K = new Vector3(0, 0, 1), pe = new Vector3(0, 0, 0), me = 1, ge = 16776960, xe = me * .2, ye = xe * .2) { super(), this.type = "ArrowHelper", _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry, _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, .5, 1, 5, 1), _coneGeometry.translate(0, -.5, 0)), this.position.copy(pe), this.line = new Line$2(_lineGeometry, new LineBasicMaterial({ color: ge, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: ge, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(K), this.setLength(me, xe, ye) } setDirection(K) { if (K.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (K.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { _axis.set(K.z, 0, -K.x).normalize(); const pe = Math.acos(K.y); this.quaternion.setFromAxisAngle(_axis, pe) } } setLength(K, pe = K * .2, me = pe * .2) { this.line.scale.set(1, Math.max(1e-4, K - pe), 1), this.line.updateMatrix(), this.cone.scale.set(me, pe, me), this.cone.position.y = K, this.cone.updateMatrix() } setColor(K) { this.line.material.color.set(K), this.cone.material.color.set(K) } copy(K) { return super.copy(K, !1), this.line.copy(K.line), this.cone.copy(K.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class AxesHelper extends LineSegments { constructor(K = 1) { const pe = [0, 0, 0, K, 0, 0, 0, 0, 0, 0, K, 0, 0, 0, 0, 0, 0, K], me = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], ge = new BufferGeometry; ge.setAttribute("position", new Float32BufferAttribute(pe, 3)), ge.setAttribute("color", new Float32BufferAttribute(me, 3)); const xe = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 }); super(ge, xe), this.type = "AxesHelper" } setColors(K, pe, me) { const ge = new Color$1, xe = this.geometry.attributes.color.array; return ge.set(K), ge.toArray(xe, 0), ge.toArray(xe, 3), ge.set(pe), ge.toArray(xe, 6), ge.toArray(xe, 9), ge.set(me), ge.toArray(xe, 12), ge.toArray(xe, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class ShapePath { constructor() { this.type = "ShapePath", this.color = new Color$1, this.subPaths = [], this.currentPath = null } moveTo(K, pe) { return this.currentPath = new Path, this.subPaths.push(this.currentPath), this.currentPath.moveTo(K, pe), this } lineTo(K, pe) { return this.currentPath.lineTo(K, pe), this } quadraticCurveTo(K, pe, me, ge) { return this.currentPath.quadraticCurveTo(K, pe, me, ge), this } bezierCurveTo(K, pe, me, ge, xe, ye) { return this.currentPath.bezierCurveTo(K, pe, me, ge, xe, ye), this } splineThru(K) { return this.currentPath.splineThru(K), this } toShapes(K) { function pe(Re) { const Ie = []; for (let Pe = 0, Ne = Re.length; Pe < Ne; Pe++) { const ke = Re[Pe], Oe = new Shape; Oe.curves = ke.curves, Ie.push(Oe) } return Ie } function me(Re, Ie) { const Pe = Ie.length; let Ne = !1; for (let ke = Pe - 1, Oe = 0; Oe < Pe; ke = Oe++) { let Ue = Ie[ke], He = Ie[Oe], Ge = He.x - Ue.x, ze = He.y - Ue.y; if (Math.abs(ze) > Number.EPSILON) { if (ze < 0 && (Ue = Ie[Oe], Ge = -Ge, He = Ie[ke], ze = -ze), Re.y < Ue.y || Re.y > He.y) continue; if (Re.y === Ue.y) { if (Re.x === Ue.x) return !0 } else { const We = ze * (Re.x - Ue.x) - Ge * (Re.y - Ue.y); if (We === 0) return !0; if (We < 0) continue; Ne = !Ne } } else { if (Re.y !== Ue.y) continue; if (He.x <= Re.x && Re.x <= Ue.x || Ue.x <= Re.x && Re.x <= He.x) return !0 } } return Ne } const ge = ShapeUtils.isClockWise, xe = this.subPaths; if (xe.length === 0) return []; let ye, ve, _e; const Ee = []; if (xe.length === 1) return ve = xe[0], _e = new Shape, _e.curves = ve.curves, Ee.push(_e), Ee; let be = !ge(xe[0].getPoints()); be = K ? !be : be; const Ae = [], Se = []; let Ce = [], we = 0, Be; Se[we] = void 0, Ce[we] = []; for (let Re = 0, Ie = xe.length; Re < Ie; Re++)ve = xe[Re], Be = ve.getPoints(), ye = ge(Be), ye = K ? !ye : ye, ye ? (!be && Se[we] && we++, Se[we] = { s: new Shape, p: Be }, Se[we].s.curves = ve.curves, be && we++, Ce[we] = []) : Ce[we].push({ h: ve, p: Be[0] }); if (!Se[0]) return pe(xe); if (Se.length > 1) { let Re = !1, Ie = 0; for (let Pe = 0, Ne = Se.length; Pe < Ne; Pe++)Ae[Pe] = []; for (let Pe = 0, Ne = Se.length; Pe < Ne; Pe++) { const ke = Ce[Pe]; for (let Oe = 0; Oe < ke.length; Oe++) { const Ue = ke[Oe]; let He = !0; for (let Ge = 0; Ge < Se.length; Ge++)me(Ue.p, Se[Ge].p) && (Pe !== Ge && Ie++, He ? (He = !1, Ae[Ge].push(Ue)) : Re = !0); He && Ae[Pe].push(Ue) } } Ie > 0 && Re === !1 && (Ce = Ae) } let De; for (let Re = 0, Ie = Se.length; Re < Ie; Re++) { _e = Se[Re].s, Ee.push(_e), De = Ce[Re]; for (let Pe = 0, Ne = De.length; Pe < Ne; Pe++)_e.holes.push(De[Pe].h) } return Ee } } class Controls extends EventDispatcher$2 { constructor(K, pe = null) { super(), this.object = K, this.domElement = pe, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null } } connect() { } disconnect() { } dispose() { } update() { } } function contain(fe, K) { const pe = fe.image && fe.image.width ? fe.image.width / fe.image.height : 1; return pe > K ? (fe.repeat.x = 1, fe.repeat.y = pe / K, fe.offset.x = 0, fe.offset.y = (1 - fe.repeat.y) / 2) : (fe.repeat.x = K / pe, fe.repeat.y = 1, fe.offset.x = (1 - fe.repeat.x) / 2, fe.offset.y = 0), fe } function cover(fe, K) { const pe = fe.image && fe.image.width ? fe.image.width / fe.image.height : 1; return pe > K ? (fe.repeat.x = K / pe, fe.repeat.y = 1, fe.offset.x = (1 - fe.repeat.x) / 2, fe.offset.y = 0) : (fe.repeat.x = 1, fe.repeat.y = pe / K, fe.offset.x = 0, fe.offset.y = (1 - fe.repeat.y) / 2), fe } function fill(fe) { return fe.repeat.x = 1, fe.repeat.y = 1, fe.offset.x = 0, fe.offset.y = 0, fe } function getByteLength(fe, K, pe, me) { const ge = getTextureTypeByteLength(me); switch (pe) { case AlphaFormat: return fe * K; case LuminanceFormat: return fe * K; case LuminanceAlphaFormat: return fe * K * 2; case RedFormat: return fe * K / ge.components * ge.byteLength; case RedIntegerFormat: return fe * K / ge.components * ge.byteLength; case RGFormat: return fe * K * 2 / ge.components * ge.byteLength; case RGIntegerFormat: return fe * K * 2 / ge.components * ge.byteLength; case RGBFormat: return fe * K * 3 / ge.components * ge.byteLength; case RGBAFormat: return fe * K * 4 / ge.components * ge.byteLength; case RGBAIntegerFormat: return fe * K * 4 / ge.components * ge.byteLength; case RGB_S3TC_DXT1_Format: case RGBA_S3TC_DXT1_Format: return Math.floor((fe + 3) / 4) * Math.floor((K + 3) / 4) * 8; case RGBA_S3TC_DXT3_Format: case RGBA_S3TC_DXT5_Format: return Math.floor((fe + 3) / 4) * Math.floor((K + 3) / 4) * 16; case RGB_PVRTC_2BPPV1_Format: case RGBA_PVRTC_2BPPV1_Format: return Math.max(fe, 16) * Math.max(K, 8) / 4; case RGB_PVRTC_4BPPV1_Format: case RGBA_PVRTC_4BPPV1_Format: return Math.max(fe, 8) * Math.max(K, 8) / 2; case RGB_ETC1_Format: case RGB_ETC2_Format: return Math.floor((fe + 3) / 4) * Math.floor((K + 3) / 4) * 8; case RGBA_ETC2_EAC_Format: return Math.floor((fe + 3) / 4) * Math.floor((K + 3) / 4) * 16; case RGBA_ASTC_4x4_Format: return Math.floor((fe + 3) / 4) * Math.floor((K + 3) / 4) * 16; case RGBA_ASTC_5x4_Format: return Math.floor((fe + 4) / 5) * Math.floor((K + 3) / 4) * 16; case RGBA_ASTC_5x5_Format: return Math.floor((fe + 4) / 5) * Math.floor((K + 4) / 5) * 16; case RGBA_ASTC_6x5_Format: return Math.floor((fe + 5) / 6) * Math.floor((K + 4) / 5) * 16; case RGBA_ASTC_6x6_Format: return Math.floor((fe + 5) / 6) * Math.floor((K + 5) / 6) * 16; case RGBA_ASTC_8x5_Format: return Math.floor((fe + 7) / 8) * Math.floor((K + 4) / 5) * 16; case RGBA_ASTC_8x6_Format: return Math.floor((fe + 7) / 8) * Math.floor((K + 5) / 6) * 16; case RGBA_ASTC_8x8_Format: return Math.floor((fe + 7) / 8) * Math.floor((K + 7) / 8) * 16; case RGBA_ASTC_10x5_Format: return Math.floor((fe + 9) / 10) * Math.floor((K + 4) / 5) * 16; case RGBA_ASTC_10x6_Format: return Math.floor((fe + 9) / 10) * Math.floor((K + 5) / 6) * 16; case RGBA_ASTC_10x8_Format: return Math.floor((fe + 9) / 10) * Math.floor((K + 7) / 8) * 16; case RGBA_ASTC_10x10_Format: return Math.floor((fe + 9) / 10) * Math.floor((K + 9) / 10) * 16; case RGBA_ASTC_12x10_Format: return Math.floor((fe + 11) / 12) * Math.floor((K + 9) / 10) * 16; case RGBA_ASTC_12x12_Format: return Math.floor((fe + 11) / 12) * Math.floor((K + 11) / 12) * 16; case RGBA_BPTC_Format: case RGB_BPTC_SIGNED_Format: case RGB_BPTC_UNSIGNED_Format: return Math.ceil(fe / 4) * Math.ceil(K / 4) * 16; case RED_RGTC1_Format: case SIGNED_RED_RGTC1_Format: return Math.ceil(fe / 4) * Math.ceil(K / 4) * 8; case RED_GREEN_RGTC2_Format: case SIGNED_RED_GREEN_RGTC2_Format: return Math.ceil(fe / 4) * Math.ceil(K / 4) * 16 }throw new Error(`Unable to determine texture byte length for ${pe} format.`) } function getTextureTypeByteLength(fe) { switch (fe) { case UnsignedByteType: case ByteType: return { byteLength: 1, components: 1 }; case UnsignedShortType: case ShortType: case HalfFloatType: return { byteLength: 2, components: 1 }; case UnsignedShort4444Type: case UnsignedShort5551Type: return { byteLength: 2, components: 4 }; case UnsignedIntType: case IntType: case FloatType: return { byteLength: 4, components: 1 }; case UnsignedInt5999Type: return { byteLength: 4, components: 3 } }throw new Error(`Unknown texture type ${fe}.`) } class TextureUtils { static contain(K, pe) { return contain(K, pe) } static cover(K, pe) { return cover(K, pe) } static fill(K) { return fill(K) } static getByteLength(K, pe, me, ge) { return getByteLength(K, pe, me, ge) } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function WebGLAnimation() { let fe = null, K = !1, pe = null, me = null; function ge(xe, ye) { pe(xe, ye), me = fe.requestAnimationFrame(ge) } return { start: function () { K !== !0 && pe !== null && (me = fe.requestAnimationFrame(ge), K = !0) }, stop: function () { fe.cancelAnimationFrame(me), K = !1 }, setAnimationLoop: function (xe) { pe = xe }, setContext: function (xe) { fe = xe } } } function WebGLAttributes(fe) { const K = new WeakMap; function pe(ve, _e) { const Ee = ve.array, be = ve.usage, Ae = Ee.byteLength, Se = fe.createBuffer(); fe.bindBuffer(_e, Se), fe.bufferData(_e, Ee, be), ve.onUploadCallback(); let Ce; if (Ee instanceof Float32Array) Ce = fe.FLOAT; else if (Ee instanceof Uint16Array) ve.isFloat16BufferAttribute ? Ce = fe.HALF_FLOAT : Ce = fe.UNSIGNED_SHORT; else if (Ee instanceof Int16Array) Ce = fe.SHORT; else if (Ee instanceof Uint32Array) Ce = fe.UNSIGNED_INT; else if (Ee instanceof Int32Array) Ce = fe.INT; else if (Ee instanceof Int8Array) Ce = fe.BYTE; else if (Ee instanceof Uint8Array) Ce = fe.UNSIGNED_BYTE; else if (Ee instanceof Uint8ClampedArray) Ce = fe.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + Ee); return { buffer: Se, type: Ce, bytesPerElement: Ee.BYTES_PER_ELEMENT, version: ve.version, size: Ae } } function me(ve, _e, Ee) { const be = _e.array, Ae = _e.updateRanges; if (fe.bindBuffer(Ee, ve), Ae.length === 0) fe.bufferSubData(Ee, 0, be); else { Ae.sort((Ce, we) => Ce.start - we.start); let Se = 0; for (let Ce = 1; Ce < Ae.length; Ce++) { const we = Ae[Se], Be = Ae[Ce]; Be.start <= we.start + we.count + 1 ? we.count = Math.max(we.count, Be.start + Be.count - we.start) : (++Se, Ae[Se] = Be) } Ae.length = Se + 1; for (let Ce = 0, we = Ae.length; Ce < we; Ce++) { const Be = Ae[Ce]; fe.bufferSubData(Ee, Be.start * be.BYTES_PER_ELEMENT, be, Be.start, Be.count) } _e.clearUpdateRanges() } _e.onUploadCallback() } function ge(ve) { return ve.isInterleavedBufferAttribute && (ve = ve.data), K.get(ve) } function xe(ve) { ve.isInterleavedBufferAttribute && (ve = ve.data); const _e = K.get(ve); _e && (fe.deleteBuffer(_e.buffer), K.delete(ve)) } function ye(ve, _e) { if (ve.isInterleavedBufferAttribute && (ve = ve.data), ve.isGLBufferAttribute) { const be = K.get(ve); (!be || be.version < ve.version) && K.set(ve, { buffer: ve.buffer, type: ve.type, bytesPerElement: ve.elementSize, version: ve.version }); return } const Ee = K.get(ve); if (Ee === void 0) K.set(ve, pe(ve, _e)); else if (Ee.version < ve.version) { if (Ee.size !== ve.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); me(Ee.buffer, ve, _e), Ee.version = ve.version } } return { get: ge, remove: xe, update: ye } } var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ShaderChunk = { alphahash_fragment, alphahash_pars_fragment, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, batching_pars_vertex, batching_vertex, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, colorspace_fragment, colorspace_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_physical_pars_fragment, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphinstance_vertex, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, opaque_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, worldpos_vertex, background_vert: vertex$h, background_frag: fragment$h, backgroundCube_vert: vertex$g, backgroundCube_frag: fragment$g, cube_vert: vertex$f, cube_frag: fragment$f, depth_vert: vertex$e, depth_frag: fragment$e, distanceRGBA_vert: vertex$d, distanceRGBA_frag: fragment$d, equirect_vert: vertex$c, equirect_frag: fragment$c, linedashed_vert: vertex$b, linedashed_frag: fragment$b, meshbasic_vert: vertex$a, meshbasic_frag: fragment$a, meshlambert_vert: vertex$9, meshlambert_frag: fragment$9, meshmatcap_vert: vertex$8, meshmatcap_frag: fragment$8, meshnormal_vert: vertex$7, meshnormal_frag: fragment$7, meshphong_vert: vertex$6, meshphong_frag: fragment$6, meshphysical_vert: vertex$5, meshphysical_frag: fragment$5, meshtoon_vert: vertex$4, meshtoon_frag: fragment$4, points_vert: vertex$3, points_frag: fragment$3, shadow_vert: vertex$2, shadow_frag: fragment$2, sprite_vert: vertex$1, sprite_frag: fragment$1 }, UniformsLib = { common: { diffuse: { value: new Color$1(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Matrix3 }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Matrix3 } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Matrix3 }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Matrix3 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Matrix3 } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Matrix3 }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Matrix3 }, normalScale: { value: new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Matrix3 }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Matrix3 } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Matrix3 } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Matrix3 } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color$1(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color$1(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3 } }, sprite: { diffuse: { value: new Color$1(16777215) }, opacity: { value: 1 }, center: { value: new Vector2(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Matrix3 }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 } } }, ShaderLib = { basic: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) }, specular: { value: new Color$1(1118481) }, shininess: { value: 30 } }]), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) } }]), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } }]), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.meshnormal_vert, fragmentShader: ShaderChunk.meshnormal_frag }, sprite: { uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3 }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Matrix3 } }, vertexShader: ShaderChunk.backgroundCube_vert, fragmentShader: ShaderChunk.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3 }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: new Color$1(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } }; ShaderLib.physical = { uniforms: mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Matrix3 }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Matrix3 }, clearcoatNormalScale: { value: new Vector2(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Matrix3 }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Matrix3 }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Matrix3 }, sheen: { value: 0 }, sheenColor: { value: new Color$1(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Matrix3 }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Matrix3 }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Matrix3 }, transmissionSamplerSize: { value: new Vector2 }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Matrix3 }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Color$1(0) }, specularColor: { value: new Color$1(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Matrix3 }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Matrix3 }, anisotropyVector: { value: new Vector2 }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Matrix3 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }; const _rgb = { r: 0, b: 0, g: 0 }, _e1$1 = new Euler, _m1$1 = new Matrix4; function WebGLBackground(fe, K, pe, me, ge, xe, ye) { const ve = new Color$1(0); let _e = xe === !0 ? 0 : 1, Ee, be, Ae = null, Se = 0, Ce = null; function we(Pe) { let Ne = Pe.isScene === !0 ? Pe.background : null; return Ne && Ne.isTexture && (Ne = (Pe.backgroundBlurriness > 0 ? pe : K).get(Ne)), Ne } function Be(Pe) { let Ne = !1; const ke = we(Pe); ke === null ? Re(ve, _e) : ke && ke.isColor && (Re(ke, 1), Ne = !0); const Oe = fe.xr.getEnvironmentBlendMode(); Oe === "additive" ? me.buffers.color.setClear(0, 0, 0, 1, ye) : Oe === "alpha-blend" && me.buffers.color.setClear(0, 0, 0, 0, ye), (fe.autoClear || Ne) && (me.buffers.depth.setTest(!0), me.buffers.depth.setMask(!0), me.buffers.color.setMask(!0), fe.clear(fe.autoClearColor, fe.autoClearDepth, fe.autoClearStencil)) } function De(Pe, Ne) { const ke = we(Ne); ke && (ke.isCubeTexture || ke.mapping === CubeUVReflectionMapping) ? (be === void 0 && (be = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({ name: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms), vertexShader: ShaderLib.backgroundCube.vertexShader, fragmentShader: ShaderLib.backgroundCube.fragmentShader, side: BackSide, depthTest: !1, depthWrite: !1, fog: !1 })), be.geometry.deleteAttribute("normal"), be.geometry.deleteAttribute("uv"), be.onBeforeRender = function (Oe, Ue, He) { this.matrixWorld.copyPosition(He.matrixWorld) }, Object.defineProperty(be.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), ge.update(be)), _e1$1.copy(Ne.backgroundRotation), _e1$1.x *= -1, _e1$1.y *= -1, _e1$1.z *= -1, ke.isCubeTexture && ke.isRenderTargetTexture === !1 && (_e1$1.y *= -1, _e1$1.z *= -1), be.material.uniforms.envMap.value = ke, be.material.uniforms.flipEnvMap.value = ke.isCubeTexture && ke.isRenderTargetTexture === !1 ? -1 : 1, be.material.uniforms.backgroundBlurriness.value = Ne.backgroundBlurriness, be.material.uniforms.backgroundIntensity.value = Ne.backgroundIntensity, be.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)), be.material.toneMapped = ColorManagement.getTransfer(ke.colorSpace) !== SRGBTransfer, (Ae !== ke || Se !== ke.version || Ce !== fe.toneMapping) && (be.material.needsUpdate = !0, Ae = ke, Se = ke.version, Ce = fe.toneMapping), be.layers.enableAll(), Pe.unshift(be, be.geometry, be.material, 0, 0, null)) : ke && ke.isTexture && (Ee === void 0 && (Ee = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ name: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: !1, depthWrite: !1, fog: !1 })), Ee.geometry.deleteAttribute("normal"), Object.defineProperty(Ee.material, "map", { get: function () { return this.uniforms.t2D.value } }), ge.update(Ee)), Ee.material.uniforms.t2D.value = ke, Ee.material.uniforms.backgroundIntensity.value = Ne.backgroundIntensity, Ee.material.toneMapped = ColorManagement.getTransfer(ke.colorSpace) !== SRGBTransfer, ke.matrixAutoUpdate === !0 && ke.updateMatrix(), Ee.material.uniforms.uvTransform.value.copy(ke.matrix), (Ae !== ke || Se !== ke.version || Ce !== fe.toneMapping) && (Ee.material.needsUpdate = !0, Ae = ke, Se = ke.version, Ce = fe.toneMapping), Ee.layers.enableAll(), Pe.unshift(Ee, Ee.geometry, Ee.material, 0, 0, null)) } function Re(Pe, Ne) { Pe.getRGB(_rgb, getUnlitUniformColorSpace(fe)), me.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, Ne, ye) } function Ie() { be !== void 0 && (be.geometry.dispose(), be.material.dispose(), be = void 0), Ee !== void 0 && (Ee.geometry.dispose(), Ee.material.dispose(), Ee = void 0) } return { getClearColor: function () { return ve }, setClearColor: function (Pe, Ne = 1) { ve.set(Pe), _e = Ne, Re(ve, _e) }, getClearAlpha: function () { return _e }, setClearAlpha: function (Pe) { _e = Pe, Re(ve, _e) }, render: Be, addToRenderList: De, dispose: Ie } } function WebGLBindingStates(fe, K) { const pe = fe.getParameter(fe.MAX_VERTEX_ATTRIBS), me = {}, ge = Se(null); let xe = ge, ye = !1; function ve(ze, We, Xe, Ye, Ze) { let ot = !1; const qe = Ae(Ye, Xe, We); xe !== qe && (xe = qe, Ee(xe.object)), ot = Ce(ze, Ye, Xe, Ze), ot && we(ze, Ye, Xe, Ze), Ze !== null && K.update(Ze, fe.ELEMENT_ARRAY_BUFFER), (ot || ye) && (ye = !1, Ne(ze, We, Xe, Ye), Ze !== null && fe.bindBuffer(fe.ELEMENT_ARRAY_BUFFER, K.get(Ze).buffer)) } function _e() { return fe.createVertexArray() } function Ee(ze) { return fe.bindVertexArray(ze) } function be(ze) { return fe.deleteVertexArray(ze) } function Ae(ze, We, Xe) { const Ye = Xe.wireframe === !0; let Ze = me[ze.id]; Ze === void 0 && (Ze = {}, me[ze.id] = Ze); let ot = Ze[We.id]; ot === void 0 && (ot = {}, Ze[We.id] = ot); let qe = ot[Ye]; return qe === void 0 && (qe = Se(_e()), ot[Ye] = qe), qe } function Se(ze) { const We = [], Xe = [], Ye = []; for (let Ze = 0; Ze < pe; Ze++)We[Ze] = 0, Xe[Ze] = 0, Ye[Ze] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: We, enabledAttributes: Xe, attributeDivisors: Ye, object: ze, attributes: {}, index: null } } function Ce(ze, We, Xe, Ye) { const Ze = xe.attributes, ot = We.attributes; let qe = 0; const Qe = Xe.getAttributes(); for (const st in Qe) if (Qe[st].location >= 0) { const Je = Ze[st]; let jt = ot[st]; if (jt === void 0 && (st === "instanceMatrix" && ze.instanceMatrix && (jt = ze.instanceMatrix), st === "instanceColor" && ze.instanceColor && (jt = ze.instanceColor)), Je === void 0 || Je.attribute !== jt || jt && Je.data !== jt.data) return !0; qe++ } return xe.attributesNum !== qe || xe.index !== Ye } function we(ze, We, Xe, Ye) { const Ze = {}, ot = We.attributes; let qe = 0; const Qe = Xe.getAttributes(); for (const st in Qe) if (Qe[st].location >= 0) { let Je = ot[st]; Je === void 0 && (st === "instanceMatrix" && ze.instanceMatrix && (Je = ze.instanceMatrix), st === "instanceColor" && ze.instanceColor && (Je = ze.instanceColor)); const jt = {}; jt.attribute = Je, Je && Je.data && (jt.data = Je.data), Ze[st] = jt, qe++ } xe.attributes = Ze, xe.attributesNum = qe, xe.index = Ye } function Be() { const ze = xe.newAttributes; for (let We = 0, Xe = ze.length; We < Xe; We++)ze[We] = 0 } function De(ze) { Re(ze, 0) } function Re(ze, We) { const Xe = xe.newAttributes, Ye = xe.enabledAttributes, Ze = xe.attributeDivisors; Xe[ze] = 1, Ye[ze] === 0 && (fe.enableVertexAttribArray(ze), Ye[ze] = 1), Ze[ze] !== We && (fe.vertexAttribDivisor(ze, We), Ze[ze] = We) } function Ie() { const ze = xe.newAttributes, We = xe.enabledAttributes; for (let Xe = 0, Ye = We.length; Xe < Ye; Xe++)We[Xe] !== ze[Xe] && (fe.disableVertexAttribArray(Xe), We[Xe] = 0) } function Pe(ze, We, Xe, Ye, Ze, ot, qe) { qe === !0 ? fe.vertexAttribIPointer(ze, We, Xe, Ze, ot) : fe.vertexAttribPointer(ze, We, Xe, Ye, Ze, ot) } function Ne(ze, We, Xe, Ye) { Be(); const Ze = Ye.attributes, ot = Xe.getAttributes(), qe = We.defaultAttributeValues; for (const Qe in ot) { const st = ot[Qe]; if (st.location >= 0) { let Nt = Ze[Qe]; if (Nt === void 0 && (Qe === "instanceMatrix" && ze.instanceMatrix && (Nt = ze.instanceMatrix), Qe === "instanceColor" && ze.instanceColor && (Nt = ze.instanceColor)), Nt !== void 0) { const Je = Nt.normalized, jt = Nt.itemSize, Xt = K.get(Nt); if (Xt === void 0) continue; const ct = Xt.buffer, nn = Xt.type, $t = Xt.bytesPerElement, an = nn === fe.INT || nn === fe.UNSIGNED_INT || Nt.gpuType === IntType; if (Nt.isInterleavedBufferAttribute) { const gn = Nt.data, Mn = gn.stride, Xn = Nt.offset; if (gn.isInstancedInterleavedBuffer) { for (let Ln = 0; Ln < st.locationSize; Ln++)Re(st.location + Ln, gn.meshPerAttribute); ze.isInstancedMesh !== !0 && Ye._maxInstanceCount === void 0 && (Ye._maxInstanceCount = gn.meshPerAttribute * gn.count) } else for (let Ln = 0; Ln < st.locationSize; Ln++)De(st.location + Ln); fe.bindBuffer(fe.ARRAY_BUFFER, ct); for (let Ln = 0; Ln < st.locationSize; Ln++)Pe(st.location + Ln, jt / st.locationSize, nn, Je, Mn * $t, (Xn + jt / st.locationSize * Ln) * $t, an) } else { if (Nt.isInstancedBufferAttribute) { for (let gn = 0; gn < st.locationSize; gn++)Re(st.location + gn, Nt.meshPerAttribute); ze.isInstancedMesh !== !0 && Ye._maxInstanceCount === void 0 && (Ye._maxInstanceCount = Nt.meshPerAttribute * Nt.count) } else for (let gn = 0; gn < st.locationSize; gn++)De(st.location + gn); fe.bindBuffer(fe.ARRAY_BUFFER, ct); for (let gn = 0; gn < st.locationSize; gn++)Pe(st.location + gn, jt / st.locationSize, nn, Je, jt * $t, jt / st.locationSize * gn * $t, an) } } else if (qe !== void 0) { const Je = qe[Qe]; if (Je !== void 0) switch (Je.length) { case 2: fe.vertexAttrib2fv(st.location, Je); break; case 3: fe.vertexAttrib3fv(st.location, Je); break; case 4: fe.vertexAttrib4fv(st.location, Je); break; default: fe.vertexAttrib1fv(st.location, Je) } } } } Ie() } function ke() { He(); for (const ze in me) { const We = me[ze]; for (const Xe in We) { const Ye = We[Xe]; for (const Ze in Ye) be(Ye[Ze].object), delete Ye[Ze]; delete We[Xe] } delete me[ze] } } function Oe(ze) { if (me[ze.id] === void 0) return; const We = me[ze.id]; for (const Xe in We) { const Ye = We[Xe]; for (const Ze in Ye) be(Ye[Ze].object), delete Ye[Ze]; delete We[Xe] } delete me[ze.id] } function Ue(ze) { for (const We in me) { const Xe = me[We]; if (Xe[ze.id] === void 0) continue; const Ye = Xe[ze.id]; for (const Ze in Ye) be(Ye[Ze].object), delete Ye[Ze]; delete Xe[ze.id] } } function He() { Ge(), ye = !0, xe !== ge && (xe = ge, Ee(xe.object)) } function Ge() { ge.geometry = null, ge.program = null, ge.wireframe = !1 } return { setup: ve, reset: He, resetDefaultState: Ge, dispose: ke, releaseStatesOfGeometry: Oe, releaseStatesOfProgram: Ue, initAttributes: Be, enableAttribute: De, disableUnusedAttributes: Ie } } function WebGLBufferRenderer(fe, K, pe) { let me; function ge(Ee) { me = Ee } function xe(Ee, be) { fe.drawArrays(me, Ee, be), pe.update(be, me, 1) } function ye(Ee, be, Ae) { Ae !== 0 && (fe.drawArraysInstanced(me, Ee, be, Ae), pe.update(be, me, Ae)) } function ve(Ee, be, Ae) { if (Ae === 0) return; K.get("WEBGL_multi_draw").multiDrawArraysWEBGL(me, Ee, 0, be, 0, Ae); let Ce = 0; for (let we = 0; we < Ae; we++)Ce += be[we]; pe.update(Ce, me, 1) } function _e(Ee, be, Ae, Se) { if (Ae === 0) return; const Ce = K.get("WEBGL_multi_draw"); if (Ce === null) for (let we = 0; we < Ee.length; we++)ye(Ee[we], be[we], Se[we]); else { Ce.multiDrawArraysInstancedWEBGL(me, Ee, 0, be, 0, Se, 0, Ae); let we = 0; for (let Be = 0; Be < Ae; Be++)we += be[Be] * Se[Be]; pe.update(we, me, 1) } } this.setMode = ge, this.render = xe, this.renderInstances = ye, this.renderMultiDraw = ve, this.renderMultiDrawInstances = _e } function WebGLCapabilities(fe, K, pe, me) { let ge; function xe() { if (ge !== void 0) return ge; if (K.has("EXT_texture_filter_anisotropic") === !0) { const Ue = K.get("EXT_texture_filter_anisotropic"); ge = fe.getParameter(Ue.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else ge = 0; return ge } function ye(Ue) { return !(Ue !== RGBAFormat && me.convert(Ue) !== fe.getParameter(fe.IMPLEMENTATION_COLOR_READ_FORMAT)) } function ve(Ue) { const He = Ue === HalfFloatType && (K.has("EXT_color_buffer_half_float") || K.has("EXT_color_buffer_float")); return !(Ue !== UnsignedByteType && me.convert(Ue) !== fe.getParameter(fe.IMPLEMENTATION_COLOR_READ_TYPE) && Ue !== FloatType && !He) } function _e(Ue) { if (Ue === "highp") { if (fe.getShaderPrecisionFormat(fe.VERTEX_SHADER, fe.HIGH_FLOAT).precision > 0 && fe.getShaderPrecisionFormat(fe.FRAGMENT_SHADER, fe.HIGH_FLOAT).precision > 0) return "highp"; Ue = "mediump" } return Ue === "mediump" && fe.getShaderPrecisionFormat(fe.VERTEX_SHADER, fe.MEDIUM_FLOAT).precision > 0 && fe.getShaderPrecisionFormat(fe.FRAGMENT_SHADER, fe.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let Ee = pe.precision !== void 0 ? pe.precision : "highp"; const be = _e(Ee); be !== Ee && (console.warn("THREE.WebGLRenderer:", Ee, "not supported, using", be, "instead."), Ee = be); const Ae = pe.logarithmicDepthBuffer === !0, Se = pe.reverseDepthBuffer === !0 && K.has("EXT_clip_control"), Ce = fe.getParameter(fe.MAX_TEXTURE_IMAGE_UNITS), we = fe.getParameter(fe.MAX_VERTEX_TEXTURE_IMAGE_UNITS), Be = fe.getParameter(fe.MAX_TEXTURE_SIZE), De = fe.getParameter(fe.MAX_CUBE_MAP_TEXTURE_SIZE), Re = fe.getParameter(fe.MAX_VERTEX_ATTRIBS), Ie = fe.getParameter(fe.MAX_VERTEX_UNIFORM_VECTORS), Pe = fe.getParameter(fe.MAX_VARYING_VECTORS), Ne = fe.getParameter(fe.MAX_FRAGMENT_UNIFORM_VECTORS), ke = we > 0, Oe = fe.getParameter(fe.MAX_SAMPLES); return { isWebGL2: !0, getMaxAnisotropy: xe, getMaxPrecision: _e, textureFormatReadable: ye, textureTypeReadable: ve, precision: Ee, logarithmicDepthBuffer: Ae, reverseDepthBuffer: Se, maxTextures: Ce, maxVertexTextures: we, maxTextureSize: Be, maxCubemapSize: De, maxAttributes: Re, maxVertexUniforms: Ie, maxVaryings: Pe, maxFragmentUniforms: Ne, vertexTextures: ke, maxSamples: Oe } } function WebGLClipping(fe) { const K = this; let pe = null, me = 0, ge = !1, xe = !1; const ye = new Plane, ve = new Matrix3, _e = { value: null, needsUpdate: !1 }; this.uniform = _e, this.numPlanes = 0, this.numIntersection = 0, this.init = function (Ae, Se) { const Ce = Ae.length !== 0 || Se || me !== 0 || ge; return ge = Se, me = Ae.length, Ce }, this.beginShadows = function () { xe = !0, be(null) }, this.endShadows = function () { xe = !1 }, this.setGlobalState = function (Ae, Se) { pe = be(Ae, Se, 0) }, this.setState = function (Ae, Se, Ce) { const we = Ae.clippingPlanes, Be = Ae.clipIntersection, De = Ae.clipShadows, Re = fe.get(Ae); if (!ge || we === null || we.length === 0 || xe && !De) xe ? be(null) : Ee(); else { const Ie = xe ? 0 : me, Pe = Ie * 4; let Ne = Re.clippingState || null; _e.value = Ne, Ne = be(we, Se, Pe, Ce); for (let ke = 0; ke !== Pe; ++ke)Ne[ke] = pe[ke]; Re.clippingState = Ne, this.numIntersection = Be ? this.numPlanes : 0, this.numPlanes += Ie } }; function Ee() { _e.value !== pe && (_e.value = pe, _e.needsUpdate = me > 0), K.numPlanes = me, K.numIntersection = 0 } function be(Ae, Se, Ce, we) { const Be = Ae !== null ? Ae.length : 0; let De = null; if (Be !== 0) { if (De = _e.value, we !== !0 || De === null) { const Re = Ce + Be * 4, Ie = Se.matrixWorldInverse; ve.getNormalMatrix(Ie), (De === null || De.length < Re) && (De = new Float32Array(Re)); for (let Pe = 0, Ne = Ce; Pe !== Be; ++Pe, Ne += 4)ye.copy(Ae[Pe]).applyMatrix4(Ie, ve), ye.normal.toArray(De, Ne), De[Ne + 3] = ye.constant } _e.value = De, _e.needsUpdate = !0 } return K.numPlanes = Be, K.numIntersection = 0, De } } function WebGLCubeMaps(fe) { let K = new WeakMap; function pe(ye, ve) { return ve === EquirectangularReflectionMapping ? ye.mapping = CubeReflectionMapping : ve === EquirectangularRefractionMapping && (ye.mapping = CubeRefractionMapping), ye } function me(ye) { if (ye && ye.isTexture) { const ve = ye.mapping; if (ve === EquirectangularReflectionMapping || ve === EquirectangularRefractionMapping) if (K.has(ye)) { const _e = K.get(ye).texture; return pe(_e, ye.mapping) } else { const _e = ye.image; if (_e && _e.height > 0) { const Ee = new WebGLCubeRenderTarget(_e.height); return Ee.fromEquirectangularTexture(fe, ye), K.set(ye, Ee), ye.addEventListener("dispose", ge), pe(Ee.texture, ye.mapping) } else return null } } return ye } function ge(ye) { const ve = ye.target; ve.removeEventListener("dispose", ge); const _e = K.get(ve); _e !== void 0 && (K.delete(ve), _e.dispose()) } function xe() { K = new WeakMap } return { get: me, dispose: xe } } const LOD_MIN = 4, EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582], MAX_SAMPLES = 20, _flatCamera = new OrthographicCamera, _clearColor = new Color$1; let _oldTarget = null, _oldActiveCubeFace = 0, _oldActiveMipmapLevel = 0, _oldXrEnabled = !1; const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [new Vector3(-PHI, INV_PHI, 0), new Vector3(PHI, INV_PHI, 0), new Vector3(-INV_PHI, 0, PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(0, PHI, INV_PHI), new Vector3(-1, 1, -1), new Vector3(1, 1, -1), new Vector3(-1, 1, 1), new Vector3(1, 1, 1)], _origin = new Vector3; class PMREMGenerator { constructor(K) { this._renderer = K, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(K, pe = 0, me = .1, ge = 100, xe = {}) { const { size: ye = 256, position: ve = _origin } = xe; _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(ye); const _e = this._allocateTargets(); return _e.depthBuffer = !0, this._sceneToCubeUV(K, me, ge, _e, ve), pe > 0 && this._blur(_e, 0, 0, pe), this._applyPMREM(_e), this._cleanup(_e), _e } fromEquirectangular(K, pe = null) { return this._fromTexture(K, pe) } fromCubemap(K, pe = null) { return this._fromTexture(K, pe) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(K) { this._lodMax = Math.floor(Math.log2(K)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let K = 0; K < this._lodPlanes.length; K++)this._lodPlanes[K].dispose() } _cleanup(K) { this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), this._renderer.xr.enabled = _oldXrEnabled, K.scissorTest = !1, _setViewport(K, 0, 0, K.width, K.height) } _fromTexture(K, pe) { K.mapping === CubeReflectionMapping || K.mapping === CubeRefractionMapping ? this._setSize(K.image.length === 0 ? 16 : K.image[0].width || K.image[0].image.width) : this._setSize(K.image.width / 4), _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; const me = pe || this._allocateTargets(); return this._textureToCubeUV(K, me), this._applyPMREM(me), this._cleanup(me), me } _allocateTargets() { const K = 3 * Math.max(this._cubeSize, 112), pe = 4 * this._cubeSize, me = { magFilter: LinearFilter, minFilter: LinearFilter, generateMipmaps: !1, type: HalfFloatType, format: RGBAFormat, colorSpace: LinearSRGBColorSpace, depthBuffer: !1 }, ge = _createRenderTarget(K, pe, me); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== K || this._pingPongRenderTarget.height !== pe) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _createRenderTarget(K, pe, me); const { _lodMax: xe } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(xe)), this._blurMaterial = _getBlurShader(xe, K, pe) } return ge } _compileMaterial(K) { const pe = new Mesh(this._lodPlanes[0], K); this._renderer.compile(pe, _flatCamera) } _sceneToCubeUV(K, pe, me, ge, xe) { const _e = new PerspectiveCamera(90, 1, pe, me), Ee = [1, -1, 1, 1, 1, 1], be = [1, 1, 1, -1, -1, -1], Ae = this._renderer, Se = Ae.autoClear, Ce = Ae.toneMapping; Ae.getClearColor(_clearColor), Ae.toneMapping = NoToneMapping, Ae.autoClear = !1; const we = new MeshBasicMaterial({ name: "PMREM.Background", side: BackSide, depthWrite: !1, depthTest: !1 }), Be = new Mesh(new BoxGeometry, we); let De = !1; const Re = K.background; Re ? Re.isColor && (we.color.copy(Re), K.background = null, De = !0) : (we.color.copy(_clearColor), De = !0); for (let Ie = 0; Ie < 6; Ie++) { const Pe = Ie % 3; Pe === 0 ? (_e.up.set(0, Ee[Ie], 0), _e.position.set(xe.x, xe.y, xe.z), _e.lookAt(xe.x + be[Ie], xe.y, xe.z)) : Pe === 1 ? (_e.up.set(0, 0, Ee[Ie]), _e.position.set(xe.x, xe.y, xe.z), _e.lookAt(xe.x, xe.y + be[Ie], xe.z)) : (_e.up.set(0, Ee[Ie], 0), _e.position.set(xe.x, xe.y, xe.z), _e.lookAt(xe.x, xe.y, xe.z + be[Ie])); const Ne = this._cubeSize; _setViewport(ge, Pe * Ne, Ie > 2 ? Ne : 0, Ne, Ne), Ae.setRenderTarget(ge), De && Ae.render(Be, _e), Ae.render(K, _e) } Be.geometry.dispose(), Be.material.dispose(), Ae.toneMapping = Ce, Ae.autoClear = Se, K.background = Re } _textureToCubeUV(K, pe) { const me = this._renderer, ge = K.mapping === CubeReflectionMapping || K.mapping === CubeRefractionMapping; ge ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()), this._cubemapMaterial.uniforms.flipEnvMap.value = K.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial()); const xe = ge ? this._cubemapMaterial : this._equirectMaterial, ye = new Mesh(this._lodPlanes[0], xe), ve = xe.uniforms; ve.envMap.value = K; const _e = this._cubeSize; _setViewport(pe, 0, 0, 3 * _e, 2 * _e), me.setRenderTarget(pe), me.render(ye, _flatCamera) } _applyPMREM(K) { const pe = this._renderer, me = pe.autoClear; pe.autoClear = !1; const ge = this._lodPlanes.length; for (let xe = 1; xe < ge; xe++) { const ye = Math.sqrt(this._sigmas[xe] * this._sigmas[xe] - this._sigmas[xe - 1] * this._sigmas[xe - 1]), ve = _axisDirections[(ge - xe - 1) % _axisDirections.length]; this._blur(K, xe - 1, xe, ye, ve) } pe.autoClear = me } _blur(K, pe, me, ge, xe) { const ye = this._pingPongRenderTarget; this._halfBlur(K, ye, pe, me, ge, "latitudinal", xe), this._halfBlur(ye, K, me, me, ge, "longitudinal", xe) } _halfBlur(K, pe, me, ge, xe, ye, ve) { const _e = this._renderer, Ee = this._blurMaterial; ye !== "latitudinal" && ye !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const be = 3, Ae = new Mesh(this._lodPlanes[ge], Ee), Se = Ee.uniforms, Ce = this._sizeLods[me] - 1, we = isFinite(xe) ? Math.PI / (2 * Ce) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), Be = xe / we, De = isFinite(xe) ? 1 + Math.floor(be * Be) : MAX_SAMPLES; De > MAX_SAMPLES && console.warn(`sigmaRadians, ${xe}, is too large and will clip, as it requested ${De} samples when the maximum is set to ${MAX_SAMPLES}`); const Re = []; let Ie = 0; for (let Ue = 0; Ue < MAX_SAMPLES; ++Ue) { const He = Ue / Be, Ge = Math.exp(-He * He / 2); Re.push(Ge), Ue === 0 ? Ie += Ge : Ue < De && (Ie += 2 * Ge) } for (let Ue = 0; Ue < Re.length; Ue++)Re[Ue] = Re[Ue] / Ie; Se.envMap.value = K.texture, Se.samples.value = De, Se.weights.value = Re, Se.latitudinal.value = ye === "latitudinal", ve && (Se.poleAxis.value = ve); const { _lodMax: Pe } = this; Se.dTheta.value = we, Se.mipInt.value = Pe - me; const Ne = this._sizeLods[ge], ke = 3 * Ne * (ge > Pe - LOD_MIN ? ge - Pe + LOD_MIN : 0), Oe = 4 * (this._cubeSize - Ne); _setViewport(pe, ke, Oe, 3 * Ne, 2 * Ne), _e.setRenderTarget(pe), _e.render(Ae, _flatCamera) } } function _createPlanes(fe) { const K = [], pe = [], me = []; let ge = fe; const xe = fe - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; for (let ye = 0; ye < xe; ye++) { const ve = Math.pow(2, ge); pe.push(ve); let _e = 1 / ve; ye > fe - LOD_MIN ? _e = EXTRA_LOD_SIGMA[ye - fe + LOD_MIN - 1] : ye === 0 && (_e = 0), me.push(_e); const Ee = 1 / (ve - 2), be = -Ee, Ae = 1 + Ee, Se = [be, be, Ae, be, Ae, Ae, be, be, Ae, Ae, be, Ae], Ce = 6, we = 6, Be = 3, De = 2, Re = 1, Ie = new Float32Array(Be * we * Ce), Pe = new Float32Array(De * we * Ce), Ne = new Float32Array(Re * we * Ce); for (let Oe = 0; Oe < Ce; Oe++) { const Ue = Oe % 3 * 2 / 3 - 1, He = Oe > 2 ? 0 : -1, Ge = [Ue, He, 0, Ue + 2 / 3, He, 0, Ue + 2 / 3, He + 1, 0, Ue, He, 0, Ue + 2 / 3, He + 1, 0, Ue, He + 1, 0]; Ie.set(Ge, Be * we * Oe), Pe.set(Se, De * we * Oe); const ze = [Oe, Oe, Oe, Oe, Oe, Oe]; Ne.set(ze, Re * we * Oe) } const ke = new BufferGeometry; ke.setAttribute("position", new BufferAttribute(Ie, Be)), ke.setAttribute("uv", new BufferAttribute(Pe, De)), ke.setAttribute("faceIndex", new BufferAttribute(Ne, Re)), K.push(ke), ge > LOD_MIN && ge-- } return { lodPlanes: K, sizeLods: pe, sigmas: me } } function _createRenderTarget(fe, K, pe) { const me = new WebGLRenderTarget(fe, K, pe); return me.texture.mapping = CubeUVReflectionMapping, me.texture.name = "PMREM.cubeUv", me.scissorTest = !0, me } function _setViewport(fe, K, pe, me, ge) { fe.viewport.set(K, pe, me, ge), fe.scissor.set(K, pe, me, ge) } function _getBlurShader(fe, K, pe) {
	const me = new Float32Array(MAX_SAMPLES), ge = new Vector3(0, 1, 0); return new ShaderMaterial({
		name: "SphericalGaussianBlur", defines: { n: MAX_SAMPLES, CUBEUV_TEXEL_WIDTH: 1 / K, CUBEUV_TEXEL_HEIGHT: 1 / pe, CUBEUV_MAX_MIP: `${fe}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: me }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: ge } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
	})
} function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
	})
} function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
	})
} function _getCommonVertexShader() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function WebGLCubeUVMaps(fe) { let K = new WeakMap, pe = null; function me(ve) { if (ve && ve.isTexture) { const _e = ve.mapping, Ee = _e === EquirectangularReflectionMapping || _e === EquirectangularRefractionMapping, be = _e === CubeReflectionMapping || _e === CubeRefractionMapping; if (Ee || be) { let Ae = K.get(ve); const Se = Ae !== void 0 ? Ae.texture.pmremVersion : 0; if (ve.isRenderTargetTexture && ve.pmremVersion !== Se) return pe === null && (pe = new PMREMGenerator(fe)), Ae = Ee ? pe.fromEquirectangular(ve, Ae) : pe.fromCubemap(ve, Ae), Ae.texture.pmremVersion = ve.pmremVersion, K.set(ve, Ae), Ae.texture; if (Ae !== void 0) return Ae.texture; { const Ce = ve.image; return Ee && Ce && Ce.height > 0 || be && Ce && ge(Ce) ? (pe === null && (pe = new PMREMGenerator(fe)), Ae = Ee ? pe.fromEquirectangular(ve) : pe.fromCubemap(ve), Ae.texture.pmremVersion = ve.pmremVersion, K.set(ve, Ae), ve.addEventListener("dispose", xe), Ae.texture) : null } } } return ve } function ge(ve) { let _e = 0; const Ee = 6; for (let be = 0; be < Ee; be++)ve[be] !== void 0 && _e++; return _e === Ee } function xe(ve) { const _e = ve.target; _e.removeEventListener("dispose", xe); const Ee = K.get(_e); Ee !== void 0 && (K.delete(_e), Ee.dispose()) } function ye() { K = new WeakMap, pe !== null && (pe.dispose(), pe = null) } return { get: me, dispose: ye } } function WebGLExtensions(fe) { const K = {}; function pe(me) { if (K[me] !== void 0) return K[me]; let ge; switch (me) { case "WEBGL_depth_texture": ge = fe.getExtension("WEBGL_depth_texture") || fe.getExtension("MOZ_WEBGL_depth_texture") || fe.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": ge = fe.getExtension("EXT_texture_filter_anisotropic") || fe.getExtension("MOZ_EXT_texture_filter_anisotropic") || fe.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": ge = fe.getExtension("WEBGL_compressed_texture_s3tc") || fe.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || fe.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": ge = fe.getExtension("WEBGL_compressed_texture_pvrtc") || fe.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: ge = fe.getExtension(me) }return K[me] = ge, ge } return { has: function (me) { return pe(me) !== null }, init: function () { pe("EXT_color_buffer_float"), pe("WEBGL_clip_cull_distance"), pe("OES_texture_float_linear"), pe("EXT_color_buffer_half_float"), pe("WEBGL_multisampled_render_to_texture"), pe("WEBGL_render_shared_exponent") }, get: function (me) { const ge = pe(me); return ge === null && warnOnce("THREE.WebGLRenderer: " + me + " extension not supported."), ge } } } function WebGLGeometries(fe, K, pe, me) { const ge = {}, xe = new WeakMap; function ye(Ae) { const Se = Ae.target; Se.index !== null && K.remove(Se.index); for (const we in Se.attributes) K.remove(Se.attributes[we]); Se.removeEventListener("dispose", ye), delete ge[Se.id]; const Ce = xe.get(Se); Ce && (K.remove(Ce), xe.delete(Se)), me.releaseStatesOfGeometry(Se), Se.isInstancedBufferGeometry === !0 && delete Se._maxInstanceCount, pe.memory.geometries-- } function ve(Ae, Se) { return ge[Se.id] === !0 || (Se.addEventListener("dispose", ye), ge[Se.id] = !0, pe.memory.geometries++), Se } function _e(Ae) { const Se = Ae.attributes; for (const Ce in Se) K.update(Se[Ce], fe.ARRAY_BUFFER) } function Ee(Ae) { const Se = [], Ce = Ae.index, we = Ae.attributes.position; let Be = 0; if (Ce !== null) { const Ie = Ce.array; Be = Ce.version; for (let Pe = 0, Ne = Ie.length; Pe < Ne; Pe += 3) { const ke = Ie[Pe + 0], Oe = Ie[Pe + 1], Ue = Ie[Pe + 2]; Se.push(ke, Oe, Oe, Ue, Ue, ke) } } else if (we !== void 0) { const Ie = we.array; Be = we.version; for (let Pe = 0, Ne = Ie.length / 3 - 1; Pe < Ne; Pe += 3) { const ke = Pe + 0, Oe = Pe + 1, Ue = Pe + 2; Se.push(ke, Oe, Oe, Ue, Ue, ke) } } else return; const De = new (arrayNeedsUint32(Se) ? Uint32BufferAttribute : Uint16BufferAttribute)(Se, 1); De.version = Be; const Re = xe.get(Ae); Re && K.remove(Re), xe.set(Ae, De) } function be(Ae) { const Se = xe.get(Ae); if (Se) { const Ce = Ae.index; Ce !== null && Se.version < Ce.version && Ee(Ae) } else Ee(Ae); return xe.get(Ae) } return { get: ve, update: _e, getWireframeAttribute: be } } function WebGLIndexedBufferRenderer(fe, K, pe) { let me; function ge(Se) { me = Se } let xe, ye; function ve(Se) { xe = Se.type, ye = Se.bytesPerElement } function _e(Se, Ce) { fe.drawElements(me, Ce, xe, Se * ye), pe.update(Ce, me, 1) } function Ee(Se, Ce, we) { we !== 0 && (fe.drawElementsInstanced(me, Ce, xe, Se * ye, we), pe.update(Ce, me, we)) } function be(Se, Ce, we) { if (we === 0) return; K.get("WEBGL_multi_draw").multiDrawElementsWEBGL(me, Ce, 0, xe, Se, 0, we); let De = 0; for (let Re = 0; Re < we; Re++)De += Ce[Re]; pe.update(De, me, 1) } function Ae(Se, Ce, we, Be) { if (we === 0) return; const De = K.get("WEBGL_multi_draw"); if (De === null) for (let Re = 0; Re < Se.length; Re++)Ee(Se[Re] / ye, Ce[Re], Be[Re]); else { De.multiDrawElementsInstancedWEBGL(me, Ce, 0, xe, Se, 0, Be, 0, we); let Re = 0; for (let Ie = 0; Ie < we; Ie++)Re += Ce[Ie] * Be[Ie]; pe.update(Re, me, 1) } } this.setMode = ge, this.setIndex = ve, this.render = _e, this.renderInstances = Ee, this.renderMultiDraw = be, this.renderMultiDrawInstances = Ae } function WebGLInfo(fe) { const K = { geometries: 0, textures: 0 }, pe = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function me(xe, ye, ve) { switch (pe.calls++, ye) { case fe.TRIANGLES: pe.triangles += ve * (xe / 3); break; case fe.LINES: pe.lines += ve * (xe / 2); break; case fe.LINE_STRIP: pe.lines += ve * (xe - 1); break; case fe.LINE_LOOP: pe.lines += ve * xe; break; case fe.POINTS: pe.points += ve * xe; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", ye); break } } function ge() { pe.calls = 0, pe.triangles = 0, pe.points = 0, pe.lines = 0 } return { memory: K, render: pe, programs: null, autoReset: !0, reset: ge, update: me } } function WebGLMorphtargets(fe, K, pe) { const me = new WeakMap, ge = new Vector4; function xe(ye, ve, _e) { const Ee = ye.morphTargetInfluences, be = ve.morphAttributes.position || ve.morphAttributes.normal || ve.morphAttributes.color, Ae = be !== void 0 ? be.length : 0; let Se = me.get(ve); if (Se === void 0 || Se.count !== Ae) { let Ge = function () { Ue.dispose(), me.delete(ve), ve.removeEventListener("dispose", Ge) }; Se !== void 0 && Se.texture.dispose(); const Ce = ve.morphAttributes.position !== void 0, we = ve.morphAttributes.normal !== void 0, Be = ve.morphAttributes.color !== void 0, De = ve.morphAttributes.position || [], Re = ve.morphAttributes.normal || [], Ie = ve.morphAttributes.color || []; let Pe = 0; Ce === !0 && (Pe = 1), we === !0 && (Pe = 2), Be === !0 && (Pe = 3); let Ne = ve.attributes.position.count * Pe, ke = 1; Ne > K.maxTextureSize && (ke = Math.ceil(Ne / K.maxTextureSize), Ne = K.maxTextureSize); const Oe = new Float32Array(Ne * ke * 4 * Ae), Ue = new DataArrayTexture(Oe, Ne, ke, Ae); Ue.type = FloatType, Ue.needsUpdate = !0; const He = Pe * 4; for (let ze = 0; ze < Ae; ze++) { const We = De[ze], Xe = Re[ze], Ye = Ie[ze], Ze = Ne * ke * 4 * ze; for (let ot = 0; ot < We.count; ot++) { const qe = ot * He; Ce === !0 && (ge.fromBufferAttribute(We, ot), Oe[Ze + qe + 0] = ge.x, Oe[Ze + qe + 1] = ge.y, Oe[Ze + qe + 2] = ge.z, Oe[Ze + qe + 3] = 0), we === !0 && (ge.fromBufferAttribute(Xe, ot), Oe[Ze + qe + 4] = ge.x, Oe[Ze + qe + 5] = ge.y, Oe[Ze + qe + 6] = ge.z, Oe[Ze + qe + 7] = 0), Be === !0 && (ge.fromBufferAttribute(Ye, ot), Oe[Ze + qe + 8] = ge.x, Oe[Ze + qe + 9] = ge.y, Oe[Ze + qe + 10] = ge.z, Oe[Ze + qe + 11] = Ye.itemSize === 4 ? ge.w : 1) } } Se = { count: Ae, texture: Ue, size: new Vector2(Ne, ke) }, me.set(ve, Se), ve.addEventListener("dispose", Ge) } if (ye.isInstancedMesh === !0 && ye.morphTexture !== null) _e.getUniforms().setValue(fe, "morphTexture", ye.morphTexture, pe); else { let Ce = 0; for (let Be = 0; Be < Ee.length; Be++)Ce += Ee[Be]; const we = ve.morphTargetsRelative ? 1 : 1 - Ce; _e.getUniforms().setValue(fe, "morphTargetBaseInfluence", we), _e.getUniforms().setValue(fe, "morphTargetInfluences", Ee) } _e.getUniforms().setValue(fe, "morphTargetsTexture", Se.texture, pe), _e.getUniforms().setValue(fe, "morphTargetsTextureSize", Se.size) } return { update: xe } } function WebGLObjects(fe, K, pe, me) { let ge = new WeakMap; function xe(_e) { const Ee = me.render.frame, be = _e.geometry, Ae = K.get(_e, be); if (ge.get(Ae) !== Ee && (K.update(Ae), ge.set(Ae, Ee)), _e.isInstancedMesh && (_e.hasEventListener("dispose", ve) === !1 && _e.addEventListener("dispose", ve), ge.get(_e) !== Ee && (pe.update(_e.instanceMatrix, fe.ARRAY_BUFFER), _e.instanceColor !== null && pe.update(_e.instanceColor, fe.ARRAY_BUFFER), ge.set(_e, Ee))), _e.isSkinnedMesh) { const Se = _e.skeleton; ge.get(Se) !== Ee && (Se.update(), ge.set(Se, Ee)) } return Ae } function ye() { ge = new WeakMap } function ve(_e) { const Ee = _e.target; Ee.removeEventListener("dispose", ve), pe.remove(Ee.instanceMatrix), Ee.instanceColor !== null && pe.remove(Ee.instanceColor) } return { update: xe, dispose: ye } } const emptyTexture = new Texture, emptyShadowTexture = new DepthTexture(1, 1), emptyArrayTexture = new DataArrayTexture, empty3dTexture = new Data3DTexture, emptyCubeTexture = new CubeTexture, arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4); function flatten(fe, K, pe) { const me = fe[0]; if (me <= 0 || me > 0) return fe; const ge = K * pe; let xe = arrayCacheF32[ge]; if (xe === void 0 && (xe = new Float32Array(ge), arrayCacheF32[ge] = xe), K !== 0) { me.toArray(xe, 0); for (let ye = 1, ve = 0; ye !== K; ++ye)ve += pe, fe[ye].toArray(xe, ve) } return xe } function arraysEqual(fe, K) { if (fe.length !== K.length) return !1; for (let pe = 0, me = fe.length; pe < me; pe++)if (fe[pe] !== K[pe]) return !1; return !0 } function copyArray(fe, K) { for (let pe = 0, me = K.length; pe < me; pe++)fe[pe] = K[pe] } function allocTexUnits(fe, K) { let pe = arrayCacheI32[K]; pe === void 0 && (pe = new Int32Array(K), arrayCacheI32[K] = pe); for (let me = 0; me !== K; ++me)pe[me] = fe.allocateTextureUnit(); return pe } function setValueV1f(fe, K) { const pe = this.cache; pe[0] !== K && (fe.uniform1f(this.addr, K), pe[0] = K) } function setValueV2f(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y) && (fe.uniform2f(this.addr, K.x, K.y), pe[0] = K.x, pe[1] = K.y); else { if (arraysEqual(pe, K)) return; fe.uniform2fv(this.addr, K), copyArray(pe, K) } } function setValueV3f(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z) && (fe.uniform3f(this.addr, K.x, K.y, K.z), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z); else if (K.r !== void 0) (pe[0] !== K.r || pe[1] !== K.g || pe[2] !== K.b) && (fe.uniform3f(this.addr, K.r, K.g, K.b), pe[0] = K.r, pe[1] = K.g, pe[2] = K.b); else { if (arraysEqual(pe, K)) return; fe.uniform3fv(this.addr, K), copyArray(pe, K) } } function setValueV4f(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z || pe[3] !== K.w) && (fe.uniform4f(this.addr, K.x, K.y, K.z, K.w), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z, pe[3] = K.w); else { if (arraysEqual(pe, K)) return; fe.uniform4fv(this.addr, K), copyArray(pe, K) } } function setValueM2(fe, K) { const pe = this.cache, me = K.elements; if (me === void 0) { if (arraysEqual(pe, K)) return; fe.uniformMatrix2fv(this.addr, !1, K), copyArray(pe, K) } else { if (arraysEqual(pe, me)) return; mat2array.set(me), fe.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(pe, me) } } function setValueM3(fe, K) { const pe = this.cache, me = K.elements; if (me === void 0) { if (arraysEqual(pe, K)) return; fe.uniformMatrix3fv(this.addr, !1, K), copyArray(pe, K) } else { if (arraysEqual(pe, me)) return; mat3array.set(me), fe.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(pe, me) } } function setValueM4(fe, K) { const pe = this.cache, me = K.elements; if (me === void 0) { if (arraysEqual(pe, K)) return; fe.uniformMatrix4fv(this.addr, !1, K), copyArray(pe, K) } else { if (arraysEqual(pe, me)) return; mat4array.set(me), fe.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(pe, me) } } function setValueV1i(fe, K) { const pe = this.cache; pe[0] !== K && (fe.uniform1i(this.addr, K), pe[0] = K) } function setValueV2i(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y) && (fe.uniform2i(this.addr, K.x, K.y), pe[0] = K.x, pe[1] = K.y); else { if (arraysEqual(pe, K)) return; fe.uniform2iv(this.addr, K), copyArray(pe, K) } } function setValueV3i(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z) && (fe.uniform3i(this.addr, K.x, K.y, K.z), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z); else { if (arraysEqual(pe, K)) return; fe.uniform3iv(this.addr, K), copyArray(pe, K) } } function setValueV4i(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z || pe[3] !== K.w) && (fe.uniform4i(this.addr, K.x, K.y, K.z, K.w), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z, pe[3] = K.w); else { if (arraysEqual(pe, K)) return; fe.uniform4iv(this.addr, K), copyArray(pe, K) } } function setValueV1ui(fe, K) { const pe = this.cache; pe[0] !== K && (fe.uniform1ui(this.addr, K), pe[0] = K) } function setValueV2ui(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y) && (fe.uniform2ui(this.addr, K.x, K.y), pe[0] = K.x, pe[1] = K.y); else { if (arraysEqual(pe, K)) return; fe.uniform2uiv(this.addr, K), copyArray(pe, K) } } function setValueV3ui(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z) && (fe.uniform3ui(this.addr, K.x, K.y, K.z), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z); else { if (arraysEqual(pe, K)) return; fe.uniform3uiv(this.addr, K), copyArray(pe, K) } } function setValueV4ui(fe, K) { const pe = this.cache; if (K.x !== void 0) (pe[0] !== K.x || pe[1] !== K.y || pe[2] !== K.z || pe[3] !== K.w) && (fe.uniform4ui(this.addr, K.x, K.y, K.z, K.w), pe[0] = K.x, pe[1] = K.y, pe[2] = K.z, pe[3] = K.w); else { if (arraysEqual(pe, K)) return; fe.uniform4uiv(this.addr, K), copyArray(pe, K) } } function setValueT1(fe, K, pe) { const me = this.cache, ge = pe.allocateTextureUnit(); me[0] !== ge && (fe.uniform1i(this.addr, ge), me[0] = ge); let xe; this.type === fe.SAMPLER_2D_SHADOW ? (emptyShadowTexture.compareFunction = LessEqualCompare, xe = emptyShadowTexture) : xe = emptyTexture, pe.setTexture2D(K || xe, ge) } function setValueT3D1(fe, K, pe) { const me = this.cache, ge = pe.allocateTextureUnit(); me[0] !== ge && (fe.uniform1i(this.addr, ge), me[0] = ge), pe.setTexture3D(K || empty3dTexture, ge) } function setValueT6(fe, K, pe) { const me = this.cache, ge = pe.allocateTextureUnit(); me[0] !== ge && (fe.uniform1i(this.addr, ge), me[0] = ge), pe.setTextureCube(K || emptyCubeTexture, ge) } function setValueT2DArray1(fe, K, pe) { const me = this.cache, ge = pe.allocateTextureUnit(); me[0] !== ge && (fe.uniform1i(this.addr, ge), me[0] = ge), pe.setTexture2DArray(K || emptyArrayTexture, ge) } function getSingularSetter(fe) { switch (fe) { case 5126: return setValueV1f; case 35664: return setValueV2f; case 35665: return setValueV3f; case 35666: return setValueV4f; case 35674: return setValueM2; case 35675: return setValueM3; case 35676: return setValueM4; case 5124: case 35670: return setValueV1i; case 35667: case 35671: return setValueV2i; case 35668: case 35672: return setValueV3i; case 35669: case 35673: return setValueV4i; case 5125: return setValueV1ui; case 36294: return setValueV2ui; case 36295: return setValueV3ui; case 36296: return setValueV4ui; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1; case 35679: case 36299: case 36307: return setValueT3D1; case 35680: case 36300: case 36308: case 36293: return setValueT6; case 36289: case 36303: case 36311: case 36292: return setValueT2DArray1 } } function setValueV1fArray(fe, K) { fe.uniform1fv(this.addr, K) } function setValueV2fArray(fe, K) { const pe = flatten(K, this.size, 2); fe.uniform2fv(this.addr, pe) } function setValueV3fArray(fe, K) { const pe = flatten(K, this.size, 3); fe.uniform3fv(this.addr, pe) } function setValueV4fArray(fe, K) { const pe = flatten(K, this.size, 4); fe.uniform4fv(this.addr, pe) } function setValueM2Array(fe, K) { const pe = flatten(K, this.size, 4); fe.uniformMatrix2fv(this.addr, !1, pe) } function setValueM3Array(fe, K) { const pe = flatten(K, this.size, 9); fe.uniformMatrix3fv(this.addr, !1, pe) } function setValueM4Array(fe, K) { const pe = flatten(K, this.size, 16); fe.uniformMatrix4fv(this.addr, !1, pe) } function setValueV1iArray(fe, K) { fe.uniform1iv(this.addr, K) } function setValueV2iArray(fe, K) { fe.uniform2iv(this.addr, K) } function setValueV3iArray(fe, K) { fe.uniform3iv(this.addr, K) } function setValueV4iArray(fe, K) { fe.uniform4iv(this.addr, K) } function setValueV1uiArray(fe, K) { fe.uniform1uiv(this.addr, K) } function setValueV2uiArray(fe, K) { fe.uniform2uiv(this.addr, K) } function setValueV3uiArray(fe, K) { fe.uniform3uiv(this.addr, K) } function setValueV4uiArray(fe, K) { fe.uniform4uiv(this.addr, K) } function setValueT1Array(fe, K, pe) { const me = this.cache, ge = K.length, xe = allocTexUnits(pe, ge); arraysEqual(me, xe) || (fe.uniform1iv(this.addr, xe), copyArray(me, xe)); for (let ye = 0; ye !== ge; ++ye)pe.setTexture2D(K[ye] || emptyTexture, xe[ye]) } function setValueT3DArray(fe, K, pe) { const me = this.cache, ge = K.length, xe = allocTexUnits(pe, ge); arraysEqual(me, xe) || (fe.uniform1iv(this.addr, xe), copyArray(me, xe)); for (let ye = 0; ye !== ge; ++ye)pe.setTexture3D(K[ye] || empty3dTexture, xe[ye]) } function setValueT6Array(fe, K, pe) { const me = this.cache, ge = K.length, xe = allocTexUnits(pe, ge); arraysEqual(me, xe) || (fe.uniform1iv(this.addr, xe), copyArray(me, xe)); for (let ye = 0; ye !== ge; ++ye)pe.setTextureCube(K[ye] || emptyCubeTexture, xe[ye]) } function setValueT2DArrayArray(fe, K, pe) { const me = this.cache, ge = K.length, xe = allocTexUnits(pe, ge); arraysEqual(me, xe) || (fe.uniform1iv(this.addr, xe), copyArray(me, xe)); for (let ye = 0; ye !== ge; ++ye)pe.setTexture2DArray(K[ye] || emptyArrayTexture, xe[ye]) } function getPureArraySetter(fe) { switch (fe) { case 5126: return setValueV1fArray; case 35664: return setValueV2fArray; case 35665: return setValueV3fArray; case 35666: return setValueV4fArray; case 35674: return setValueM2Array; case 35675: return setValueM3Array; case 35676: return setValueM4Array; case 5124: case 35670: return setValueV1iArray; case 35667: case 35671: return setValueV2iArray; case 35668: case 35672: return setValueV3iArray; case 35669: case 35673: return setValueV4iArray; case 5125: return setValueV1uiArray; case 36294: return setValueV2uiArray; case 36295: return setValueV3uiArray; case 36296: return setValueV4uiArray; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1Array; case 35679: case 36299: case 36307: return setValueT3DArray; case 35680: case 36300: case 36308: case 36293: return setValueT6Array; case 36289: case 36303: case 36311: case 36292: return setValueT2DArrayArray } } class SingleUniform { constructor(K, pe, me) { this.id = K, this.addr = me, this.cache = [], this.type = pe.type, this.setValue = getSingularSetter(pe.type) } } class PureArrayUniform { constructor(K, pe, me) { this.id = K, this.addr = me, this.cache = [], this.type = pe.type, this.size = pe.size, this.setValue = getPureArraySetter(pe.type) } } class StructuredUniform { constructor(K) { this.id = K, this.seq = [], this.map = {} } setValue(K, pe, me) { const ge = this.seq; for (let xe = 0, ye = ge.length; xe !== ye; ++xe) { const ve = ge[xe]; ve.setValue(K, pe[ve.id], me) } } } const RePathPart = /(\w+)(\])?(\[|\.)?/g; function addUniform(fe, K) { fe.seq.push(K), fe.map[K.id] = K } function parseUniform(fe, K, pe) { const me = fe.name, ge = me.length; for (RePathPart.lastIndex = 0; ;) { const xe = RePathPart.exec(me), ye = RePathPart.lastIndex; let ve = xe[1]; const _e = xe[2] === "]", Ee = xe[3]; if (_e && (ve = ve | 0), Ee === void 0 || Ee === "[" && ye + 2 === ge) { addUniform(pe, Ee === void 0 ? new SingleUniform(ve, fe, K) : new PureArrayUniform(ve, fe, K)); break } else { let Ae = pe.map[ve]; Ae === void 0 && (Ae = new StructuredUniform(ve), addUniform(pe, Ae)), pe = Ae } } } class WebGLUniforms { constructor(K, pe) { this.seq = [], this.map = {}; const me = K.getProgramParameter(pe, K.ACTIVE_UNIFORMS); for (let ge = 0; ge < me; ++ge) { const xe = K.getActiveUniform(pe, ge), ye = K.getUniformLocation(pe, xe.name); parseUniform(xe, ye, this) } } setValue(K, pe, me, ge) { const xe = this.map[pe]; xe !== void 0 && xe.setValue(K, me, ge) } setOptional(K, pe, me) { const ge = pe[me]; ge !== void 0 && this.setValue(K, me, ge) } static upload(K, pe, me, ge) { for (let xe = 0, ye = pe.length; xe !== ye; ++xe) { const ve = pe[xe], _e = me[ve.id]; _e.needsUpdate !== !1 && ve.setValue(K, _e.value, ge) } } static seqWithValue(K, pe) { const me = []; for (let ge = 0, xe = K.length; ge !== xe; ++ge) { const ye = K[ge]; ye.id in pe && me.push(ye) } return me } } function WebGLShader(fe, K, pe) { const me = fe.createShader(K); return fe.shaderSource(me, pe), fe.compileShader(me), me } const COMPLETION_STATUS_KHR = 37297; let programIdCount = 0; function handleSource(fe, K) {
	const pe = fe.split(`
`), me = [], ge = Math.max(K - 6, 0), xe = Math.min(K + 6, pe.length); for (let ye = ge; ye < xe; ye++) { const ve = ye + 1; me.push(`${ve === K ? ">" : " "} ${ve}: ${pe[ye]}`) } return me.join(`
`)
} const _m0 = new Matrix3; function getEncodingComponents(fe) { ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, fe); const K = `mat3( ${_m0.elements.map(pe => pe.toFixed(4))} )`; switch (ColorManagement.getTransfer(fe)) { case LinearTransfer: return [K, "LinearTransferOETF"]; case SRGBTransfer: return [K, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space: ", fe), [K, "LinearTransferOETF"] } } function getShaderErrors(fe, K, pe) {
	const me = fe.getShaderParameter(K, fe.COMPILE_STATUS), ge = fe.getShaderInfoLog(K).trim(); if (me && ge === "") return ""; const xe = /ERROR: 0:(\d+)/.exec(ge); if (xe) {
		const ye = parseInt(xe[1]); return pe.toUpperCase() + `

`+ ge + `

`+ handleSource(fe.getShaderSource(K), ye)
	} else return ge
} function getTexelEncodingFunction(fe, K) {
	const pe = getEncodingComponents(K); return [`vec4 ${fe}( vec4 value ) {`, `	return ${pe[1]}( vec4( value.rgb * ${pe[0]}, value.a ) );`, "}"].join(`
`)
} function getToneMappingFunction(fe, K) { let pe; switch (K) { case LinearToneMapping: pe = "Linear"; break; case ReinhardToneMapping: pe = "Reinhard"; break; case CineonToneMapping: pe = "Cineon"; break; case ACESFilmicToneMapping: pe = "ACESFilmic"; break; case AgXToneMapping: pe = "AgX"; break; case NeutralToneMapping: pe = "Neutral"; break; case CustomToneMapping: pe = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", K), pe = "Linear" }return "vec3 " + fe + "( vec3 color ) { return " + pe + "ToneMapping( color ); }" } const _v0 = new Vector3; function getLuminanceFunction() {
	ColorManagement.getLuminanceCoefficients(_v0); const fe = _v0.x.toFixed(4), K = _v0.y.toFixed(4), pe = _v0.z.toFixed(4); return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${fe}, ${K}, ${pe} );`, "	return dot( weights, rgb );", "}"].join(`
`)
} function generateVertexExtensions(fe) {
	return [fe.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", fe.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join(`
`)
} function generateDefines(fe) {
	const K = []; for (const pe in fe) { const me = fe[pe]; me !== !1 && K.push("#define " + pe + " " + me) } return K.join(`
`)
} function fetchAttributeLocations(fe, K) { const pe = {}, me = fe.getProgramParameter(K, fe.ACTIVE_ATTRIBUTES); for (let ge = 0; ge < me; ge++) { const xe = fe.getActiveAttrib(K, ge), ye = xe.name; let ve = 1; xe.type === fe.FLOAT_MAT2 && (ve = 2), xe.type === fe.FLOAT_MAT3 && (ve = 3), xe.type === fe.FLOAT_MAT4 && (ve = 4), pe[ye] = { type: xe.type, location: fe.getAttribLocation(K, ye), locationSize: ve } } return pe } function filterEmptyLine(fe) { return fe !== "" } function replaceLightNums(fe, K) { const pe = K.numSpotLightShadows + K.numSpotLightMaps - K.numSpotLightShadowsWithMaps; return fe.replace(/NUM_DIR_LIGHTS/g, K.numDirLights).replace(/NUM_SPOT_LIGHTS/g, K.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, K.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, pe).replace(/NUM_RECT_AREA_LIGHTS/g, K.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, K.numPointLights).replace(/NUM_HEMI_LIGHTS/g, K.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, K.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, K.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, K.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, K.numPointLightShadows) } function replaceClippingPlaneNums(fe, K) { return fe.replace(/NUM_CLIPPING_PLANES/g, K.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, K.numClippingPlanes - K.numClipIntersection) } const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm; function resolveIncludes(fe) { return fe.replace(includePattern, includeReplacer) } const shaderChunkMap = new Map; function includeReplacer(fe, K) { let pe = ShaderChunk[K]; if (pe === void 0) { const me = shaderChunkMap.get(K); if (me !== void 0) pe = ShaderChunk[me], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', K, me); else throw new Error("Can not resolve #include <" + K + ">") } return resolveIncludes(pe) } const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function unrollLoops(fe) { return fe.replace(unrollLoopPattern, loopReplacer) } function loopReplacer(fe, K, pe, me) { let ge = ""; for (let xe = parseInt(K); xe < parseInt(pe); xe++)ge += me.replace(/\[\s*i\s*\]/g, "[ " + xe + " ]").replace(/UNROLLED_LOOP_INDEX/g, xe); return ge } function generatePrecision(fe) {
	let K = `precision ${fe.precision} float;
	precision ${fe.precision} int;
	precision ${fe.precision} sampler2D;
	precision ${fe.precision} samplerCube;
	precision ${fe.precision} sampler3D;
	precision ${fe.precision} sampler2DArray;
	precision ${fe.precision} sampler2DShadow;
	precision ${fe.precision} samplerCubeShadow;
	precision ${fe.precision} sampler2DArrayShadow;
	precision ${fe.precision} isampler2D;
	precision ${fe.precision} isampler3D;
	precision ${fe.precision} isamplerCube;
	precision ${fe.precision} isampler2DArray;
	precision ${fe.precision} usampler2D;
	precision ${fe.precision} usampler3D;
	precision ${fe.precision} usamplerCube;
	precision ${fe.precision} usampler2DArray;
	`; return fe.precision === "highp" ? K += `
#define HIGH_PRECISION`: fe.precision === "mediump" ? K += `
#define MEDIUM_PRECISION`: fe.precision === "lowp" && (K += `
#define LOW_PRECISION`), K
} function generateShadowMapTypeDefine(fe) { let K = "SHADOWMAP_TYPE_BASIC"; return fe.shadowMapType === PCFShadowMap ? K = "SHADOWMAP_TYPE_PCF" : fe.shadowMapType === PCFSoftShadowMap ? K = "SHADOWMAP_TYPE_PCF_SOFT" : fe.shadowMapType === VSMShadowMap && (K = "SHADOWMAP_TYPE_VSM"), K } function generateEnvMapTypeDefine(fe) { let K = "ENVMAP_TYPE_CUBE"; if (fe.envMap) switch (fe.envMapMode) { case CubeReflectionMapping: case CubeRefractionMapping: K = "ENVMAP_TYPE_CUBE"; break; case CubeUVReflectionMapping: K = "ENVMAP_TYPE_CUBE_UV"; break }return K } function generateEnvMapModeDefine(fe) { let K = "ENVMAP_MODE_REFLECTION"; if (fe.envMap) switch (fe.envMapMode) { case CubeRefractionMapping: K = "ENVMAP_MODE_REFRACTION"; break }return K } function generateEnvMapBlendingDefine(fe) { let K = "ENVMAP_BLENDING_NONE"; if (fe.envMap) switch (fe.combine) { case MultiplyOperation: K = "ENVMAP_BLENDING_MULTIPLY"; break; case MixOperation: K = "ENVMAP_BLENDING_MIX"; break; case AddOperation: K = "ENVMAP_BLENDING_ADD"; break }return K } function generateCubeUVSize(fe) { const K = fe.envMapCubeUVHeight; if (K === null) return null; const pe = Math.log2(K) - 2, me = 1 / K; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, pe), 7 * 16)), texelHeight: me, maxMip: pe } } function WebGLProgram(fe, K, pe, me) {
	const ge = fe.getContext(), xe = pe.defines; let ye = pe.vertexShader, ve = pe.fragmentShader; const _e = generateShadowMapTypeDefine(pe), Ee = generateEnvMapTypeDefine(pe), be = generateEnvMapModeDefine(pe), Ae = generateEnvMapBlendingDefine(pe), Se = generateCubeUVSize(pe), Ce = generateVertexExtensions(pe), we = generateDefines(xe), Be = ge.createProgram(); let De, Re, Ie = pe.glslVersion ? "#version " + pe.glslVersion + `
`: ""; pe.isRawShaderMaterial ? (De = ["#define SHADER_TYPE " + pe.shaderType, "#define SHADER_NAME " + pe.shaderName, we].filter(filterEmptyLine).join(`
`), De.length > 0 && (De += `
`), Re = ["#define SHADER_TYPE " + pe.shaderType, "#define SHADER_NAME " + pe.shaderName, we].filter(filterEmptyLine).join(`
`), Re.length > 0 && (Re += `
`)) : (De = [generatePrecision(pe), "#define SHADER_TYPE " + pe.shaderType, "#define SHADER_NAME " + pe.shaderName, we, pe.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", pe.batching ? "#define USE_BATCHING" : "", pe.batchingColor ? "#define USE_BATCHING_COLOR" : "", pe.instancing ? "#define USE_INSTANCING" : "", pe.instancingColor ? "#define USE_INSTANCING_COLOR" : "", pe.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", pe.useFog && pe.fog ? "#define USE_FOG" : "", pe.useFog && pe.fogExp2 ? "#define FOG_EXP2" : "", pe.map ? "#define USE_MAP" : "", pe.envMap ? "#define USE_ENVMAP" : "", pe.envMap ? "#define " + be : "", pe.lightMap ? "#define USE_LIGHTMAP" : "", pe.aoMap ? "#define USE_AOMAP" : "", pe.bumpMap ? "#define USE_BUMPMAP" : "", pe.normalMap ? "#define USE_NORMALMAP" : "", pe.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", pe.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", pe.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", pe.emissiveMap ? "#define USE_EMISSIVEMAP" : "", pe.anisotropy ? "#define USE_ANISOTROPY" : "", pe.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", pe.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", pe.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", pe.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", pe.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", pe.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", pe.specularMap ? "#define USE_SPECULARMAP" : "", pe.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", pe.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", pe.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", pe.metalnessMap ? "#define USE_METALNESSMAP" : "", pe.alphaMap ? "#define USE_ALPHAMAP" : "", pe.alphaHash ? "#define USE_ALPHAHASH" : "", pe.transmission ? "#define USE_TRANSMISSION" : "", pe.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", pe.thicknessMap ? "#define USE_THICKNESSMAP" : "", pe.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", pe.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", pe.mapUv ? "#define MAP_UV " + pe.mapUv : "", pe.alphaMapUv ? "#define ALPHAMAP_UV " + pe.alphaMapUv : "", pe.lightMapUv ? "#define LIGHTMAP_UV " + pe.lightMapUv : "", pe.aoMapUv ? "#define AOMAP_UV " + pe.aoMapUv : "", pe.emissiveMapUv ? "#define EMISSIVEMAP_UV " + pe.emissiveMapUv : "", pe.bumpMapUv ? "#define BUMPMAP_UV " + pe.bumpMapUv : "", pe.normalMapUv ? "#define NORMALMAP_UV " + pe.normalMapUv : "", pe.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + pe.displacementMapUv : "", pe.metalnessMapUv ? "#define METALNESSMAP_UV " + pe.metalnessMapUv : "", pe.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + pe.roughnessMapUv : "", pe.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + pe.anisotropyMapUv : "", pe.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + pe.clearcoatMapUv : "", pe.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + pe.clearcoatNormalMapUv : "", pe.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + pe.clearcoatRoughnessMapUv : "", pe.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + pe.iridescenceMapUv : "", pe.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + pe.iridescenceThicknessMapUv : "", pe.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + pe.sheenColorMapUv : "", pe.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + pe.sheenRoughnessMapUv : "", pe.specularMapUv ? "#define SPECULARMAP_UV " + pe.specularMapUv : "", pe.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + pe.specularColorMapUv : "", pe.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + pe.specularIntensityMapUv : "", pe.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + pe.transmissionMapUv : "", pe.thicknessMapUv ? "#define THICKNESSMAP_UV " + pe.thicknessMapUv : "", pe.vertexTangents && pe.flatShading === !1 ? "#define USE_TANGENT" : "", pe.vertexColors ? "#define USE_COLOR" : "", pe.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", pe.vertexUv1s ? "#define USE_UV1" : "", pe.vertexUv2s ? "#define USE_UV2" : "", pe.vertexUv3s ? "#define USE_UV3" : "", pe.pointsUvs ? "#define USE_POINTS_UV" : "", pe.flatShading ? "#define FLAT_SHADED" : "", pe.skinning ? "#define USE_SKINNING" : "", pe.morphTargets ? "#define USE_MORPHTARGETS" : "", pe.morphNormals && pe.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", pe.morphColors ? "#define USE_MORPHCOLORS" : "", pe.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + pe.morphTextureStride : "", pe.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + pe.morphTargetsCount : "", pe.doubleSided ? "#define DOUBLE_SIDED" : "", pe.flipSided ? "#define FLIP_SIDED" : "", pe.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", pe.shadowMapEnabled ? "#define " + _e : "", pe.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", pe.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", pe.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", pe.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`), Re = [generatePrecision(pe), "#define SHADER_TYPE " + pe.shaderType, "#define SHADER_NAME " + pe.shaderName, we, pe.useFog && pe.fog ? "#define USE_FOG" : "", pe.useFog && pe.fogExp2 ? "#define FOG_EXP2" : "", pe.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", pe.map ? "#define USE_MAP" : "", pe.matcap ? "#define USE_MATCAP" : "", pe.envMap ? "#define USE_ENVMAP" : "", pe.envMap ? "#define " + Ee : "", pe.envMap ? "#define " + be : "", pe.envMap ? "#define " + Ae : "", Se ? "#define CUBEUV_TEXEL_WIDTH " + Se.texelWidth : "", Se ? "#define CUBEUV_TEXEL_HEIGHT " + Se.texelHeight : "", Se ? "#define CUBEUV_MAX_MIP " + Se.maxMip + ".0" : "", pe.lightMap ? "#define USE_LIGHTMAP" : "", pe.aoMap ? "#define USE_AOMAP" : "", pe.bumpMap ? "#define USE_BUMPMAP" : "", pe.normalMap ? "#define USE_NORMALMAP" : "", pe.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", pe.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", pe.emissiveMap ? "#define USE_EMISSIVEMAP" : "", pe.anisotropy ? "#define USE_ANISOTROPY" : "", pe.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", pe.clearcoat ? "#define USE_CLEARCOAT" : "", pe.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", pe.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", pe.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", pe.dispersion ? "#define USE_DISPERSION" : "", pe.iridescence ? "#define USE_IRIDESCENCE" : "", pe.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", pe.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", pe.specularMap ? "#define USE_SPECULARMAP" : "", pe.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", pe.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", pe.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", pe.metalnessMap ? "#define USE_METALNESSMAP" : "", pe.alphaMap ? "#define USE_ALPHAMAP" : "", pe.alphaTest ? "#define USE_ALPHATEST" : "", pe.alphaHash ? "#define USE_ALPHAHASH" : "", pe.sheen ? "#define USE_SHEEN" : "", pe.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", pe.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", pe.transmission ? "#define USE_TRANSMISSION" : "", pe.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", pe.thicknessMap ? "#define USE_THICKNESSMAP" : "", pe.vertexTangents && pe.flatShading === !1 ? "#define USE_TANGENT" : "", pe.vertexColors || pe.instancingColor || pe.batchingColor ? "#define USE_COLOR" : "", pe.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", pe.vertexUv1s ? "#define USE_UV1" : "", pe.vertexUv2s ? "#define USE_UV2" : "", pe.vertexUv3s ? "#define USE_UV3" : "", pe.pointsUvs ? "#define USE_POINTS_UV" : "", pe.gradientMap ? "#define USE_GRADIENTMAP" : "", pe.flatShading ? "#define FLAT_SHADED" : "", pe.doubleSided ? "#define DOUBLE_SIDED" : "", pe.flipSided ? "#define FLIP_SIDED" : "", pe.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", pe.shadowMapEnabled ? "#define " + _e : "", pe.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", pe.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", pe.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", pe.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", pe.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", pe.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", pe.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", pe.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", pe.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", pe.toneMapping) : "", pe.dithering ? "#define DITHERING" : "", pe.opaque ? "#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", pe.outputColorSpace), getLuminanceFunction(), pe.useDepthPacking ? "#define DEPTH_PACKING " + pe.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)), ye = resolveIncludes(ye), ye = replaceLightNums(ye, pe), ye = replaceClippingPlaneNums(ye, pe), ve = resolveIncludes(ve), ve = replaceLightNums(ve, pe), ve = replaceClippingPlaneNums(ve, pe), ye = unrollLoops(ye), ve = unrollLoops(ve), pe.isRawShaderMaterial !== !0 && (Ie = `#version 300 es
`, De = [Ce, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ De, Re = ["#define varying in", pe.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", pe.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ Re); const Pe = Ie + De + ye, Ne = Ie + Re + ve, ke = WebGLShader(ge, ge.VERTEX_SHADER, Pe), Oe = WebGLShader(ge, ge.FRAGMENT_SHADER, Ne); ge.attachShader(Be, ke), ge.attachShader(Be, Oe), pe.index0AttributeName !== void 0 ? ge.bindAttribLocation(Be, 0, pe.index0AttributeName) : pe.morphTargets === !0 && ge.bindAttribLocation(Be, 0, "position"), ge.linkProgram(Be); function Ue(We) {
		if (fe.debug.checkShaderErrors) {
			const Xe = ge.getProgramInfoLog(Be).trim(), Ye = ge.getShaderInfoLog(ke).trim(), Ze = ge.getShaderInfoLog(Oe).trim(); let ot = !0, qe = !0; if (ge.getProgramParameter(Be, ge.LINK_STATUS) === !1) if (ot = !1, typeof fe.debug.onShaderError == "function") fe.debug.onShaderError(ge, Be, ke, Oe); else {
				const Qe = getShaderErrors(ge, ke, "vertex"), st = getShaderErrors(ge, Oe, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + ge.getError() + " - VALIDATE_STATUS " + ge.getProgramParameter(Be, ge.VALIDATE_STATUS) + `

Material Name: `+ We.name + `
Material Type: `+ We.type + `

Program Info Log: `+ Xe + `
`+ Qe + `
`+ st)
			} else Xe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Xe) : (Ye === "" || Ze === "") && (qe = !1); qe && (We.diagnostics = { runnable: ot, programLog: Xe, vertexShader: { log: Ye, prefix: De }, fragmentShader: { log: Ze, prefix: Re } })
		} ge.deleteShader(ke), ge.deleteShader(Oe), He = new WebGLUniforms(ge, Be), Ge = fetchAttributeLocations(ge, Be)
	} let He; this.getUniforms = function () { return He === void 0 && Ue(this), He }; let Ge; this.getAttributes = function () { return Ge === void 0 && Ue(this), Ge }; let ze = pe.rendererExtensionParallelShaderCompile === !1; return this.isReady = function () { return ze === !1 && (ze = ge.getProgramParameter(Be, COMPLETION_STATUS_KHR)), ze }, this.destroy = function () { me.releaseStatesOfProgram(this), ge.deleteProgram(Be), this.program = void 0 }, this.type = pe.shaderType, this.name = pe.shaderName, this.id = programIdCount++, this.cacheKey = K, this.usedTimes = 1, this.program = Be, this.vertexShader = ke, this.fragmentShader = Oe, this
} let _id = 0; class WebGLShaderCache { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(K) { const pe = K.vertexShader, me = K.fragmentShader, ge = this._getShaderStage(pe), xe = this._getShaderStage(me), ye = this._getShaderCacheForMaterial(K); return ye.has(ge) === !1 && (ye.add(ge), ge.usedTimes++), ye.has(xe) === !1 && (ye.add(xe), xe.usedTimes++), this } remove(K) { const pe = this.materialCache.get(K); for (const me of pe) me.usedTimes--, me.usedTimes === 0 && this.shaderCache.delete(me.code); return this.materialCache.delete(K), this } getVertexShaderID(K) { return this._getShaderStage(K.vertexShader).id } getFragmentShaderID(K) { return this._getShaderStage(K.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(K) { const pe = this.materialCache; let me = pe.get(K); return me === void 0 && (me = new Set, pe.set(K, me)), me } _getShaderStage(K) { const pe = this.shaderCache; let me = pe.get(K); return me === void 0 && (me = new WebGLShaderStage(K), pe.set(K, me)), me } } class WebGLShaderStage { constructor(K) { this.id = _id++, this.code = K, this.usedTimes = 0 } } function WebGLPrograms(fe, K, pe, me, ge, xe, ye) { const ve = new Layers, _e = new WebGLShaderCache, Ee = new Set, be = [], Ae = ge.logarithmicDepthBuffer, Se = ge.vertexTextures; let Ce = ge.precision; const we = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function Be(Ge) { return Ee.add(Ge), Ge === 0 ? "uv" : `uv${Ge}` } function De(Ge, ze, We, Xe, Ye) { const Ze = Xe.fog, ot = Ye.geometry, qe = Ge.isMeshStandardMaterial ? Xe.environment : null, Qe = (Ge.isMeshStandardMaterial ? pe : K).get(Ge.envMap || qe), st = Qe && Qe.mapping === CubeUVReflectionMapping ? Qe.image.height : null, Nt = we[Ge.type]; Ge.precision !== null && (Ce = ge.getMaxPrecision(Ge.precision), Ce !== Ge.precision && console.warn("THREE.WebGLProgram.getParameters:", Ge.precision, "not supported, using", Ce, "instead.")); const Je = ot.morphAttributes.position || ot.morphAttributes.normal || ot.morphAttributes.color, jt = Je !== void 0 ? Je.length : 0; let Xt = 0; ot.morphAttributes.position !== void 0 && (Xt = 1), ot.morphAttributes.normal !== void 0 && (Xt = 2), ot.morphAttributes.color !== void 0 && (Xt = 3); let ct, nn, $t, an; if (Nt) { const ti = ShaderLib[Nt]; ct = ti.vertexShader, nn = ti.fragmentShader } else ct = Ge.vertexShader, nn = Ge.fragmentShader, _e.update(Ge), $t = _e.getVertexShaderID(Ge), an = _e.getFragmentShaderID(Ge); const gn = fe.getRenderTarget(), Mn = fe.state.buffers.depth.getReversed(), Xn = Ye.isInstancedMesh === !0, Ln = Ye.isBatchedMesh === !0, Gn = !!Ge.map, wn = !!Ge.matcap, Bn = !!Qe, Gt = !!Ge.aoMap, nr = !!Ge.lightMap, Kn = !!Ge.bumpMap, vn = !!Ge.normalMap, yn = !!Ge.displacementMap, Hn = !!Ge.emissiveMap, kn = !!Ge.metalnessMap, Ht = !!Ge.roughnessMap, Dt = Ge.anisotropy > 0, fn = Ge.clearcoat > 0, en = Ge.dispersion > 0, cn = Ge.iridescence > 0, Wt = Ge.sheen > 0, un = Ge.transmission > 0, Ft = Dt && !!Ge.anisotropyMap, Sn = fn && !!Ge.clearcoatMap, lr = fn && !!Ge.clearcoatNormalMap, jn = fn && !!Ge.clearcoatRoughnessMap, Pn = cn && !!Ge.iridescenceMap, fr = cn && !!Ge.iridescenceThicknessMap, Yn = Wt && !!Ge.sheenColorMap, sr = Wt && !!Ge.sheenRoughnessMap, Ar = !!Ge.specularMap, Er = !!Ge.specularColorMap, Rr = !!Ge.specularIntensityMap, mn = un && !!Ge.transmissionMap, Dn = un && !!Ge.thicknessMap, Rn = !!Ge.gradientMap, qn = !!Ge.alphaMap, ar = Ge.alphaTest > 0, yr = !!Ge.alphaHash, dr = !!Ge.extensions; let mi = NoToneMapping; Ge.toneMapped && (gn === null || gn.isXRRenderTarget === !0) && (mi = fe.toneMapping); const bi = { shaderID: Nt, shaderType: Ge.type, shaderName: Ge.name, vertexShader: ct, fragmentShader: nn, defines: Ge.defines, customVertexShaderID: $t, customFragmentShaderID: an, isRawShaderMaterial: Ge.isRawShaderMaterial === !0, glslVersion: Ge.glslVersion, precision: Ce, batching: Ln, batchingColor: Ln && Ye._colorsTexture !== null, instancing: Xn, instancingColor: Xn && Ye.instanceColor !== null, instancingMorph: Xn && Ye.morphTexture !== null, supportsVertexTextures: Se, outputColorSpace: gn === null ? fe.outputColorSpace : gn.isXRRenderTarget === !0 ? gn.texture.colorSpace : LinearSRGBColorSpace, alphaToCoverage: !!Ge.alphaToCoverage, map: Gn, matcap: wn, envMap: Bn, envMapMode: Bn && Qe.mapping, envMapCubeUVHeight: st, aoMap: Gt, lightMap: nr, bumpMap: Kn, normalMap: vn, displacementMap: Se && yn, emissiveMap: Hn, normalMapObjectSpace: vn && Ge.normalMapType === ObjectSpaceNormalMap, normalMapTangentSpace: vn && Ge.normalMapType === TangentSpaceNormalMap, metalnessMap: kn, roughnessMap: Ht, anisotropy: Dt, anisotropyMap: Ft, clearcoat: fn, clearcoatMap: Sn, clearcoatNormalMap: lr, clearcoatRoughnessMap: jn, dispersion: en, iridescence: cn, iridescenceMap: Pn, iridescenceThicknessMap: fr, sheen: Wt, sheenColorMap: Yn, sheenRoughnessMap: sr, specularMap: Ar, specularColorMap: Er, specularIntensityMap: Rr, transmission: un, transmissionMap: mn, thicknessMap: Dn, gradientMap: Rn, opaque: Ge.transparent === !1 && Ge.blending === NormalBlending && Ge.alphaToCoverage === !1, alphaMap: qn, alphaTest: ar, alphaHash: yr, combine: Ge.combine, mapUv: Gn && Be(Ge.map.channel), aoMapUv: Gt && Be(Ge.aoMap.channel), lightMapUv: nr && Be(Ge.lightMap.channel), bumpMapUv: Kn && Be(Ge.bumpMap.channel), normalMapUv: vn && Be(Ge.normalMap.channel), displacementMapUv: yn && Be(Ge.displacementMap.channel), emissiveMapUv: Hn && Be(Ge.emissiveMap.channel), metalnessMapUv: kn && Be(Ge.metalnessMap.channel), roughnessMapUv: Ht && Be(Ge.roughnessMap.channel), anisotropyMapUv: Ft && Be(Ge.anisotropyMap.channel), clearcoatMapUv: Sn && Be(Ge.clearcoatMap.channel), clearcoatNormalMapUv: lr && Be(Ge.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: jn && Be(Ge.clearcoatRoughnessMap.channel), iridescenceMapUv: Pn && Be(Ge.iridescenceMap.channel), iridescenceThicknessMapUv: fr && Be(Ge.iridescenceThicknessMap.channel), sheenColorMapUv: Yn && Be(Ge.sheenColorMap.channel), sheenRoughnessMapUv: sr && Be(Ge.sheenRoughnessMap.channel), specularMapUv: Ar && Be(Ge.specularMap.channel), specularColorMapUv: Er && Be(Ge.specularColorMap.channel), specularIntensityMapUv: Rr && Be(Ge.specularIntensityMap.channel), transmissionMapUv: mn && Be(Ge.transmissionMap.channel), thicknessMapUv: Dn && Be(Ge.thicknessMap.channel), alphaMapUv: qn && Be(Ge.alphaMap.channel), vertexTangents: !!ot.attributes.tangent && (vn || Dt), vertexColors: Ge.vertexColors, vertexAlphas: Ge.vertexColors === !0 && !!ot.attributes.color && ot.attributes.color.itemSize === 4, pointsUvs: Ye.isPoints === !0 && !!ot.attributes.uv && (Gn || qn), fog: !!Ze, useFog: Ge.fog === !0, fogExp2: !!Ze && Ze.isFogExp2, flatShading: Ge.flatShading === !0, sizeAttenuation: Ge.sizeAttenuation === !0, logarithmicDepthBuffer: Ae, reverseDepthBuffer: Mn, skinning: Ye.isSkinnedMesh === !0, morphTargets: ot.morphAttributes.position !== void 0, morphNormals: ot.morphAttributes.normal !== void 0, morphColors: ot.morphAttributes.color !== void 0, morphTargetsCount: jt, morphTextureStride: Xt, numDirLights: ze.directional.length, numPointLights: ze.point.length, numSpotLights: ze.spot.length, numSpotLightMaps: ze.spotLightMap.length, numRectAreaLights: ze.rectArea.length, numHemiLights: ze.hemi.length, numDirLightShadows: ze.directionalShadowMap.length, numPointLightShadows: ze.pointShadowMap.length, numSpotLightShadows: ze.spotShadowMap.length, numSpotLightShadowsWithMaps: ze.numSpotLightShadowsWithMaps, numLightProbes: ze.numLightProbes, numClippingPlanes: ye.numPlanes, numClipIntersection: ye.numIntersection, dithering: Ge.dithering, shadowMapEnabled: fe.shadowMap.enabled && We.length > 0, shadowMapType: fe.shadowMap.type, toneMapping: mi, decodeVideoTexture: Gn && Ge.map.isVideoTexture === !0 && ColorManagement.getTransfer(Ge.map.colorSpace) === SRGBTransfer, decodeVideoTextureEmissive: Hn && Ge.emissiveMap.isVideoTexture === !0 && ColorManagement.getTransfer(Ge.emissiveMap.colorSpace) === SRGBTransfer, premultipliedAlpha: Ge.premultipliedAlpha, doubleSided: Ge.side === DoubleSide, flipSided: Ge.side === BackSide, useDepthPacking: Ge.depthPacking >= 0, depthPacking: Ge.depthPacking || 0, index0AttributeName: Ge.index0AttributeName, extensionClipCullDistance: dr && Ge.extensions.clipCullDistance === !0 && me.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (dr && Ge.extensions.multiDraw === !0 || Ln) && me.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: me.has("KHR_parallel_shader_compile"), customProgramCacheKey: Ge.customProgramCacheKey() }; return bi.vertexUv1s = Ee.has(1), bi.vertexUv2s = Ee.has(2), bi.vertexUv3s = Ee.has(3), Ee.clear(), bi } function Re(Ge) { const ze = []; if (Ge.shaderID ? ze.push(Ge.shaderID) : (ze.push(Ge.customVertexShaderID), ze.push(Ge.customFragmentShaderID)), Ge.defines !== void 0) for (const We in Ge.defines) ze.push(We), ze.push(Ge.defines[We]); return Ge.isRawShaderMaterial === !1 && (Ie(ze, Ge), Pe(ze, Ge), ze.push(fe.outputColorSpace)), ze.push(Ge.customProgramCacheKey), ze.join() } function Ie(Ge, ze) { Ge.push(ze.precision), Ge.push(ze.outputColorSpace), Ge.push(ze.envMapMode), Ge.push(ze.envMapCubeUVHeight), Ge.push(ze.mapUv), Ge.push(ze.alphaMapUv), Ge.push(ze.lightMapUv), Ge.push(ze.aoMapUv), Ge.push(ze.bumpMapUv), Ge.push(ze.normalMapUv), Ge.push(ze.displacementMapUv), Ge.push(ze.emissiveMapUv), Ge.push(ze.metalnessMapUv), Ge.push(ze.roughnessMapUv), Ge.push(ze.anisotropyMapUv), Ge.push(ze.clearcoatMapUv), Ge.push(ze.clearcoatNormalMapUv), Ge.push(ze.clearcoatRoughnessMapUv), Ge.push(ze.iridescenceMapUv), Ge.push(ze.iridescenceThicknessMapUv), Ge.push(ze.sheenColorMapUv), Ge.push(ze.sheenRoughnessMapUv), Ge.push(ze.specularMapUv), Ge.push(ze.specularColorMapUv), Ge.push(ze.specularIntensityMapUv), Ge.push(ze.transmissionMapUv), Ge.push(ze.thicknessMapUv), Ge.push(ze.combine), Ge.push(ze.fogExp2), Ge.push(ze.sizeAttenuation), Ge.push(ze.morphTargetsCount), Ge.push(ze.morphAttributeCount), Ge.push(ze.numDirLights), Ge.push(ze.numPointLights), Ge.push(ze.numSpotLights), Ge.push(ze.numSpotLightMaps), Ge.push(ze.numHemiLights), Ge.push(ze.numRectAreaLights), Ge.push(ze.numDirLightShadows), Ge.push(ze.numPointLightShadows), Ge.push(ze.numSpotLightShadows), Ge.push(ze.numSpotLightShadowsWithMaps), Ge.push(ze.numLightProbes), Ge.push(ze.shadowMapType), Ge.push(ze.toneMapping), Ge.push(ze.numClippingPlanes), Ge.push(ze.numClipIntersection), Ge.push(ze.depthPacking) } function Pe(Ge, ze) { ve.disableAll(), ze.supportsVertexTextures && ve.enable(0), ze.instancing && ve.enable(1), ze.instancingColor && ve.enable(2), ze.instancingMorph && ve.enable(3), ze.matcap && ve.enable(4), ze.envMap && ve.enable(5), ze.normalMapObjectSpace && ve.enable(6), ze.normalMapTangentSpace && ve.enable(7), ze.clearcoat && ve.enable(8), ze.iridescence && ve.enable(9), ze.alphaTest && ve.enable(10), ze.vertexColors && ve.enable(11), ze.vertexAlphas && ve.enable(12), ze.vertexUv1s && ve.enable(13), ze.vertexUv2s && ve.enable(14), ze.vertexUv3s && ve.enable(15), ze.vertexTangents && ve.enable(16), ze.anisotropy && ve.enable(17), ze.alphaHash && ve.enable(18), ze.batching && ve.enable(19), ze.dispersion && ve.enable(20), ze.batchingColor && ve.enable(21), Ge.push(ve.mask), ve.disableAll(), ze.fog && ve.enable(0), ze.useFog && ve.enable(1), ze.flatShading && ve.enable(2), ze.logarithmicDepthBuffer && ve.enable(3), ze.reverseDepthBuffer && ve.enable(4), ze.skinning && ve.enable(5), ze.morphTargets && ve.enable(6), ze.morphNormals && ve.enable(7), ze.morphColors && ve.enable(8), ze.premultipliedAlpha && ve.enable(9), ze.shadowMapEnabled && ve.enable(10), ze.doubleSided && ve.enable(11), ze.flipSided && ve.enable(12), ze.useDepthPacking && ve.enable(13), ze.dithering && ve.enable(14), ze.transmission && ve.enable(15), ze.sheen && ve.enable(16), ze.opaque && ve.enable(17), ze.pointsUvs && ve.enable(18), ze.decodeVideoTexture && ve.enable(19), ze.decodeVideoTextureEmissive && ve.enable(20), ze.alphaToCoverage && ve.enable(21), Ge.push(ve.mask) } function Ne(Ge) { const ze = we[Ge.type]; let We; if (ze) { const Xe = ShaderLib[ze]; We = UniformsUtils.clone(Xe.uniforms) } else We = Ge.uniforms; return We } function ke(Ge, ze) { let We; for (let Xe = 0, Ye = be.length; Xe < Ye; Xe++) { const Ze = be[Xe]; if (Ze.cacheKey === ze) { We = Ze, ++We.usedTimes; break } } return We === void 0 && (We = new WebGLProgram(fe, ze, Ge, xe), be.push(We)), We } function Oe(Ge) { if (--Ge.usedTimes === 0) { const ze = be.indexOf(Ge); be[ze] = be[be.length - 1], be.pop(), Ge.destroy() } } function Ue(Ge) { _e.remove(Ge) } function He() { _e.dispose() } return { getParameters: De, getProgramCacheKey: Re, getUniforms: Ne, acquireProgram: ke, releaseProgram: Oe, releaseShaderCache: Ue, programs: be, dispose: He } } function WebGLProperties() { let fe = new WeakMap; function K(ye) { return fe.has(ye) } function pe(ye) { let ve = fe.get(ye); return ve === void 0 && (ve = {}, fe.set(ye, ve)), ve } function me(ye) { fe.delete(ye) } function ge(ye, ve, _e) { fe.get(ye)[ve] = _e } function xe() { fe = new WeakMap } return { has: K, get: pe, remove: me, update: ge, dispose: xe } } function painterSortStable(fe, K) { return fe.groupOrder !== K.groupOrder ? fe.groupOrder - K.groupOrder : fe.renderOrder !== K.renderOrder ? fe.renderOrder - K.renderOrder : fe.material.id !== K.material.id ? fe.material.id - K.material.id : fe.z !== K.z ? fe.z - K.z : fe.id - K.id } function reversePainterSortStable(fe, K) { return fe.groupOrder !== K.groupOrder ? fe.groupOrder - K.groupOrder : fe.renderOrder !== K.renderOrder ? fe.renderOrder - K.renderOrder : fe.z !== K.z ? K.z - fe.z : fe.id - K.id } function WebGLRenderList() { const fe = []; let K = 0; const pe = [], me = [], ge = []; function xe() { K = 0, pe.length = 0, me.length = 0, ge.length = 0 } function ye(Ae, Se, Ce, we, Be, De) { let Re = fe[K]; return Re === void 0 ? (Re = { id: Ae.id, object: Ae, geometry: Se, material: Ce, groupOrder: we, renderOrder: Ae.renderOrder, z: Be, group: De }, fe[K] = Re) : (Re.id = Ae.id, Re.object = Ae, Re.geometry = Se, Re.material = Ce, Re.groupOrder = we, Re.renderOrder = Ae.renderOrder, Re.z = Be, Re.group = De), K++, Re } function ve(Ae, Se, Ce, we, Be, De) { const Re = ye(Ae, Se, Ce, we, Be, De); Ce.transmission > 0 ? me.push(Re) : Ce.transparent === !0 ? ge.push(Re) : pe.push(Re) } function _e(Ae, Se, Ce, we, Be, De) { const Re = ye(Ae, Se, Ce, we, Be, De); Ce.transmission > 0 ? me.unshift(Re) : Ce.transparent === !0 ? ge.unshift(Re) : pe.unshift(Re) } function Ee(Ae, Se) { pe.length > 1 && pe.sort(Ae || painterSortStable), me.length > 1 && me.sort(Se || reversePainterSortStable), ge.length > 1 && ge.sort(Se || reversePainterSortStable) } function be() { for (let Ae = K, Se = fe.length; Ae < Se; Ae++) { const Ce = fe[Ae]; if (Ce.id === null) break; Ce.id = null, Ce.object = null, Ce.geometry = null, Ce.material = null, Ce.group = null } } return { opaque: pe, transmissive: me, transparent: ge, init: xe, push: ve, unshift: _e, finish: be, sort: Ee } } function WebGLRenderLists() { let fe = new WeakMap; function K(me, ge) { const xe = fe.get(me); let ye; return xe === void 0 ? (ye = new WebGLRenderList, fe.set(me, [ye])) : ge >= xe.length ? (ye = new WebGLRenderList, xe.push(ye)) : ye = xe[ge], ye } function pe() { fe = new WeakMap } return { get: K, dispose: pe } } function UniformsCache() { const fe = {}; return { get: function (K) { if (fe[K.id] !== void 0) return fe[K.id]; let pe; switch (K.type) { case "DirectionalLight": pe = { direction: new Vector3, color: new Color$1 }; break; case "SpotLight": pe = { position: new Vector3, direction: new Vector3, color: new Color$1, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": pe = { position: new Vector3, color: new Color$1, distance: 0, decay: 0 }; break; case "HemisphereLight": pe = { direction: new Vector3, skyColor: new Color$1, groundColor: new Color$1 }; break; case "RectAreaLight": pe = { color: new Color$1, position: new Vector3, halfWidth: new Vector3, halfHeight: new Vector3 }; break }return fe[K.id] = pe, pe } } } function ShadowUniformsCache() { const fe = {}; return { get: function (K) { if (fe[K.id] !== void 0) return fe[K.id]; let pe; switch (K.type) { case "DirectionalLight": pe = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2 }; break; case "SpotLight": pe = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2 }; break; case "PointLight": pe = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return fe[K.id] = pe, pe } } } let nextVersion = 0; function shadowCastingAndTexturingLightsFirst(fe, K) { return (K.castShadow ? 2 : 0) - (fe.castShadow ? 2 : 0) + (K.map ? 1 : 0) - (fe.map ? 1 : 0) } function WebGLLights(fe) { const K = new UniformsCache, pe = ShadowUniformsCache(), me = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let Ee = 0; Ee < 9; Ee++)me.probe.push(new Vector3); const ge = new Vector3, xe = new Matrix4, ye = new Matrix4; function ve(Ee) { let be = 0, Ae = 0, Se = 0; for (let Ge = 0; Ge < 9; Ge++)me.probe[Ge].set(0, 0, 0); let Ce = 0, we = 0, Be = 0, De = 0, Re = 0, Ie = 0, Pe = 0, Ne = 0, ke = 0, Oe = 0, Ue = 0; Ee.sort(shadowCastingAndTexturingLightsFirst); for (let Ge = 0, ze = Ee.length; Ge < ze; Ge++) { const We = Ee[Ge], Xe = We.color, Ye = We.intensity, Ze = We.distance, ot = We.shadow && We.shadow.map ? We.shadow.map.texture : null; if (We.isAmbientLight) be += Xe.r * Ye, Ae += Xe.g * Ye, Se += Xe.b * Ye; else if (We.isLightProbe) { for (let qe = 0; qe < 9; qe++)me.probe[qe].addScaledVector(We.sh.coefficients[qe], Ye); Ue++ } else if (We.isDirectionalLight) { const qe = K.get(We); if (qe.color.copy(We.color).multiplyScalar(We.intensity), We.castShadow) { const Qe = We.shadow, st = pe.get(We); st.shadowIntensity = Qe.intensity, st.shadowBias = Qe.bias, st.shadowNormalBias = Qe.normalBias, st.shadowRadius = Qe.radius, st.shadowMapSize = Qe.mapSize, me.directionalShadow[Ce] = st, me.directionalShadowMap[Ce] = ot, me.directionalShadowMatrix[Ce] = We.shadow.matrix, Ie++ } me.directional[Ce] = qe, Ce++ } else if (We.isSpotLight) { const qe = K.get(We); qe.position.setFromMatrixPosition(We.matrixWorld), qe.color.copy(Xe).multiplyScalar(Ye), qe.distance = Ze, qe.coneCos = Math.cos(We.angle), qe.penumbraCos = Math.cos(We.angle * (1 - We.penumbra)), qe.decay = We.decay, me.spot[Be] = qe; const Qe = We.shadow; if (We.map && (me.spotLightMap[ke] = We.map, ke++, Qe.updateMatrices(We), We.castShadow && Oe++), me.spotLightMatrix[Be] = Qe.matrix, We.castShadow) { const st = pe.get(We); st.shadowIntensity = Qe.intensity, st.shadowBias = Qe.bias, st.shadowNormalBias = Qe.normalBias, st.shadowRadius = Qe.radius, st.shadowMapSize = Qe.mapSize, me.spotShadow[Be] = st, me.spotShadowMap[Be] = ot, Ne++ } Be++ } else if (We.isRectAreaLight) { const qe = K.get(We); qe.color.copy(Xe).multiplyScalar(Ye), qe.halfWidth.set(We.width * .5, 0, 0), qe.halfHeight.set(0, We.height * .5, 0), me.rectArea[De] = qe, De++ } else if (We.isPointLight) { const qe = K.get(We); if (qe.color.copy(We.color).multiplyScalar(We.intensity), qe.distance = We.distance, qe.decay = We.decay, We.castShadow) { const Qe = We.shadow, st = pe.get(We); st.shadowIntensity = Qe.intensity, st.shadowBias = Qe.bias, st.shadowNormalBias = Qe.normalBias, st.shadowRadius = Qe.radius, st.shadowMapSize = Qe.mapSize, st.shadowCameraNear = Qe.camera.near, st.shadowCameraFar = Qe.camera.far, me.pointShadow[we] = st, me.pointShadowMap[we] = ot, me.pointShadowMatrix[we] = We.shadow.matrix, Pe++ } me.point[we] = qe, we++ } else if (We.isHemisphereLight) { const qe = K.get(We); qe.skyColor.copy(We.color).multiplyScalar(Ye), qe.groundColor.copy(We.groundColor).multiplyScalar(Ye), me.hemi[Re] = qe, Re++ } } De > 0 && (fe.has("OES_texture_float_linear") === !0 ? (me.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, me.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : (me.rectAreaLTC1 = UniformsLib.LTC_HALF_1, me.rectAreaLTC2 = UniformsLib.LTC_HALF_2)), me.ambient[0] = be, me.ambient[1] = Ae, me.ambient[2] = Se; const He = me.hash; (He.directionalLength !== Ce || He.pointLength !== we || He.spotLength !== Be || He.rectAreaLength !== De || He.hemiLength !== Re || He.numDirectionalShadows !== Ie || He.numPointShadows !== Pe || He.numSpotShadows !== Ne || He.numSpotMaps !== ke || He.numLightProbes !== Ue) && (me.directional.length = Ce, me.spot.length = Be, me.rectArea.length = De, me.point.length = we, me.hemi.length = Re, me.directionalShadow.length = Ie, me.directionalShadowMap.length = Ie, me.pointShadow.length = Pe, me.pointShadowMap.length = Pe, me.spotShadow.length = Ne, me.spotShadowMap.length = Ne, me.directionalShadowMatrix.length = Ie, me.pointShadowMatrix.length = Pe, me.spotLightMatrix.length = Ne + ke - Oe, me.spotLightMap.length = ke, me.numSpotLightShadowsWithMaps = Oe, me.numLightProbes = Ue, He.directionalLength = Ce, He.pointLength = we, He.spotLength = Be, He.rectAreaLength = De, He.hemiLength = Re, He.numDirectionalShadows = Ie, He.numPointShadows = Pe, He.numSpotShadows = Ne, He.numSpotMaps = ke, He.numLightProbes = Ue, me.version = nextVersion++) } function _e(Ee, be) { let Ae = 0, Se = 0, Ce = 0, we = 0, Be = 0; const De = be.matrixWorldInverse; for (let Re = 0, Ie = Ee.length; Re < Ie; Re++) { const Pe = Ee[Re]; if (Pe.isDirectionalLight) { const Ne = me.directional[Ae]; Ne.direction.setFromMatrixPosition(Pe.matrixWorld), ge.setFromMatrixPosition(Pe.target.matrixWorld), Ne.direction.sub(ge), Ne.direction.transformDirection(De), Ae++ } else if (Pe.isSpotLight) { const Ne = me.spot[Ce]; Ne.position.setFromMatrixPosition(Pe.matrixWorld), Ne.position.applyMatrix4(De), Ne.direction.setFromMatrixPosition(Pe.matrixWorld), ge.setFromMatrixPosition(Pe.target.matrixWorld), Ne.direction.sub(ge), Ne.direction.transformDirection(De), Ce++ } else if (Pe.isRectAreaLight) { const Ne = me.rectArea[we]; Ne.position.setFromMatrixPosition(Pe.matrixWorld), Ne.position.applyMatrix4(De), ye.identity(), xe.copy(Pe.matrixWorld), xe.premultiply(De), ye.extractRotation(xe), Ne.halfWidth.set(Pe.width * .5, 0, 0), Ne.halfHeight.set(0, Pe.height * .5, 0), Ne.halfWidth.applyMatrix4(ye), Ne.halfHeight.applyMatrix4(ye), we++ } else if (Pe.isPointLight) { const Ne = me.point[Se]; Ne.position.setFromMatrixPosition(Pe.matrixWorld), Ne.position.applyMatrix4(De), Se++ } else if (Pe.isHemisphereLight) { const Ne = me.hemi[Be]; Ne.direction.setFromMatrixPosition(Pe.matrixWorld), Ne.direction.transformDirection(De), Be++ } } } return { setup: ve, setupView: _e, state: me } } function WebGLRenderState(fe) { const K = new WebGLLights(fe), pe = [], me = []; function ge(be) { Ee.camera = be, pe.length = 0, me.length = 0 } function xe(be) { pe.push(be) } function ye(be) { me.push(be) } function ve() { K.setup(pe) } function _e(be) { K.setupView(pe, be) } const Ee = { lightsArray: pe, shadowsArray: me, camera: null, lights: K, transmissionRenderTarget: {} }; return { init: ge, state: Ee, setupLights: ve, setupLightsView: _e, pushLight: xe, pushShadow: ye } } function WebGLRenderStates(fe) { let K = new WeakMap; function pe(ge, xe = 0) { const ye = K.get(ge); let ve; return ye === void 0 ? (ve = new WebGLRenderState(fe), K.set(ge, [ve])) : xe >= ye.length ? (ve = new WebGLRenderState(fe), ye.push(ve)) : ve = ye[xe], ve } function me() { K = new WeakMap } return { get: pe, dispose: me } } const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function WebGLShadowMap(fe, K, pe) { let me = new Frustum; const ge = new Vector2, xe = new Vector2, ye = new Vector4, ve = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _e = new MeshDistanceMaterial, Ee = {}, be = pe.maxTextureSize, Ae = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide }, Se = new ShaderMaterial({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2 }, radius: { value: 4 } }, vertexShader: vertex, fragmentShader: fragment }), Ce = Se.clone(); Ce.defines.HORIZONTAL_PASS = 1; const we = new BufferGeometry; we.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const Be = new Mesh(we, Se), De = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap; let Re = this.type; this.render = function (Oe, Ue, He) { if (De.enabled === !1 || De.autoUpdate === !1 && De.needsUpdate === !1 || Oe.length === 0) return; const Ge = fe.getRenderTarget(), ze = fe.getActiveCubeFace(), We = fe.getActiveMipmapLevel(), Xe = fe.state; Xe.setBlending(NoBlending), Xe.buffers.color.setClear(1, 1, 1, 1), Xe.buffers.depth.setTest(!0), Xe.setScissorTest(!1); const Ye = Re !== VSMShadowMap && this.type === VSMShadowMap, Ze = Re === VSMShadowMap && this.type !== VSMShadowMap; for (let ot = 0, qe = Oe.length; ot < qe; ot++) { const Qe = Oe[ot], st = Qe.shadow; if (st === void 0) { console.warn("THREE.WebGLShadowMap:", Qe, "has no shadow."); continue } if (st.autoUpdate === !1 && st.needsUpdate === !1) continue; ge.copy(st.mapSize); const Nt = st.getFrameExtents(); if (ge.multiply(Nt), xe.copy(st.mapSize), (ge.x > be || ge.y > be) && (ge.x > be && (xe.x = Math.floor(be / Nt.x), ge.x = xe.x * Nt.x, st.mapSize.x = xe.x), ge.y > be && (xe.y = Math.floor(be / Nt.y), ge.y = xe.y * Nt.y, st.mapSize.y = xe.y)), st.map === null || Ye === !0 || Ze === !0) { const jt = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {}; st.map !== null && st.map.dispose(), st.map = new WebGLRenderTarget(ge.x, ge.y, jt), st.map.texture.name = Qe.name + ".shadowMap", st.camera.updateProjectionMatrix() } fe.setRenderTarget(st.map), fe.clear(); const Je = st.getViewportCount(); for (let jt = 0; jt < Je; jt++) { const Xt = st.getViewport(jt); ye.set(xe.x * Xt.x, xe.y * Xt.y, xe.x * Xt.z, xe.y * Xt.w), Xe.viewport(ye), st.updateMatrices(Qe, jt), me = st.getFrustum(), Ne(Ue, He, st.camera, Qe, this.type) } st.isPointLightShadow !== !0 && this.type === VSMShadowMap && Ie(st, He), st.needsUpdate = !1 } Re = this.type, De.needsUpdate = !1, fe.setRenderTarget(Ge, ze, We) }; function Ie(Oe, Ue) { const He = K.update(Be); Se.defines.VSM_SAMPLES !== Oe.blurSamples && (Se.defines.VSM_SAMPLES = Oe.blurSamples, Ce.defines.VSM_SAMPLES = Oe.blurSamples, Se.needsUpdate = !0, Ce.needsUpdate = !0), Oe.mapPass === null && (Oe.mapPass = new WebGLRenderTarget(ge.x, ge.y)), Se.uniforms.shadow_pass.value = Oe.map.texture, Se.uniforms.resolution.value = Oe.mapSize, Se.uniforms.radius.value = Oe.radius, fe.setRenderTarget(Oe.mapPass), fe.clear(), fe.renderBufferDirect(Ue, null, He, Se, Be, null), Ce.uniforms.shadow_pass.value = Oe.mapPass.texture, Ce.uniforms.resolution.value = Oe.mapSize, Ce.uniforms.radius.value = Oe.radius, fe.setRenderTarget(Oe.map), fe.clear(), fe.renderBufferDirect(Ue, null, He, Ce, Be, null) } function Pe(Oe, Ue, He, Ge) { let ze = null; const We = He.isPointLight === !0 ? Oe.customDistanceMaterial : Oe.customDepthMaterial; if (We !== void 0) ze = We; else if (ze = He.isPointLight === !0 ? _e : ve, fe.localClippingEnabled && Ue.clipShadows === !0 && Array.isArray(Ue.clippingPlanes) && Ue.clippingPlanes.length !== 0 || Ue.displacementMap && Ue.displacementScale !== 0 || Ue.alphaMap && Ue.alphaTest > 0 || Ue.map && Ue.alphaTest > 0) { const Xe = ze.uuid, Ye = Ue.uuid; let Ze = Ee[Xe]; Ze === void 0 && (Ze = {}, Ee[Xe] = Ze); let ot = Ze[Ye]; ot === void 0 && (ot = ze.clone(), Ze[Ye] = ot, Ue.addEventListener("dispose", ke)), ze = ot } if (ze.visible = Ue.visible, ze.wireframe = Ue.wireframe, Ge === VSMShadowMap ? ze.side = Ue.shadowSide !== null ? Ue.shadowSide : Ue.side : ze.side = Ue.shadowSide !== null ? Ue.shadowSide : Ae[Ue.side], ze.alphaMap = Ue.alphaMap, ze.alphaTest = Ue.alphaTest, ze.map = Ue.map, ze.clipShadows = Ue.clipShadows, ze.clippingPlanes = Ue.clippingPlanes, ze.clipIntersection = Ue.clipIntersection, ze.displacementMap = Ue.displacementMap, ze.displacementScale = Ue.displacementScale, ze.displacementBias = Ue.displacementBias, ze.wireframeLinewidth = Ue.wireframeLinewidth, ze.linewidth = Ue.linewidth, He.isPointLight === !0 && ze.isMeshDistanceMaterial === !0) { const Xe = fe.properties.get(ze); Xe.light = He } return ze } function Ne(Oe, Ue, He, Ge, ze) { if (Oe.visible === !1) return; if (Oe.layers.test(Ue.layers) && (Oe.isMesh || Oe.isLine || Oe.isPoints) && (Oe.castShadow || Oe.receiveShadow && ze === VSMShadowMap) && (!Oe.frustumCulled || me.intersectsObject(Oe))) { Oe.modelViewMatrix.multiplyMatrices(He.matrixWorldInverse, Oe.matrixWorld); const Ye = K.update(Oe), Ze = Oe.material; if (Array.isArray(Ze)) { const ot = Ye.groups; for (let qe = 0, Qe = ot.length; qe < Qe; qe++) { const st = ot[qe], Nt = Ze[st.materialIndex]; if (Nt && Nt.visible) { const Je = Pe(Oe, Nt, Ge, ze); Oe.onBeforeShadow(fe, Oe, Ue, He, Ye, Je, st), fe.renderBufferDirect(He, null, Ye, Je, Oe, st), Oe.onAfterShadow(fe, Oe, Ue, He, Ye, Je, st) } } } else if (Ze.visible) { const ot = Pe(Oe, Ze, Ge, ze); Oe.onBeforeShadow(fe, Oe, Ue, He, Ye, ot, null), fe.renderBufferDirect(He, null, Ye, ot, Oe, null), Oe.onAfterShadow(fe, Oe, Ue, He, Ye, ot, null) } } const Xe = Oe.children; for (let Ye = 0, Ze = Xe.length; Ye < Ze; Ye++)Ne(Xe[Ye], Ue, He, Ge, ze) } function ke(Oe) { Oe.target.removeEventListener("dispose", ke); for (const He in Ee) { const Ge = Ee[He], ze = Oe.target.uuid; ze in Ge && (Ge[ze].dispose(), delete Ge[ze]) } } } const reversedFuncs = { [NeverDepth]: AlwaysDepth, [LessDepth]: GreaterDepth, [EqualDepth]: NotEqualDepth, [LessEqualDepth]: GreaterEqualDepth, [AlwaysDepth]: NeverDepth, [GreaterDepth]: LessDepth, [NotEqualDepth]: EqualDepth, [GreaterEqualDepth]: LessEqualDepth }; function WebGLState(fe, K) { function pe() { let mn = !1; const Dn = new Vector4; let Rn = null; const qn = new Vector4(0, 0, 0, 0); return { setMask: function (ar) { Rn !== ar && !mn && (fe.colorMask(ar, ar, ar, ar), Rn = ar) }, setLocked: function (ar) { mn = ar }, setClear: function (ar, yr, dr, mi, bi) { bi === !0 && (ar *= mi, yr *= mi, dr *= mi), Dn.set(ar, yr, dr, mi), qn.equals(Dn) === !1 && (fe.clearColor(ar, yr, dr, mi), qn.copy(Dn)) }, reset: function () { mn = !1, Rn = null, qn.set(-1, 0, 0, 0) } } } function me() { let mn = !1, Dn = !1, Rn = null, qn = null, ar = null; return { setReversed: function (yr) { if (Dn !== yr) { const dr = K.get("EXT_clip_control"); Dn ? dr.clipControlEXT(dr.LOWER_LEFT_EXT, dr.ZERO_TO_ONE_EXT) : dr.clipControlEXT(dr.LOWER_LEFT_EXT, dr.NEGATIVE_ONE_TO_ONE_EXT); const mi = ar; ar = null, this.setClear(mi) } Dn = yr }, getReversed: function () { return Dn }, setTest: function (yr) { yr ? gn(fe.DEPTH_TEST) : Mn(fe.DEPTH_TEST) }, setMask: function (yr) { Rn !== yr && !mn && (fe.depthMask(yr), Rn = yr) }, setFunc: function (yr) { if (Dn && (yr = reversedFuncs[yr]), qn !== yr) { switch (yr) { case NeverDepth: fe.depthFunc(fe.NEVER); break; case AlwaysDepth: fe.depthFunc(fe.ALWAYS); break; case LessDepth: fe.depthFunc(fe.LESS); break; case LessEqualDepth: fe.depthFunc(fe.LEQUAL); break; case EqualDepth: fe.depthFunc(fe.EQUAL); break; case GreaterEqualDepth: fe.depthFunc(fe.GEQUAL); break; case GreaterDepth: fe.depthFunc(fe.GREATER); break; case NotEqualDepth: fe.depthFunc(fe.NOTEQUAL); break; default: fe.depthFunc(fe.LEQUAL) }qn = yr } }, setLocked: function (yr) { mn = yr }, setClear: function (yr) { ar !== yr && (Dn && (yr = 1 - yr), fe.clearDepth(yr), ar = yr) }, reset: function () { mn = !1, Rn = null, qn = null, ar = null, Dn = !1 } } } function ge() { let mn = !1, Dn = null, Rn = null, qn = null, ar = null, yr = null, dr = null, mi = null, bi = null; return { setTest: function (ti) { mn || (ti ? gn(fe.STENCIL_TEST) : Mn(fe.STENCIL_TEST)) }, setMask: function (ti) { Dn !== ti && !mn && (fe.stencilMask(ti), Dn = ti) }, setFunc: function (ti, Si, ri) { (Rn !== ti || qn !== Si || ar !== ri) && (fe.stencilFunc(ti, Si, ri), Rn = ti, qn = Si, ar = ri) }, setOp: function (ti, Si, ri) { (yr !== ti || dr !== Si || mi !== ri) && (fe.stencilOp(ti, Si, ri), yr = ti, dr = Si, mi = ri) }, setLocked: function (ti) { mn = ti }, setClear: function (ti) { bi !== ti && (fe.clearStencil(ti), bi = ti) }, reset: function () { mn = !1, Dn = null, Rn = null, qn = null, ar = null, yr = null, dr = null, mi = null, bi = null } } } const xe = new pe, ye = new me, ve = new ge, _e = new WeakMap, Ee = new WeakMap; let be = {}, Ae = {}, Se = new WeakMap, Ce = [], we = null, Be = !1, De = null, Re = null, Ie = null, Pe = null, Ne = null, ke = null, Oe = null, Ue = new Color$1(0, 0, 0), He = 0, Ge = !1, ze = null, We = null, Xe = null, Ye = null, Ze = null; const ot = fe.getParameter(fe.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let qe = !1, Qe = 0; const st = fe.getParameter(fe.VERSION); st.indexOf("WebGL") !== -1 ? (Qe = parseFloat(/^WebGL (\d)/.exec(st)[1]), qe = Qe >= 1) : st.indexOf("OpenGL ES") !== -1 && (Qe = parseFloat(/^OpenGL ES (\d)/.exec(st)[1]), qe = Qe >= 2); let Nt = null, Je = {}; const jt = fe.getParameter(fe.SCISSOR_BOX), Xt = fe.getParameter(fe.VIEWPORT), ct = new Vector4().fromArray(jt), nn = new Vector4().fromArray(Xt); function $t(mn, Dn, Rn, qn) { const ar = new Uint8Array(4), yr = fe.createTexture(); fe.bindTexture(mn, yr), fe.texParameteri(mn, fe.TEXTURE_MIN_FILTER, fe.NEAREST), fe.texParameteri(mn, fe.TEXTURE_MAG_FILTER, fe.NEAREST); for (let dr = 0; dr < Rn; dr++)mn === fe.TEXTURE_3D || mn === fe.TEXTURE_2D_ARRAY ? fe.texImage3D(Dn, 0, fe.RGBA, 1, 1, qn, 0, fe.RGBA, fe.UNSIGNED_BYTE, ar) : fe.texImage2D(Dn + dr, 0, fe.RGBA, 1, 1, 0, fe.RGBA, fe.UNSIGNED_BYTE, ar); return yr } const an = {}; an[fe.TEXTURE_2D] = $t(fe.TEXTURE_2D, fe.TEXTURE_2D, 1), an[fe.TEXTURE_CUBE_MAP] = $t(fe.TEXTURE_CUBE_MAP, fe.TEXTURE_CUBE_MAP_POSITIVE_X, 6), an[fe.TEXTURE_2D_ARRAY] = $t(fe.TEXTURE_2D_ARRAY, fe.TEXTURE_2D_ARRAY, 1, 1), an[fe.TEXTURE_3D] = $t(fe.TEXTURE_3D, fe.TEXTURE_3D, 1, 1), xe.setClear(0, 0, 0, 1), ye.setClear(1), ve.setClear(0), gn(fe.DEPTH_TEST), ye.setFunc(LessEqualDepth), Kn(!1), vn(CullFaceBack), gn(fe.CULL_FACE), Gt(NoBlending); function gn(mn) { be[mn] !== !0 && (fe.enable(mn), be[mn] = !0) } function Mn(mn) { be[mn] !== !1 && (fe.disable(mn), be[mn] = !1) } function Xn(mn, Dn) { return Ae[mn] !== Dn ? (fe.bindFramebuffer(mn, Dn), Ae[mn] = Dn, mn === fe.DRAW_FRAMEBUFFER && (Ae[fe.FRAMEBUFFER] = Dn), mn === fe.FRAMEBUFFER && (Ae[fe.DRAW_FRAMEBUFFER] = Dn), !0) : !1 } function Ln(mn, Dn) { let Rn = Ce, qn = !1; if (mn) { Rn = Se.get(Dn), Rn === void 0 && (Rn = [], Se.set(Dn, Rn)); const ar = mn.textures; if (Rn.length !== ar.length || Rn[0] !== fe.COLOR_ATTACHMENT0) { for (let yr = 0, dr = ar.length; yr < dr; yr++)Rn[yr] = fe.COLOR_ATTACHMENT0 + yr; Rn.length = ar.length, qn = !0 } } else Rn[0] !== fe.BACK && (Rn[0] = fe.BACK, qn = !0); qn && fe.drawBuffers(Rn) } function Gn(mn) { return we !== mn ? (fe.useProgram(mn), we = mn, !0) : !1 } const wn = { [AddEquation]: fe.FUNC_ADD, [SubtractEquation]: fe.FUNC_SUBTRACT, [ReverseSubtractEquation]: fe.FUNC_REVERSE_SUBTRACT }; wn[MinEquation] = fe.MIN, wn[MaxEquation] = fe.MAX; const Bn = { [ZeroFactor]: fe.ZERO, [OneFactor]: fe.ONE, [SrcColorFactor]: fe.SRC_COLOR, [SrcAlphaFactor]: fe.SRC_ALPHA, [SrcAlphaSaturateFactor]: fe.SRC_ALPHA_SATURATE, [DstColorFactor]: fe.DST_COLOR, [DstAlphaFactor]: fe.DST_ALPHA, [OneMinusSrcColorFactor]: fe.ONE_MINUS_SRC_COLOR, [OneMinusSrcAlphaFactor]: fe.ONE_MINUS_SRC_ALPHA, [OneMinusDstColorFactor]: fe.ONE_MINUS_DST_COLOR, [OneMinusDstAlphaFactor]: fe.ONE_MINUS_DST_ALPHA, [ConstantColorFactor]: fe.CONSTANT_COLOR, [OneMinusConstantColorFactor]: fe.ONE_MINUS_CONSTANT_COLOR, [ConstantAlphaFactor]: fe.CONSTANT_ALPHA, [OneMinusConstantAlphaFactor]: fe.ONE_MINUS_CONSTANT_ALPHA }; function Gt(mn, Dn, Rn, qn, ar, yr, dr, mi, bi, ti) { if (mn === NoBlending) { Be === !0 && (Mn(fe.BLEND), Be = !1); return } if (Be === !1 && (gn(fe.BLEND), Be = !0), mn !== CustomBlending) { if (mn !== De || ti !== Ge) { if ((Re !== AddEquation || Ne !== AddEquation) && (fe.blendEquation(fe.FUNC_ADD), Re = AddEquation, Ne = AddEquation), ti) switch (mn) { case NormalBlending: fe.blendFuncSeparate(fe.ONE, fe.ONE_MINUS_SRC_ALPHA, fe.ONE, fe.ONE_MINUS_SRC_ALPHA); break; case AdditiveBlending: fe.blendFunc(fe.ONE, fe.ONE); break; case SubtractiveBlending: fe.blendFuncSeparate(fe.ZERO, fe.ONE_MINUS_SRC_COLOR, fe.ZERO, fe.ONE); break; case MultiplyBlending: fe.blendFuncSeparate(fe.ZERO, fe.SRC_COLOR, fe.ZERO, fe.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", mn); break } else switch (mn) { case NormalBlending: fe.blendFuncSeparate(fe.SRC_ALPHA, fe.ONE_MINUS_SRC_ALPHA, fe.ONE, fe.ONE_MINUS_SRC_ALPHA); break; case AdditiveBlending: fe.blendFunc(fe.SRC_ALPHA, fe.ONE); break; case SubtractiveBlending: fe.blendFuncSeparate(fe.ZERO, fe.ONE_MINUS_SRC_COLOR, fe.ZERO, fe.ONE); break; case MultiplyBlending: fe.blendFunc(fe.ZERO, fe.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", mn); break }Ie = null, Pe = null, ke = null, Oe = null, Ue.set(0, 0, 0), He = 0, De = mn, Ge = ti } return } ar = ar || Dn, yr = yr || Rn, dr = dr || qn, (Dn !== Re || ar !== Ne) && (fe.blendEquationSeparate(wn[Dn], wn[ar]), Re = Dn, Ne = ar), (Rn !== Ie || qn !== Pe || yr !== ke || dr !== Oe) && (fe.blendFuncSeparate(Bn[Rn], Bn[qn], Bn[yr], Bn[dr]), Ie = Rn, Pe = qn, ke = yr, Oe = dr), (mi.equals(Ue) === !1 || bi !== He) && (fe.blendColor(mi.r, mi.g, mi.b, bi), Ue.copy(mi), He = bi), De = mn, Ge = !1 } function nr(mn, Dn) { mn.side === DoubleSide ? Mn(fe.CULL_FACE) : gn(fe.CULL_FACE); let Rn = mn.side === BackSide; Dn && (Rn = !Rn), Kn(Rn), mn.blending === NormalBlending && mn.transparent === !1 ? Gt(NoBlending) : Gt(mn.blending, mn.blendEquation, mn.blendSrc, mn.blendDst, mn.blendEquationAlpha, mn.blendSrcAlpha, mn.blendDstAlpha, mn.blendColor, mn.blendAlpha, mn.premultipliedAlpha), ye.setFunc(mn.depthFunc), ye.setTest(mn.depthTest), ye.setMask(mn.depthWrite), xe.setMask(mn.colorWrite); const qn = mn.stencilWrite; ve.setTest(qn), qn && (ve.setMask(mn.stencilWriteMask), ve.setFunc(mn.stencilFunc, mn.stencilRef, mn.stencilFuncMask), ve.setOp(mn.stencilFail, mn.stencilZFail, mn.stencilZPass)), Hn(mn.polygonOffset, mn.polygonOffsetFactor, mn.polygonOffsetUnits), mn.alphaToCoverage === !0 ? gn(fe.SAMPLE_ALPHA_TO_COVERAGE) : Mn(fe.SAMPLE_ALPHA_TO_COVERAGE) } function Kn(mn) { ze !== mn && (mn ? fe.frontFace(fe.CW) : fe.frontFace(fe.CCW), ze = mn) } function vn(mn) { mn !== CullFaceNone ? (gn(fe.CULL_FACE), mn !== We && (mn === CullFaceBack ? fe.cullFace(fe.BACK) : mn === CullFaceFront ? fe.cullFace(fe.FRONT) : fe.cullFace(fe.FRONT_AND_BACK))) : Mn(fe.CULL_FACE), We = mn } function yn(mn) { mn !== Xe && (qe && fe.lineWidth(mn), Xe = mn) } function Hn(mn, Dn, Rn) { mn ? (gn(fe.POLYGON_OFFSET_FILL), (Ye !== Dn || Ze !== Rn) && (fe.polygonOffset(Dn, Rn), Ye = Dn, Ze = Rn)) : Mn(fe.POLYGON_OFFSET_FILL) } function kn(mn) { mn ? gn(fe.SCISSOR_TEST) : Mn(fe.SCISSOR_TEST) } function Ht(mn) { mn === void 0 && (mn = fe.TEXTURE0 + ot - 1), Nt !== mn && (fe.activeTexture(mn), Nt = mn) } function Dt(mn, Dn, Rn) { Rn === void 0 && (Nt === null ? Rn = fe.TEXTURE0 + ot - 1 : Rn = Nt); let qn = Je[Rn]; qn === void 0 && (qn = { type: void 0, texture: void 0 }, Je[Rn] = qn), (qn.type !== mn || qn.texture !== Dn) && (Nt !== Rn && (fe.activeTexture(Rn), Nt = Rn), fe.bindTexture(mn, Dn || an[mn]), qn.type = mn, qn.texture = Dn) } function fn() { const mn = Je[Nt]; mn !== void 0 && mn.type !== void 0 && (fe.bindTexture(mn.type, null), mn.type = void 0, mn.texture = void 0) } function en() { try { fe.compressedTexImage2D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function cn() { try { fe.compressedTexImage3D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function Wt() { try { fe.texSubImage2D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function un() { try { fe.texSubImage3D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function Ft() { try { fe.compressedTexSubImage2D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function Sn() { try { fe.compressedTexSubImage3D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function lr() { try { fe.texStorage2D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function jn() { try { fe.texStorage3D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function Pn() { try { fe.texImage2D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function fr() { try { fe.texImage3D(...arguments) } catch (mn) { console.error("THREE.WebGLState:", mn) } } function Yn(mn) { ct.equals(mn) === !1 && (fe.scissor(mn.x, mn.y, mn.z, mn.w), ct.copy(mn)) } function sr(mn) { nn.equals(mn) === !1 && (fe.viewport(mn.x, mn.y, mn.z, mn.w), nn.copy(mn)) } function Ar(mn, Dn) { let Rn = Ee.get(Dn); Rn === void 0 && (Rn = new WeakMap, Ee.set(Dn, Rn)); let qn = Rn.get(mn); qn === void 0 && (qn = fe.getUniformBlockIndex(Dn, mn.name), Rn.set(mn, qn)) } function Er(mn, Dn) { const qn = Ee.get(Dn).get(mn); _e.get(Dn) !== qn && (fe.uniformBlockBinding(Dn, qn, mn.__bindingPointIndex), _e.set(Dn, qn)) } function Rr() { fe.disable(fe.BLEND), fe.disable(fe.CULL_FACE), fe.disable(fe.DEPTH_TEST), fe.disable(fe.POLYGON_OFFSET_FILL), fe.disable(fe.SCISSOR_TEST), fe.disable(fe.STENCIL_TEST), fe.disable(fe.SAMPLE_ALPHA_TO_COVERAGE), fe.blendEquation(fe.FUNC_ADD), fe.blendFunc(fe.ONE, fe.ZERO), fe.blendFuncSeparate(fe.ONE, fe.ZERO, fe.ONE, fe.ZERO), fe.blendColor(0, 0, 0, 0), fe.colorMask(!0, !0, !0, !0), fe.clearColor(0, 0, 0, 0), fe.depthMask(!0), fe.depthFunc(fe.LESS), ye.setReversed(!1), fe.clearDepth(1), fe.stencilMask(4294967295), fe.stencilFunc(fe.ALWAYS, 0, 4294967295), fe.stencilOp(fe.KEEP, fe.KEEP, fe.KEEP), fe.clearStencil(0), fe.cullFace(fe.BACK), fe.frontFace(fe.CCW), fe.polygonOffset(0, 0), fe.activeTexture(fe.TEXTURE0), fe.bindFramebuffer(fe.FRAMEBUFFER, null), fe.bindFramebuffer(fe.DRAW_FRAMEBUFFER, null), fe.bindFramebuffer(fe.READ_FRAMEBUFFER, null), fe.useProgram(null), fe.lineWidth(1), fe.scissor(0, 0, fe.canvas.width, fe.canvas.height), fe.viewport(0, 0, fe.canvas.width, fe.canvas.height), be = {}, Nt = null, Je = {}, Ae = {}, Se = new WeakMap, Ce = [], we = null, Be = !1, De = null, Re = null, Ie = null, Pe = null, Ne = null, ke = null, Oe = null, Ue = new Color$1(0, 0, 0), He = 0, Ge = !1, ze = null, We = null, Xe = null, Ye = null, Ze = null, ct.set(0, 0, fe.canvas.width, fe.canvas.height), nn.set(0, 0, fe.canvas.width, fe.canvas.height), xe.reset(), ye.reset(), ve.reset() } return { buffers: { color: xe, depth: ye, stencil: ve }, enable: gn, disable: Mn, bindFramebuffer: Xn, drawBuffers: Ln, useProgram: Gn, setBlending: Gt, setMaterial: nr, setFlipSided: Kn, setCullFace: vn, setLineWidth: yn, setPolygonOffset: Hn, setScissorTest: kn, activeTexture: Ht, bindTexture: Dt, unbindTexture: fn, compressedTexImage2D: en, compressedTexImage3D: cn, texImage2D: Pn, texImage3D: fr, updateUBOMapping: Ar, uniformBlockBinding: Er, texStorage2D: lr, texStorage3D: jn, texSubImage2D: Wt, texSubImage3D: un, compressedTexSubImage2D: Ft, compressedTexSubImage3D: Sn, scissor: Yn, viewport: sr, reset: Rr } } function WebGLTextures(fe, K, pe, me, ge, xe, ye) { const ve = K.has("WEBGL_multisampled_render_to_texture") ? K.get("WEBGL_multisampled_render_to_texture") : null, _e = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), Ee = new Vector2, be = new WeakMap; let Ae; const Se = new WeakMap; let Ce = !1; try { Ce = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function we(Ht, Dt) { return Ce ? new OffscreenCanvas(Ht, Dt) : createElementNS("canvas") } function Be(Ht, Dt, fn) { let en = 1; const cn = kn(Ht); if ((cn.width > fn || cn.height > fn) && (en = fn / Math.max(cn.width, cn.height)), en < 1) if (typeof HTMLImageElement < "u" && Ht instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Ht instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Ht instanceof ImageBitmap || typeof VideoFrame < "u" && Ht instanceof VideoFrame) { const Wt = Math.floor(en * cn.width), un = Math.floor(en * cn.height); Ae === void 0 && (Ae = we(Wt, un)); const Ft = Dt ? we(Wt, un) : Ae; return Ft.width = Wt, Ft.height = un, Ft.getContext("2d").drawImage(Ht, 0, 0, Wt, un), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + cn.width + "x" + cn.height + ") to (" + Wt + "x" + un + ")."), Ft } else return "data" in Ht && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + cn.width + "x" + cn.height + ")."), Ht; return Ht } function De(Ht) { return Ht.generateMipmaps } function Re(Ht) { fe.generateMipmap(Ht) } function Ie(Ht) { return Ht.isWebGLCubeRenderTarget ? fe.TEXTURE_CUBE_MAP : Ht.isWebGL3DRenderTarget ? fe.TEXTURE_3D : Ht.isWebGLArrayRenderTarget || Ht.isCompressedArrayTexture ? fe.TEXTURE_2D_ARRAY : fe.TEXTURE_2D } function Pe(Ht, Dt, fn, en, cn = !1) { if (Ht !== null) { if (fe[Ht] !== void 0) return fe[Ht]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Ht + "'") } let Wt = Dt; if (Dt === fe.RED && (fn === fe.FLOAT && (Wt = fe.R32F), fn === fe.HALF_FLOAT && (Wt = fe.R16F), fn === fe.UNSIGNED_BYTE && (Wt = fe.R8)), Dt === fe.RED_INTEGER && (fn === fe.UNSIGNED_BYTE && (Wt = fe.R8UI), fn === fe.UNSIGNED_SHORT && (Wt = fe.R16UI), fn === fe.UNSIGNED_INT && (Wt = fe.R32UI), fn === fe.BYTE && (Wt = fe.R8I), fn === fe.SHORT && (Wt = fe.R16I), fn === fe.INT && (Wt = fe.R32I)), Dt === fe.RG && (fn === fe.FLOAT && (Wt = fe.RG32F), fn === fe.HALF_FLOAT && (Wt = fe.RG16F), fn === fe.UNSIGNED_BYTE && (Wt = fe.RG8)), Dt === fe.RG_INTEGER && (fn === fe.UNSIGNED_BYTE && (Wt = fe.RG8UI), fn === fe.UNSIGNED_SHORT && (Wt = fe.RG16UI), fn === fe.UNSIGNED_INT && (Wt = fe.RG32UI), fn === fe.BYTE && (Wt = fe.RG8I), fn === fe.SHORT && (Wt = fe.RG16I), fn === fe.INT && (Wt = fe.RG32I)), Dt === fe.RGB_INTEGER && (fn === fe.UNSIGNED_BYTE && (Wt = fe.RGB8UI), fn === fe.UNSIGNED_SHORT && (Wt = fe.RGB16UI), fn === fe.UNSIGNED_INT && (Wt = fe.RGB32UI), fn === fe.BYTE && (Wt = fe.RGB8I), fn === fe.SHORT && (Wt = fe.RGB16I), fn === fe.INT && (Wt = fe.RGB32I)), Dt === fe.RGBA_INTEGER && (fn === fe.UNSIGNED_BYTE && (Wt = fe.RGBA8UI), fn === fe.UNSIGNED_SHORT && (Wt = fe.RGBA16UI), fn === fe.UNSIGNED_INT && (Wt = fe.RGBA32UI), fn === fe.BYTE && (Wt = fe.RGBA8I), fn === fe.SHORT && (Wt = fe.RGBA16I), fn === fe.INT && (Wt = fe.RGBA32I)), Dt === fe.RGB && fn === fe.UNSIGNED_INT_5_9_9_9_REV && (Wt = fe.RGB9_E5), Dt === fe.RGBA) { const un = cn ? LinearTransfer : ColorManagement.getTransfer(en); fn === fe.FLOAT && (Wt = fe.RGBA32F), fn === fe.HALF_FLOAT && (Wt = fe.RGBA16F), fn === fe.UNSIGNED_BYTE && (Wt = un === SRGBTransfer ? fe.SRGB8_ALPHA8 : fe.RGBA8), fn === fe.UNSIGNED_SHORT_4_4_4_4 && (Wt = fe.RGBA4), fn === fe.UNSIGNED_SHORT_5_5_5_1 && (Wt = fe.RGB5_A1) } return (Wt === fe.R16F || Wt === fe.R32F || Wt === fe.RG16F || Wt === fe.RG32F || Wt === fe.RGBA16F || Wt === fe.RGBA32F) && K.get("EXT_color_buffer_float"), Wt } function Ne(Ht, Dt) { let fn; return Ht ? Dt === null || Dt === UnsignedIntType || Dt === UnsignedInt248Type ? fn = fe.DEPTH24_STENCIL8 : Dt === FloatType ? fn = fe.DEPTH32F_STENCIL8 : Dt === UnsignedShortType && (fn = fe.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : Dt === null || Dt === UnsignedIntType || Dt === UnsignedInt248Type ? fn = fe.DEPTH_COMPONENT24 : Dt === FloatType ? fn = fe.DEPTH_COMPONENT32F : Dt === UnsignedShortType && (fn = fe.DEPTH_COMPONENT16), fn } function ke(Ht, Dt) { return De(Ht) === !0 || Ht.isFramebufferTexture && Ht.minFilter !== NearestFilter && Ht.minFilter !== LinearFilter ? Math.log2(Math.max(Dt.width, Dt.height)) + 1 : Ht.mipmaps !== void 0 && Ht.mipmaps.length > 0 ? Ht.mipmaps.length : Ht.isCompressedTexture && Array.isArray(Ht.image) ? Dt.mipmaps.length : 1 } function Oe(Ht) { const Dt = Ht.target; Dt.removeEventListener("dispose", Oe), He(Dt), Dt.isVideoTexture && be.delete(Dt) } function Ue(Ht) { const Dt = Ht.target; Dt.removeEventListener("dispose", Ue), ze(Dt) } function He(Ht) { const Dt = me.get(Ht); if (Dt.__webglInit === void 0) return; const fn = Ht.source, en = Se.get(fn); if (en) { const cn = en[Dt.__cacheKey]; cn.usedTimes--, cn.usedTimes === 0 && Ge(Ht), Object.keys(en).length === 0 && Se.delete(fn) } me.remove(Ht) } function Ge(Ht) { const Dt = me.get(Ht); fe.deleteTexture(Dt.__webglTexture); const fn = Ht.source, en = Se.get(fn); delete en[Dt.__cacheKey], ye.memory.textures-- } function ze(Ht) { const Dt = me.get(Ht); if (Ht.depthTexture && (Ht.depthTexture.dispose(), me.remove(Ht.depthTexture)), Ht.isWebGLCubeRenderTarget) for (let en = 0; en < 6; en++) { if (Array.isArray(Dt.__webglFramebuffer[en])) for (let cn = 0; cn < Dt.__webglFramebuffer[en].length; cn++)fe.deleteFramebuffer(Dt.__webglFramebuffer[en][cn]); else fe.deleteFramebuffer(Dt.__webglFramebuffer[en]); Dt.__webglDepthbuffer && fe.deleteRenderbuffer(Dt.__webglDepthbuffer[en]) } else { if (Array.isArray(Dt.__webglFramebuffer)) for (let en = 0; en < Dt.__webglFramebuffer.length; en++)fe.deleteFramebuffer(Dt.__webglFramebuffer[en]); else fe.deleteFramebuffer(Dt.__webglFramebuffer); if (Dt.__webglDepthbuffer && fe.deleteRenderbuffer(Dt.__webglDepthbuffer), Dt.__webglMultisampledFramebuffer && fe.deleteFramebuffer(Dt.__webglMultisampledFramebuffer), Dt.__webglColorRenderbuffer) for (let en = 0; en < Dt.__webglColorRenderbuffer.length; en++)Dt.__webglColorRenderbuffer[en] && fe.deleteRenderbuffer(Dt.__webglColorRenderbuffer[en]); Dt.__webglDepthRenderbuffer && fe.deleteRenderbuffer(Dt.__webglDepthRenderbuffer) } const fn = Ht.textures; for (let en = 0, cn = fn.length; en < cn; en++) { const Wt = me.get(fn[en]); Wt.__webglTexture && (fe.deleteTexture(Wt.__webglTexture), ye.memory.textures--), me.remove(fn[en]) } me.remove(Ht) } let We = 0; function Xe() { We = 0 } function Ye() { const Ht = We; return Ht >= ge.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Ht + " texture units while this GPU supports only " + ge.maxTextures), We += 1, Ht } function Ze(Ht) { const Dt = []; return Dt.push(Ht.wrapS), Dt.push(Ht.wrapT), Dt.push(Ht.wrapR || 0), Dt.push(Ht.magFilter), Dt.push(Ht.minFilter), Dt.push(Ht.anisotropy), Dt.push(Ht.internalFormat), Dt.push(Ht.format), Dt.push(Ht.type), Dt.push(Ht.generateMipmaps), Dt.push(Ht.premultiplyAlpha), Dt.push(Ht.flipY), Dt.push(Ht.unpackAlignment), Dt.push(Ht.colorSpace), Dt.join() } function ot(Ht, Dt) { const fn = me.get(Ht); if (Ht.isVideoTexture && yn(Ht), Ht.isRenderTargetTexture === !1 && Ht.version > 0 && fn.__version !== Ht.version) { const en = Ht.image; if (en === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (en.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { nn(fn, Ht, Dt); return } } pe.bindTexture(fe.TEXTURE_2D, fn.__webglTexture, fe.TEXTURE0 + Dt) } function qe(Ht, Dt) { const fn = me.get(Ht); if (Ht.version > 0 && fn.__version !== Ht.version) { nn(fn, Ht, Dt); return } pe.bindTexture(fe.TEXTURE_2D_ARRAY, fn.__webglTexture, fe.TEXTURE0 + Dt) } function Qe(Ht, Dt) { const fn = me.get(Ht); if (Ht.version > 0 && fn.__version !== Ht.version) { nn(fn, Ht, Dt); return } pe.bindTexture(fe.TEXTURE_3D, fn.__webglTexture, fe.TEXTURE0 + Dt) } function st(Ht, Dt) { const fn = me.get(Ht); if (Ht.version > 0 && fn.__version !== Ht.version) { $t(fn, Ht, Dt); return } pe.bindTexture(fe.TEXTURE_CUBE_MAP, fn.__webglTexture, fe.TEXTURE0 + Dt) } const Nt = { [RepeatWrapping]: fe.REPEAT, [ClampToEdgeWrapping]: fe.CLAMP_TO_EDGE, [MirroredRepeatWrapping]: fe.MIRRORED_REPEAT }, Je = { [NearestFilter]: fe.NEAREST, [NearestMipmapNearestFilter]: fe.NEAREST_MIPMAP_NEAREST, [NearestMipmapLinearFilter]: fe.NEAREST_MIPMAP_LINEAR, [LinearFilter]: fe.LINEAR, [LinearMipmapNearestFilter]: fe.LINEAR_MIPMAP_NEAREST, [LinearMipmapLinearFilter]: fe.LINEAR_MIPMAP_LINEAR }, jt = { [NeverCompare]: fe.NEVER, [AlwaysCompare]: fe.ALWAYS, [LessCompare]: fe.LESS, [LessEqualCompare]: fe.LEQUAL, [EqualCompare]: fe.EQUAL, [GreaterEqualCompare]: fe.GEQUAL, [GreaterCompare]: fe.GREATER, [NotEqualCompare]: fe.NOTEQUAL }; function Xt(Ht, Dt) { if (Dt.type === FloatType && K.has("OES_texture_float_linear") === !1 && (Dt.magFilter === LinearFilter || Dt.magFilter === LinearMipmapNearestFilter || Dt.magFilter === NearestMipmapLinearFilter || Dt.magFilter === LinearMipmapLinearFilter || Dt.minFilter === LinearFilter || Dt.minFilter === LinearMipmapNearestFilter || Dt.minFilter === NearestMipmapLinearFilter || Dt.minFilter === LinearMipmapLinearFilter) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), fe.texParameteri(Ht, fe.TEXTURE_WRAP_S, Nt[Dt.wrapS]), fe.texParameteri(Ht, fe.TEXTURE_WRAP_T, Nt[Dt.wrapT]), (Ht === fe.TEXTURE_3D || Ht === fe.TEXTURE_2D_ARRAY) && fe.texParameteri(Ht, fe.TEXTURE_WRAP_R, Nt[Dt.wrapR]), fe.texParameteri(Ht, fe.TEXTURE_MAG_FILTER, Je[Dt.magFilter]), fe.texParameteri(Ht, fe.TEXTURE_MIN_FILTER, Je[Dt.minFilter]), Dt.compareFunction && (fe.texParameteri(Ht, fe.TEXTURE_COMPARE_MODE, fe.COMPARE_REF_TO_TEXTURE), fe.texParameteri(Ht, fe.TEXTURE_COMPARE_FUNC, jt[Dt.compareFunction])), K.has("EXT_texture_filter_anisotropic") === !0) { if (Dt.magFilter === NearestFilter || Dt.minFilter !== NearestMipmapLinearFilter && Dt.minFilter !== LinearMipmapLinearFilter || Dt.type === FloatType && K.has("OES_texture_float_linear") === !1) return; if (Dt.anisotropy > 1 || me.get(Dt).__currentAnisotropy) { const fn = K.get("EXT_texture_filter_anisotropic"); fe.texParameterf(Ht, fn.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Dt.anisotropy, ge.getMaxAnisotropy())), me.get(Dt).__currentAnisotropy = Dt.anisotropy } } } function ct(Ht, Dt) { let fn = !1; Ht.__webglInit === void 0 && (Ht.__webglInit = !0, Dt.addEventListener("dispose", Oe)); const en = Dt.source; let cn = Se.get(en); cn === void 0 && (cn = {}, Se.set(en, cn)); const Wt = Ze(Dt); if (Wt !== Ht.__cacheKey) { cn[Wt] === void 0 && (cn[Wt] = { texture: fe.createTexture(), usedTimes: 0 }, ye.memory.textures++, fn = !0), cn[Wt].usedTimes++; const un = cn[Ht.__cacheKey]; un !== void 0 && (cn[Ht.__cacheKey].usedTimes--, un.usedTimes === 0 && Ge(Dt)), Ht.__cacheKey = Wt, Ht.__webglTexture = cn[Wt].texture } return fn } function nn(Ht, Dt, fn) { let en = fe.TEXTURE_2D; (Dt.isDataArrayTexture || Dt.isCompressedArrayTexture) && (en = fe.TEXTURE_2D_ARRAY), Dt.isData3DTexture && (en = fe.TEXTURE_3D); const cn = ct(Ht, Dt), Wt = Dt.source; pe.bindTexture(en, Ht.__webglTexture, fe.TEXTURE0 + fn); const un = me.get(Wt); if (Wt.version !== un.__version || cn === !0) { pe.activeTexture(fe.TEXTURE0 + fn); const Ft = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), Sn = Dt.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(Dt.colorSpace), lr = Dt.colorSpace === NoColorSpace || Ft === Sn ? fe.NONE : fe.BROWSER_DEFAULT_WEBGL; fe.pixelStorei(fe.UNPACK_FLIP_Y_WEBGL, Dt.flipY), fe.pixelStorei(fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Dt.premultiplyAlpha), fe.pixelStorei(fe.UNPACK_ALIGNMENT, Dt.unpackAlignment), fe.pixelStorei(fe.UNPACK_COLORSPACE_CONVERSION_WEBGL, lr); let jn = Be(Dt.image, !1, ge.maxTextureSize); jn = Hn(Dt, jn); const Pn = xe.convert(Dt.format, Dt.colorSpace), fr = xe.convert(Dt.type); let Yn = Pe(Dt.internalFormat, Pn, fr, Dt.colorSpace, Dt.isVideoTexture); Xt(en, Dt); let sr; const Ar = Dt.mipmaps, Er = Dt.isVideoTexture !== !0, Rr = un.__version === void 0 || cn === !0, mn = Wt.dataReady, Dn = ke(Dt, jn); if (Dt.isDepthTexture) Yn = Ne(Dt.format === DepthStencilFormat, Dt.type), Rr && (Er ? pe.texStorage2D(fe.TEXTURE_2D, 1, Yn, jn.width, jn.height) : pe.texImage2D(fe.TEXTURE_2D, 0, Yn, jn.width, jn.height, 0, Pn, fr, null)); else if (Dt.isDataTexture) if (Ar.length > 0) { Er && Rr && pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, Ar[0].width, Ar[0].height); for (let Rn = 0, qn = Ar.length; Rn < qn; Rn++)sr = Ar[Rn], Er ? mn && pe.texSubImage2D(fe.TEXTURE_2D, Rn, 0, 0, sr.width, sr.height, Pn, fr, sr.data) : pe.texImage2D(fe.TEXTURE_2D, Rn, Yn, sr.width, sr.height, 0, Pn, fr, sr.data); Dt.generateMipmaps = !1 } else Er ? (Rr && pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, jn.width, jn.height), mn && pe.texSubImage2D(fe.TEXTURE_2D, 0, 0, 0, jn.width, jn.height, Pn, fr, jn.data)) : pe.texImage2D(fe.TEXTURE_2D, 0, Yn, jn.width, jn.height, 0, Pn, fr, jn.data); else if (Dt.isCompressedTexture) if (Dt.isCompressedArrayTexture) { Er && Rr && pe.texStorage3D(fe.TEXTURE_2D_ARRAY, Dn, Yn, Ar[0].width, Ar[0].height, jn.depth); for (let Rn = 0, qn = Ar.length; Rn < qn; Rn++)if (sr = Ar[Rn], Dt.format !== RGBAFormat) if (Pn !== null) if (Er) { if (mn) if (Dt.layerUpdates.size > 0) { const ar = getByteLength(sr.width, sr.height, Dt.format, Dt.type); for (const yr of Dt.layerUpdates) { const dr = sr.data.subarray(yr * ar / sr.data.BYTES_PER_ELEMENT, (yr + 1) * ar / sr.data.BYTES_PER_ELEMENT); pe.compressedTexSubImage3D(fe.TEXTURE_2D_ARRAY, Rn, 0, 0, yr, sr.width, sr.height, 1, Pn, dr) } Dt.clearLayerUpdates() } else pe.compressedTexSubImage3D(fe.TEXTURE_2D_ARRAY, Rn, 0, 0, 0, sr.width, sr.height, jn.depth, Pn, sr.data) } else pe.compressedTexImage3D(fe.TEXTURE_2D_ARRAY, Rn, Yn, sr.width, sr.height, jn.depth, 0, sr.data, 0, 0); else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"); else Er ? mn && pe.texSubImage3D(fe.TEXTURE_2D_ARRAY, Rn, 0, 0, 0, sr.width, sr.height, jn.depth, Pn, fr, sr.data) : pe.texImage3D(fe.TEXTURE_2D_ARRAY, Rn, Yn, sr.width, sr.height, jn.depth, 0, Pn, fr, sr.data) } else { Er && Rr && pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, Ar[0].width, Ar[0].height); for (let Rn = 0, qn = Ar.length; Rn < qn; Rn++)sr = Ar[Rn], Dt.format !== RGBAFormat ? Pn !== null ? Er ? mn && pe.compressedTexSubImage2D(fe.TEXTURE_2D, Rn, 0, 0, sr.width, sr.height, Pn, sr.data) : pe.compressedTexImage2D(fe.TEXTURE_2D, Rn, Yn, sr.width, sr.height, 0, sr.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Er ? mn && pe.texSubImage2D(fe.TEXTURE_2D, Rn, 0, 0, sr.width, sr.height, Pn, fr, sr.data) : pe.texImage2D(fe.TEXTURE_2D, Rn, Yn, sr.width, sr.height, 0, Pn, fr, sr.data) } else if (Dt.isDataArrayTexture) if (Er) { if (Rr && pe.texStorage3D(fe.TEXTURE_2D_ARRAY, Dn, Yn, jn.width, jn.height, jn.depth), mn) if (Dt.layerUpdates.size > 0) { const Rn = getByteLength(jn.width, jn.height, Dt.format, Dt.type); for (const qn of Dt.layerUpdates) { const ar = jn.data.subarray(qn * Rn / jn.data.BYTES_PER_ELEMENT, (qn + 1) * Rn / jn.data.BYTES_PER_ELEMENT); pe.texSubImage3D(fe.TEXTURE_2D_ARRAY, 0, 0, 0, qn, jn.width, jn.height, 1, Pn, fr, ar) } Dt.clearLayerUpdates() } else pe.texSubImage3D(fe.TEXTURE_2D_ARRAY, 0, 0, 0, 0, jn.width, jn.height, jn.depth, Pn, fr, jn.data) } else pe.texImage3D(fe.TEXTURE_2D_ARRAY, 0, Yn, jn.width, jn.height, jn.depth, 0, Pn, fr, jn.data); else if (Dt.isData3DTexture) Er ? (Rr && pe.texStorage3D(fe.TEXTURE_3D, Dn, Yn, jn.width, jn.height, jn.depth), mn && pe.texSubImage3D(fe.TEXTURE_3D, 0, 0, 0, 0, jn.width, jn.height, jn.depth, Pn, fr, jn.data)) : pe.texImage3D(fe.TEXTURE_3D, 0, Yn, jn.width, jn.height, jn.depth, 0, Pn, fr, jn.data); else if (Dt.isFramebufferTexture) { if (Rr) if (Er) pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, jn.width, jn.height); else { let Rn = jn.width, qn = jn.height; for (let ar = 0; ar < Dn; ar++)pe.texImage2D(fe.TEXTURE_2D, ar, Yn, Rn, qn, 0, Pn, fr, null), Rn >>= 1, qn >>= 1 } } else if (Ar.length > 0) { if (Er && Rr) { const Rn = kn(Ar[0]); pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, Rn.width, Rn.height) } for (let Rn = 0, qn = Ar.length; Rn < qn; Rn++)sr = Ar[Rn], Er ? mn && pe.texSubImage2D(fe.TEXTURE_2D, Rn, 0, 0, Pn, fr, sr) : pe.texImage2D(fe.TEXTURE_2D, Rn, Yn, Pn, fr, sr); Dt.generateMipmaps = !1 } else if (Er) { if (Rr) { const Rn = kn(jn); pe.texStorage2D(fe.TEXTURE_2D, Dn, Yn, Rn.width, Rn.height) } mn && pe.texSubImage2D(fe.TEXTURE_2D, 0, 0, 0, Pn, fr, jn) } else pe.texImage2D(fe.TEXTURE_2D, 0, Yn, Pn, fr, jn); De(Dt) && Re(en), un.__version = Wt.version, Dt.onUpdate && Dt.onUpdate(Dt) } Ht.__version = Dt.version } function $t(Ht, Dt, fn) { if (Dt.image.length !== 6) return; const en = ct(Ht, Dt), cn = Dt.source; pe.bindTexture(fe.TEXTURE_CUBE_MAP, Ht.__webglTexture, fe.TEXTURE0 + fn); const Wt = me.get(cn); if (cn.version !== Wt.__version || en === !0) { pe.activeTexture(fe.TEXTURE0 + fn); const un = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), Ft = Dt.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(Dt.colorSpace), Sn = Dt.colorSpace === NoColorSpace || un === Ft ? fe.NONE : fe.BROWSER_DEFAULT_WEBGL; fe.pixelStorei(fe.UNPACK_FLIP_Y_WEBGL, Dt.flipY), fe.pixelStorei(fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Dt.premultiplyAlpha), fe.pixelStorei(fe.UNPACK_ALIGNMENT, Dt.unpackAlignment), fe.pixelStorei(fe.UNPACK_COLORSPACE_CONVERSION_WEBGL, Sn); const lr = Dt.isCompressedTexture || Dt.image[0].isCompressedTexture, jn = Dt.image[0] && Dt.image[0].isDataTexture, Pn = []; for (let qn = 0; qn < 6; qn++)!lr && !jn ? Pn[qn] = Be(Dt.image[qn], !0, ge.maxCubemapSize) : Pn[qn] = jn ? Dt.image[qn].image : Dt.image[qn], Pn[qn] = Hn(Dt, Pn[qn]); const fr = Pn[0], Yn = xe.convert(Dt.format, Dt.colorSpace), sr = xe.convert(Dt.type), Ar = Pe(Dt.internalFormat, Yn, sr, Dt.colorSpace), Er = Dt.isVideoTexture !== !0, Rr = Wt.__version === void 0 || en === !0, mn = cn.dataReady; let Dn = ke(Dt, fr); Xt(fe.TEXTURE_CUBE_MAP, Dt); let Rn; if (lr) { Er && Rr && pe.texStorage2D(fe.TEXTURE_CUBE_MAP, Dn, Ar, fr.width, fr.height); for (let qn = 0; qn < 6; qn++) { Rn = Pn[qn].mipmaps; for (let ar = 0; ar < Rn.length; ar++) { const yr = Rn[ar]; Dt.format !== RGBAFormat ? Yn !== null ? Er ? mn && pe.compressedTexSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar, 0, 0, yr.width, yr.height, Yn, yr.data) : pe.compressedTexImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar, Ar, yr.width, yr.height, 0, yr.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Er ? mn && pe.texSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar, 0, 0, yr.width, yr.height, Yn, sr, yr.data) : pe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar, Ar, yr.width, yr.height, 0, Yn, sr, yr.data) } } } else { if (Rn = Dt.mipmaps, Er && Rr) { Rn.length > 0 && Dn++; const qn = kn(Pn[0]); pe.texStorage2D(fe.TEXTURE_CUBE_MAP, Dn, Ar, qn.width, qn.height) } for (let qn = 0; qn < 6; qn++)if (jn) { Er ? mn && pe.texSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, 0, 0, 0, Pn[qn].width, Pn[qn].height, Yn, sr, Pn[qn].data) : pe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, 0, Ar, Pn[qn].width, Pn[qn].height, 0, Yn, sr, Pn[qn].data); for (let ar = 0; ar < Rn.length; ar++) { const dr = Rn[ar].image[qn].image; Er ? mn && pe.texSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar + 1, 0, 0, dr.width, dr.height, Yn, sr, dr.data) : pe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar + 1, Ar, dr.width, dr.height, 0, Yn, sr, dr.data) } } else { Er ? mn && pe.texSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, 0, 0, 0, Yn, sr, Pn[qn]) : pe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, 0, Ar, Yn, sr, Pn[qn]); for (let ar = 0; ar < Rn.length; ar++) { const yr = Rn[ar]; Er ? mn && pe.texSubImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar + 1, 0, 0, Yn, sr, yr.image[qn]) : pe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X + qn, ar + 1, Ar, Yn, sr, yr.image[qn]) } } } De(Dt) && Re(fe.TEXTURE_CUBE_MAP), Wt.__version = cn.version, Dt.onUpdate && Dt.onUpdate(Dt) } Ht.__version = Dt.version } function an(Ht, Dt, fn, en, cn, Wt) { const un = xe.convert(fn.format, fn.colorSpace), Ft = xe.convert(fn.type), Sn = Pe(fn.internalFormat, un, Ft, fn.colorSpace), lr = me.get(Dt), jn = me.get(fn); if (jn.__renderTarget = Dt, !lr.__hasExternalTextures) { const Pn = Math.max(1, Dt.width >> Wt), fr = Math.max(1, Dt.height >> Wt); cn === fe.TEXTURE_3D || cn === fe.TEXTURE_2D_ARRAY ? pe.texImage3D(cn, Wt, Sn, Pn, fr, Dt.depth, 0, un, Ft, null) : pe.texImage2D(cn, Wt, Sn, Pn, fr, 0, un, Ft, null) } pe.bindFramebuffer(fe.FRAMEBUFFER, Ht), vn(Dt) ? ve.framebufferTexture2DMultisampleEXT(fe.FRAMEBUFFER, en, cn, jn.__webglTexture, 0, Kn(Dt)) : (cn === fe.TEXTURE_2D || cn >= fe.TEXTURE_CUBE_MAP_POSITIVE_X && cn <= fe.TEXTURE_CUBE_MAP_NEGATIVE_Z) && fe.framebufferTexture2D(fe.FRAMEBUFFER, en, cn, jn.__webglTexture, Wt), pe.bindFramebuffer(fe.FRAMEBUFFER, null) } function gn(Ht, Dt, fn) { if (fe.bindRenderbuffer(fe.RENDERBUFFER, Ht), Dt.depthBuffer) { const en = Dt.depthTexture, cn = en && en.isDepthTexture ? en.type : null, Wt = Ne(Dt.stencilBuffer, cn), un = Dt.stencilBuffer ? fe.DEPTH_STENCIL_ATTACHMENT : fe.DEPTH_ATTACHMENT, Ft = Kn(Dt); vn(Dt) ? ve.renderbufferStorageMultisampleEXT(fe.RENDERBUFFER, Ft, Wt, Dt.width, Dt.height) : fn ? fe.renderbufferStorageMultisample(fe.RENDERBUFFER, Ft, Wt, Dt.width, Dt.height) : fe.renderbufferStorage(fe.RENDERBUFFER, Wt, Dt.width, Dt.height), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, un, fe.RENDERBUFFER, Ht) } else { const en = Dt.textures; for (let cn = 0; cn < en.length; cn++) { const Wt = en[cn], un = xe.convert(Wt.format, Wt.colorSpace), Ft = xe.convert(Wt.type), Sn = Pe(Wt.internalFormat, un, Ft, Wt.colorSpace), lr = Kn(Dt); fn && vn(Dt) === !1 ? fe.renderbufferStorageMultisample(fe.RENDERBUFFER, lr, Sn, Dt.width, Dt.height) : vn(Dt) ? ve.renderbufferStorageMultisampleEXT(fe.RENDERBUFFER, lr, Sn, Dt.width, Dt.height) : fe.renderbufferStorage(fe.RENDERBUFFER, Sn, Dt.width, Dt.height) } } fe.bindRenderbuffer(fe.RENDERBUFFER, null) } function Mn(Ht, Dt) { if (Dt && Dt.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (pe.bindFramebuffer(fe.FRAMEBUFFER, Ht), !(Dt.depthTexture && Dt.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); const en = me.get(Dt.depthTexture); en.__renderTarget = Dt, (!en.__webglTexture || Dt.depthTexture.image.width !== Dt.width || Dt.depthTexture.image.height !== Dt.height) && (Dt.depthTexture.image.width = Dt.width, Dt.depthTexture.image.height = Dt.height, Dt.depthTexture.needsUpdate = !0), ot(Dt.depthTexture, 0); const cn = en.__webglTexture, Wt = Kn(Dt); if (Dt.depthTexture.format === DepthFormat) vn(Dt) ? ve.framebufferTexture2DMultisampleEXT(fe.FRAMEBUFFER, fe.DEPTH_ATTACHMENT, fe.TEXTURE_2D, cn, 0, Wt) : fe.framebufferTexture2D(fe.FRAMEBUFFER, fe.DEPTH_ATTACHMENT, fe.TEXTURE_2D, cn, 0); else if (Dt.depthTexture.format === DepthStencilFormat) vn(Dt) ? ve.framebufferTexture2DMultisampleEXT(fe.FRAMEBUFFER, fe.DEPTH_STENCIL_ATTACHMENT, fe.TEXTURE_2D, cn, 0, Wt) : fe.framebufferTexture2D(fe.FRAMEBUFFER, fe.DEPTH_STENCIL_ATTACHMENT, fe.TEXTURE_2D, cn, 0); else throw new Error("Unknown depthTexture format") } function Xn(Ht) { const Dt = me.get(Ht), fn = Ht.isWebGLCubeRenderTarget === !0; if (Dt.__boundDepthTexture !== Ht.depthTexture) { const en = Ht.depthTexture; if (Dt.__depthDisposeCallback && Dt.__depthDisposeCallback(), en) { const cn = () => { delete Dt.__boundDepthTexture, delete Dt.__depthDisposeCallback, en.removeEventListener("dispose", cn) }; en.addEventListener("dispose", cn), Dt.__depthDisposeCallback = cn } Dt.__boundDepthTexture = en } if (Ht.depthTexture && !Dt.__autoAllocateDepthBuffer) { if (fn) throw new Error("target.depthTexture not supported in Cube render targets"); Mn(Dt.__webglFramebuffer, Ht) } else if (fn) { Dt.__webglDepthbuffer = []; for (let en = 0; en < 6; en++)if (pe.bindFramebuffer(fe.FRAMEBUFFER, Dt.__webglFramebuffer[en]), Dt.__webglDepthbuffer[en] === void 0) Dt.__webglDepthbuffer[en] = fe.createRenderbuffer(), gn(Dt.__webglDepthbuffer[en], Ht, !1); else { const cn = Ht.stencilBuffer ? fe.DEPTH_STENCIL_ATTACHMENT : fe.DEPTH_ATTACHMENT, Wt = Dt.__webglDepthbuffer[en]; fe.bindRenderbuffer(fe.RENDERBUFFER, Wt), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, cn, fe.RENDERBUFFER, Wt) } } else if (pe.bindFramebuffer(fe.FRAMEBUFFER, Dt.__webglFramebuffer), Dt.__webglDepthbuffer === void 0) Dt.__webglDepthbuffer = fe.createRenderbuffer(), gn(Dt.__webglDepthbuffer, Ht, !1); else { const en = Ht.stencilBuffer ? fe.DEPTH_STENCIL_ATTACHMENT : fe.DEPTH_ATTACHMENT, cn = Dt.__webglDepthbuffer; fe.bindRenderbuffer(fe.RENDERBUFFER, cn), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, en, fe.RENDERBUFFER, cn) } pe.bindFramebuffer(fe.FRAMEBUFFER, null) } function Ln(Ht, Dt, fn) { const en = me.get(Ht); Dt !== void 0 && an(en.__webglFramebuffer, Ht, Ht.texture, fe.COLOR_ATTACHMENT0, fe.TEXTURE_2D, 0), fn !== void 0 && Xn(Ht) } function Gn(Ht) { const Dt = Ht.texture, fn = me.get(Ht), en = me.get(Dt); Ht.addEventListener("dispose", Ue); const cn = Ht.textures, Wt = Ht.isWebGLCubeRenderTarget === !0, un = cn.length > 1; if (un || (en.__webglTexture === void 0 && (en.__webglTexture = fe.createTexture()), en.__version = Dt.version, ye.memory.textures++), Wt) { fn.__webglFramebuffer = []; for (let Ft = 0; Ft < 6; Ft++)if (Dt.mipmaps && Dt.mipmaps.length > 0) { fn.__webglFramebuffer[Ft] = []; for (let Sn = 0; Sn < Dt.mipmaps.length; Sn++)fn.__webglFramebuffer[Ft][Sn] = fe.createFramebuffer() } else fn.__webglFramebuffer[Ft] = fe.createFramebuffer() } else { if (Dt.mipmaps && Dt.mipmaps.length > 0) { fn.__webglFramebuffer = []; for (let Ft = 0; Ft < Dt.mipmaps.length; Ft++)fn.__webglFramebuffer[Ft] = fe.createFramebuffer() } else fn.__webglFramebuffer = fe.createFramebuffer(); if (un) for (let Ft = 0, Sn = cn.length; Ft < Sn; Ft++) { const lr = me.get(cn[Ft]); lr.__webglTexture === void 0 && (lr.__webglTexture = fe.createTexture(), ye.memory.textures++) } if (Ht.samples > 0 && vn(Ht) === !1) { fn.__webglMultisampledFramebuffer = fe.createFramebuffer(), fn.__webglColorRenderbuffer = [], pe.bindFramebuffer(fe.FRAMEBUFFER, fn.__webglMultisampledFramebuffer); for (let Ft = 0; Ft < cn.length; Ft++) { const Sn = cn[Ft]; fn.__webglColorRenderbuffer[Ft] = fe.createRenderbuffer(), fe.bindRenderbuffer(fe.RENDERBUFFER, fn.__webglColorRenderbuffer[Ft]); const lr = xe.convert(Sn.format, Sn.colorSpace), jn = xe.convert(Sn.type), Pn = Pe(Sn.internalFormat, lr, jn, Sn.colorSpace, Ht.isXRRenderTarget === !0), fr = Kn(Ht); fe.renderbufferStorageMultisample(fe.RENDERBUFFER, fr, Pn, Ht.width, Ht.height), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, fe.COLOR_ATTACHMENT0 + Ft, fe.RENDERBUFFER, fn.__webglColorRenderbuffer[Ft]) } fe.bindRenderbuffer(fe.RENDERBUFFER, null), Ht.depthBuffer && (fn.__webglDepthRenderbuffer = fe.createRenderbuffer(), gn(fn.__webglDepthRenderbuffer, Ht, !0)), pe.bindFramebuffer(fe.FRAMEBUFFER, null) } } if (Wt) { pe.bindTexture(fe.TEXTURE_CUBE_MAP, en.__webglTexture), Xt(fe.TEXTURE_CUBE_MAP, Dt); for (let Ft = 0; Ft < 6; Ft++)if (Dt.mipmaps && Dt.mipmaps.length > 0) for (let Sn = 0; Sn < Dt.mipmaps.length; Sn++)an(fn.__webglFramebuffer[Ft][Sn], Ht, Dt, fe.COLOR_ATTACHMENT0, fe.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, Sn); else an(fn.__webglFramebuffer[Ft], Ht, Dt, fe.COLOR_ATTACHMENT0, fe.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, 0); De(Dt) && Re(fe.TEXTURE_CUBE_MAP), pe.unbindTexture() } else if (un) { for (let Ft = 0, Sn = cn.length; Ft < Sn; Ft++) { const lr = cn[Ft], jn = me.get(lr); pe.bindTexture(fe.TEXTURE_2D, jn.__webglTexture), Xt(fe.TEXTURE_2D, lr), an(fn.__webglFramebuffer, Ht, lr, fe.COLOR_ATTACHMENT0 + Ft, fe.TEXTURE_2D, 0), De(lr) && Re(fe.TEXTURE_2D) } pe.unbindTexture() } else { let Ft = fe.TEXTURE_2D; if ((Ht.isWebGL3DRenderTarget || Ht.isWebGLArrayRenderTarget) && (Ft = Ht.isWebGL3DRenderTarget ? fe.TEXTURE_3D : fe.TEXTURE_2D_ARRAY), pe.bindTexture(Ft, en.__webglTexture), Xt(Ft, Dt), Dt.mipmaps && Dt.mipmaps.length > 0) for (let Sn = 0; Sn < Dt.mipmaps.length; Sn++)an(fn.__webglFramebuffer[Sn], Ht, Dt, fe.COLOR_ATTACHMENT0, Ft, Sn); else an(fn.__webglFramebuffer, Ht, Dt, fe.COLOR_ATTACHMENT0, Ft, 0); De(Dt) && Re(Ft), pe.unbindTexture() } Ht.depthBuffer && Xn(Ht) } function wn(Ht) { const Dt = Ht.textures; for (let fn = 0, en = Dt.length; fn < en; fn++) { const cn = Dt[fn]; if (De(cn)) { const Wt = Ie(Ht), un = me.get(cn).__webglTexture; pe.bindTexture(Wt, un), Re(Wt), pe.unbindTexture() } } } const Bn = [], Gt = []; function nr(Ht) { if (Ht.samples > 0) { if (vn(Ht) === !1) { const Dt = Ht.textures, fn = Ht.width, en = Ht.height; let cn = fe.COLOR_BUFFER_BIT; const Wt = Ht.stencilBuffer ? fe.DEPTH_STENCIL_ATTACHMENT : fe.DEPTH_ATTACHMENT, un = me.get(Ht), Ft = Dt.length > 1; if (Ft) for (let Sn = 0; Sn < Dt.length; Sn++)pe.bindFramebuffer(fe.FRAMEBUFFER, un.__webglMultisampledFramebuffer), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, fe.COLOR_ATTACHMENT0 + Sn, fe.RENDERBUFFER, null), pe.bindFramebuffer(fe.FRAMEBUFFER, un.__webglFramebuffer), fe.framebufferTexture2D(fe.DRAW_FRAMEBUFFER, fe.COLOR_ATTACHMENT0 + Sn, fe.TEXTURE_2D, null, 0); pe.bindFramebuffer(fe.READ_FRAMEBUFFER, un.__webglMultisampledFramebuffer), pe.bindFramebuffer(fe.DRAW_FRAMEBUFFER, un.__webglFramebuffer); for (let Sn = 0; Sn < Dt.length; Sn++) { if (Ht.resolveDepthBuffer && (Ht.depthBuffer && (cn |= fe.DEPTH_BUFFER_BIT), Ht.stencilBuffer && Ht.resolveStencilBuffer && (cn |= fe.STENCIL_BUFFER_BIT)), Ft) { fe.framebufferRenderbuffer(fe.READ_FRAMEBUFFER, fe.COLOR_ATTACHMENT0, fe.RENDERBUFFER, un.__webglColorRenderbuffer[Sn]); const lr = me.get(Dt[Sn]).__webglTexture; fe.framebufferTexture2D(fe.DRAW_FRAMEBUFFER, fe.COLOR_ATTACHMENT0, fe.TEXTURE_2D, lr, 0) } fe.blitFramebuffer(0, 0, fn, en, 0, 0, fn, en, cn, fe.NEAREST), _e === !0 && (Bn.length = 0, Gt.length = 0, Bn.push(fe.COLOR_ATTACHMENT0 + Sn), Ht.depthBuffer && Ht.resolveDepthBuffer === !1 && (Bn.push(Wt), Gt.push(Wt), fe.invalidateFramebuffer(fe.DRAW_FRAMEBUFFER, Gt)), fe.invalidateFramebuffer(fe.READ_FRAMEBUFFER, Bn)) } if (pe.bindFramebuffer(fe.READ_FRAMEBUFFER, null), pe.bindFramebuffer(fe.DRAW_FRAMEBUFFER, null), Ft) for (let Sn = 0; Sn < Dt.length; Sn++) { pe.bindFramebuffer(fe.FRAMEBUFFER, un.__webglMultisampledFramebuffer), fe.framebufferRenderbuffer(fe.FRAMEBUFFER, fe.COLOR_ATTACHMENT0 + Sn, fe.RENDERBUFFER, un.__webglColorRenderbuffer[Sn]); const lr = me.get(Dt[Sn]).__webglTexture; pe.bindFramebuffer(fe.FRAMEBUFFER, un.__webglFramebuffer), fe.framebufferTexture2D(fe.DRAW_FRAMEBUFFER, fe.COLOR_ATTACHMENT0 + Sn, fe.TEXTURE_2D, lr, 0) } pe.bindFramebuffer(fe.DRAW_FRAMEBUFFER, un.__webglMultisampledFramebuffer) } else if (Ht.depthBuffer && Ht.resolveDepthBuffer === !1 && _e) { const Dt = Ht.stencilBuffer ? fe.DEPTH_STENCIL_ATTACHMENT : fe.DEPTH_ATTACHMENT; fe.invalidateFramebuffer(fe.DRAW_FRAMEBUFFER, [Dt]) } } } function Kn(Ht) { return Math.min(ge.maxSamples, Ht.samples) } function vn(Ht) { const Dt = me.get(Ht); return Ht.samples > 0 && K.has("WEBGL_multisampled_render_to_texture") === !0 && Dt.__useRenderToTexture !== !1 } function yn(Ht) { const Dt = ye.render.frame; be.get(Ht) !== Dt && (be.set(Ht, Dt), Ht.update()) } function Hn(Ht, Dt) { const fn = Ht.colorSpace, en = Ht.format, cn = Ht.type; return Ht.isCompressedTexture === !0 || Ht.isVideoTexture === !0 || fn !== LinearSRGBColorSpace && fn !== NoColorSpace && (ColorManagement.getTransfer(fn) === SRGBTransfer ? (en !== RGBAFormat || cn !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", fn)), Dt } function kn(Ht) { return typeof HTMLImageElement < "u" && Ht instanceof HTMLImageElement ? (Ee.width = Ht.naturalWidth || Ht.width, Ee.height = Ht.naturalHeight || Ht.height) : typeof VideoFrame < "u" && Ht instanceof VideoFrame ? (Ee.width = Ht.displayWidth, Ee.height = Ht.displayHeight) : (Ee.width = Ht.width, Ee.height = Ht.height), Ee } this.allocateTextureUnit = Ye, this.resetTextureUnits = Xe, this.setTexture2D = ot, this.setTexture2DArray = qe, this.setTexture3D = Qe, this.setTextureCube = st, this.rebindTextures = Ln, this.setupRenderTarget = Gn, this.updateRenderTargetMipmap = wn, this.updateMultisampleRenderTarget = nr, this.setupDepthRenderbuffer = Xn, this.setupFrameBufferTexture = an, this.useMultisampledRTT = vn } function WebGLUtils(fe, K) { function pe(me, ge = NoColorSpace) { let xe; const ye = ColorManagement.getTransfer(ge); if (me === UnsignedByteType) return fe.UNSIGNED_BYTE; if (me === UnsignedShort4444Type) return fe.UNSIGNED_SHORT_4_4_4_4; if (me === UnsignedShort5551Type) return fe.UNSIGNED_SHORT_5_5_5_1; if (me === UnsignedInt5999Type) return fe.UNSIGNED_INT_5_9_9_9_REV; if (me === ByteType) return fe.BYTE; if (me === ShortType) return fe.SHORT; if (me === UnsignedShortType) return fe.UNSIGNED_SHORT; if (me === IntType) return fe.INT; if (me === UnsignedIntType) return fe.UNSIGNED_INT; if (me === FloatType) return fe.FLOAT; if (me === HalfFloatType) return fe.HALF_FLOAT; if (me === AlphaFormat) return fe.ALPHA; if (me === RGBFormat) return fe.RGB; if (me === RGBAFormat) return fe.RGBA; if (me === LuminanceFormat) return fe.LUMINANCE; if (me === LuminanceAlphaFormat) return fe.LUMINANCE_ALPHA; if (me === DepthFormat) return fe.DEPTH_COMPONENT; if (me === DepthStencilFormat) return fe.DEPTH_STENCIL; if (me === RedFormat) return fe.RED; if (me === RedIntegerFormat) return fe.RED_INTEGER; if (me === RGFormat) return fe.RG; if (me === RGIntegerFormat) return fe.RG_INTEGER; if (me === RGBAIntegerFormat) return fe.RGBA_INTEGER; if (me === RGB_S3TC_DXT1_Format || me === RGBA_S3TC_DXT1_Format || me === RGBA_S3TC_DXT3_Format || me === RGBA_S3TC_DXT5_Format) if (ye === SRGBTransfer) if (xe = K.get("WEBGL_compressed_texture_s3tc_srgb"), xe !== null) { if (me === RGB_S3TC_DXT1_Format) return xe.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (me === RGBA_S3TC_DXT1_Format) return xe.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (me === RGBA_S3TC_DXT3_Format) return xe.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (me === RGBA_S3TC_DXT5_Format) return xe.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (xe = K.get("WEBGL_compressed_texture_s3tc"), xe !== null) { if (me === RGB_S3TC_DXT1_Format) return xe.COMPRESSED_RGB_S3TC_DXT1_EXT; if (me === RGBA_S3TC_DXT1_Format) return xe.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (me === RGBA_S3TC_DXT3_Format) return xe.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (me === RGBA_S3TC_DXT5_Format) return xe.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (me === RGB_PVRTC_4BPPV1_Format || me === RGB_PVRTC_2BPPV1_Format || me === RGBA_PVRTC_4BPPV1_Format || me === RGBA_PVRTC_2BPPV1_Format) if (xe = K.get("WEBGL_compressed_texture_pvrtc"), xe !== null) { if (me === RGB_PVRTC_4BPPV1_Format) return xe.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (me === RGB_PVRTC_2BPPV1_Format) return xe.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (me === RGBA_PVRTC_4BPPV1_Format) return xe.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (me === RGBA_PVRTC_2BPPV1_Format) return xe.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (me === RGB_ETC1_Format || me === RGB_ETC2_Format || me === RGBA_ETC2_EAC_Format) if (xe = K.get("WEBGL_compressed_texture_etc"), xe !== null) { if (me === RGB_ETC1_Format || me === RGB_ETC2_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ETC2 : xe.COMPRESSED_RGB8_ETC2; if (me === RGBA_ETC2_EAC_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : xe.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (me === RGBA_ASTC_4x4_Format || me === RGBA_ASTC_5x4_Format || me === RGBA_ASTC_5x5_Format || me === RGBA_ASTC_6x5_Format || me === RGBA_ASTC_6x6_Format || me === RGBA_ASTC_8x5_Format || me === RGBA_ASTC_8x6_Format || me === RGBA_ASTC_8x8_Format || me === RGBA_ASTC_10x5_Format || me === RGBA_ASTC_10x6_Format || me === RGBA_ASTC_10x8_Format || me === RGBA_ASTC_10x10_Format || me === RGBA_ASTC_12x10_Format || me === RGBA_ASTC_12x12_Format) if (xe = K.get("WEBGL_compressed_texture_astc"), xe !== null) { if (me === RGBA_ASTC_4x4_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : xe.COMPRESSED_RGBA_ASTC_4x4_KHR; if (me === RGBA_ASTC_5x4_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : xe.COMPRESSED_RGBA_ASTC_5x4_KHR; if (me === RGBA_ASTC_5x5_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : xe.COMPRESSED_RGBA_ASTC_5x5_KHR; if (me === RGBA_ASTC_6x5_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : xe.COMPRESSED_RGBA_ASTC_6x5_KHR; if (me === RGBA_ASTC_6x6_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : xe.COMPRESSED_RGBA_ASTC_6x6_KHR; if (me === RGBA_ASTC_8x5_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : xe.COMPRESSED_RGBA_ASTC_8x5_KHR; if (me === RGBA_ASTC_8x6_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : xe.COMPRESSED_RGBA_ASTC_8x6_KHR; if (me === RGBA_ASTC_8x8_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : xe.COMPRESSED_RGBA_ASTC_8x8_KHR; if (me === RGBA_ASTC_10x5_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : xe.COMPRESSED_RGBA_ASTC_10x5_KHR; if (me === RGBA_ASTC_10x6_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : xe.COMPRESSED_RGBA_ASTC_10x6_KHR; if (me === RGBA_ASTC_10x8_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : xe.COMPRESSED_RGBA_ASTC_10x8_KHR; if (me === RGBA_ASTC_10x10_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : xe.COMPRESSED_RGBA_ASTC_10x10_KHR; if (me === RGBA_ASTC_12x10_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : xe.COMPRESSED_RGBA_ASTC_12x10_KHR; if (me === RGBA_ASTC_12x12_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : xe.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (me === RGBA_BPTC_Format || me === RGB_BPTC_SIGNED_Format || me === RGB_BPTC_UNSIGNED_Format) if (xe = K.get("EXT_texture_compression_bptc"), xe !== null) { if (me === RGBA_BPTC_Format) return ye === SRGBTransfer ? xe.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : xe.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (me === RGB_BPTC_SIGNED_Format) return xe.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (me === RGB_BPTC_UNSIGNED_Format) return xe.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } else return null; if (me === RED_RGTC1_Format || me === SIGNED_RED_RGTC1_Format || me === RED_GREEN_RGTC2_Format || me === SIGNED_RED_GREEN_RGTC2_Format) if (xe = K.get("EXT_texture_compression_rgtc"), xe !== null) { if (me === RGBA_BPTC_Format) return xe.COMPRESSED_RED_RGTC1_EXT; if (me === SIGNED_RED_RGTC1_Format) return xe.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (me === RED_GREEN_RGTC2_Format) return xe.COMPRESSED_RED_GREEN_RGTC2_EXT; if (me === SIGNED_RED_GREEN_RGTC2_Format) return xe.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return me === UnsignedInt248Type ? fe.UNSIGNED_INT_24_8 : fe[me] !== void 0 ? fe[me] : null } return { convert: pe } } const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`; class WebXRDepthSensing { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(K, pe, me) { if (this.texture === null) { const ge = new Texture, xe = K.properties.get(ge); xe.__webglTexture = pe.texture, (pe.depthNear !== me.depthNear || pe.depthFar !== me.depthFar) && (this.depthNear = pe.depthNear, this.depthFar = pe.depthFar), this.texture = ge } } getMesh(K) { if (this.texture !== null && this.mesh === null) { const pe = K.cameras[0].viewport, me = new ShaderMaterial({ vertexShader: _occlusion_vertex, fragmentShader: _occlusion_fragment, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: pe.z }, depthHeight: { value: pe.w } } }); this.mesh = new Mesh(new PlaneGeometry(20, 20), me) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class WebXRManager extends EventDispatcher$2 { constructor(K, pe) { super(); const me = this; let ge = null, xe = 1, ye = null, ve = "local-floor", _e = 1, Ee = null, be = null, Ae = null, Se = null, Ce = null, we = null; const Be = new WebXRDepthSensing, De = pe.getContextAttributes(); let Re = null, Ie = null; const Pe = [], Ne = [], ke = new Vector2; let Oe = null; const Ue = new PerspectiveCamera; Ue.viewport = new Vector4; const He = new PerspectiveCamera; He.viewport = new Vector4; const Ge = [Ue, He], ze = new ArrayCamera; let We = null, Xe = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (nn) { let $t = Pe[nn]; return $t === void 0 && ($t = new WebXRController, Pe[nn] = $t), $t.getTargetRaySpace() }, this.getControllerGrip = function (nn) { let $t = Pe[nn]; return $t === void 0 && ($t = new WebXRController, Pe[nn] = $t), $t.getGripSpace() }, this.getHand = function (nn) { let $t = Pe[nn]; return $t === void 0 && ($t = new WebXRController, Pe[nn] = $t), $t.getHandSpace() }; function Ye(nn) { const $t = Ne.indexOf(nn.inputSource); if ($t === -1) return; const an = Pe[$t]; an !== void 0 && (an.update(nn.inputSource, nn.frame, Ee || ye), an.dispatchEvent({ type: nn.type, data: nn.inputSource })) } function Ze() { ge.removeEventListener("select", Ye), ge.removeEventListener("selectstart", Ye), ge.removeEventListener("selectend", Ye), ge.removeEventListener("squeeze", Ye), ge.removeEventListener("squeezestart", Ye), ge.removeEventListener("squeezeend", Ye), ge.removeEventListener("end", Ze), ge.removeEventListener("inputsourceschange", ot); for (let nn = 0; nn < Pe.length; nn++) { const $t = Ne[nn]; $t !== null && (Ne[nn] = null, Pe[nn].disconnect($t)) } We = null, Xe = null, Be.reset(), K.setRenderTarget(Re), Ce = null, Se = null, Ae = null, ge = null, Ie = null, ct.stop(), me.isPresenting = !1, K.setPixelRatio(Oe), K.setSize(ke.width, ke.height, !1), me.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (nn) { xe = nn, me.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (nn) { ve = nn, me.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return Ee || ye }, this.setReferenceSpace = function (nn) { Ee = nn }, this.getBaseLayer = function () { return Se !== null ? Se : Ce }, this.getBinding = function () { return Ae }, this.getFrame = function () { return we }, this.getSession = function () { return ge }, this.setSession = async function (nn) { if (ge = nn, ge !== null) { if (Re = K.getRenderTarget(), ge.addEventListener("select", Ye), ge.addEventListener("selectstart", Ye), ge.addEventListener("selectend", Ye), ge.addEventListener("squeeze", Ye), ge.addEventListener("squeezestart", Ye), ge.addEventListener("squeezeend", Ye), ge.addEventListener("end", Ze), ge.addEventListener("inputsourceschange", ot), De.xrCompatible !== !0 && await pe.makeXRCompatible(), Oe = K.getPixelRatio(), K.getSize(ke), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) { let an = null, gn = null, Mn = null; De.depth && (Mn = De.stencil ? pe.DEPTH24_STENCIL8 : pe.DEPTH_COMPONENT24, an = De.stencil ? DepthStencilFormat : DepthFormat, gn = De.stencil ? UnsignedInt248Type : UnsignedIntType); const Xn = { colorFormat: pe.RGBA8, depthFormat: Mn, scaleFactor: xe }; Ae = new XRWebGLBinding(ge, pe), Se = Ae.createProjectionLayer(Xn), ge.updateRenderState({ layers: [Se] }), K.setPixelRatio(1), K.setSize(Se.textureWidth, Se.textureHeight, !1), Ie = new WebGLRenderTarget(Se.textureWidth, Se.textureHeight, { format: RGBAFormat, type: UnsignedByteType, depthTexture: new DepthTexture(Se.textureWidth, Se.textureHeight, gn, void 0, void 0, void 0, void 0, void 0, void 0, an), stencilBuffer: De.stencil, colorSpace: K.outputColorSpace, samples: De.antialias ? 4 : 0, resolveDepthBuffer: Se.ignoreDepthValues === !1, resolveStencilBuffer: Se.ignoreDepthValues === !1 }) } else { const an = { antialias: De.antialias, alpha: !0, depth: De.depth, stencil: De.stencil, framebufferScaleFactor: xe }; Ce = new XRWebGLLayer(ge, pe, an), ge.updateRenderState({ baseLayer: Ce }), K.setPixelRatio(1), K.setSize(Ce.framebufferWidth, Ce.framebufferHeight, !1), Ie = new WebGLRenderTarget(Ce.framebufferWidth, Ce.framebufferHeight, { format: RGBAFormat, type: UnsignedByteType, colorSpace: K.outputColorSpace, stencilBuffer: De.stencil, resolveDepthBuffer: Ce.ignoreDepthValues === !1, resolveStencilBuffer: Ce.ignoreDepthValues === !1 }) } Ie.isXRRenderTarget = !0, this.setFoveation(_e), Ee = null, ye = await ge.requestReferenceSpace(ve), ct.setContext(ge), ct.start(), me.isPresenting = !0, me.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (ge !== null) return ge.environmentBlendMode }, this.getDepthTexture = function () { return Be.getDepthTexture() }; function ot(nn) { for (let $t = 0; $t < nn.removed.length; $t++) { const an = nn.removed[$t], gn = Ne.indexOf(an); gn >= 0 && (Ne[gn] = null, Pe[gn].disconnect(an)) } for (let $t = 0; $t < nn.added.length; $t++) { const an = nn.added[$t]; let gn = Ne.indexOf(an); if (gn === -1) { for (let Xn = 0; Xn < Pe.length; Xn++)if (Xn >= Ne.length) { Ne.push(an), gn = Xn; break } else if (Ne[Xn] === null) { Ne[Xn] = an, gn = Xn; break } if (gn === -1) break } const Mn = Pe[gn]; Mn && Mn.connect(an) } } const qe = new Vector3, Qe = new Vector3; function st(nn, $t, an) { qe.setFromMatrixPosition($t.matrixWorld), Qe.setFromMatrixPosition(an.matrixWorld); const gn = qe.distanceTo(Qe), Mn = $t.projectionMatrix.elements, Xn = an.projectionMatrix.elements, Ln = Mn[14] / (Mn[10] - 1), Gn = Mn[14] / (Mn[10] + 1), wn = (Mn[9] + 1) / Mn[5], Bn = (Mn[9] - 1) / Mn[5], Gt = (Mn[8] - 1) / Mn[0], nr = (Xn[8] + 1) / Xn[0], Kn = Ln * Gt, vn = Ln * nr, yn = gn / (-Gt + nr), Hn = yn * -Gt; if ($t.matrixWorld.decompose(nn.position, nn.quaternion, nn.scale), nn.translateX(Hn), nn.translateZ(yn), nn.matrixWorld.compose(nn.position, nn.quaternion, nn.scale), nn.matrixWorldInverse.copy(nn.matrixWorld).invert(), Mn[10] === -1) nn.projectionMatrix.copy($t.projectionMatrix), nn.projectionMatrixInverse.copy($t.projectionMatrixInverse); else { const kn = Ln + yn, Ht = Gn + yn, Dt = Kn - Hn, fn = vn + (gn - Hn), en = wn * Gn / Ht * kn, cn = Bn * Gn / Ht * kn; nn.projectionMatrix.makePerspective(Dt, fn, en, cn, kn, Ht), nn.projectionMatrixInverse.copy(nn.projectionMatrix).invert() } } function Nt(nn, $t) { $t === null ? nn.matrixWorld.copy(nn.matrix) : nn.matrixWorld.multiplyMatrices($t.matrixWorld, nn.matrix), nn.matrixWorldInverse.copy(nn.matrixWorld).invert() } this.updateCamera = function (nn) { if (ge === null) return; let $t = nn.near, an = nn.far; Be.texture !== null && (Be.depthNear > 0 && ($t = Be.depthNear), Be.depthFar > 0 && (an = Be.depthFar)), ze.near = He.near = Ue.near = $t, ze.far = He.far = Ue.far = an, (We !== ze.near || Xe !== ze.far) && (ge.updateRenderState({ depthNear: ze.near, depthFar: ze.far }), We = ze.near, Xe = ze.far), Ue.layers.mask = nn.layers.mask | 2, He.layers.mask = nn.layers.mask | 4, ze.layers.mask = Ue.layers.mask | He.layers.mask; const gn = nn.parent, Mn = ze.cameras; Nt(ze, gn); for (let Xn = 0; Xn < Mn.length; Xn++)Nt(Mn[Xn], gn); Mn.length === 2 ? st(ze, Ue, He) : ze.projectionMatrix.copy(Ue.projectionMatrix), Je(nn, ze, gn) }; function Je(nn, $t, an) { an === null ? nn.matrix.copy($t.matrixWorld) : (nn.matrix.copy(an.matrixWorld), nn.matrix.invert(), nn.matrix.multiply($t.matrixWorld)), nn.matrix.decompose(nn.position, nn.quaternion, nn.scale), nn.updateMatrixWorld(!0), nn.projectionMatrix.copy($t.projectionMatrix), nn.projectionMatrixInverse.copy($t.projectionMatrixInverse), nn.isPerspectiveCamera && (nn.fov = RAD2DEG * 2 * Math.atan(1 / nn.projectionMatrix.elements[5]), nn.zoom = 1) } this.getCamera = function () { return ze }, this.getFoveation = function () { if (!(Se === null && Ce === null)) return _e }, this.setFoveation = function (nn) { _e = nn, Se !== null && (Se.fixedFoveation = nn), Ce !== null && Ce.fixedFoveation !== void 0 && (Ce.fixedFoveation = nn) }, this.hasDepthSensing = function () { return Be.texture !== null }, this.getDepthSensingMesh = function () { return Be.getMesh(ze) }; let jt = null; function Xt(nn, $t) { if (be = $t.getViewerPose(Ee || ye), we = $t, be !== null) { const an = be.views; Ce !== null && (K.setRenderTargetFramebuffer(Ie, Ce.framebuffer), K.setRenderTarget(Ie)); let gn = !1; an.length !== ze.cameras.length && (ze.cameras.length = 0, gn = !0); for (let Ln = 0; Ln < an.length; Ln++) { const Gn = an[Ln]; let wn = null; if (Ce !== null) wn = Ce.getViewport(Gn); else { const Gt = Ae.getViewSubImage(Se, Gn); wn = Gt.viewport, Ln === 0 && (K.setRenderTargetTextures(Ie, Gt.colorTexture, Se.ignoreDepthValues ? void 0 : Gt.depthStencilTexture), K.setRenderTarget(Ie)) } let Bn = Ge[Ln]; Bn === void 0 && (Bn = new PerspectiveCamera, Bn.layers.enable(Ln), Bn.viewport = new Vector4, Ge[Ln] = Bn), Bn.matrix.fromArray(Gn.transform.matrix), Bn.matrix.decompose(Bn.position, Bn.quaternion, Bn.scale), Bn.projectionMatrix.fromArray(Gn.projectionMatrix), Bn.projectionMatrixInverse.copy(Bn.projectionMatrix).invert(), Bn.viewport.set(wn.x, wn.y, wn.width, wn.height), Ln === 0 && (ze.matrix.copy(Bn.matrix), ze.matrix.decompose(ze.position, ze.quaternion, ze.scale)), gn === !0 && ze.cameras.push(Bn) } const Mn = ge.enabledFeatures; if (Mn && Mn.includes("depth-sensing") && ge.depthUsage == "gpu-optimized" && Ae) { const Ln = Ae.getDepthInformation(an[0]); Ln && Ln.isValid && Ln.texture && Be.init(K, Ln, ge.renderState) } } for (let an = 0; an < Pe.length; an++) { const gn = Ne[an], Mn = Pe[an]; gn !== null && Mn !== void 0 && Mn.update(gn, $t, Ee || ye) } jt && jt(nn, $t), $t.detectedPlanes && me.dispatchEvent({ type: "planesdetected", data: $t }), we = null } const ct = new WebGLAnimation; ct.setAnimationLoop(Xt), this.setAnimationLoop = function (nn) { jt = nn }, this.dispose = function () { } } } const _e1 = new Euler, _m1 = new Matrix4; function WebGLMaterials(fe, K) { function pe(De, Re) { De.matrixAutoUpdate === !0 && De.updateMatrix(), Re.value.copy(De.matrix) } function me(De, Re) { Re.color.getRGB(De.fogColor.value, getUnlitUniformColorSpace(fe)), Re.isFog ? (De.fogNear.value = Re.near, De.fogFar.value = Re.far) : Re.isFogExp2 && (De.fogDensity.value = Re.density) } function ge(De, Re, Ie, Pe, Ne) { Re.isMeshBasicMaterial || Re.isMeshLambertMaterial ? xe(De, Re) : Re.isMeshToonMaterial ? (xe(De, Re), Ae(De, Re)) : Re.isMeshPhongMaterial ? (xe(De, Re), be(De, Re)) : Re.isMeshStandardMaterial ? (xe(De, Re), Se(De, Re), Re.isMeshPhysicalMaterial && Ce(De, Re, Ne)) : Re.isMeshMatcapMaterial ? (xe(De, Re), we(De, Re)) : Re.isMeshDepthMaterial ? xe(De, Re) : Re.isMeshDistanceMaterial ? (xe(De, Re), Be(De, Re)) : Re.isMeshNormalMaterial ? xe(De, Re) : Re.isLineBasicMaterial ? (ye(De, Re), Re.isLineDashedMaterial && ve(De, Re)) : Re.isPointsMaterial ? _e(De, Re, Ie, Pe) : Re.isSpriteMaterial ? Ee(De, Re) : Re.isShadowMaterial ? (De.color.value.copy(Re.color), De.opacity.value = Re.opacity) : Re.isShaderMaterial && (Re.uniformsNeedUpdate = !1) } function xe(De, Re) { De.opacity.value = Re.opacity, Re.color && De.diffuse.value.copy(Re.color), Re.emissive && De.emissive.value.copy(Re.emissive).multiplyScalar(Re.emissiveIntensity), Re.map && (De.map.value = Re.map, pe(Re.map, De.mapTransform)), Re.alphaMap && (De.alphaMap.value = Re.alphaMap, pe(Re.alphaMap, De.alphaMapTransform)), Re.bumpMap && (De.bumpMap.value = Re.bumpMap, pe(Re.bumpMap, De.bumpMapTransform), De.bumpScale.value = Re.bumpScale, Re.side === BackSide && (De.bumpScale.value *= -1)), Re.normalMap && (De.normalMap.value = Re.normalMap, pe(Re.normalMap, De.normalMapTransform), De.normalScale.value.copy(Re.normalScale), Re.side === BackSide && De.normalScale.value.negate()), Re.displacementMap && (De.displacementMap.value = Re.displacementMap, pe(Re.displacementMap, De.displacementMapTransform), De.displacementScale.value = Re.displacementScale, De.displacementBias.value = Re.displacementBias), Re.emissiveMap && (De.emissiveMap.value = Re.emissiveMap, pe(Re.emissiveMap, De.emissiveMapTransform)), Re.specularMap && (De.specularMap.value = Re.specularMap, pe(Re.specularMap, De.specularMapTransform)), Re.alphaTest > 0 && (De.alphaTest.value = Re.alphaTest); const Ie = K.get(Re), Pe = Ie.envMap, Ne = Ie.envMapRotation; Pe && (De.envMap.value = Pe, _e1.copy(Ne), _e1.x *= -1, _e1.y *= -1, _e1.z *= -1, Pe.isCubeTexture && Pe.isRenderTargetTexture === !1 && (_e1.y *= -1, _e1.z *= -1), De.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)), De.flipEnvMap.value = Pe.isCubeTexture && Pe.isRenderTargetTexture === !1 ? -1 : 1, De.reflectivity.value = Re.reflectivity, De.ior.value = Re.ior, De.refractionRatio.value = Re.refractionRatio), Re.lightMap && (De.lightMap.value = Re.lightMap, De.lightMapIntensity.value = Re.lightMapIntensity, pe(Re.lightMap, De.lightMapTransform)), Re.aoMap && (De.aoMap.value = Re.aoMap, De.aoMapIntensity.value = Re.aoMapIntensity, pe(Re.aoMap, De.aoMapTransform)) } function ye(De, Re) { De.diffuse.value.copy(Re.color), De.opacity.value = Re.opacity, Re.map && (De.map.value = Re.map, pe(Re.map, De.mapTransform)) } function ve(De, Re) { De.dashSize.value = Re.dashSize, De.totalSize.value = Re.dashSize + Re.gapSize, De.scale.value = Re.scale } function _e(De, Re, Ie, Pe) { De.diffuse.value.copy(Re.color), De.opacity.value = Re.opacity, De.size.value = Re.size * Ie, De.scale.value = Pe * .5, Re.map && (De.map.value = Re.map, pe(Re.map, De.uvTransform)), Re.alphaMap && (De.alphaMap.value = Re.alphaMap, pe(Re.alphaMap, De.alphaMapTransform)), Re.alphaTest > 0 && (De.alphaTest.value = Re.alphaTest) } function Ee(De, Re) { De.diffuse.value.copy(Re.color), De.opacity.value = Re.opacity, De.rotation.value = Re.rotation, Re.map && (De.map.value = Re.map, pe(Re.map, De.mapTransform)), Re.alphaMap && (De.alphaMap.value = Re.alphaMap, pe(Re.alphaMap, De.alphaMapTransform)), Re.alphaTest > 0 && (De.alphaTest.value = Re.alphaTest) } function be(De, Re) { De.specular.value.copy(Re.specular), De.shininess.value = Math.max(Re.shininess, 1e-4) } function Ae(De, Re) { Re.gradientMap && (De.gradientMap.value = Re.gradientMap) } function Se(De, Re) { De.metalness.value = Re.metalness, Re.metalnessMap && (De.metalnessMap.value = Re.metalnessMap, pe(Re.metalnessMap, De.metalnessMapTransform)), De.roughness.value = Re.roughness, Re.roughnessMap && (De.roughnessMap.value = Re.roughnessMap, pe(Re.roughnessMap, De.roughnessMapTransform)), Re.envMap && (De.envMapIntensity.value = Re.envMapIntensity) } function Ce(De, Re, Ie) { De.ior.value = Re.ior, Re.sheen > 0 && (De.sheenColor.value.copy(Re.sheenColor).multiplyScalar(Re.sheen), De.sheenRoughness.value = Re.sheenRoughness, Re.sheenColorMap && (De.sheenColorMap.value = Re.sheenColorMap, pe(Re.sheenColorMap, De.sheenColorMapTransform)), Re.sheenRoughnessMap && (De.sheenRoughnessMap.value = Re.sheenRoughnessMap, pe(Re.sheenRoughnessMap, De.sheenRoughnessMapTransform))), Re.clearcoat > 0 && (De.clearcoat.value = Re.clearcoat, De.clearcoatRoughness.value = Re.clearcoatRoughness, Re.clearcoatMap && (De.clearcoatMap.value = Re.clearcoatMap, pe(Re.clearcoatMap, De.clearcoatMapTransform)), Re.clearcoatRoughnessMap && (De.clearcoatRoughnessMap.value = Re.clearcoatRoughnessMap, pe(Re.clearcoatRoughnessMap, De.clearcoatRoughnessMapTransform)), Re.clearcoatNormalMap && (De.clearcoatNormalMap.value = Re.clearcoatNormalMap, pe(Re.clearcoatNormalMap, De.clearcoatNormalMapTransform), De.clearcoatNormalScale.value.copy(Re.clearcoatNormalScale), Re.side === BackSide && De.clearcoatNormalScale.value.negate())), Re.dispersion > 0 && (De.dispersion.value = Re.dispersion), Re.iridescence > 0 && (De.iridescence.value = Re.iridescence, De.iridescenceIOR.value = Re.iridescenceIOR, De.iridescenceThicknessMinimum.value = Re.iridescenceThicknessRange[0], De.iridescenceThicknessMaximum.value = Re.iridescenceThicknessRange[1], Re.iridescenceMap && (De.iridescenceMap.value = Re.iridescenceMap, pe(Re.iridescenceMap, De.iridescenceMapTransform)), Re.iridescenceThicknessMap && (De.iridescenceThicknessMap.value = Re.iridescenceThicknessMap, pe(Re.iridescenceThicknessMap, De.iridescenceThicknessMapTransform))), Re.transmission > 0 && (De.transmission.value = Re.transmission, De.transmissionSamplerMap.value = Ie.texture, De.transmissionSamplerSize.value.set(Ie.width, Ie.height), Re.transmissionMap && (De.transmissionMap.value = Re.transmissionMap, pe(Re.transmissionMap, De.transmissionMapTransform)), De.thickness.value = Re.thickness, Re.thicknessMap && (De.thicknessMap.value = Re.thicknessMap, pe(Re.thicknessMap, De.thicknessMapTransform)), De.attenuationDistance.value = Re.attenuationDistance, De.attenuationColor.value.copy(Re.attenuationColor)), Re.anisotropy > 0 && (De.anisotropyVector.value.set(Re.anisotropy * Math.cos(Re.anisotropyRotation), Re.anisotropy * Math.sin(Re.anisotropyRotation)), Re.anisotropyMap && (De.anisotropyMap.value = Re.anisotropyMap, pe(Re.anisotropyMap, De.anisotropyMapTransform))), De.specularIntensity.value = Re.specularIntensity, De.specularColor.value.copy(Re.specularColor), Re.specularColorMap && (De.specularColorMap.value = Re.specularColorMap, pe(Re.specularColorMap, De.specularColorMapTransform)), Re.specularIntensityMap && (De.specularIntensityMap.value = Re.specularIntensityMap, pe(Re.specularIntensityMap, De.specularIntensityMapTransform)) } function we(De, Re) { Re.matcap && (De.matcap.value = Re.matcap) } function Be(De, Re) { const Ie = K.get(Re).light; De.referencePosition.value.setFromMatrixPosition(Ie.matrixWorld), De.nearDistance.value = Ie.shadow.camera.near, De.farDistance.value = Ie.shadow.camera.far } return { refreshFogUniforms: me, refreshMaterialUniforms: ge } } function WebGLUniformsGroups(fe, K, pe, me) { let ge = {}, xe = {}, ye = []; const ve = fe.getParameter(fe.MAX_UNIFORM_BUFFER_BINDINGS); function _e(Ie, Pe) { const Ne = Pe.program; me.uniformBlockBinding(Ie, Ne) } function Ee(Ie, Pe) { let Ne = ge[Ie.id]; Ne === void 0 && (we(Ie), Ne = be(Ie), ge[Ie.id] = Ne, Ie.addEventListener("dispose", De)); const ke = Pe.program; me.updateUBOMapping(Ie, ke); const Oe = K.render.frame; xe[Ie.id] !== Oe && (Se(Ie), xe[Ie.id] = Oe) } function be(Ie) { const Pe = Ae(); Ie.__bindingPointIndex = Pe; const Ne = fe.createBuffer(), ke = Ie.__size, Oe = Ie.usage; return fe.bindBuffer(fe.UNIFORM_BUFFER, Ne), fe.bufferData(fe.UNIFORM_BUFFER, ke, Oe), fe.bindBuffer(fe.UNIFORM_BUFFER, null), fe.bindBufferBase(fe.UNIFORM_BUFFER, Pe, Ne), Ne } function Ae() { for (let Ie = 0; Ie < ve; Ie++)if (ye.indexOf(Ie) === -1) return ye.push(Ie), Ie; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function Se(Ie) { const Pe = ge[Ie.id], Ne = Ie.uniforms, ke = Ie.__cache; fe.bindBuffer(fe.UNIFORM_BUFFER, Pe); for (let Oe = 0, Ue = Ne.length; Oe < Ue; Oe++) { const He = Array.isArray(Ne[Oe]) ? Ne[Oe] : [Ne[Oe]]; for (let Ge = 0, ze = He.length; Ge < ze; Ge++) { const We = He[Ge]; if (Ce(We, Oe, Ge, ke) === !0) { const Xe = We.__offset, Ye = Array.isArray(We.value) ? We.value : [We.value]; let Ze = 0; for (let ot = 0; ot < Ye.length; ot++) { const qe = Ye[ot], Qe = Be(qe); typeof qe == "number" || typeof qe == "boolean" ? (We.__data[0] = qe, fe.bufferSubData(fe.UNIFORM_BUFFER, Xe + Ze, We.__data)) : qe.isMatrix3 ? (We.__data[0] = qe.elements[0], We.__data[1] = qe.elements[1], We.__data[2] = qe.elements[2], We.__data[3] = 0, We.__data[4] = qe.elements[3], We.__data[5] = qe.elements[4], We.__data[6] = qe.elements[5], We.__data[7] = 0, We.__data[8] = qe.elements[6], We.__data[9] = qe.elements[7], We.__data[10] = qe.elements[8], We.__data[11] = 0) : (qe.toArray(We.__data, Ze), Ze += Qe.storage / Float32Array.BYTES_PER_ELEMENT) } fe.bufferSubData(fe.UNIFORM_BUFFER, Xe, We.__data) } } } fe.bindBuffer(fe.UNIFORM_BUFFER, null) } function Ce(Ie, Pe, Ne, ke) { const Oe = Ie.value, Ue = Pe + "_" + Ne; if (ke[Ue] === void 0) return typeof Oe == "number" || typeof Oe == "boolean" ? ke[Ue] = Oe : ke[Ue] = Oe.clone(), !0; { const He = ke[Ue]; if (typeof Oe == "number" || typeof Oe == "boolean") { if (He !== Oe) return ke[Ue] = Oe, !0 } else if (He.equals(Oe) === !1) return He.copy(Oe), !0 } return !1 } function we(Ie) { const Pe = Ie.uniforms; let Ne = 0; const ke = 16; for (let Ue = 0, He = Pe.length; Ue < He; Ue++) { const Ge = Array.isArray(Pe[Ue]) ? Pe[Ue] : [Pe[Ue]]; for (let ze = 0, We = Ge.length; ze < We; ze++) { const Xe = Ge[ze], Ye = Array.isArray(Xe.value) ? Xe.value : [Xe.value]; for (let Ze = 0, ot = Ye.length; Ze < ot; Ze++) { const qe = Ye[Ze], Qe = Be(qe), st = Ne % ke, Nt = st % Qe.boundary, Je = st + Nt; Ne += Nt, Je !== 0 && ke - Je < Qe.storage && (Ne += ke - Je), Xe.__data = new Float32Array(Qe.storage / Float32Array.BYTES_PER_ELEMENT), Xe.__offset = Ne, Ne += Qe.storage } } } const Oe = Ne % ke; return Oe > 0 && (Ne += ke - Oe), Ie.__size = Ne, Ie.__cache = {}, this } function Be(Ie) { const Pe = { boundary: 0, storage: 0 }; return typeof Ie == "number" || typeof Ie == "boolean" ? (Pe.boundary = 4, Pe.storage = 4) : Ie.isVector2 ? (Pe.boundary = 8, Pe.storage = 8) : Ie.isVector3 || Ie.isColor ? (Pe.boundary = 16, Pe.storage = 12) : Ie.isVector4 ? (Pe.boundary = 16, Pe.storage = 16) : Ie.isMatrix3 ? (Pe.boundary = 48, Pe.storage = 48) : Ie.isMatrix4 ? (Pe.boundary = 64, Pe.storage = 64) : Ie.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Ie), Pe } function De(Ie) { const Pe = Ie.target; Pe.removeEventListener("dispose", De); const Ne = ye.indexOf(Pe.__bindingPointIndex); ye.splice(Ne, 1), fe.deleteBuffer(ge[Pe.id]), delete ge[Pe.id], delete xe[Pe.id] } function Re() { for (const Ie in ge) fe.deleteBuffer(ge[Ie]); ye = [], ge = {}, xe = {} } return { bind: _e, update: Ee, dispose: Re } } class WebGLRenderer { constructor(K = {}) { const { canvas: pe = createCanvasElement(), context: me = null, depth: ge = !0, stencil: xe = !1, alpha: ye = !1, antialias: ve = !1, premultipliedAlpha: _e = !0, preserveDrawingBuffer: Ee = !1, powerPreference: be = "default", failIfMajorPerformanceCaveat: Ae = !1, reverseDepthBuffer: Se = !1 } = K; this.isWebGLRenderer = !0; let Ce; if (me !== null) { if (typeof WebGLRenderingContext < "u" && me instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); Ce = me.getContextAttributes().alpha } else Ce = ye; const we = new Uint32Array(4), Be = new Int32Array(4); let De = null, Re = null; const Ie = [], Pe = []; this.domElement = pe, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = SRGBColorSpace, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1; const Ne = this; let ke = !1, Oe = 0, Ue = 0, He = null, Ge = -1, ze = null; const We = new Vector4, Xe = new Vector4; let Ye = null; const Ze = new Color$1(0); let ot = 0, qe = pe.width, Qe = pe.height, st = 1, Nt = null, Je = null; const jt = new Vector4(0, 0, qe, Qe), Xt = new Vector4(0, 0, qe, Qe); let ct = !1; const nn = new Frustum; let $t = !1, an = !1; this.transmissionResolutionScale = 1; const gn = new Matrix4, Mn = new Matrix4, Xn = new Vector3, Ln = new Vector4, Gn = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; let wn = !1; function Bn() { return He === null ? st : 1 } let Gt = me; function nr(ft, qt) { return pe.getContext(ft, qt) } try { const ft = { alpha: !0, depth: ge, stencil: xe, antialias: ve, premultipliedAlpha: _e, preserveDrawingBuffer: Ee, powerPreference: be, failIfMajorPerformanceCaveat: Ae }; if ("setAttribute" in pe && pe.setAttribute("data-engine", `three.js r${REVISION}`), pe.addEventListener("webglcontextlost", qn, !1), pe.addEventListener("webglcontextrestored", ar, !1), pe.addEventListener("webglcontextcreationerror", yr, !1), Gt === null) { const qt = "webgl2"; if (Gt = nr(qt, ft), Gt === null) throw nr(qt) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } } catch (ft) { throw console.error("THREE.WebGLRenderer: " + ft.message), ft } let Kn, vn, yn, Hn, kn, Ht, Dt, fn, en, cn, Wt, un, Ft, Sn, lr, jn, Pn, fr, Yn, sr, Ar, Er, Rr, mn; function Dn() { Kn = new WebGLExtensions(Gt), Kn.init(), Er = new WebGLUtils(Gt, Kn), vn = new WebGLCapabilities(Gt, Kn, K, Er), yn = new WebGLState(Gt, Kn), vn.reverseDepthBuffer && Se && yn.buffers.depth.setReversed(!0), Hn = new WebGLInfo(Gt), kn = new WebGLProperties, Ht = new WebGLTextures(Gt, Kn, yn, kn, vn, Er, Hn), Dt = new WebGLCubeMaps(Ne), fn = new WebGLCubeUVMaps(Ne), en = new WebGLAttributes(Gt), Rr = new WebGLBindingStates(Gt, en), cn = new WebGLGeometries(Gt, en, Hn, Rr), Wt = new WebGLObjects(Gt, cn, en, Hn), Yn = new WebGLMorphtargets(Gt, vn, Ht), jn = new WebGLClipping(kn), un = new WebGLPrograms(Ne, Dt, fn, Kn, vn, Rr, jn), Ft = new WebGLMaterials(Ne, kn), Sn = new WebGLRenderLists, lr = new WebGLRenderStates(Kn), fr = new WebGLBackground(Ne, Dt, fn, yn, Wt, Ce, _e), Pn = new WebGLShadowMap(Ne, Wt, vn), mn = new WebGLUniformsGroups(Gt, Hn, vn, yn), sr = new WebGLBufferRenderer(Gt, Kn, Hn), Ar = new WebGLIndexedBufferRenderer(Gt, Kn, Hn), Hn.programs = un.programs, Ne.capabilities = vn, Ne.extensions = Kn, Ne.properties = kn, Ne.renderLists = Sn, Ne.shadowMap = Pn, Ne.state = yn, Ne.info = Hn } Dn(); const Rn = new WebXRManager(Ne, Gt); this.xr = Rn, this.getContext = function () { return Gt }, this.getContextAttributes = function () { return Gt.getContextAttributes() }, this.forceContextLoss = function () { const ft = Kn.get("WEBGL_lose_context"); ft && ft.loseContext() }, this.forceContextRestore = function () { const ft = Kn.get("WEBGL_lose_context"); ft && ft.restoreContext() }, this.getPixelRatio = function () { return st }, this.setPixelRatio = function (ft) { ft !== void 0 && (st = ft, this.setSize(qe, Qe, !1)) }, this.getSize = function (ft) { return ft.set(qe, Qe) }, this.setSize = function (ft, qt, sn = !0) { if (Rn.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } qe = ft, Qe = qt, pe.width = Math.floor(ft * st), pe.height = Math.floor(qt * st), sn === !0 && (pe.style.width = ft + "px", pe.style.height = qt + "px"), this.setViewport(0, 0, ft, qt) }, this.getDrawingBufferSize = function (ft) { return ft.set(qe * st, Qe * st).floor() }, this.setDrawingBufferSize = function (ft, qt, sn) { qe = ft, Qe = qt, st = sn, pe.width = Math.floor(ft * sn), pe.height = Math.floor(qt * sn), this.setViewport(0, 0, ft, qt) }, this.getCurrentViewport = function (ft) { return ft.copy(We) }, this.getViewport = function (ft) { return ft.copy(jt) }, this.setViewport = function (ft, qt, sn, ln) { ft.isVector4 ? jt.set(ft.x, ft.y, ft.z, ft.w) : jt.set(ft, qt, sn, ln), yn.viewport(We.copy(jt).multiplyScalar(st).round()) }, this.getScissor = function (ft) { return ft.copy(Xt) }, this.setScissor = function (ft, qt, sn, ln) { ft.isVector4 ? Xt.set(ft.x, ft.y, ft.z, ft.w) : Xt.set(ft, qt, sn, ln), yn.scissor(Xe.copy(Xt).multiplyScalar(st).round()) }, this.getScissorTest = function () { return ct }, this.setScissorTest = function (ft) { yn.setScissorTest(ct = ft) }, this.setOpaqueSort = function (ft) { Nt = ft }, this.setTransparentSort = function (ft) { Je = ft }, this.getClearColor = function (ft) { return ft.copy(fr.getClearColor()) }, this.setClearColor = function () { fr.setClearColor(...arguments) }, this.getClearAlpha = function () { return fr.getClearAlpha() }, this.setClearAlpha = function () { fr.setClearAlpha(...arguments) }, this.clear = function (ft = !0, qt = !0, sn = !0) { let ln = 0; if (ft) { let pn = !1; if (He !== null) { const Tn = He.texture.format; pn = Tn === RGBAIntegerFormat || Tn === RGIntegerFormat || Tn === RedIntegerFormat } if (pn) { const Tn = He.texture.type, $n = Tn === UnsignedByteType || Tn === UnsignedIntType || Tn === UnsignedShortType || Tn === UnsignedInt248Type || Tn === UnsignedShort4444Type || Tn === UnsignedShort5551Type, Zn = fr.getClearColor(), rr = fr.getClearAlpha(), br = Zn.r, Un = Zn.g, _r = Zn.b; $n ? (we[0] = br, we[1] = Un, we[2] = _r, we[3] = rr, Gt.clearBufferuiv(Gt.COLOR, 0, we)) : (Be[0] = br, Be[1] = Un, Be[2] = _r, Be[3] = rr, Gt.clearBufferiv(Gt.COLOR, 0, Be)) } else ln |= Gt.COLOR_BUFFER_BIT } qt && (ln |= Gt.DEPTH_BUFFER_BIT), sn && (ln |= Gt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Gt.clear(ln) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { pe.removeEventListener("webglcontextlost", qn, !1), pe.removeEventListener("webglcontextrestored", ar, !1), pe.removeEventListener("webglcontextcreationerror", yr, !1), fr.dispose(), Sn.dispose(), lr.dispose(), kn.dispose(), Dt.dispose(), fn.dispose(), Wt.dispose(), Rr.dispose(), mn.dispose(), un.dispose(), Rn.dispose(), Rn.removeEventListener("sessionstart", es), Rn.removeEventListener("sessionend", Hi), Ai.stop() }; function qn(ft) { ft.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ke = !0 } function ar() { console.log("THREE.WebGLRenderer: Context Restored."), ke = !1; const ft = Hn.autoReset, qt = Pn.enabled, sn = Pn.autoUpdate, ln = Pn.needsUpdate, pn = Pn.type; Dn(), Hn.autoReset = ft, Pn.enabled = qt, Pn.autoUpdate = sn, Pn.needsUpdate = ln, Pn.type = pn } function yr(ft) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ft.statusMessage) } function dr(ft) { const qt = ft.target; qt.removeEventListener("dispose", dr), mi(qt) } function mi(ft) { bi(ft), kn.remove(ft) } function bi(ft) { const qt = kn.get(ft).programs; qt !== void 0 && (qt.forEach(function (sn) { un.releaseProgram(sn) }), ft.isShaderMaterial && un.releaseShaderCache(ft)) } this.renderBufferDirect = function (ft, qt, sn, ln, pn, Tn) { qt === null && (qt = Gn); const $n = pn.isMesh && pn.matrixWorld.determinant() < 0, Zn = dn(ft, qt, sn, ln, pn); yn.setMaterial(ln, $n); let rr = sn.index, br = 1; if (ln.wireframe === !0) { if (rr = cn.getWireframeAttribute(sn), rr === void 0) return; br = 2 } const Un = sn.drawRange, _r = sn.attributes.position; let Lr = Un.start * br, Br = (Un.start + Un.count) * br; Tn !== null && (Lr = Math.max(Lr, Tn.start * br), Br = Math.min(Br, (Tn.start + Tn.count) * br)), rr !== null ? (Lr = Math.max(Lr, 0), Br = Math.min(Br, rr.count)) : _r != null && (Lr = Math.max(Lr, 0), Br = Math.min(Br, _r.count)); const ni = Br - Lr; if (ni < 0 || ni === 1 / 0) return; Rr.setup(pn, ln, Zn, sn, rr); let wr, Fr = sr; if (rr !== null && (wr = en.get(rr), Fr = Ar, Fr.setIndex(wr)), pn.isMesh) ln.wireframe === !0 ? (yn.setLineWidth(ln.wireframeLinewidth * Bn()), Fr.setMode(Gt.LINES)) : Fr.setMode(Gt.TRIANGLES); else if (pn.isLine) { let Dr = ln.linewidth; Dr === void 0 && (Dr = 1), yn.setLineWidth(Dr * Bn()), pn.isLineSegments ? Fr.setMode(Gt.LINES) : pn.isLineLoop ? Fr.setMode(Gt.LINE_LOOP) : Fr.setMode(Gt.LINE_STRIP) } else pn.isPoints ? Fr.setMode(Gt.POINTS) : pn.isSprite && Fr.setMode(Gt.TRIANGLES); if (pn.isBatchedMesh) if (pn._multiDrawInstances !== null) warnOnce("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Fr.renderMultiDrawInstances(pn._multiDrawStarts, pn._multiDrawCounts, pn._multiDrawCount, pn._multiDrawInstances); else if (Kn.get("WEBGL_multi_draw")) Fr.renderMultiDraw(pn._multiDrawStarts, pn._multiDrawCounts, pn._multiDrawCount); else { const Dr = pn._multiDrawStarts, li = pn._multiDrawCounts, Gr = pn._multiDrawCount, Wr = rr ? en.get(rr).bytesPerElement : 1, ii = kn.get(ln).currentProgram.getUniforms(); for (let kr = 0; kr < Gr; kr++)ii.setValue(Gt, "_gl_DrawID", kr), Fr.render(Dr[kr] / Wr, li[kr]) } else if (pn.isInstancedMesh) Fr.renderInstances(Lr, ni, pn.count); else if (sn.isInstancedBufferGeometry) { const Dr = sn._maxInstanceCount !== void 0 ? sn._maxInstanceCount : 1 / 0, li = Math.min(sn.instanceCount, Dr); Fr.renderInstances(Lr, ni, li) } else Fr.render(Lr, ni) }; function ti(ft, qt, sn) { ft.transparent === !0 && ft.side === DoubleSide && ft.forceSinglePass === !1 ? (ft.side = BackSide, ft.needsUpdate = !0, xi(ft, qt, sn), ft.side = FrontSide, ft.needsUpdate = !0, xi(ft, qt, sn), ft.side = DoubleSide) : xi(ft, qt, sn) } this.compile = function (ft, qt, sn = null) { sn === null && (sn = ft), Re = lr.get(sn), Re.init(qt), Pe.push(Re), sn.traverseVisible(function (pn) { pn.isLight && pn.layers.test(qt.layers) && (Re.pushLight(pn), pn.castShadow && Re.pushShadow(pn)) }), ft !== sn && ft.traverseVisible(function (pn) { pn.isLight && pn.layers.test(qt.layers) && (Re.pushLight(pn), pn.castShadow && Re.pushShadow(pn)) }), Re.setupLights(); const ln = new Set; return ft.traverse(function (pn) { if (!(pn.isMesh || pn.isPoints || pn.isLine || pn.isSprite)) return; const Tn = pn.material; if (Tn) if (Array.isArray(Tn)) for (let $n = 0; $n < Tn.length; $n++) { const Zn = Tn[$n]; ti(Zn, sn, pn), ln.add(Zn) } else ti(Tn, sn, pn), ln.add(Tn) }), Re = Pe.pop(), ln }, this.compileAsync = function (ft, qt, sn = null) { const ln = this.compile(ft, qt, sn); return new Promise(pn => { function Tn() { if (ln.forEach(function ($n) { kn.get($n).currentProgram.isReady() && ln.delete($n) }), ln.size === 0) { pn(ft); return } setTimeout(Tn, 10) } Kn.get("KHR_parallel_shader_compile") !== null ? Tn() : setTimeout(Tn, 10) }) }; let Si = null; function ri(ft) { Si && Si(ft) } function es() { Ai.stop() } function Hi() { Ai.start() } const Ai = new WebGLAnimation; Ai.setAnimationLoop(ri), typeof self < "u" && Ai.setContext(self), this.setAnimationLoop = function (ft) { Si = ft, Rn.setAnimationLoop(ft), ft === null ? Ai.stop() : Ai.start() }, Rn.addEventListener("sessionstart", es), Rn.addEventListener("sessionend", Hi), this.render = function (ft, qt) { if (qt !== void 0 && qt.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (ke === !0) return; if (ft.matrixWorldAutoUpdate === !0 && ft.updateMatrixWorld(), qt.parent === null && qt.matrixWorldAutoUpdate === !0 && qt.updateMatrixWorld(), Rn.enabled === !0 && Rn.isPresenting === !0 && (Rn.cameraAutoUpdate === !0 && Rn.updateCamera(qt), qt = Rn.getCamera()), ft.isScene === !0 && ft.onBeforeRender(Ne, ft, qt, He), Re = lr.get(ft, Pe.length), Re.init(qt), Pe.push(Re), Mn.multiplyMatrices(qt.projectionMatrix, qt.matrixWorldInverse), nn.setFromProjectionMatrix(Mn), an = this.localClippingEnabled, $t = jn.init(this.clippingPlanes, an), De = Sn.get(ft, Ie.length), De.init(), Ie.push(De), Rn.enabled === !0 && Rn.isPresenting === !0) { const Tn = Ne.xr.getDepthSensingMesh(); Tn !== null && gi(Tn, qt, -1 / 0, Ne.sortObjects) } gi(ft, qt, 0, Ne.sortObjects), De.finish(), Ne.sortObjects === !0 && De.sort(Nt, Je), wn = Rn.enabled === !1 || Rn.isPresenting === !1 || Rn.hasDepthSensing() === !1, wn && fr.addToRenderList(De, ft), this.info.render.frame++, $t === !0 && jn.beginShadows(); const sn = Re.state.shadowsArray; Pn.render(sn, ft, qt), $t === !0 && jn.endShadows(), this.info.autoReset === !0 && this.info.reset(); const ln = De.opaque, pn = De.transmissive; if (Re.setupLights(), qt.isArrayCamera) { const Tn = qt.cameras; if (pn.length > 0) for (let $n = 0, Zn = Tn.length; $n < Zn; $n++) { const rr = Tn[$n]; Ii(ln, pn, ft, rr) } wn && fr.render(ft); for (let $n = 0, Zn = Tn.length; $n < Zn; $n++) { const rr = Tn[$n]; ts(De, ft, rr, rr.viewport) } } else pn.length > 0 && Ii(ln, pn, ft, qt), wn && fr.render(ft), ts(De, ft, qt); He !== null && Ue === 0 && (Ht.updateMultisampleRenderTarget(He), Ht.updateRenderTargetMipmap(He)), ft.isScene === !0 && ft.onAfterRender(Ne, ft, qt), Rr.resetDefaultState(), Ge = -1, ze = null, Pe.pop(), Pe.length > 0 ? (Re = Pe[Pe.length - 1], $t === !0 && jn.setGlobalState(Ne.clippingPlanes, Re.state.camera)) : Re = null, Ie.pop(), Ie.length > 0 ? De = Ie[Ie.length - 1] : De = null }; function gi(ft, qt, sn, ln) { if (ft.visible === !1) return; if (ft.layers.test(qt.layers)) { if (ft.isGroup) sn = ft.renderOrder; else if (ft.isLOD) ft.autoUpdate === !0 && ft.update(qt); else if (ft.isLight) Re.pushLight(ft), ft.castShadow && Re.pushShadow(ft); else if (ft.isSprite) { if (!ft.frustumCulled || nn.intersectsSprite(ft)) { ln && Ln.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Mn); const $n = Wt.update(ft), Zn = ft.material; Zn.visible && De.push(ft, $n, Zn, sn, Ln.z, null) } } else if ((ft.isMesh || ft.isLine || ft.isPoints) && (!ft.frustumCulled || nn.intersectsObject(ft))) { const $n = Wt.update(ft), Zn = ft.material; if (ln && (ft.boundingSphere !== void 0 ? (ft.boundingSphere === null && ft.computeBoundingSphere(), Ln.copy(ft.boundingSphere.center)) : ($n.boundingSphere === null && $n.computeBoundingSphere(), Ln.copy($n.boundingSphere.center)), Ln.applyMatrix4(ft.matrixWorld).applyMatrix4(Mn)), Array.isArray(Zn)) { const rr = $n.groups; for (let br = 0, Un = rr.length; br < Un; br++) { const _r = rr[br], Lr = Zn[_r.materialIndex]; Lr && Lr.visible && De.push(ft, $n, Lr, sn, Ln.z, _r) } } else Zn.visible && De.push(ft, $n, Zn, sn, Ln.z, null) } } const Tn = ft.children; for (let $n = 0, Zn = Tn.length; $n < Zn; $n++)gi(Tn[$n], qt, sn, ln) } function ts(ft, qt, sn, ln) { const pn = ft.opaque, Tn = ft.transmissive, $n = ft.transparent; Re.setupLightsView(sn), $t === !0 && jn.setGlobalState(Ne.clippingPlanes, sn), ln && yn.viewport(We.copy(ln)), pn.length > 0 && Nr(pn, qt, sn), Tn.length > 0 && Nr(Tn, qt, sn), $n.length > 0 && Nr($n, qt, sn), yn.buffers.depth.setTest(!0), yn.buffers.depth.setMask(!0), yn.buffers.color.setMask(!0), yn.setPolygonOffset(!1) } function Ii(ft, qt, sn, ln) { if ((sn.isScene === !0 ? sn.overrideMaterial : null) !== null) return; Re.state.transmissionRenderTarget[ln.id] === void 0 && (Re.state.transmissionRenderTarget[ln.id] = new WebGLRenderTarget(1, 1, { generateMipmaps: !0, type: Kn.has("EXT_color_buffer_half_float") || Kn.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType, minFilter: LinearMipmapLinearFilter, samples: 4, stencilBuffer: xe, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: ColorManagement.workingColorSpace })); const Tn = Re.state.transmissionRenderTarget[ln.id], $n = ln.viewport || We; Tn.setSize($n.z * Ne.transmissionResolutionScale, $n.w * Ne.transmissionResolutionScale); const Zn = Ne.getRenderTarget(); Ne.setRenderTarget(Tn), Ne.getClearColor(Ze), ot = Ne.getClearAlpha(), ot < 1 && Ne.setClearColor(16777215, .5), Ne.clear(), wn && fr.render(sn); const rr = Ne.toneMapping; Ne.toneMapping = NoToneMapping; const br = ln.viewport; if (ln.viewport !== void 0 && (ln.viewport = void 0), Re.setupLightsView(ln), $t === !0 && jn.setGlobalState(Ne.clippingPlanes, ln), Nr(ft, sn, ln), Ht.updateMultisampleRenderTarget(Tn), Ht.updateRenderTargetMipmap(Tn), Kn.has("WEBGL_multisampled_render_to_texture") === !1) { let Un = !1; for (let _r = 0, Lr = qt.length; _r < Lr; _r++) { const Br = qt[_r], ni = Br.object, wr = Br.geometry, Fr = Br.material, Dr = Br.group; if (Fr.side === DoubleSide && ni.layers.test(ln.layers)) { const li = Fr.side; Fr.side = BackSide, Fr.needsUpdate = !0, hs(ni, sn, ln, wr, Fr, Dr), Fr.side = li, Fr.needsUpdate = !0, Un = !0 } } Un === !0 && (Ht.updateMultisampleRenderTarget(Tn), Ht.updateRenderTargetMipmap(Tn)) } Ne.setRenderTarget(Zn), Ne.setClearColor(Ze, ot), br !== void 0 && (ln.viewport = br), Ne.toneMapping = rr } function Nr(ft, qt, sn) { const ln = qt.isScene === !0 ? qt.overrideMaterial : null; for (let pn = 0, Tn = ft.length; pn < Tn; pn++) { const $n = ft[pn], Zn = $n.object, rr = $n.geometry, br = ln === null ? $n.material : ln, Un = $n.group; Zn.layers.test(sn.layers) && hs(Zn, qt, sn, rr, br, Un) } } function hs(ft, qt, sn, ln, pn, Tn) { ft.onBeforeRender(Ne, qt, sn, ln, pn, Tn), ft.modelViewMatrix.multiplyMatrices(sn.matrixWorldInverse, ft.matrixWorld), ft.normalMatrix.getNormalMatrix(ft.modelViewMatrix), pn.onBeforeRender(Ne, qt, sn, ln, ft, Tn), pn.transparent === !0 && pn.side === DoubleSide && pn.forceSinglePass === !1 ? (pn.side = BackSide, pn.needsUpdate = !0, Ne.renderBufferDirect(sn, qt, ln, pn, ft, Tn), pn.side = FrontSide, pn.needsUpdate = !0, Ne.renderBufferDirect(sn, qt, ln, pn, ft, Tn), pn.side = DoubleSide) : Ne.renderBufferDirect(sn, qt, ln, pn, ft, Tn), ft.onAfterRender(Ne, qt, sn, ln, pn, Tn) } function xi(ft, qt, sn) { qt.isScene !== !0 && (qt = Gn); const ln = kn.get(ft), pn = Re.state.lights, Tn = Re.state.shadowsArray, $n = pn.state.version, Zn = un.getParameters(ft, pn.state, Tn, qt, sn), rr = un.getProgramCacheKey(Zn); let br = ln.programs; ln.environment = ft.isMeshStandardMaterial ? qt.environment : null, ln.fog = qt.fog, ln.envMap = (ft.isMeshStandardMaterial ? fn : Dt).get(ft.envMap || ln.environment), ln.envMapRotation = ln.environment !== null && ft.envMap === null ? qt.environmentRotation : ft.envMapRotation, br === void 0 && (ft.addEventListener("dispose", dr), br = new Map, ln.programs = br); let Un = br.get(rr); if (Un !== void 0) { if (ln.currentProgram === Un && ln.lightsStateVersion === $n) return Vt(ft, Zn), Un } else Zn.uniforms = un.getUniforms(ft), ft.onBeforeCompile(Zn, Ne), Un = un.acquireProgram(Zn, rr), br.set(rr, Un), ln.uniforms = Zn.uniforms; const _r = ln.uniforms; return (!ft.isShaderMaterial && !ft.isRawShaderMaterial || ft.clipping === !0) && (_r.clippingPlanes = jn.uniform), Vt(ft, Zn), ln.needsLights = Vn(ft), ln.lightsStateVersion = $n, ln.needsLights && (_r.ambientLightColor.value = pn.state.ambient, _r.lightProbe.value = pn.state.probe, _r.directionalLights.value = pn.state.directional, _r.directionalLightShadows.value = pn.state.directionalShadow, _r.spotLights.value = pn.state.spot, _r.spotLightShadows.value = pn.state.spotShadow, _r.rectAreaLights.value = pn.state.rectArea, _r.ltc_1.value = pn.state.rectAreaLTC1, _r.ltc_2.value = pn.state.rectAreaLTC2, _r.pointLights.value = pn.state.point, _r.pointLightShadows.value = pn.state.pointShadow, _r.hemisphereLights.value = pn.state.hemi, _r.directionalShadowMap.value = pn.state.directionalShadowMap, _r.directionalShadowMatrix.value = pn.state.directionalShadowMatrix, _r.spotShadowMap.value = pn.state.spotShadowMap, _r.spotLightMatrix.value = pn.state.spotLightMatrix, _r.spotLightMap.value = pn.state.spotLightMap, _r.pointShadowMap.value = pn.state.pointShadowMap, _r.pointShadowMatrix.value = pn.state.pointShadowMatrix), ln.currentProgram = Un, ln.uniformsList = null, Un } function Rt(ft) { if (ft.uniformsList === null) { const qt = ft.currentProgram.getUniforms(); ft.uniformsList = WebGLUniforms.seqWithValue(qt.seq, ft.uniforms) } return ft.uniformsList } function Vt(ft, qt) { const sn = kn.get(ft); sn.outputColorSpace = qt.outputColorSpace, sn.batching = qt.batching, sn.batchingColor = qt.batchingColor, sn.instancing = qt.instancing, sn.instancingColor = qt.instancingColor, sn.instancingMorph = qt.instancingMorph, sn.skinning = qt.skinning, sn.morphTargets = qt.morphTargets, sn.morphNormals = qt.morphNormals, sn.morphColors = qt.morphColors, sn.morphTargetsCount = qt.morphTargetsCount, sn.numClippingPlanes = qt.numClippingPlanes, sn.numIntersection = qt.numClipIntersection, sn.vertexAlphas = qt.vertexAlphas, sn.vertexTangents = qt.vertexTangents, sn.toneMapping = qt.toneMapping } function dn(ft, qt, sn, ln, pn) { qt.isScene !== !0 && (qt = Gn), Ht.resetTextureUnits(); const Tn = qt.fog, $n = ln.isMeshStandardMaterial ? qt.environment : null, Zn = He === null ? Ne.outputColorSpace : He.isXRRenderTarget === !0 ? He.texture.colorSpace : LinearSRGBColorSpace, rr = (ln.isMeshStandardMaterial ? fn : Dt).get(ln.envMap || $n), br = ln.vertexColors === !0 && !!sn.attributes.color && sn.attributes.color.itemSize === 4, Un = !!sn.attributes.tangent && (!!ln.normalMap || ln.anisotropy > 0), _r = !!sn.morphAttributes.position, Lr = !!sn.morphAttributes.normal, Br = !!sn.morphAttributes.color; let ni = NoToneMapping; ln.toneMapped && (He === null || He.isXRRenderTarget === !0) && (ni = Ne.toneMapping); const wr = sn.morphAttributes.position || sn.morphAttributes.normal || sn.morphAttributes.color, Fr = wr !== void 0 ? wr.length : 0, Dr = kn.get(ln), li = Re.state.lights; if ($t === !0 && (an === !0 || ft !== ze)) { const yi = ft === ze && ln.id === Ge; jn.setState(ln, ft, yi) } let Gr = !1; ln.version === Dr.__version ? (Dr.needsLights && Dr.lightsStateVersion !== li.state.version || Dr.outputColorSpace !== Zn || pn.isBatchedMesh && Dr.batching === !1 || !pn.isBatchedMesh && Dr.batching === !0 || pn.isBatchedMesh && Dr.batchingColor === !0 && pn.colorTexture === null || pn.isBatchedMesh && Dr.batchingColor === !1 && pn.colorTexture !== null || pn.isInstancedMesh && Dr.instancing === !1 || !pn.isInstancedMesh && Dr.instancing === !0 || pn.isSkinnedMesh && Dr.skinning === !1 || !pn.isSkinnedMesh && Dr.skinning === !0 || pn.isInstancedMesh && Dr.instancingColor === !0 && pn.instanceColor === null || pn.isInstancedMesh && Dr.instancingColor === !1 && pn.instanceColor !== null || pn.isInstancedMesh && Dr.instancingMorph === !0 && pn.morphTexture === null || pn.isInstancedMesh && Dr.instancingMorph === !1 && pn.morphTexture !== null || Dr.envMap !== rr || ln.fog === !0 && Dr.fog !== Tn || Dr.numClippingPlanes !== void 0 && (Dr.numClippingPlanes !== jn.numPlanes || Dr.numIntersection !== jn.numIntersection) || Dr.vertexAlphas !== br || Dr.vertexTangents !== Un || Dr.morphTargets !== _r || Dr.morphNormals !== Lr || Dr.morphColors !== Br || Dr.toneMapping !== ni || Dr.morphTargetsCount !== Fr) && (Gr = !0) : (Gr = !0, Dr.__version = ln.version); let Wr = Dr.currentProgram; Gr === !0 && (Wr = xi(ln, qt, pn)); let ii = !1, kr = !1, Zr = !1; const Xr = Wr.getUniforms(), Ri = Dr.uniforms; if (yn.useProgram(Wr.program) && (ii = !0, kr = !0, Zr = !0), ln.id !== Ge && (Ge = ln.id, kr = !0), ii || ze !== ft) { yn.buffers.depth.getReversed() ? (gn.copy(ft.projectionMatrix), toNormalizedProjectionMatrix(gn), toReversedProjectionMatrix(gn), Xr.setValue(Gt, "projectionMatrix", gn)) : Xr.setValue(Gt, "projectionMatrix", ft.projectionMatrix), Xr.setValue(Gt, "viewMatrix", ft.matrixWorldInverse); const Vi = Xr.map.cameraPosition; Vi !== void 0 && Vi.setValue(Gt, Xn.setFromMatrixPosition(ft.matrixWorld)), vn.logarithmicDepthBuffer && Xr.setValue(Gt, "logDepthBufFC", 2 / (Math.log(ft.far + 1) / Math.LN2)), (ln.isMeshPhongMaterial || ln.isMeshToonMaterial || ln.isMeshLambertMaterial || ln.isMeshBasicMaterial || ln.isMeshStandardMaterial || ln.isShaderMaterial) && Xr.setValue(Gt, "isOrthographic", ft.isOrthographicCamera === !0), ze !== ft && (ze = ft, kr = !0, Zr = !0) } if (pn.isSkinnedMesh) { Xr.setOptional(Gt, pn, "bindMatrix"), Xr.setOptional(Gt, pn, "bindMatrixInverse"); const yi = pn.skeleton; yi && (yi.boneTexture === null && yi.computeBoneTexture(), Xr.setValue(Gt, "boneTexture", yi.boneTexture, Ht)) } pn.isBatchedMesh && (Xr.setOptional(Gt, pn, "batchingTexture"), Xr.setValue(Gt, "batchingTexture", pn._matricesTexture, Ht), Xr.setOptional(Gt, pn, "batchingIdTexture"), Xr.setValue(Gt, "batchingIdTexture", pn._indirectTexture, Ht), Xr.setOptional(Gt, pn, "batchingColorTexture"), pn._colorsTexture !== null && Xr.setValue(Gt, "batchingColorTexture", pn._colorsTexture, Ht)); const di = sn.morphAttributes; if ((di.position !== void 0 || di.normal !== void 0 || di.color !== void 0) && Yn.update(pn, sn, Wr), (kr || Dr.receiveShadow !== pn.receiveShadow) && (Dr.receiveShadow = pn.receiveShadow, Xr.setValue(Gt, "receiveShadow", pn.receiveShadow)), ln.isMeshGouraudMaterial && ln.envMap !== null && (Ri.envMap.value = rr, Ri.flipEnvMap.value = rr.isCubeTexture && rr.isRenderTargetTexture === !1 ? -1 : 1), ln.isMeshStandardMaterial && ln.envMap === null && qt.environment !== null && (Ri.envMapIntensity.value = qt.environmentIntensity), kr && (Xr.setValue(Gt, "toneMappingExposure", Ne.toneMappingExposure), Dr.needsLights && In(Ri, Zr), Tn && ln.fog === !0 && Ft.refreshFogUniforms(Ri, Tn), Ft.refreshMaterialUniforms(Ri, ln, st, Qe, Re.state.transmissionRenderTarget[ft.id]), WebGLUniforms.upload(Gt, Rt(Dr), Ri, Ht)), ln.isShaderMaterial && ln.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(Gt, Rt(Dr), Ri, Ht), ln.uniformsNeedUpdate = !1), ln.isSpriteMaterial && Xr.setValue(Gt, "center", pn.center), Xr.setValue(Gt, "modelViewMatrix", pn.modelViewMatrix), Xr.setValue(Gt, "normalMatrix", pn.normalMatrix), Xr.setValue(Gt, "modelMatrix", pn.matrixWorld), ln.isShaderMaterial || ln.isRawShaderMaterial) { const yi = ln.uniformsGroups; for (let Vi = 0, Ji = yi.length; Vi < Ji; Vi++) { const vs = yi[Vi]; mn.update(vs, Wr), mn.bind(vs, Wr) } } return Wr } function In(ft, qt) { ft.ambientLightColor.needsUpdate = qt, ft.lightProbe.needsUpdate = qt, ft.directionalLights.needsUpdate = qt, ft.directionalLightShadows.needsUpdate = qt, ft.pointLights.needsUpdate = qt, ft.pointLightShadows.needsUpdate = qt, ft.spotLights.needsUpdate = qt, ft.spotLightShadows.needsUpdate = qt, ft.rectAreaLights.needsUpdate = qt, ft.hemisphereLights.needsUpdate = qt } function Vn(ft) { return ft.isMeshLambertMaterial || ft.isMeshToonMaterial || ft.isMeshPhongMaterial || ft.isMeshStandardMaterial || ft.isShadowMaterial || ft.isShaderMaterial && ft.lights === !0 } this.getActiveCubeFace = function () { return Oe }, this.getActiveMipmapLevel = function () { return Ue }, this.getRenderTarget = function () { return He }, this.setRenderTargetTextures = function (ft, qt, sn) { kn.get(ft.texture).__webglTexture = qt, kn.get(ft.depthTexture).__webglTexture = sn; const ln = kn.get(ft); ln.__hasExternalTextures = !0, ln.__autoAllocateDepthBuffer = sn === void 0, ln.__autoAllocateDepthBuffer || Kn.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ln.__useRenderToTexture = !1) }, this.setRenderTargetFramebuffer = function (ft, qt) { const sn = kn.get(ft); sn.__webglFramebuffer = qt, sn.__useDefaultFramebuffer = qt === void 0 }; const Nn = Gt.createFramebuffer(); this.setRenderTarget = function (ft, qt = 0, sn = 0) { He = ft, Oe = qt, Ue = sn; let ln = !0, pn = null, Tn = !1, $n = !1; if (ft) { const rr = kn.get(ft); if (rr.__useDefaultFramebuffer !== void 0) yn.bindFramebuffer(Gt.FRAMEBUFFER, null), ln = !1; else if (rr.__webglFramebuffer === void 0) Ht.setupRenderTarget(ft); else if (rr.__hasExternalTextures) Ht.rebindTextures(ft, kn.get(ft.texture).__webglTexture, kn.get(ft.depthTexture).__webglTexture); else if (ft.depthBuffer) { const _r = ft.depthTexture; if (rr.__boundDepthTexture !== _r) { if (_r !== null && kn.has(_r) && (ft.width !== _r.image.width || ft.height !== _r.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); Ht.setupDepthRenderbuffer(ft) } } const br = ft.texture; (br.isData3DTexture || br.isDataArrayTexture || br.isCompressedArrayTexture) && ($n = !0); const Un = kn.get(ft).__webglFramebuffer; ft.isWebGLCubeRenderTarget ? (Array.isArray(Un[qt]) ? pn = Un[qt][sn] : pn = Un[qt], Tn = !0) : ft.samples > 0 && Ht.useMultisampledRTT(ft) === !1 ? pn = kn.get(ft).__webglMultisampledFramebuffer : Array.isArray(Un) ? pn = Un[sn] : pn = Un, We.copy(ft.viewport), Xe.copy(ft.scissor), Ye = ft.scissorTest } else We.copy(jt).multiplyScalar(st).floor(), Xe.copy(Xt).multiplyScalar(st).floor(), Ye = ct; if (sn !== 0 && (pn = Nn), yn.bindFramebuffer(Gt.FRAMEBUFFER, pn) && ln && yn.drawBuffers(ft, pn), yn.viewport(We), yn.scissor(Xe), yn.setScissorTest(Ye), Tn) { const rr = kn.get(ft.texture); Gt.framebufferTexture2D(Gt.FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, Gt.TEXTURE_CUBE_MAP_POSITIVE_X + qt, rr.__webglTexture, sn) } else if ($n) { const rr = kn.get(ft.texture), br = qt; Gt.framebufferTextureLayer(Gt.FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, rr.__webglTexture, sn, br) } else if (ft !== null && sn !== 0) { const rr = kn.get(ft.texture); Gt.framebufferTexture2D(Gt.FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, Gt.TEXTURE_2D, rr.__webglTexture, sn) } Ge = -1 }, this.readRenderTargetPixels = function (ft, qt, sn, ln, pn, Tn, $n) { if (!(ft && ft.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let Zn = kn.get(ft).__webglFramebuffer; if (ft.isWebGLCubeRenderTarget && $n !== void 0 && (Zn = Zn[$n]), Zn) { yn.bindFramebuffer(Gt.FRAMEBUFFER, Zn); try { const rr = ft.texture, br = rr.format, Un = rr.type; if (!vn.textureFormatReadable(br)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } if (!vn.textureTypeReadable(Un)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } qt >= 0 && qt <= ft.width - ln && sn >= 0 && sn <= ft.height - pn && Gt.readPixels(qt, sn, ln, pn, Er.convert(br), Er.convert(Un), Tn) } finally { const rr = He !== null ? kn.get(He).__webglFramebuffer : null; yn.bindFramebuffer(Gt.FRAMEBUFFER, rr) } } }, this.readRenderTargetPixelsAsync = async function (ft, qt, sn, ln, pn, Tn, $n) { if (!(ft && ft.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let Zn = kn.get(ft).__webglFramebuffer; if (ft.isWebGLCubeRenderTarget && $n !== void 0 && (Zn = Zn[$n]), Zn) { const rr = ft.texture, br = rr.format, Un = rr.type; if (!vn.textureFormatReadable(br)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!vn.textureTypeReadable(Un)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); if (qt >= 0 && qt <= ft.width - ln && sn >= 0 && sn <= ft.height - pn) { yn.bindFramebuffer(Gt.FRAMEBUFFER, Zn); const _r = Gt.createBuffer(); Gt.bindBuffer(Gt.PIXEL_PACK_BUFFER, _r), Gt.bufferData(Gt.PIXEL_PACK_BUFFER, Tn.byteLength, Gt.STREAM_READ), Gt.readPixels(qt, sn, ln, pn, Er.convert(br), Er.convert(Un), 0); const Lr = He !== null ? kn.get(He).__webglFramebuffer : null; yn.bindFramebuffer(Gt.FRAMEBUFFER, Lr); const Br = Gt.fenceSync(Gt.SYNC_GPU_COMMANDS_COMPLETE, 0); return Gt.flush(), await probeAsync(Gt, Br, 4), Gt.bindBuffer(Gt.PIXEL_PACK_BUFFER, _r), Gt.getBufferSubData(Gt.PIXEL_PACK_BUFFER, 0, Tn), Gt.deleteBuffer(_r), Gt.deleteSync(Br), Tn } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") } }, this.copyFramebufferToTexture = function (ft, qt = null, sn = 0) { ft.isTexture !== !0 && (warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed."), qt = arguments[0] || null, ft = arguments[1]); const ln = Math.pow(2, -sn), pn = Math.floor(ft.image.width * ln), Tn = Math.floor(ft.image.height * ln), $n = qt !== null ? qt.x : 0, Zn = qt !== null ? qt.y : 0; Ht.setTexture2D(ft, 0), Gt.copyTexSubImage2D(Gt.TEXTURE_2D, sn, 0, 0, $n, Zn, pn, Tn), yn.unbindTexture() }; const ir = Gt.createFramebuffer(), Jn = Gt.createFramebuffer(); this.copyTextureToTexture = function (ft, qt, sn = null, ln = null, pn = 0, Tn = null) { ft.isTexture !== !0 && (warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed."), ln = arguments[0] || null, ft = arguments[1], qt = arguments[2], Tn = arguments[3] || 0, sn = null), Tn === null && (pn !== 0 ? (warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), Tn = pn, pn = 0) : Tn = 0); let $n, Zn, rr, br, Un, _r, Lr, Br, ni; const wr = ft.isCompressedTexture ? ft.mipmaps[Tn] : ft.image; if (sn !== null) $n = sn.max.x - sn.min.x, Zn = sn.max.y - sn.min.y, rr = sn.isBox3 ? sn.max.z - sn.min.z : 1, br = sn.min.x, Un = sn.min.y, _r = sn.isBox3 ? sn.min.z : 0; else { const di = Math.pow(2, -pn); $n = Math.floor(wr.width * di), Zn = Math.floor(wr.height * di), ft.isDataArrayTexture ? rr = wr.depth : ft.isData3DTexture ? rr = Math.floor(wr.depth * di) : rr = 1, br = 0, Un = 0, _r = 0 } ln !== null ? (Lr = ln.x, Br = ln.y, ni = ln.z) : (Lr = 0, Br = 0, ni = 0); const Fr = Er.convert(qt.format), Dr = Er.convert(qt.type); let li; qt.isData3DTexture ? (Ht.setTexture3D(qt, 0), li = Gt.TEXTURE_3D) : qt.isDataArrayTexture || qt.isCompressedArrayTexture ? (Ht.setTexture2DArray(qt, 0), li = Gt.TEXTURE_2D_ARRAY) : (Ht.setTexture2D(qt, 0), li = Gt.TEXTURE_2D), Gt.pixelStorei(Gt.UNPACK_FLIP_Y_WEBGL, qt.flipY), Gt.pixelStorei(Gt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, qt.premultiplyAlpha), Gt.pixelStorei(Gt.UNPACK_ALIGNMENT, qt.unpackAlignment); const Gr = Gt.getParameter(Gt.UNPACK_ROW_LENGTH), Wr = Gt.getParameter(Gt.UNPACK_IMAGE_HEIGHT), ii = Gt.getParameter(Gt.UNPACK_SKIP_PIXELS), kr = Gt.getParameter(Gt.UNPACK_SKIP_ROWS), Zr = Gt.getParameter(Gt.UNPACK_SKIP_IMAGES); Gt.pixelStorei(Gt.UNPACK_ROW_LENGTH, wr.width), Gt.pixelStorei(Gt.UNPACK_IMAGE_HEIGHT, wr.height), Gt.pixelStorei(Gt.UNPACK_SKIP_PIXELS, br), Gt.pixelStorei(Gt.UNPACK_SKIP_ROWS, Un), Gt.pixelStorei(Gt.UNPACK_SKIP_IMAGES, _r); const Xr = ft.isDataArrayTexture || ft.isData3DTexture, Ri = qt.isDataArrayTexture || qt.isData3DTexture; if (ft.isDepthTexture) { const di = kn.get(ft), yi = kn.get(qt), Vi = kn.get(di.__renderTarget), Ji = kn.get(yi.__renderTarget); yn.bindFramebuffer(Gt.READ_FRAMEBUFFER, Vi.__webglFramebuffer), yn.bindFramebuffer(Gt.DRAW_FRAMEBUFFER, Ji.__webglFramebuffer); for (let vs = 0; vs < rr; vs++)Xr && (Gt.framebufferTextureLayer(Gt.READ_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, kn.get(ft).__webglTexture, pn, _r + vs), Gt.framebufferTextureLayer(Gt.DRAW_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, kn.get(qt).__webglTexture, Tn, ni + vs)), Gt.blitFramebuffer(br, Un, $n, Zn, Lr, Br, $n, Zn, Gt.DEPTH_BUFFER_BIT, Gt.NEAREST); yn.bindFramebuffer(Gt.READ_FRAMEBUFFER, null), yn.bindFramebuffer(Gt.DRAW_FRAMEBUFFER, null) } else if (pn !== 0 || ft.isRenderTargetTexture || kn.has(ft)) { const di = kn.get(ft), yi = kn.get(qt); yn.bindFramebuffer(Gt.READ_FRAMEBUFFER, ir), yn.bindFramebuffer(Gt.DRAW_FRAMEBUFFER, Jn); for (let Vi = 0; Vi < rr; Vi++)Xr ? Gt.framebufferTextureLayer(Gt.READ_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, di.__webglTexture, pn, _r + Vi) : Gt.framebufferTexture2D(Gt.READ_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, Gt.TEXTURE_2D, di.__webglTexture, pn), Ri ? Gt.framebufferTextureLayer(Gt.DRAW_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, yi.__webglTexture, Tn, ni + Vi) : Gt.framebufferTexture2D(Gt.DRAW_FRAMEBUFFER, Gt.COLOR_ATTACHMENT0, Gt.TEXTURE_2D, yi.__webglTexture, Tn), pn !== 0 ? Gt.blitFramebuffer(br, Un, $n, Zn, Lr, Br, $n, Zn, Gt.COLOR_BUFFER_BIT, Gt.NEAREST) : Ri ? Gt.copyTexSubImage3D(li, Tn, Lr, Br, ni + Vi, br, Un, $n, Zn) : Gt.copyTexSubImage2D(li, Tn, Lr, Br, br, Un, $n, Zn); yn.bindFramebuffer(Gt.READ_FRAMEBUFFER, null), yn.bindFramebuffer(Gt.DRAW_FRAMEBUFFER, null) } else Ri ? ft.isDataTexture || ft.isData3DTexture ? Gt.texSubImage3D(li, Tn, Lr, Br, ni, $n, Zn, rr, Fr, Dr, wr.data) : qt.isCompressedArrayTexture ? Gt.compressedTexSubImage3D(li, Tn, Lr, Br, ni, $n, Zn, rr, Fr, wr.data) : Gt.texSubImage3D(li, Tn, Lr, Br, ni, $n, Zn, rr, Fr, Dr, wr) : ft.isDataTexture ? Gt.texSubImage2D(Gt.TEXTURE_2D, Tn, Lr, Br, $n, Zn, Fr, Dr, wr.data) : ft.isCompressedTexture ? Gt.compressedTexSubImage2D(Gt.TEXTURE_2D, Tn, Lr, Br, wr.width, wr.height, Fr, wr.data) : Gt.texSubImage2D(Gt.TEXTURE_2D, Tn, Lr, Br, $n, Zn, Fr, Dr, wr); Gt.pixelStorei(Gt.UNPACK_ROW_LENGTH, Gr), Gt.pixelStorei(Gt.UNPACK_IMAGE_HEIGHT, Wr), Gt.pixelStorei(Gt.UNPACK_SKIP_PIXELS, ii), Gt.pixelStorei(Gt.UNPACK_SKIP_ROWS, kr), Gt.pixelStorei(Gt.UNPACK_SKIP_IMAGES, Zr), Tn === 0 && qt.generateMipmaps && Gt.generateMipmap(li), yn.unbindTexture() }, this.copyTextureToTexture3D = function (ft, qt, sn = null, ln = null, pn = 0) { return ft.isTexture !== !0 && (warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed."), sn = arguments[0] || null, ln = arguments[1] || null, ft = arguments[2], qt = arguments[3], pn = arguments[4] || 0), warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(ft, qt, sn, ln, pn) }, this.initRenderTarget = function (ft) { kn.get(ft).__webglFramebuffer === void 0 && Ht.setupRenderTarget(ft) }, this.initTexture = function (ft) { ft.isCubeTexture ? Ht.setTextureCube(ft, 0) : ft.isData3DTexture ? Ht.setTexture3D(ft, 0) : ft.isDataArrayTexture || ft.isCompressedArrayTexture ? Ht.setTexture2DArray(ft, 0) : Ht.setTexture2D(ft, 0), yn.unbindTexture() }, this.resetState = function () { Oe = 0, Ue = 0, He = null, yn.reset(), Rr.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return WebGLCoordinateSystem } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(K) { this._outputColorSpace = K; const pe = this.getContext(); pe.drawingBufferColorspace = ColorManagement._getDrawingBufferColorSpace(K), pe.unpackColorSpace = ColorManagement._getUnpackColorSpace() } } const THREE$1 = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh: BatchedMesh$1, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color: Color$1, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher: EventDispatcher$2, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line: Line$2, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RenderTarget3D, RenderTargetArray, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh: SkinnedMesh$1, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TextureUtils, TimestampQuery, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WebGPUCoordinateSystem, WebXRController, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, createCanvasElement }, Symbol.toStringTag, { value: "Module" })); var constants = { exports: {} }, reactReconcilerConstants_production = {};/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */reactReconcilerConstants_production.ConcurrentRoot = 1; reactReconcilerConstants_production.ContinuousEventPriority = 8; reactReconcilerConstants_production.DefaultEventPriority = 32; reactReconcilerConstants_production.DiscreteEventPriority = 2; reactReconcilerConstants_production.IdleEventPriority = 268435456; reactReconcilerConstants_production.LegacyRoot = 0; reactReconcilerConstants_production.NoEventPriority = 0; constants.exports = reactReconcilerConstants_production; var constantsExports = constants.exports, withSelector = { exports: {} }, withSelector_production = {}, shim$2 = { exports: {} }, useSyncExternalStoreShim_production = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var React$1 = reactExports; function is$3(fe, K) { return fe === K && (fe !== 0 || 1 / fe === 1 / K) || fe !== fe && K !== K } var objectIs$1 = typeof Object.is == "function" ? Object.is : is$3, useState = React$1.useState, useEffect$1 = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue$2 = React$1.useDebugValue; function useSyncExternalStore$2(fe, K) { var pe = K(), me = useState({ inst: { value: pe, getSnapshot: K } }), ge = me[0].inst, xe = me[1]; return useLayoutEffect(function () { ge.value = pe, ge.getSnapshot = K, checkIfSnapshotChanged(ge) && xe({ inst: ge }) }, [fe, pe, K]), useEffect$1(function () { return checkIfSnapshotChanged(ge) && xe({ inst: ge }), fe(function () { checkIfSnapshotChanged(ge) && xe({ inst: ge }) }) }, [fe]), useDebugValue$2(pe), pe } function checkIfSnapshotChanged(fe) { var K = fe.getSnapshot; fe = fe.value; try { var pe = K(); return !objectIs$1(fe, pe) } catch { return !0 } } function useSyncExternalStore$1(fe, K) { return K() } var shim$1 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2; useSyncExternalStoreShim_production.useSyncExternalStore = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim$1; shim$2.exports = useSyncExternalStoreShim_production; var shimExports = shim$2.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var React = reactExports, shim = shimExports; function is$2(fe, K) { return fe === K && (fe !== 0 || 1 / fe === 1 / K) || fe !== fe && K !== K } var objectIs = typeof Object.is == "function" ? Object.is : is$2, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue$1 = React.useDebugValue; withSelector_production.useSyncExternalStoreWithSelector = function (fe, K, pe, me, ge) { var xe = useRef(null); if (xe.current === null) { var ye = { hasValue: !1, value: null }; xe.current = ye } else ye = xe.current; xe = useMemo(function () { function _e(Ce) { if (!Ee) { if (Ee = !0, be = Ce, Ce = me(Ce), ge !== void 0 && ye.hasValue) { var we = ye.value; if (ge(we, Ce)) return Ae = we } return Ae = Ce } if (we = Ae, objectIs(be, Ce)) return we; var Be = me(Ce); return ge !== void 0 && ge(we, Be) ? (be = Ce, we) : (be = Ce, Ae = Be) } var Ee = !1, be, Ae, Se = pe === void 0 ? null : pe; return [function () { return _e(K()) }, Se === null ? void 0 : function () { return _e(Se()) }] }, [K, pe, me, ge]); var ve = useSyncExternalStore(fe, xe[0], xe[1]); return useEffect(function () { ye.hasValue = !0, ye.value = ve }, [ve]), useDebugValue$1(ve), ve }; withSelector.exports = withSelector_production; var withSelectorExports = withSelector.exports; const useSyncExternalStoreExports = getDefaultExportFromCjs(withSelectorExports), createStoreImpl$1 = fe => { let K; const pe = new Set, me = (Ee, be) => { const Ae = typeof Ee == "function" ? Ee(K) : Ee; if (!Object.is(Ae, K)) { const Se = K; K = be ?? (typeof Ae != "object" || Ae === null) ? Ae : Object.assign({}, K, Ae), pe.forEach(Ce => Ce(K, Se)) } }, ge = () => K, ve = { setState: me, getState: ge, getInitialState: () => _e, subscribe: Ee => (pe.add(Ee), () => pe.delete(Ee)) }, _e = K = fe(me, ge, ve); return ve }, createStore$2 = fe => fe ? createStoreImpl$1(fe) : createStoreImpl$1, { useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector$1 } = useSyncExternalStoreExports, identity$1 = fe => fe; function useStoreWithEqualityFn(fe, K = identity$1, pe) { const me = useSyncExternalStoreWithSelector$1(fe.subscribe, fe.getState, fe.getInitialState, K, pe); return React$4.useDebugValue(me), me } const createWithEqualityFnImpl = (fe, K) => { const pe = createStore$2(fe), me = (ge, xe = K) => useStoreWithEqualityFn(pe, ge, xe); return Object.assign(me, pe), me }, createWithEqualityFn = (fe, K) => fe ? createWithEqualityFnImpl(fe, K) : createWithEqualityFnImpl; var reactReconciler = { exports: {} }, reactReconciler_production = { exports: {} };/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (fe) {
	fe.exports = function (K) {
		function pe(Te, Me, Fe, Ve) { return new of(Te, Me, Fe, Ve) } function me() { } function ge(Te) { var Me = "https://react.dev/errors/" + Te; if (1 < arguments.length) { Me += "?args[]=" + encodeURIComponent(arguments[1]); for (var Fe = 2; Fe < arguments.length; Fe++)Me += "&args[]=" + encodeURIComponent(arguments[Fe]) } return "Minified React error #" + Te + "; visit " + Me + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function xe(Te) { return Te === null || typeof Te != "object" ? null : (Te = xu && Te[xu] || Te["@@iterator"], typeof Te == "function" ? Te : null) } function ye(Te) { if (Te == null) return null; if (typeof Te == "function") return Te.$$typeof === hf ? null : Te.displayName || Te.name || null; if (typeof Te == "string") return Te; switch (Te) { case Po: return "Fragment"; case Io: return "Portal"; case ac: return "Profiler"; case pu: return "StrictMode"; case lc: return "Suspense"; case cc: return "SuspenseList" }if (typeof Te == "object") switch (Te.$$typeof) { case Ja: return (Te.displayName || "Context") + ".Provider"; case mu: return (Te._context.displayName || "Context") + ".Consumer"; case oc: var Me = Te.render; return Te = Te.displayName, Te || (Te = Me.displayName || Me.name || "", Te = Te !== "" ? "ForwardRef(" + Te + ")" : "ForwardRef"), Te; case uc: return Me = Te.displayName || null, Me !== null ? Me : ye(Te.type) || "Memo"; case Za: Me = Te._payload, Te = Te._init; try { return ye(Te(Me)) } catch { } }return null } function ve(Te) {
			if (fc === void 0) try { throw Error() } catch (Fe) {
				var Me = Fe.stack.trim().match(/\n( *(at )?)/); fc = Me && Me[1] || "", yu = -1 < Fe.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < Fe.stack.indexOf("@") ? "@unknown:0:0" : ""
			} return `
`+ fc + Te + yu
		} function _e(Te, Me) {
			if (!Te || dc) return ""; dc = !0; var Fe = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
				var Ve = { DetermineComponentFrameRoot: function () { try { if (Me) { var Mr = function () { throw Error() }; if (Object.defineProperty(Mr.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(Mr, []) } catch (si) { var Pr = si } Reflect.construct(Te, [], Mr) } else { try { Mr.call() } catch (si) { Pr = si } Te.call(Mr.prototype) } } else { try { throw Error() } catch (si) { Pr = si } (Mr = Te()) && typeof Mr.catch == "function" && Mr.catch(function () { }) } } catch (si) { if (si && Pr && typeof si.stack == "string") return [si.stack, Pr.stack] } return [null, null] } }; Ve.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var je = Object.getOwnPropertyDescriptor(Ve.DetermineComponentFrameRoot, "name"); je && je.configurable && Object.defineProperty(Ve.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var Ke = Ve.DetermineComponentFrameRoot(), zt = Ke[0], hn = Ke[1]; if (zt && hn) {
					var Cn = zt.split(`
`), tr = hn.split(`
`); for (je = Ve = 0; Ve < Cn.length && !Cn[Ve].includes("DetermineComponentFrameRoot");)Ve++; for (; je < tr.length && !tr[je].includes("DetermineComponentFrameRoot");)je++; if (Ve === Cn.length || je === tr.length) for (Ve = Cn.length - 1, je = tr.length - 1; 1 <= Ve && 0 <= je && Cn[Ve] !== tr[je];)je--; for (; 1 <= Ve && 0 <= je; Ve--, je--)if (Cn[Ve] !== tr[je]) {
						if (Ve !== 1 || je !== 1) do if (Ve--, je--, 0 > je || Cn[Ve] !== tr[je]) {
							var vr = `
`+ Cn[Ve].replace(" at new ", " at "); return Te.displayName && vr.includes("<anonymous>") && (vr = vr.replace("<anonymous>", Te.displayName)), vr
						} while (1 <= Ve && 0 <= je); break
					}
				}
			} finally { dc = !1, Error.prepareStackTrace = Fe } return (Fe = Te ? Te.displayName || Te.name : "") ? ve(Fe) : ""
		} function Ee(Te) { switch (Te.tag) { case 26: case 27: case 5: return ve(Te.type); case 16: return ve("Lazy"); case 13: return ve("Suspense"); case 19: return ve("SuspenseList"); case 0: case 15: return Te = _e(Te.type, !1), Te; case 11: return Te = _e(Te.type.render, !1), Te; case 1: return Te = _e(Te.type, !0), Te; default: return "" } } function be(Te) {
			try { var Me = ""; do Me += Ee(Te), Te = Te.return; while (Te); return Me } catch (Fe) {
				return `
Error generating stack: `+ Fe.message + `
`+ Fe.stack
			}
		} function Ae(Te) { var Me = Te, Fe = Te; if (Te.alternate) for (; Me.return;)Me = Me.return; else { Te = Me; do Me = Te, Me.flags & 4098 && (Fe = Me.return), Te = Me.return; while (Te) } return Me.tag === 3 ? Fe : null } function Se(Te) { if (Ae(Te) !== Te) throw Error(ge(188)) } function Ce(Te) { var Me = Te.alternate; if (!Me) { if (Me = Ae(Te), Me === null) throw Error(ge(188)); return Me !== Te ? null : Te } for (var Fe = Te, Ve = Me; ;) { var je = Fe.return; if (je === null) break; var Ke = je.alternate; if (Ke === null) { if (Ve = je.return, Ve !== null) { Fe = Ve; continue } break } if (je.child === Ke.child) { for (Ke = je.child; Ke;) { if (Ke === Fe) return Se(je), Te; if (Ke === Ve) return Se(je), Me; Ke = Ke.sibling } throw Error(ge(188)) } if (Fe.return !== Ve.return) Fe = je, Ve = Ke; else { for (var zt = !1, hn = je.child; hn;) { if (hn === Fe) { zt = !0, Fe = je, Ve = Ke; break } if (hn === Ve) { zt = !0, Ve = je, Fe = Ke; break } hn = hn.sibling } if (!zt) { for (hn = Ke.child; hn;) { if (hn === Fe) { zt = !0, Fe = Ke, Ve = je; break } if (hn === Ve) { zt = !0, Ve = Ke, Fe = je; break } hn = hn.sibling } if (!zt) throw Error(ge(189)) } } if (Fe.alternate !== Ve) throw Error(ge(190)) } if (Fe.tag !== 3) throw Error(ge(188)); return Fe.stateNode.current === Fe ? Te : Me } function we(Te) { var Me = Te.tag; if (Me === 5 || Me === 26 || Me === 27 || Me === 6) return Te; for (Te = Te.child; Te !== null;) { if (Me = we(Te), Me !== null) return Me; Te = Te.sibling } return null } function Be(Te) { var Me = Te.tag; if (Me === 5 || Me === 26 || Me === 27 || Me === 6) return Te; for (Te = Te.child; Te !== null;) { if (Te.tag !== 4 && (Me = Be(Te), Me !== null)) return Me; Te = Te.sibling } return null } function De(Te) { return { current: Te } } function Re(Te) { 0 > Oo || (Te.current = yc[Oo], yc[Oo] = null, Oo--) } function Ie(Te, Me) { Oo++, yc[Oo] = Te.current, Te.current = Me } function Pe(Te) { return Te >>>= 0, Te === 0 ? 32 : 31 - (Dd(Te) / Id | 0) | 0 } function Ne(Te) { var Me = Te & 42; if (Me !== 0) return Me; switch (Te & -Te) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return Te & 4194176; case 4194304: case 8388608: case 16777216: case 33554432: return Te & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return Te } } function ke(Te, Me) { var Fe = Te.pendingLanes; if (Fe === 0) return 0; var Ve = 0, je = Te.suspendedLanes, Ke = Te.pingedLanes, zt = Te.warmLanes; Te = Te.finishedLanes !== 0; var hn = Fe & 134217727; return hn !== 0 ? (Fe = hn & ~je, Fe !== 0 ? Ve = Ne(Fe) : (Ke &= hn, Ke !== 0 ? Ve = Ne(Ke) : Te || (zt = hn & ~zt, zt !== 0 && (Ve = Ne(zt))))) : (hn = Fe & ~je, hn !== 0 ? Ve = Ne(hn) : Ke !== 0 ? Ve = Ne(Ke) : Te || (zt = Fe & ~zt, zt !== 0 && (Ve = Ne(zt)))), Ve === 0 ? 0 : Me !== 0 && Me !== Ve && !(Me & je) && (je = Ve & -Ve, zt = Me & -Me, je >= zt || je === 32 && (zt & 4194176) !== 0) ? Me : Ve } function Oe(Te, Me) { return (Te.pendingLanes & ~(Te.suspendedLanes & ~Te.pingedLanes) & Me) === 0 } function Ue(Te, Me) { switch (Te) { case 1: case 2: case 4: case 8: return Me + 250; case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return Me + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function He() { var Te = Al; return Al <<= 1, !(Al & 4194176) && (Al = 128), Te } function Ge() { var Te = Sl; return Sl <<= 1, !(Sl & 62914560) && (Sl = 4194304), Te } function ze(Te) { for (var Me = [], Fe = 0; 31 > Fe; Fe++)Me.push(Te); return Me } function We(Te, Me) { Te.pendingLanes |= Me, Me !== 268435456 && (Te.suspendedLanes = 0, Te.pingedLanes = 0, Te.warmLanes = 0) } function Xe(Te, Me, Fe, Ve, je, Ke) { var zt = Te.pendingLanes; Te.pendingLanes = Fe, Te.suspendedLanes = 0, Te.pingedLanes = 0, Te.warmLanes = 0, Te.expiredLanes &= Fe, Te.entangledLanes &= Fe, Te.errorRecoveryDisabledLanes &= Fe, Te.shellSuspendCounter = 0; var hn = Te.entanglements, Cn = Te.expirationTimes, tr = Te.hiddenUpdates; for (Fe = zt & ~Fe; 0 < Fe;) { var vr = 31 - ta(Fe), Mr = 1 << vr; hn[vr] = 0, Cn[vr] = -1; var Pr = tr[vr]; if (Pr !== null) for (tr[vr] = null, vr = 0; vr < Pr.length; vr++) { var si = Pr[vr]; si !== null && (si.lane &= -536870913) } Fe &= ~Mr } Ve !== 0 && Ye(Te, Ve, 0), Ke !== 0 && je === 0 && Te.tag !== 0 && (Te.suspendedLanes |= Ke & ~(zt & ~Me)) } function Ye(Te, Me, Fe) { Te.pendingLanes |= Me, Te.suspendedLanes &= ~Me; var Ve = 31 - ta(Me); Te.entangledLanes |= Me, Te.entanglements[Ve] = Te.entanglements[Ve] | 1073741824 | Fe & 4194218 } function Ze(Te, Me) { var Fe = Te.entangledLanes |= Me; for (Te = Te.entanglements; Fe;) { var Ve = 31 - ta(Fe), je = 1 << Ve; je & Me | Te[Ve] & Me && (Te[Ve] |= Me), Fe &= ~je } } function ot(Te) { return Te &= -Te, 2 < Te ? 8 < Te ? Te & 134217727 ? 32 : 268435456 : 8 : 2 } function qe(Te) { if (na && typeof na.onCommitFiberRoot == "function") try { na.onCommitFiberRoot(il, Te, void 0, (Te.current.flags & 128) === 128) } catch { } } function Qe(Te) { if (typeof Fd == "function" && kd(Te), na && typeof na.setStrictMode == "function") try { na.setStrictMode(il, Te) } catch { } } function st(Te, Me) { return Te === Me && (Te !== 0 || 1 / Te === 1 / Me) || Te !== Te && Me !== Me } function Nt(Te, Me) { if (typeof Te == "object" && Te !== null) { var Fe = $u.get(Te); return Fe !== void 0 ? Fe : (Me = { value: Te, source: Me, stack: be(Me) }, $u.set(Te, Me), Me) } return { value: Te, source: Me, stack: be(Me) } } function Je(Te, Me) { Fo[ko++] = wl, Fo[ko++] = Tl, Tl = Te, wl = Me } function jt(Te, Me, Fe) { da[ha++] = Ua, da[ha++] = Ha, da[ha++] = yo, yo = Te; var Ve = Ua; Te = Ha; var je = 32 - ta(Ve) - 1; Ve &= ~(1 << je), Fe += 1; var Ke = 32 - ta(Me) + je; if (30 < Ke) { var zt = je - je % 5; Ke = (Ve & (1 << zt) - 1).toString(32), Ve >>= zt, je -= zt, Ua = 1 << 32 - ta(Me) + je | Fe << je | Ve, Ha = Ke + Te } else Ua = 1 << Ke | Fe << je | Ve, Ha = Te } function Xt(Te) { Te.return !== null && (Je(Te, 1), jt(Te, 1, 0)) } function ct(Te) { for (; Te === Tl;)Tl = Fo[--ko], Fo[ko] = null, wl = Fo[--ko], Fo[ko] = null; for (; Te === yo;)yo = da[--ha], da[ha] = null, Ha = da[--ha], da[ha] = null, Ua = da[--ha], da[ha] = null } function nn(Te, Me) { Ie(eo, Me), Ie(sl, Te), Ie(Es, null), Te = gf(Me), Re(Es), Ie(Es, Te) } function $t() { Re(Es), Re(sl), Re(eo) } function an(Te) { Te.memoizedState !== null && Ie(Ml, Te); var Me = Es.current, Fe = xf(Me, Te.type); Me !== Fe && (Ie(sl, Te), Ie(Es, Fe)) } function gn(Te) { sl.current === Te && (Re(Es), Re(sl)), Ml.current === Te && (Re(Ml), ka ? xo._currentValue = Lo : xo._currentValue2 = Lo) } function Mn(Te) { var Me = Error(ge(418, "")); throw Bn(Nt(Me, Te)), Ec } function Xn(Te, Me) { if (!ua) throw Error(ge(175)); dd(Te.stateNode, Te.type, Te.memoizedProps, Me, Te) || Mn(Te) } function Ln(Te) { for (Us = Te.return; Us;)switch (Us.tag) { case 3: case 27: Ra = !0; return; case 5: case 13: Ra = !1; return; default: Us = Us.return } } function Gn(Te) { if (!ua || Te !== Us) return !1; if (!Ci) return Ln(Te), Ci = !0, !1; var Me = !1; if (Ms ? Te.tag !== 3 && Te.tag !== 27 && (Te.tag !== 5 || Pu(Te.type) && !bl(Te.type, Te.memoizedProps)) && (Me = !0) : Te.tag !== 3 && (Te.tag !== 5 || Pu(Te.type) && !bl(Te.type, Te.memoizedProps)) && (Me = !0), Me && Rs && Mn(Te), Ln(Te), Te.tag === 13) { if (!ua) throw Error(ge(316)); if (Te = Te.memoizedState, Te = Te !== null ? Te.dehydrated : null, !Te) throw Error(ge(317)); Rs = gd(Te) } else Rs = Us ? Du(Te.stateNode) : null; return !0 } function wn() { ua && (Rs = Us = null, Ci = !1) } function Bn(Te) { Ca === null ? Ca = [Te] : Ca.push(Te) } function Gt() { for (var Te = Uo, Me = bc = Uo = 0; Me < Te;) { var Fe = pa[Me]; pa[Me++] = null; var Ve = pa[Me]; pa[Me++] = null; var je = pa[Me]; pa[Me++] = null; var Ke = pa[Me]; if (pa[Me++] = null, Ve !== null && je !== null) { var zt = Ve.pending; zt === null ? je.next = je : (je.next = zt.next, zt.next = je), Ve.pending = je } Ke !== 0 && yn(Fe, je, Ke) } } function nr(Te, Me, Fe, Ve) { pa[Uo++] = Te, pa[Uo++] = Me, pa[Uo++] = Fe, pa[Uo++] = Ve, bc |= Ve, Te.lanes |= Ve, Te = Te.alternate, Te !== null && (Te.lanes |= Ve) } function Kn(Te, Me, Fe, Ve) { return nr(Te, Me, Fe, Ve), Hn(Te) } function vn(Te, Me) { return nr(Te, null, null, Me), Hn(Te) } function yn(Te, Me, Fe) { Te.lanes |= Fe; var Ve = Te.alternate; Ve !== null && (Ve.lanes |= Fe); for (var je = !1, Ke = Te.return; Ke !== null;)Ke.childLanes |= Fe, Ve = Ke.alternate, Ve !== null && (Ve.childLanes |= Fe), Ke.tag === 22 && (Te = Ke.stateNode, Te === null || Te._visibility & 1 || (je = !0)), Te = Ke, Ke = Ke.return; je && Me !== null && Te.tag === 3 && (Ke = Te.stateNode, je = 31 - ta(Fe), Ke = Ke.hiddenUpdates, Te = Ke[je], Te === null ? Ke[je] = [Me] : Te.push(Me), Me.lane = Fe | 536870912) } function Hn(Te) { if (50 < ml) throw ml = 0, kc = null, Error(ge(185)); for (var Me = Te.return; Me !== null;)Te = Me, Me = Te.return; return Te.tag === 3 ? Te.stateNode : null } function kn(Te) { Te !== Ho && Te.next === null && (Ho === null ? Rl = Ho = Te : Ho = Ho.next = Te), Bl = !0, Ac || (Ac = !0, Wt(Dt)) } function Ht(Te, Me) { if (!Sc && Bl) { Sc = !0; do for (var Fe = !1, Ve = Rl; Ve !== null;) { if (Te !== 0) { var je = Ve.pendingLanes; if (je === 0) var Ke = 0; else { var zt = Ve.suspendedLanes, hn = Ve.pingedLanes; Ke = (1 << 31 - ta(42 | Te) + 1) - 1, Ke &= je & ~(zt & ~hn), Ke = Ke & 201326677 ? Ke & 201326677 | 1 : Ke ? Ke | 2 : 0 } Ke !== 0 && (Fe = !0, cn(Ve, Ke)) } else Ke = Ei, Ke = ke(Ve, Ve === $i ? Ke : 0), !(Ke & 3) || Oe(Ve, Ke) || (Fe = !0, cn(Ve, Ke)); Ve = Ve.next } while (Fe); Sc = !1 } } function Dt() { Bl = Ac = !1; var Te = 0; Vo !== 0 && (Cf() && (Te = Vo), Vo = 0); for (var Me = Sa(), Fe = null, Ve = Rl; Ve !== null;) { var je = Ve.next, Ke = fn(Ve, Me); Ke === 0 ? (Ve.next = null, Fe === null ? Rl = je : Fe.next = je, je === null && (Ho = Fe)) : (Fe = Ve, (Te !== 0 || Ke & 3) && (Bl = !0)), Ve = je } Ht(Te) } function fn(Te, Me) { for (var Fe = Te.suspendedLanes, Ve = Te.pingedLanes, je = Te.expirationTimes, Ke = Te.pendingLanes & -62914561; 0 < Ke;) { var zt = 31 - ta(Ke), hn = 1 << zt, Cn = je[zt]; Cn === -1 ? (!(hn & Fe) || hn & Ve) && (je[zt] = Ue(hn, Me)) : Cn <= Me && (Te.expiredLanes |= hn), Ke &= ~hn } if (Me = $i, Fe = Ei, Fe = ke(Te, Te === Me ? Fe : 0), Ve = Te.callbackNode, Fe === 0 || Te === Me && ji === 2 || Te.cancelPendingCommit !== null) return Ve !== null && Ve !== null && vc(Ve), Te.callbackNode = null, Te.callbackPriority = 0; if (!(Fe & 3) || Oe(Te, Fe)) { if (Me = Fe & -Fe, Me === Te.callbackPriority) return Me; switch (Ve !== null && vc(Ve), ot(Fe)) { case 2: case 8: Fe = Od; break; case 32: Fe = _c; break; case 268435456: Fe = Nd; break; default: Fe = _c }return Ve = en.bind(null, Te), Fe = Cl(Fe, Ve), Te.callbackPriority = Me, Te.callbackNode = Fe, Me } return Ve !== null && Ve !== null && vc(Ve), Te.callbackPriority = 2, Te.callbackNode = null, 2 } function en(Te, Me) { var Fe = Te.callbackNode; if (po() && Te.callbackNode !== Fe) return null; var Ve = Ei; return Ve = ke(Te, Te === $i ? Ve : 0), Ve === 0 ? null : (Xc(Te, Ve, Me), fn(Te, Sa()), Te.callbackNode != null && Te.callbackNode === Fe ? en.bind(null, Te) : null) } function cn(Te, Me) { if (po()) return null; Xc(Te, Me, !0) } function Wt(Te) { Df ? If(function () { Ui & 6 ? Cl(Gu, Te) : Te() }) : Cl(Gu, Te) } function un() { return Vo === 0 && (Vo = He()), Vo } function Ft(Te, Me) { if (al === null) { var Fe = al = []; Cc = 0, zo = un(), Go = { status: "pending", value: void 0, then: function (Ve) { Fe.push(Ve) } } } return Cc++, Me.then(Sn, Sn), Me } function Sn() { if (--Cc === 0 && al !== null) { Go !== null && (Go.status = "fulfilled"); var Te = al; al = null, zo = 0, Go = null; for (var Me = 0; Me < Te.length; Me++)(0, Te[Me])() } } function lr(Te, Me) { var Fe = [], Ve = { status: "pending", value: null, reason: null, then: function (je) { Fe.push(je) } }; return Te.then(function () { Ve.status = "fulfilled", Ve.value = Me; for (var je = 0; je < Fe.length; je++)(0, Fe[je])(Me) }, function (je) { for (Ve.status = "rejected", Ve.reason = je, je = 0; je < Fe.length; je++)(0, Fe[je])(void 0) }), Ve } function jn(Te) { Te.updateQueue = { baseState: Te.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function Pn(Te, Me) { Te = Te.updateQueue, Me.updateQueue === Te && (Me.updateQueue = { baseState: Te.baseState, firstBaseUpdate: Te.firstBaseUpdate, lastBaseUpdate: Te.lastBaseUpdate, shared: Te.shared, callbacks: null }) } function fr(Te) { return { lane: Te, tag: 0, payload: null, callback: null, next: null } } function Yn(Te, Me, Fe) { var Ve = Te.updateQueue; if (Ve === null) return null; if (Ve = Ve.shared, Ui & 2) { var je = Ve.pending; return je === null ? Me.next = Me : (Me.next = je.next, je.next = Me), Ve.pending = Me, Me = Hn(Te), yn(Te, null, Fe), Me } return nr(Te, Ve, Me, Fe), Hn(Te) } function sr(Te, Me, Fe) { if (Me = Me.updateQueue, Me !== null && (Me = Me.shared, (Fe & 4194176) !== 0)) { var Ve = Me.lanes; Ve &= Te.pendingLanes, Fe |= Ve, Me.lanes = Fe, Ze(Te, Fe) } } function Ar(Te, Me) { var Fe = Te.updateQueue, Ve = Te.alternate; if (Ve !== null && (Ve = Ve.updateQueue, Fe === Ve)) { var je = null, Ke = null; if (Fe = Fe.firstBaseUpdate, Fe !== null) { do { var zt = { lane: Fe.lane, tag: Fe.tag, payload: Fe.payload, callback: null, next: null }; Ke === null ? je = Ke = zt : Ke = Ke.next = zt, Fe = Fe.next } while (Fe !== null); Ke === null ? je = Ke = Me : Ke = Ke.next = Me } else je = Ke = Me; Fe = { baseState: Ve.baseState, firstBaseUpdate: je, lastBaseUpdate: Ke, shared: Ve.shared, callbacks: Ve.callbacks }, Te.updateQueue = Fe; return } Te = Fe.lastBaseUpdate, Te === null ? Fe.firstBaseUpdate = Me : Te.next = Me, Fe.lastBaseUpdate = Me } function Er() { if (Tc) { var Te = Go; if (Te !== null) throw Te } } function Rr(Te, Me, Fe, Ve) { Tc = !1; var je = Te.updateQueue; to = !1; var Ke = je.firstBaseUpdate, zt = je.lastBaseUpdate, hn = je.shared.pending; if (hn !== null) { je.shared.pending = null; var Cn = hn, tr = Cn.next; Cn.next = null, zt === null ? Ke = tr : zt.next = tr, zt = Cn; var vr = Te.alternate; vr !== null && (vr = vr.updateQueue, hn = vr.lastBaseUpdate, hn !== zt && (hn === null ? vr.firstBaseUpdate = tr : hn.next = tr, vr.lastBaseUpdate = Cn)) } if (Ke !== null) { var Mr = je.baseState; zt = 0, vr = tr = Cn = null, hn = Ke; do { var Pr = hn.lane & -536870913, si = Pr !== hn.lane; if (si ? (Ei & Pr) === Pr : (Ve & Pr) === Pr) { Pr !== 0 && Pr === zo && (Tc = !0), vr !== null && (vr = vr.next = { lane: 0, tag: hn.tag, payload: hn.payload, callback: null, next: null }); e: { var xa = Te, gl = hn; Pr = Me; var wo = Fe; switch (gl.tag) { case 1: if (xa = gl.payload, typeof xa == "function") { Mr = xa.call(wo, Mr, Pr); break e } Mr = xa; break e; case 3: xa.flags = xa.flags & -65537 | 128; case 0: if (xa = gl.payload, Pr = typeof xa == "function" ? xa.call(wo, Mr, Pr) : xa, Pr == null) break e; Mr = sc({}, Mr, Pr); break e; case 2: to = !0 } } Pr = hn.callback, Pr !== null && (Te.flags |= 64, si && (Te.flags |= 8192), si = je.callbacks, si === null ? je.callbacks = [Pr] : si.push(Pr)) } else si = { lane: Pr, tag: hn.tag, payload: hn.payload, callback: hn.callback, next: null }, vr === null ? (tr = vr = si, Cn = Mr) : vr = vr.next = si, zt |= Pr; if (hn = hn.next, hn === null) { if (hn = je.shared.pending, hn === null) break; si = hn, hn = si.next, si.next = null, je.lastBaseUpdate = si, je.shared.pending = null } } while (!0); vr === null && (Cn = Mr), je.baseState = Cn, je.firstBaseUpdate = tr, je.lastBaseUpdate = vr, Ke === null && (je.shared.lanes = 0), io |= zt, Te.lanes = zt, Te.memoizedState = Mr } } function mn(Te, Me) { if (typeof Te != "function") throw Error(ge(191, Te)); Te.call(Me) } function Dn(Te, Me) { var Fe = Te.callbacks; if (Fe !== null) for (Te.callbacks = null, Te = 0; Te < Fe.length; Te++)mn(Fe[Te], Me) } function Rn(Te, Me) { if (ra(Te, Me)) return !0; if (typeof Te != "object" || Te === null || typeof Me != "object" || Me === null) return !1; var Fe = Object.keys(Te), Ve = Object.keys(Me); if (Fe.length !== Ve.length) return !1; for (Ve = 0; Ve < Fe.length; Ve++) { var je = Fe[Ve]; if (!Ud.call(Me, je) || !ra(Te[je], Me[je])) return !1 } return !0 } function qn(Te) { return Te = Te.status, Te === "fulfilled" || Te === "rejected" } function ar() { } function yr(Te, Me, Fe) { switch (Fe = Te[Fe], Fe === void 0 ? Te.push(Me) : Fe !== Me && (Me.then(ar, ar), Me = Fe), Me.status) { case "fulfilled": return Me.value; case "rejected": throw Te = Me.reason, Te === ol ? Error(ge(483)) : Te; default: if (typeof Me.status == "string") Me.then(ar, ar); else { if (Te = $i, Te !== null && 100 < Te.shellSuspendCounter) throw Error(ge(482)); Te = Me, Te.status = "pending", Te.then(function (Ve) { if (Me.status === "pending") { var je = Me; je.status = "fulfilled", je.value = Ve } }, function (Ve) { if (Me.status === "pending") { var je = Me; je.status = "rejected", je.reason = Ve } }) } switch (Me.status) { case "fulfilled": return Me.value; case "rejected": throw Te = Me.reason, Te === ol ? Error(ge(483)) : Te }throw $o = Me, ol } } function dr() { if ($o === null) throw Error(ge(459)); var Te = $o; return $o = null, Te } function mi(Te) { var Me = ll; return ll += 1, jo === null && (jo = []), yr(jo, Te, Me) } function bi(Te, Me) { Me = Me.props.ref, Te.ref = Me !== void 0 ? Me : null } function ti(Te, Me) { throw Me.$$typeof === uf ? Error(ge(525)) : (Te = Object.prototype.toString.call(Me), Error(ge(31, Te === "[object Object]" ? "object with keys {" + Object.keys(Me).join(", ") + "}" : Te))) } function Si(Te) { var Me = Te._init; return Me(Te._payload) } function ri(Te) { function Me(Fn, An) { if (Te) { var zn = Fn.deletions; zn === null ? (Fn.deletions = [An], Fn.flags |= 16) : zn.push(An) } } function Fe(Fn, An) { if (!Te) return null; for (; An !== null;)Me(Fn, An), An = An.sibling; return null } function Ve(Fn) { for (var An = new Map; Fn !== null;)Fn.key !== null ? An.set(Fn.key, Fn) : An.set(Fn.index, Fn), Fn = Fn.sibling; return An } function je(Fn, An) { return Fn = Ya(Fn, An), Fn.index = 0, Fn.sibling = null, Fn } function Ke(Fn, An, zn) { return Fn.index = zn, Te ? (zn = Fn.alternate, zn !== null ? (zn = zn.index, zn < An ? (Fn.flags |= 33554434, An) : zn) : (Fn.flags |= 33554434, An)) : (Fn.flags |= 1048576, An) } function zt(Fn) { return Te && Fn.alternate === null && (Fn.flags |= 33554434), Fn } function hn(Fn, An, zn, mr) { return An === null || An.tag !== 6 ? (An = nc(zn, Fn.mode, mr), An.return = Fn, An) : (An = je(An, zn), An.return = Fn, An) } function Cn(Fn, An, zn, mr) { var Vr = zn.type; return Vr === Po ? vr(Fn, An, zn.props.children, mr, zn.key) : An !== null && (An.elementType === Vr || typeof Vr == "object" && Vr !== null && Vr.$$typeof === Za && Si(Vr) === An.type) ? (An = je(An, zn.props), bi(An, zn), An.return = Fn, An) : (An = vl(zn.type, zn.key, zn.props, null, Fn.mode, mr), bi(An, zn), An.return = Fn, An) } function tr(Fn, An, zn, mr) { return An === null || An.tag !== 4 || An.stateNode.containerInfo !== zn.containerInfo || An.stateNode.implementation !== zn.implementation ? (An = rc(zn, Fn.mode, mr), An.return = Fn, An) : (An = je(An, zn.children || []), An.return = Fn, An) } function vr(Fn, An, zn, mr, Vr) { return An === null || An.tag !== 7 ? (An = mo(zn, Fn.mode, mr, Vr), An.return = Fn, An) : (An = je(An, zn), An.return = Fn, An) } function Mr(Fn, An, zn) { if (typeof An == "string" && An !== "" || typeof An == "number" || typeof An == "bigint") return An = nc("" + An, Fn.mode, zn), An.return = Fn, An; if (typeof An == "object" && An !== null) { switch (An.$$typeof) { case _l: return zn = vl(An.type, An.key, An.props, null, Fn.mode, zn), bi(zn, An), zn.return = Fn, zn; case Io: return An = rc(An, Fn.mode, zn), An.return = Fn, An; case Za: var mr = An._init; return An = mr(An._payload), Mr(Fn, An, zn) }if (El(An) || xe(An)) return An = mo(An, Fn.mode, zn, null), An.return = Fn, An; if (typeof An.then == "function") return Mr(Fn, mi(An), zn); if (An.$$typeof === Ja) return Mr(Fn, Tr(Fn, An), zn); ti(Fn, An) } return null } function Pr(Fn, An, zn, mr) { var Vr = An !== null ? An.key : null; if (typeof zn == "string" && zn !== "" || typeof zn == "number" || typeof zn == "bigint") return Vr !== null ? null : hn(Fn, An, "" + zn, mr); if (typeof zn == "object" && zn !== null) { switch (zn.$$typeof) { case _l: return zn.key === Vr ? Cn(Fn, An, zn, mr) : null; case Io: return zn.key === Vr ? tr(Fn, An, zn, mr) : null; case Za: return Vr = zn._init, zn = Vr(zn._payload), Pr(Fn, An, zn, mr) }if (El(zn) || xe(zn)) return Vr !== null ? null : vr(Fn, An, zn, mr, null); if (typeof zn.then == "function") return Pr(Fn, An, mi(zn), mr); if (zn.$$typeof === Ja) return Pr(Fn, An, Tr(Fn, zn), mr); ti(Fn, zn) } return null } function si(Fn, An, zn, mr, Vr) { if (typeof mr == "string" && mr !== "" || typeof mr == "number" || typeof mr == "bigint") return Fn = Fn.get(zn) || null, hn(An, Fn, "" + mr, Vr); if (typeof mr == "object" && mr !== null) { switch (mr.$$typeof) { case _l: return Fn = Fn.get(mr.key === null ? zn : mr.key) || null, Cn(An, Fn, mr, Vr); case Io: return Fn = Fn.get(mr.key === null ? zn : mr.key) || null, tr(An, Fn, mr, Vr); case Za: var Xi = mr._init; return mr = Xi(mr._payload), si(Fn, An, zn, mr, Vr) }if (El(mr) || xe(mr)) return Fn = Fn.get(zn) || null, vr(An, Fn, mr, Vr, null); if (typeof mr.then == "function") return si(Fn, An, zn, mi(mr), Vr); if (mr.$$typeof === Ja) return si(Fn, An, zn, Tr(An, mr), Vr); ti(An, mr) } return null } function xa(Fn, An, zn, mr) { for (var Vr = null, Xi = null, Yr = An, Ti = An = 0, ys = null; Yr !== null && Ti < zn.length; Ti++) { Yr.index > Ti ? (ys = Yr, Yr = null) : ys = Yr.sibling; var wi = Pr(Fn, Yr, zn[Ti], mr); if (wi === null) { Yr === null && (Yr = ys); break } Te && Yr && wi.alternate === null && Me(Fn, Yr), An = Ke(wi, An, Ti), Xi === null ? Vr = wi : Xi.sibling = wi, Xi = wi, Yr = ys } if (Ti === zn.length) return Fe(Fn, Yr), Ci && Je(Fn, Ti), Vr; if (Yr === null) { for (; Ti < zn.length; Ti++)Yr = Mr(Fn, zn[Ti], mr), Yr !== null && (An = Ke(Yr, An, Ti), Xi === null ? Vr = Yr : Xi.sibling = Yr, Xi = Yr); return Ci && Je(Fn, Ti), Vr } for (Yr = Ve(Yr); Ti < zn.length; Ti++)ys = si(Yr, Fn, Ti, zn[Ti], mr), ys !== null && (Te && ys.alternate !== null && Yr.delete(ys.key === null ? Ti : ys.key), An = Ke(ys, An, Ti), Xi === null ? Vr = ys : Xi.sibling = ys, Xi = ys); return Te && Yr.forEach(function (ao) { return Me(Fn, ao) }), Ci && Je(Fn, Ti), Vr } function gl(Fn, An, zn, mr) { if (zn == null) throw Error(ge(151)); for (var Vr = null, Xi = null, Yr = An, Ti = An = 0, ys = null, wi = zn.next(); Yr !== null && !wi.done; Ti++, wi = zn.next()) { Yr.index > Ti ? (ys = Yr, Yr = null) : ys = Yr.sibling; var ao = Pr(Fn, Yr, wi.value, mr); if (ao === null) { Yr === null && (Yr = ys); break } Te && Yr && ao.alternate === null && Me(Fn, Yr), An = Ke(ao, An, Ti), Xi === null ? Vr = ao : Xi.sibling = ao, Xi = ao, Yr = ys } if (wi.done) return Fe(Fn, Yr), Ci && Je(Fn, Ti), Vr; if (Yr === null) { for (; !wi.done; Ti++, wi = zn.next())wi = Mr(Fn, wi.value, mr), wi !== null && (An = Ke(wi, An, Ti), Xi === null ? Vr = wi : Xi.sibling = wi, Xi = wi); return Ci && Je(Fn, Ti), Vr } for (Yr = Ve(Yr); !wi.done; Ti++, wi = zn.next())wi = si(Yr, Fn, Ti, wi.value, mr), wi !== null && (Te && wi.alternate !== null && Yr.delete(wi.key === null ? Ti : wi.key), An = Ke(wi, An, Ti), Xi === null ? Vr = wi : Xi.sibling = wi, Xi = wi); return Te && Yr.forEach(function (Wd) { return Me(Fn, Wd) }), Ci && Je(Fn, Ti), Vr } function wo(Fn, An, zn, mr) { if (typeof zn == "object" && zn !== null && zn.type === Po && zn.key === null && (zn = zn.props.children), typeof zn == "object" && zn !== null) { switch (zn.$$typeof) { case _l: e: { for (var Vr = zn.key; An !== null;) { if (An.key === Vr) { if (Vr = zn.type, Vr === Po) { if (An.tag === 7) { Fe(Fn, An.sibling), mr = je(An, zn.props.children), mr.return = Fn, Fn = mr; break e } } else if (An.elementType === Vr || typeof Vr == "object" && Vr !== null && Vr.$$typeof === Za && Si(Vr) === An.type) { Fe(Fn, An.sibling), mr = je(An, zn.props), bi(mr, zn), mr.return = Fn, Fn = mr; break e } Fe(Fn, An); break } else Me(Fn, An); An = An.sibling } zn.type === Po ? (mr = mo(zn.props.children, Fn.mode, mr, zn.key), mr.return = Fn, Fn = mr) : (mr = vl(zn.type, zn.key, zn.props, null, Fn.mode, mr), bi(mr, zn), mr.return = Fn, Fn = mr) } return zt(Fn); case Io: e: { for (Vr = zn.key; An !== null;) { if (An.key === Vr) if (An.tag === 4 && An.stateNode.containerInfo === zn.containerInfo && An.stateNode.implementation === zn.implementation) { Fe(Fn, An.sibling), mr = je(An, zn.children || []), mr.return = Fn, Fn = mr; break e } else { Fe(Fn, An); break } else Me(Fn, An); An = An.sibling } mr = rc(zn, Fn.mode, mr), mr.return = Fn, Fn = mr } return zt(Fn); case Za: return Vr = zn._init, zn = Vr(zn._payload), wo(Fn, An, zn, mr) }if (El(zn)) return xa(Fn, An, zn, mr); if (xe(zn)) { if (Vr = xe(zn), typeof Vr != "function") throw Error(ge(150)); return zn = Vr.call(zn), gl(Fn, An, zn, mr) } if (typeof zn.then == "function") return wo(Fn, An, mi(zn), mr); if (zn.$$typeof === Ja) return wo(Fn, An, Tr(Fn, zn), mr); ti(Fn, zn) } return typeof zn == "string" && zn !== "" || typeof zn == "number" || typeof zn == "bigint" ? (zn = "" + zn, An !== null && An.tag === 6 ? (Fe(Fn, An.sibling), mr = je(An, zn), mr.return = Fn, Fn = mr) : (Fe(Fn, An), mr = nc(zn, Fn.mode, mr), mr.return = Fn, Fn = mr), zt(Fn)) : Fe(Fn, An) } return function (Fn, An, zn, mr) { try { ll = 0; var Vr = wo(Fn, An, zn, mr); return jo = null, Vr } catch (Yr) { if (Yr === ol) throw Yr; var Xi = pe(29, Yr, null, Fn.mode); return Xi.lanes = mr, Xi.return = Fn, Xi } finally { } } } function es(Te, Me) { Te = $a, Ie(Il, Te), Ie(Wo, Me), $a = Te | Me.baseLanes } function Hi() { Ie(Il, $a), Ie(Wo, Wo.current) } function Ai() { $a = Il.current, Re(Wo), Re(Il) } function gi(Te) { var Me = Te.alternate; Ie(ds, ds.current & 1), Ie(ma, Te), Ba === null && (Me === null || Wo.current !== null || Me.memoizedState !== null) && (Ba = Te) } function ts(Te) { if (Te.tag === 22) { if (Ie(ds, ds.current), Ie(ma, Te), Ba === null) { var Me = Te.alternate; Me !== null && Me.memoizedState !== null && (Ba = Te) } } else Ii() } function Ii() { Ie(ds, ds.current), Ie(ma, ma.current) } function Nr(Te) { Re(ma), Ba === Te && (Ba = null), Re(ds) } function hs(Te) { for (var Me = Te; Me !== null;) { if (Me.tag === 13) { var Fe = Me.memoizedState; if (Fe !== null && (Fe = Fe.dehydrated, Fe === null || mc(Fe) || gc(Fe))) return Me } else if (Me.tag === 19 && Me.memoizedProps.revealOrder !== void 0) { if (Me.flags & 128) return Me } else if (Me.child !== null) { Me.child.return = Me, Me = Me.child; continue } if (Me === Te) break; for (; Me.sibling === null;) { if (Me.return === null || Me.return === Te) return null; Me = Me.return } Me.sibling.return = Me.return, Me = Me.sibling } return null } function xi() { throw Error(ge(321)) } function Rt(Te, Me) { if (Me === null) return !1; for (var Fe = 0; Fe < Me.length && Fe < Te.length; Fe++)if (!ra(Te[Fe], Me[Fe])) return !1; return !0 } function Vt(Te, Me, Fe, Ve, je, Ke) { return no = Ke, fi = Me, Me.memoizedState = null, Me.updateQueue = null, Me.lanes = 0, Qr.H = Te === null || Te.memoizedState === null ? Eo : ro, _o = !1, Ke = Fe(Ve, je), _o = !1, Xo && (Ke = In(Me, Fe, Ve, je)), dn(Te), Ke } function dn(Te) { Qr.H = Da; var Me = ki !== null && ki.next !== null; if (no = 0, us = ki = fi = null, Pl = !1, cl = 0, Ko = null, Me) throw Error(ge(300)); Te === null || gs || (Te = Te.dependencies, Te !== null && gr(Te) && (gs = !0)) } function In(Te, Me, Fe, Ve) { fi = Te; var je = 0; do { if (Xo && (Ko = null), cl = 0, Xo = !1, 25 <= je) throw Error(ge(301)); if (je += 1, us = ki = null, Te.updateQueue != null) { var Ke = Te.updateQueue; Ke.lastEffect = null, Ke.events = null, Ke.stores = null, Ke.memoCache != null && (Ke.memoCache.index = 0) } Qr.H = bo, Ke = Me(Fe, Ve) } while (Xo); return Ke } function Vn() { var Te = Qr.H, Me = Te.useState()[0]; return Me = typeof Me.then == "function" ? sn(Me) : Me, Te = Te.useState()[0], (ki !== null ? ki.memoizedState : null) !== Te && (fi.flags |= 1024), Me } function Nn() { var Te = Ll !== 0; return Ll = 0, Te } function ir(Te, Me, Fe) { Me.updateQueue = Te.updateQueue, Me.flags &= -2053, Te.lanes &= ~Fe } function Jn(Te) { if (Pl) { for (Te = Te.memoizedState; Te !== null;) { var Me = Te.queue; Me !== null && (Me.pending = null), Te = Te.next } Pl = !1 } no = 0, us = ki = fi = null, Xo = !1, cl = Ll = 0, Ko = null } function ft() { var Te = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return us === null ? fi.memoizedState = us = Te : us = us.next = Te, us } function qt() { if (ki === null) { var Te = fi.alternate; Te = Te !== null ? Te.memoizedState : null } else Te = ki.next; var Me = us === null ? fi.memoizedState : us.next; if (Me !== null) us = Me, ki = Te; else { if (Te === null) throw fi.alternate === null ? Error(ge(467)) : Error(ge(310)); ki = Te, Te = { memoizedState: ki.memoizedState, baseState: ki.baseState, baseQueue: ki.baseQueue, queue: ki.queue, next: null }, us === null ? fi.memoizedState = us = Te : us = us.next = Te } return us } function sn(Te) { var Me = cl; return cl += 1, Ko === null && (Ko = []), Te = yr(Ko, Te, Me), Me = fi, (us === null ? Me.memoizedState : us.next) === null && (Me = Me.alternate, Qr.H = Me === null || Me.memoizedState === null ? Eo : ro), Te } function ln(Te) { if (Te !== null && typeof Te == "object") { if (typeof Te.then == "function") return sn(Te); if (Te.$$typeof === Ja) return ur(Te) } throw Error(ge(438, String(Te))) } function pn(Te) { var Me = null, Fe = fi.updateQueue; if (Fe !== null && (Me = Fe.memoCache), Me == null) { var Ve = fi.alternate; Ve !== null && (Ve = Ve.updateQueue, Ve !== null && (Ve = Ve.memoCache, Ve != null && (Me = { data: Ve.data.map(function (je) { return je.slice() }), index: 0 }))) } if (Me == null && (Me = { data: [], index: 0 }), Fe === null && (Fe = Mc(), fi.updateQueue = Fe), Fe.memoCache = Me, Fe = Me.data[Me.index], Fe === void 0) for (Fe = Me.data[Me.index] = Array(Te), Ve = 0; Ve < Te; Ve++)Fe[Ve] = df; return Me.index++, Fe } function Tn(Te, Me) { return typeof Me == "function" ? Me(Te) : Me } function $n(Te) { var Me = qt(); return Zn(Me, ki, Te) } function Zn(Te, Me, Fe) { var Ve = Te.queue; if (Ve === null) throw Error(ge(311)); Ve.lastRenderedReducer = Fe; var je = Te.baseQueue, Ke = Ve.pending; if (Ke !== null) { if (je !== null) { var zt = je.next; je.next = Ke.next, Ke.next = zt } Me.baseQueue = je = Ke, Ve.pending = null } if (Ke = Te.baseState, je === null) Te.memoizedState = Ke; else { Me = je.next; var hn = zt = null, Cn = null, tr = Me, vr = !1; do { var Mr = tr.lane & -536870913; if (Mr !== tr.lane ? (Ei & Mr) === Mr : (no & Mr) === Mr) { var Pr = tr.revertLane; if (Pr === 0) Cn !== null && (Cn = Cn.next = { lane: 0, revertLane: 0, action: tr.action, hasEagerState: tr.hasEagerState, eagerState: tr.eagerState, next: null }), Mr === zo && (vr = !0); else if ((no & Pr) === Pr) { tr = tr.next, Pr === zo && (vr = !0); continue } else Mr = { lane: 0, revertLane: tr.revertLane, action: tr.action, hasEagerState: tr.hasEagerState, eagerState: tr.eagerState, next: null }, Cn === null ? (hn = Cn = Mr, zt = Ke) : Cn = Cn.next = Mr, fi.lanes |= Pr, io |= Pr; Mr = tr.action, _o && Fe(Ke, Mr), Ke = tr.hasEagerState ? tr.eagerState : Fe(Ke, Mr) } else Pr = { lane: Mr, revertLane: tr.revertLane, action: tr.action, hasEagerState: tr.hasEagerState, eagerState: tr.eagerState, next: null }, Cn === null ? (hn = Cn = Pr, zt = Ke) : Cn = Cn.next = Pr, fi.lanes |= Mr, io |= Mr; tr = tr.next } while (tr !== null && tr !== Me); if (Cn === null ? zt = Ke : Cn.next = hn, !ra(Ke, Te.memoizedState) && (gs = !0, vr && (Fe = Go, Fe !== null))) throw Fe; Te.memoizedState = Ke, Te.baseState = zt, Te.baseQueue = Cn, Ve.lastRenderedState = Ke } return je === null && (Ve.lanes = 0), [Te.memoizedState, Ve.dispatch] } function rr(Te) { var Me = qt(), Fe = Me.queue; if (Fe === null) throw Error(ge(311)); Fe.lastRenderedReducer = Te; var Ve = Fe.dispatch, je = Fe.pending, Ke = Me.memoizedState; if (je !== null) { Fe.pending = null; var zt = je = je.next; do Ke = Te(Ke, zt.action), zt = zt.next; while (zt !== je); ra(Ke, Me.memoizedState) || (gs = !0), Me.memoizedState = Ke, Me.baseQueue === null && (Me.baseState = Ke), Fe.lastRenderedState = Ke } return [Ke, Ve] } function br(Te, Me, Fe) { var Ve = fi, je = qt(), Ke = Ci; if (Ke) { if (Fe === void 0) throw Error(ge(407)); Fe = Fe() } else Fe = Me(); var zt = !ra((ki || je).memoizedState, Fe); if (zt && (je.memoizedState = Fe, gs = !0), je = je.queue, $r(Lr.bind(null, Ve, je, Te), [Te]), je.getSnapshot !== Me || zt || us !== null && us.memoizedState.tag & 1) { if (Ve.flags |= 2048, Ji(9, _r.bind(null, Ve, je, Fe, Me), { destroy: void 0 }, null), $i === null) throw Error(ge(349)); Ke || no & 60 || Un(Ve, Me, Fe) } return Fe } function Un(Te, Me, Fe) { Te.flags |= 16384, Te = { getSnapshot: Me, value: Fe }, Me = fi.updateQueue, Me === null ? (Me = Mc(), fi.updateQueue = Me, Me.stores = [Te]) : (Fe = Me.stores, Fe === null ? Me.stores = [Te] : Fe.push(Te)) } function _r(Te, Me, Fe, Ve) { Me.value = Fe, Me.getSnapshot = Ve, Br(Me) && ni(Te) } function Lr(Te, Me, Fe) { return Fe(function () { Br(Me) && ni(Te) }) } function Br(Te) { var Me = Te.getSnapshot; Te = Te.value; try { var Fe = Me(); return !ra(Te, Fe) } catch { return !0 } } function ni(Te) { var Me = vn(Te, 2); Me !== null && ks(Me, Te, 2) } function wr(Te) { var Me = ft(); if (typeof Te == "function") { var Fe = Te; if (Te = Fe(), _o) { Qe(!0); try { Fe() } finally { Qe(!1) } } } return Me.memoizedState = Me.baseState = Te, Me.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Tn, lastRenderedState: Te }, Me } function Fr(Te, Me, Fe, Ve) { return Te.baseState = Fe, Zn(Te, ki, typeof Ve == "function" ? Ve : Tn) } function Dr(Te, Me, Fe, Ve, je) { if (ai(Te)) throw Error(ge(485)); if (Te = Me.action, Te !== null) { var Ke = { payload: je, action: Te, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (zt) { Ke.listeners.push(zt) } }; Qr.T !== null ? Fe(!0) : Ke.isTransition = !1, Ve(Ke), Fe = Me.pending, Fe === null ? (Ke.next = Me.pending = Ke, li(Me, Ke)) : (Ke.next = Fe.next, Me.pending = Fe.next = Ke) } } function li(Te, Me) { var Fe = Me.action, Ve = Me.payload, je = Te.state; if (Me.isTransition) { var Ke = Qr.T, zt = {}; Qr.T = zt; try { var hn = Fe(je, Ve), Cn = Qr.S; Cn !== null && Cn(zt, hn), Gr(Te, Me, hn) } catch (tr) { ii(Te, Me, tr) } finally { Qr.T = Ke } } else try { Ke = Fe(je, Ve), Gr(Te, Me, Ke) } catch (tr) { ii(Te, Me, tr) } } function Gr(Te, Me, Fe) { Fe !== null && typeof Fe == "object" && typeof Fe.then == "function" ? Fe.then(function (Ve) { Wr(Te, Me, Ve) }, function (Ve) { return ii(Te, Me, Ve) }) : Wr(Te, Me, Fe) } function Wr(Te, Me, Fe) { Me.status = "fulfilled", Me.value = Fe, kr(Me), Te.state = Fe, Me = Te.pending, Me !== null && (Fe = Me.next, Fe === Me ? Te.pending = null : (Fe = Fe.next, Me.next = Fe, li(Te, Fe))) } function ii(Te, Me, Fe) { var Ve = Te.pending; if (Te.pending = null, Ve !== null) { Ve = Ve.next; do Me.status = "rejected", Me.reason = Fe, kr(Me), Me = Me.next; while (Me !== Ve) } Te.action = null } function kr(Te) { Te = Te.listeners; for (var Me = 0; Me < Te.length; Me++)(0, Te[Me])() } function Zr(Te, Me) { return Me } function Xr(Te, Me) { if (Ci) { var Fe = $i.formState; if (Fe !== null) { e: { var Ve = fi; if (Ci) { if (Rs) { var je = id(Rs, Ra); if (je) { Rs = Du(je), Ve = sd(je); break e } } Mn(Ve) } Ve = !1 } Ve && (Me = Fe[0]) } } Fe = ft(), Fe.memoizedState = Fe.baseState = Me, Ve = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Zr, lastRenderedState: Me }, Fe.queue = Ve, Fe = zr.bind(null, fi, Ve), Ve.dispatch = Fe, Ve = wr(!1); var Ke = Ni.bind(null, fi, !1, Ve.queue); return Ve = ft(), je = { state: Me, dispatch: null, action: Te, pending: null }, Ve.queue = je, Fe = Dr.bind(null, fi, je, Ke, Fe), je.dispatch = Fe, Ve.memoizedState = Te, [Me, Fe, !1] } function Ri(Te) { var Me = qt(); return di(Me, ki, Te) } function di(Te, Me, Fe) { Me = Zn(Te, Me, Zr)[0], Te = $n(Tn)[0], Me = typeof Me == "object" && Me !== null && typeof Me.then == "function" ? sn(Me) : Me; var Ve = qt(), je = Ve.queue, Ke = je.dispatch; return Fe !== Ve.memoizedState && (fi.flags |= 2048, Ji(9, yi.bind(null, je, Fe), { destroy: void 0 }, null)), [Me, Ke, Te] } function yi(Te, Me) { Te.action = Me } function Vi(Te) { var Me = qt(), Fe = ki; if (Fe !== null) return di(Me, Fe, Te); qt(), Me = Me.memoizedState, Fe = qt(); var Ve = Fe.queue.dispatch; return Fe.memoizedState = Te, [Me, Ve, !1] } function Ji(Te, Me, Fe, Ve) { return Te = { tag: Te, create: Me, inst: Fe, deps: Ve, next: null }, Me = fi.updateQueue, Me === null && (Me = Mc(), fi.updateQueue = Me), Fe = Me.lastEffect, Fe === null ? Me.lastEffect = Te.next = Te : (Ve = Fe.next, Fe.next = Te, Te.next = Ve, Me.lastEffect = Te), Te } function vs() { return qt().memoizedState } function Gs(Te, Me, Fe, Ve) { var je = ft(); fi.flags |= Te, je.memoizedState = Ji(1 | Me, Fe, { destroy: void 0 }, Ve === void 0 ? null : Ve) } function ya(Te, Me, Fe, Ve) { var je = qt(); Ve = Ve === void 0 ? null : Ve; var Ke = je.memoizedState.inst; ki !== null && Ve !== null && Rt(Ve, ki.memoizedState.deps) ? je.memoizedState = Ji(Me, Fe, Ke, Ve) : (fi.flags |= Te, je.memoizedState = Ji(1 | Me, Fe, Ke, Ve)) } function $s(Te, Me) { Gs(8390656, 8, Te, Me) } function $r(Te, Me) { ya(2048, 8, Te, Me) } function Bs(Te, Me) { return ya(4, 2, Te, Me) } function oa(Te, Me) { return ya(4, 4, Te, Me) } function va(Te, Me) { if (typeof Me == "function") { Te = Te(); var Fe = Me(Te); return function () { typeof Fe == "function" ? Fe() : Me(null) } } if (Me != null) return Te = Te(), Me.current = Te, function () { Me.current = null } } function Ki(Te, Me, Fe) { Fe = Fe != null ? Fe.concat([Te]) : null, ya(4, 4, va.bind(null, Me, Te), Fe) } function Pa() { } function Ws(Te, Me) { var Fe = qt(); Me = Me === void 0 ? null : Me; var Ve = Fe.memoizedState; return Me !== null && Rt(Me, Ve[1]) ? Ve[0] : (Fe.memoizedState = [Te, Me], Te) } function wa(Te, Me) { var Fe = qt(); Me = Me === void 0 ? null : Me; var Ve = Fe.memoizedState; if (Me !== null && Rt(Me, Ve[1])) return Ve[0]; if (Ve = Te(), _o) { Qe(!0); try { Te() } finally { Qe(!1) } } return Fe.memoizedState = [Ve, Me], Ve } function Le(Te, Me, Fe) { return Fe === void 0 || no & 1073741824 ? Te.memoizedState = Me : (Te.memoizedState = Fe, Te = Wc(), fi.lanes |= Te, io |= Te, Fe) } function $e(Te, Me, Fe, Ve) { return ra(Fe, Me) ? Fe : Wo.current !== null ? (Te = Le(Te, Fe, Ve), ra(Te, Me) || (gs = !0), Te) : no & 42 ? (Te = Wc(), fi.lanes |= Te, io |= Te, Me) : (gs = !0, Te.memoizedState = Fe) } function rt(Te, Me, Fe, Ve, je) { var Ke = go(); zs(Ke !== 0 && 8 > Ke ? Ke : 8); var zt = Qr.T, hn = {}; Qr.T = hn, Ni(Te, !1, Me, Fe); try { var Cn = je(), tr = Qr.S; if (tr !== null && tr(hn, Cn), Cn !== null && typeof Cn == "object" && typeof Cn.then == "function") { var vr = lr(Cn, Ve); Hr(Te, Me, vr, Qs(Te)) } else Hr(Te, Me, Ve, Qs(Te)) } catch (Mr) { Hr(Te, Me, { then: function () { }, status: "rejected", reason: Mr }, Qs()) } finally { zs(Ke), Qr.T = zt } } function Pt(Te) { var Me = Te.memoizedState; if (Me !== null) return Me; Me = { memoizedState: Lo, baseState: Lo, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Tn, lastRenderedState: Lo }, next: null }; var Fe = {}; return Me.next = { memoizedState: Fe, baseState: Fe, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Tn, lastRenderedState: Fe }, next: null }, Te.memoizedState = Me, Te = Te.alternate, Te !== null && (Te.memoizedState = Me), Me } function Yt() { return ur(xo) } function bn() { return qt().memoizedState } function On() { return qt().memoizedState } function hr(Te) { for (var Me = Te.return; Me !== null;) { switch (Me.tag) { case 24: case 3: var Fe = Qs(); Te = fr(Fe); var Ve = Yn(Me, Te, Fe); Ve !== null && (ks(Ve, Me, Fe), sr(Ve, Me, Fe)), Me = { cache: ei() }, Te.payload = Me; return }Me = Me.return } } function pr(Te, Me, Fe) { var Ve = Qs(); Fe = { lane: Ve, revertLane: 0, action: Fe, hasEagerState: !1, eagerState: null, next: null }, ai(Te) ? vi(Me, Fe) : (Fe = Kn(Te, Me, Fe, Ve), Fe !== null && (ks(Fe, Te, Ve), cs(Fe, Me, Ve))) } function zr(Te, Me, Fe) { var Ve = Qs(); Hr(Te, Me, Fe, Ve) } function Hr(Te, Me, Fe, Ve) { var je = { lane: Ve, revertLane: 0, action: Fe, hasEagerState: !1, eagerState: null, next: null }; if (ai(Te)) vi(Me, je); else { var Ke = Te.alternate; if (Te.lanes === 0 && (Ke === null || Ke.lanes === 0) && (Ke = Me.lastRenderedReducer, Ke !== null)) try { var zt = Me.lastRenderedState, hn = Ke(zt, Fe); if (je.hasEagerState = !0, je.eagerState = hn, ra(hn, zt)) return nr(Te, Me, je, 0), $i === null && Gt(), !1 } catch { } finally { } if (Fe = Kn(Te, Me, je, Ve), Fe !== null) return ks(Fe, Te, Ve), cs(Fe, Me, Ve), !0 } return !1 } function Ni(Te, Me, Fe, Ve) { if (Ve = { lane: 2, revertLane: un(), action: Ve, hasEagerState: !1, eagerState: null, next: null }, ai(Te)) { if (Me) throw Error(ge(479)) } else Me = Kn(Te, Fe, Ve, 2), Me !== null && ks(Me, Te, 2) } function ai(Te) { var Me = Te.alternate; return Te === fi || Me !== null && Me === fi } function vi(Te, Me) { Xo = Pl = !0; var Fe = Te.pending; Fe === null ? Me.next = Me : (Me.next = Fe.next, Fe.next = Me), Te.pending = Me } function cs(Te, Me, Fe) { if (Fe & 4194176) { var Ve = Me.lanes; Ve &= Te.pendingLanes, Fe |= Ve, Me.lanes = Fe, Ze(Te, Fe) } } function Fi(Te, Me, Fe, Ve) { Me = Te.memoizedState, Fe = Fe(Ve, Me), Fe = Fe == null ? Me : sc({}, Me, Fe), Te.memoizedState = Fe, Te.lanes === 0 && (Te.updateQueue.baseState = Fe) } function Bi(Te, Me, Fe, Ve, je, Ke, zt) { return Te = Te.stateNode, typeof Te.shouldComponentUpdate == "function" ? Te.shouldComponentUpdate(Ve, Ke, zt) : Me.prototype && Me.prototype.isPureReactComponent ? !Rn(Fe, Ve) || !Rn(je, Ke) : !0 } function Di(Te, Me, Fe, Ve) { Te = Me.state, typeof Me.componentWillReceiveProps == "function" && Me.componentWillReceiveProps(Fe, Ve), typeof Me.UNSAFE_componentWillReceiveProps == "function" && Me.UNSAFE_componentWillReceiveProps(Fe, Ve), Me.state !== Te && Rc.enqueueReplaceState(Me, Me.state, null) } function _i(Te, Me) { var Fe = Me; if ("ref" in Me) { Fe = {}; for (var Ve in Me) Ve !== "ref" && (Fe[Ve] = Me[Ve]) } if (Te = Te.defaultProps) { Fe === Me && (Fe = sc({}, Fe)); for (var je in Te) Fe[je] === void 0 && (Fe[je] = Te[je]) } return Fe } function Xs(Te, Me) { try { var Fe = Te.onUncaughtError; Fe(Me.value, { componentStack: Me.stack }) } catch (Ve) { setTimeout(function () { throw Ve }) } } function La(Te, Me, Fe) { try { var Ve = Te.onCaughtError; Ve(Fe.value, { componentStack: Fe.stack, errorBoundary: Me.tag === 1 ? Me.stateNode : null }) } catch (je) { setTimeout(function () { throw je }) } } function oo(Te, Me, Fe) { return Fe = fr(Fe), Fe.tag = 3, Fe.payload = { element: null }, Fe.callback = function () { Xs(Te, Me) }, Fe } function Ds(Te) { return Te = fr(Te), Te.tag = 3, Te } function bs(Te, Me, Fe, Ve) { var je = Fe.type.getDerivedStateFromError; if (typeof je == "function") { var Ke = Ve.value; Te.payload = function () { return je(Ke) }, Te.callback = function () { La(Me, Fe, Ve) } } var zt = Fe.stateNode; zt !== null && typeof zt.componentDidCatch == "function" && (Te.callback = function () { La(Me, Fe, Ve), typeof je != "function" && (so === null ? so = new Set([this]) : so.add(this)); var hn = Ve.stack; this.componentDidCatch(Ve.value, { componentStack: hn !== null ? hn : "" }) }) } function Zo(Te, Me, Fe, Ve, je) { if (Fe.flags |= 32768, Ve !== null && typeof Ve == "object" && typeof Ve.then == "function") { if (Me = Fe.alternate, Me !== null && or(Me, Fe, je, !0), Fe = ma.current, Fe !== null) { switch (Fe.tag) { case 13: return Ba === null ? Jl() : Fe.alternate === null && os === 0 && (os = 3), Fe.flags &= -257, Fe.flags |= 65536, Fe.lanes = je, Ve === Dl ? Fe.flags |= 16384 : (Me = Fe.updateQueue, Me === null ? Fe.updateQueue = new Set([Ve]) : Me.add(Ve), Ql(Te, Ve, je)), !1; case 22: return Fe.flags |= 65536, Ve === Dl ? Fe.flags |= 16384 : (Me = Fe.updateQueue, Me === null ? (Me = { transitions: null, markerInstances: null, retryQueue: new Set([Ve]) }, Fe.updateQueue = Me) : (Fe = Me.retryQueue, Fe === null ? Me.retryQueue = new Set([Ve]) : Fe.add(Ve)), Ql(Te, Ve, je)), !1 }throw Error(ge(435, Fe.tag)) } return Ql(Te, Ve, je), Jl(), !1 } if (Ci) return Me = ma.current, Me !== null ? (!(Me.flags & 65536) && (Me.flags |= 256), Me.flags |= 65536, Me.lanes = je, Ve !== Ec && (Te = Error(ge(422), { cause: Ve }), Bn(Nt(Te, Fe)))) : (Ve !== Ec && (Me = Error(ge(423), { cause: Ve }), Bn(Nt(Me, Fe))), Te = Te.current.alternate, Te.flags |= 65536, je &= -je, Te.lanes |= je, Ve = Nt(Ve, Fe), je = oo(Te.stateNode, Ve, je), Ar(Te, je), os !== 4 && (os = 2)), !1; var Ke = Error(ge(520), { cause: Ve }); if (Ke = Nt(Ke, Fe), dl === null ? dl = [Ke] : dl.push(Ke), os !== 4 && (os = 2), Me === null) return !0; Ve = Nt(Ve, Fe), Fe = Me; do { switch (Fe.tag) { case 3: return Fe.flags |= 65536, Te = je & -je, Fe.lanes |= Te, Te = oo(Fe.stateNode, Ve, Te), Ar(Fe, Te), !1; case 1: if (Me = Fe.type, Ke = Fe.stateNode, (Fe.flags & 128) === 0 && (typeof Me.getDerivedStateFromError == "function" || Ke !== null && typeof Ke.componentDidCatch == "function" && (so === null || !so.has(Ke)))) return Fe.flags |= 65536, je &= -je, Fe.lanes |= je, je = Ds(je), bs(je, Te, Fe, Ve), Ar(Fe, je), !1 }Fe = Fe.return } while (Fe !== null); return !1 } function ls(Te, Me, Fe, Ve) { Me.child = Te === null ? ju(Me, null, Fe, Ve) : vo(Me, Te.child, Fe, Ve) } function lo(Te, Me, Fe, Ve, je) { Fe = Fe.render; var Ke = Me.ref; if ("ref" in Ve) { var zt = {}; for (var hn in Ve) hn !== "ref" && (zt[hn] = Ve[hn]) } else zt = Ve; return Qn(Me), Ve = Vt(Te, Me, Fe, zt, Ke, je), hn = Nn(), Te !== null && !gs ? (ir(Te, Me, je), Ls(Te, Me, je)) : (Ci && hn && Xt(Me), Me.flags |= 1, ls(Te, Me, Ve, je), Me.child) } function ja(Te, Me, Fe, Ve, je) { if (Te === null) { var Ke = Fe.type; return typeof Ke == "function" && !tc(Ke) && Ke.defaultProps === void 0 && Fe.compare === null ? (Me.tag = 15, Me.type = Ke, Hs(Te, Me, Ke, Ve, je)) : (Te = vl(Fe.type, null, Ve, Me, Me.mode, je), Te.ref = Me.ref, Te.return = Me, Me.child = Te) } if (Ke = Te.child, !ca(Te, je)) { var zt = Ke.memoizedProps; if (Fe = Fe.compare, Fe = Fe !== null ? Fe : Rn, Fe(zt, Ve) && Te.ref === Me.ref) return Ls(Te, Me, je) } return Me.flags |= 1, Te = Ya(Ke, Ve), Te.ref = Me.ref, Te.return = Me, Me.child = Te } function Hs(Te, Me, Fe, Ve, je) { if (Te !== null) { var Ke = Te.memoizedProps; if (Rn(Ke, Ve) && Te.ref === Me.ref) if (gs = !1, Me.pendingProps = Ve = Ke, ca(Te, je)) Te.flags & 131072 && (gs = !0); else return Me.lanes = Te.lanes, Ls(Te, Me, je) } return co(Te, Me, Fe, Ve, je) } function Ks(Te, Me, Fe) { var Ve = Me.pendingProps, je = Ve.children, Ke = (Me.stateNode._pendingVisibility & 2) !== 0, zt = Te !== null ? Te.memoizedState : null; if (Vs(Te, Me), Ve.mode === "hidden" || Ke) { if (Me.flags & 128) { if (Ve = zt !== null ? zt.baseLanes | Fe : Fe, Te !== null) { for (je = Me.child = Te.child, Ke = 0; je !== null;)Ke = Ke | je.lanes | je.childLanes, je = je.sibling; Me.childLanes = Ke & ~Ve } else Me.childLanes = 0, Me.child = null; return la(Te, Me, Ve, Fe) } if (Fe & 536870912) Me.memoizedState = { baseLanes: 0, cachePool: null }, Te !== null && oi(Me, zt !== null ? zt.cachePool : null), zt !== null ? es(Me, zt) : Hi(), ts(Me); else return Me.lanes = Me.childLanes = 536870912, la(Te, Me, zt !== null ? zt.baseLanes | Fe : Fe, Fe) } else zt !== null ? (oi(Me, zt.cachePool), es(Me, zt), Ii(), Me.memoizedState = null) : (Te !== null && oi(Me, null), Hi(), Ii()); return ls(Te, Me, je, Fe), Me.child } function la(Te, Me, Fe, Ve) { var je = Zi(); return je = je === null ? null : { parent: ka ? rs._currentValue : rs._currentValue2, pool: je }, Me.memoizedState = { baseLanes: Fe, cachePool: je }, Te !== null && oi(Me, null), Hi(), ts(Me), Te !== null && or(Te, Me, Ve, !0), null } function Vs(Te, Me) { var Fe = Me.ref; if (Fe === null) Te !== null && Te.ref !== null && (Me.flags |= 2097664); else { if (typeof Fe != "function" && typeof Fe != "object") throw Error(ge(284)); (Te === null || Te.ref !== Fe) && (Me.flags |= 2097664) } } function co(Te, Me, Fe, Ve, je) { return Qn(Me), Fe = Vt(Te, Me, Fe, Ve, void 0, je), Ve = Nn(), Te !== null && !gs ? (ir(Te, Me, je), Ls(Te, Me, je)) : (Ci && Ve && Xt(Me), Me.flags |= 1, ls(Te, Me, Fe, je), Me.child) } function Is(Te, Me, Fe, Ve, je, Ke) { return Qn(Me), Me.updateQueue = null, Fe = In(Me, Ve, Fe, je), dn(Te), Ve = Nn(), Te !== null && !gs ? (ir(Te, Me, Ke), Ls(Te, Me, Ke)) : (Ci && Ve && Xt(Me), Me.flags |= 1, ls(Te, Me, Fe, Ke), Me.child) } function Mo(Te, Me, Fe, Ve, je) { if (Qn(Me), Me.stateNode === null) { var Ke = No, zt = Fe.contextType; typeof zt == "object" && zt !== null && (Ke = ur(zt)), Ke = new Fe(Ve, Ke), Me.memoizedState = Ke.state !== null && Ke.state !== void 0 ? Ke.state : null, Ke.updater = Rc, Me.stateNode = Ke, Ke._reactInternals = Me, Ke = Me.stateNode, Ke.props = Ve, Ke.state = Me.memoizedState, Ke.refs = {}, jn(Me), zt = Fe.contextType, Ke.context = typeof zt == "object" && zt !== null ? ur(zt) : No, Ke.state = Me.memoizedState, zt = Fe.getDerivedStateFromProps, typeof zt == "function" && (Fi(Me, Fe, zt, Ve), Ke.state = Me.memoizedState), typeof Fe.getDerivedStateFromProps == "function" || typeof Ke.getSnapshotBeforeUpdate == "function" || typeof Ke.UNSAFE_componentWillMount != "function" && typeof Ke.componentWillMount != "function" || (zt = Ke.state, typeof Ke.componentWillMount == "function" && Ke.componentWillMount(), typeof Ke.UNSAFE_componentWillMount == "function" && Ke.UNSAFE_componentWillMount(), zt !== Ke.state && Rc.enqueueReplaceState(Ke, Ke.state, null), Rr(Me, Ve, Ke, je), Er(), Ke.state = Me.memoizedState), typeof Ke.componentDidMount == "function" && (Me.flags |= 4194308), Ve = !0 } else if (Te === null) { Ke = Me.stateNode; var hn = Me.memoizedProps, Cn = _i(Fe, hn); Ke.props = Cn; var tr = Ke.context, vr = Fe.contextType; zt = No, typeof vr == "object" && vr !== null && (zt = ur(vr)); var Mr = Fe.getDerivedStateFromProps; vr = typeof Mr == "function" || typeof Ke.getSnapshotBeforeUpdate == "function", hn = Me.pendingProps !== hn, vr || typeof Ke.UNSAFE_componentWillReceiveProps != "function" && typeof Ke.componentWillReceiveProps != "function" || (hn || tr !== zt) && Di(Me, Ke, Ve, zt), to = !1; var Pr = Me.memoizedState; Ke.state = Pr, Rr(Me, Ve, Ke, je), Er(), tr = Me.memoizedState, hn || Pr !== tr || to ? (typeof Mr == "function" && (Fi(Me, Fe, Mr, Ve), tr = Me.memoizedState), (Cn = to || Bi(Me, Fe, Cn, Ve, Pr, tr, zt)) ? (vr || typeof Ke.UNSAFE_componentWillMount != "function" && typeof Ke.componentWillMount != "function" || (typeof Ke.componentWillMount == "function" && Ke.componentWillMount(), typeof Ke.UNSAFE_componentWillMount == "function" && Ke.UNSAFE_componentWillMount()), typeof Ke.componentDidMount == "function" && (Me.flags |= 4194308)) : (typeof Ke.componentDidMount == "function" && (Me.flags |= 4194308), Me.memoizedProps = Ve, Me.memoizedState = tr), Ke.props = Ve, Ke.state = tr, Ke.context = zt, Ve = Cn) : (typeof Ke.componentDidMount == "function" && (Me.flags |= 4194308), Ve = !1) } else { Ke = Me.stateNode, Pn(Te, Me), zt = Me.memoizedProps, vr = _i(Fe, zt), Ke.props = vr, Mr = Me.pendingProps, Pr = Ke.context, tr = Fe.contextType, Cn = No, typeof tr == "object" && tr !== null && (Cn = ur(tr)), hn = Fe.getDerivedStateFromProps, (tr = typeof hn == "function" || typeof Ke.getSnapshotBeforeUpdate == "function") || typeof Ke.UNSAFE_componentWillReceiveProps != "function" && typeof Ke.componentWillReceiveProps != "function" || (zt !== Mr || Pr !== Cn) && Di(Me, Ke, Ve, Cn), to = !1, Pr = Me.memoizedState, Ke.state = Pr, Rr(Me, Ve, Ke, je), Er(); var si = Me.memoizedState; zt !== Mr || Pr !== si || to || Te !== null && Te.dependencies !== null && gr(Te.dependencies) ? (typeof hn == "function" && (Fi(Me, Fe, hn, Ve), si = Me.memoizedState), (vr = to || Bi(Me, Fe, vr, Ve, Pr, si, Cn) || Te !== null && Te.dependencies !== null && gr(Te.dependencies)) ? (tr || typeof Ke.UNSAFE_componentWillUpdate != "function" && typeof Ke.componentWillUpdate != "function" || (typeof Ke.componentWillUpdate == "function" && Ke.componentWillUpdate(Ve, si, Cn), typeof Ke.UNSAFE_componentWillUpdate == "function" && Ke.UNSAFE_componentWillUpdate(Ve, si, Cn)), typeof Ke.componentDidUpdate == "function" && (Me.flags |= 4), typeof Ke.getSnapshotBeforeUpdate == "function" && (Me.flags |= 1024)) : (typeof Ke.componentDidUpdate != "function" || zt === Te.memoizedProps && Pr === Te.memoizedState || (Me.flags |= 4), typeof Ke.getSnapshotBeforeUpdate != "function" || zt === Te.memoizedProps && Pr === Te.memoizedState || (Me.flags |= 1024), Me.memoizedProps = Ve, Me.memoizedState = si), Ke.props = Ve, Ke.state = si, Ke.context = Cn, Ve = vr) : (typeof Ke.componentDidUpdate != "function" || zt === Te.memoizedProps && Pr === Te.memoizedState || (Me.flags |= 4), typeof Ke.getSnapshotBeforeUpdate != "function" || zt === Te.memoizedProps && Pr === Te.memoizedState || (Me.flags |= 1024), Ve = !1) } return Ke = Ve, Vs(Te, Me), Ve = (Me.flags & 128) !== 0, Ke || Ve ? (Ke = Me.stateNode, Fe = Ve && typeof Fe.getDerivedStateFromError != "function" ? null : Ke.render(), Me.flags |= 1, Te !== null && Ve ? (Me.child = vo(Me, Te.child, null, je), Me.child = vo(Me, null, Fe, je)) : ls(Te, Me, Fe, je), Me.memoizedState = Ke.state, Te = Me.child) : Te = Ls(Te, Me, je), Te } function uo(Te, Me, Fe, Ve) { return wn(), Me.flags |= 256, ls(Te, Me, Fe, Ve), Me.child } function Wa(Te) { return { baseLanes: Te, cachePool: ba() } } function Ea(Te, Me, Fe) { return Te = Te !== null ? Te.childLanes & ~Fe : 0, Me && (Te |= ga), Te } function Ma(Te, Me, Fe) { var Ve = Me.pendingProps, je = !1, Ke = (Me.flags & 128) !== 0, zt; if ((zt = Ke) || (zt = Te !== null && Te.memoizedState === null ? !1 : (ds.current & 2) !== 0), zt && (je = !0, Me.flags &= -129), zt = (Me.flags & 32) !== 0, Me.flags &= -33, Te === null) { if (Ci) { if (je ? gi(Me) : Ii(), Ci) { var hn = Rs, Cn; (Cn = hn) && (hn = ud(hn, Ra), hn !== null ? (Me.memoizedState = { dehydrated: hn, treeContext: yo !== null ? { id: Ua, overflow: Ha } : null, retryLane: 536870912 }, Cn = pe(18, null, null, 0), Cn.stateNode = hn, Cn.return = Me, Me.child = Cn, Us = Me, Rs = null, Cn = !0) : Cn = !1), Cn || Mn(Me) } if (hn = Me.memoizedState, hn !== null && (hn = hn.dehydrated, hn !== null)) return gc(hn) ? Me.lanes = 16 : Me.lanes = 536870912, null; Nr(Me) } return hn = Ve.children, Ve = Ve.fallback, je ? (Ii(), je = Me.mode, hn = Oa({ mode: "hidden", children: hn }, je), Ve = mo(Ve, je, Fe, null), hn.return = Me, Ve.return = Me, hn.sibling = Ve, Me.child = hn, je = Me.child, je.memoizedState = Wa(Fe), je.childLanes = Ea(Te, zt, Fe), Me.memoizedState = Bc, Ve) : (gi(Me), fo(Me, hn)) } if (Cn = Te.memoizedState, Cn !== null && (hn = Cn.dehydrated, hn !== null)) { if (Ke) Me.flags & 256 ? (gi(Me), Me.flags &= -257, Me = Ps(Te, Me, Fe)) : Me.memoizedState !== null ? (Ii(), Me.child = Te.child, Me.flags |= 128, Me = null) : (Ii(), je = Ve.fallback, hn = Me.mode, Ve = Oa({ mode: "visible", children: Ve.children }, hn), je = mo(je, hn, Fe, null), je.flags |= 2, Ve.return = Me, je.return = Me, Ve.sibling = je, Me.child = Ve, vo(Me, Te.child, null, Fe), Ve = Me.child, Ve.memoizedState = Wa(Fe), Ve.childLanes = Ea(Te, zt, Fe), Me.memoizedState = Bc, Me = je); else if (gi(Me), gc(hn)) zt = nd(hn).digest, Ve = Error(ge(419)), Ve.stack = "", Ve.digest = zt, Bn({ value: Ve, source: null, stack: null }), Me = Ps(Te, Me, Fe); else if (gs || or(Te, Me, Fe, !1), zt = (Fe & Te.childLanes) !== 0, gs || zt) { if (zt = $i, zt !== null) { if (Ve = Fe & -Fe, Ve & 42) Ve = 1; else switch (Ve) { case 2: Ve = 1; break; case 8: Ve = 4; break; case 32: Ve = 16; break; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: Ve = 64; break; case 268435456: Ve = 134217728; break; default: Ve = 0 }if (Ve = Ve & (zt.suspendedLanes | Fe) ? 0 : Ve, Ve !== 0 && Ve !== Cn.retryLane) throw Cn.retryLane = Ve, vn(Te, Ve), ks(zt, Te, Ve), Xu } mc(hn) || Jl(), Me = Ps(Te, Me, Fe) } else mc(hn) ? (Me.flags |= 128, Me.child = Te.child, Me = rf.bind(null, Te), rd(hn, Me), Me = null) : (Te = Cn.treeContext, ua && (Rs = od(hn), Us = Me, Ci = !0, Ca = null, Ra = !1, Te !== null && (da[ha++] = Ua, da[ha++] = Ha, da[ha++] = yo, Ua = Te.id, Ha = Te.overflow, yo = Me)), Me = fo(Me, Ve.children), Me.flags |= 4096); return Me } return je ? (Ii(), je = Ve.fallback, hn = Me.mode, Cn = Te.child, Ke = Cn.sibling, Ve = Ya(Cn, { mode: "hidden", children: Ve.children }), Ve.subtreeFlags = Cn.subtreeFlags & 31457280, Ke !== null ? je = Ya(Ke, je) : (je = mo(je, hn, Fe, null), je.flags |= 2), je.return = Me, Ve.return = Me, Ve.sibling = je, Me.child = Ve, Ve = je, je = Me.child, hn = Te.child.memoizedState, hn === null ? hn = Wa(Fe) : (Cn = hn.cachePool, Cn !== null ? (Ke = ka ? rs._currentValue : rs._currentValue2, Cn = Cn.parent !== Ke ? { parent: Ke, pool: Ke } : Cn) : Cn = ba(), hn = { baseLanes: hn.baseLanes | Fe, cachePool: Cn }), je.memoizedState = hn, je.childLanes = Ea(Te, zt, Fe), Me.memoizedState = Bc, Ve) : (gi(Me), Fe = Te.child, Te = Fe.sibling, Fe = Ya(Fe, { mode: "visible", children: Ve.children }), Fe.return = Me, Fe.sibling = null, Te !== null && (zt = Me.deletions, zt === null ? (Me.deletions = [Te], Me.flags |= 16) : zt.push(Te)), Me.child = Fe, Me.memoizedState = null, Fe) } function fo(Te, Me) { return Me = Oa({ mode: "visible", children: Me }, Te.mode), Me.return = Te, Te.child = Me } function Oa(Te, Me) { return lu(Te, Me, 0, null) } function Ps(Te, Me, Fe) { return vo(Me, Te.child, null, Fe), Te = fo(Me, Me.pendingProps.children), Te.flags |= 2, Me.memoizedState = null, Te } function qs(Te, Me, Fe) { Te.lanes |= Me; var Ve = Te.alternate; Ve !== null && (Ve.lanes |= Me), _n(Te.return, Me, Fe) } function As(Te, Me, Fe, Ve, je) { var Ke = Te.memoizedState; Ke === null ? Te.memoizedState = { isBackwards: Me, rendering: null, renderingStartTime: 0, last: Ve, tail: Fe, tailMode: je } : (Ke.isBackwards = Me, Ke.rendering = null, Ke.renderingStartTime = 0, Ke.last = Ve, Ke.tail = Fe, Ke.tailMode = je) } function ps(Te, Me, Fe) { var Ve = Me.pendingProps, je = Ve.revealOrder, Ke = Ve.tail; if (ls(Te, Me, Ve.children, Fe), Ve = ds.current, Ve & 2) Ve = Ve & 1 | 2, Me.flags |= 128; else { if (Te !== null && Te.flags & 128) e: for (Te = Me.child; Te !== null;) { if (Te.tag === 13) Te.memoizedState !== null && qs(Te, Fe, Me); else if (Te.tag === 19) qs(Te, Fe, Me); else if (Te.child !== null) { Te.child.return = Te, Te = Te.child; continue } if (Te === Me) break e; for (; Te.sibling === null;) { if (Te.return === null || Te.return === Me) break e; Te = Te.return } Te.sibling.return = Te.return, Te = Te.sibling } Ve &= 1 } switch (Ie(ds, Ve), je) { case "forwards": for (Fe = Me.child, je = null; Fe !== null;)Te = Fe.alternate, Te !== null && hs(Te) === null && (je = Fe), Fe = Fe.sibling; Fe = je, Fe === null ? (je = Me.child, Me.child = null) : (je = Fe.sibling, Fe.sibling = null), As(Me, !1, je, Fe, Ke); break; case "backwards": for (Fe = null, je = Me.child, Me.child = null; je !== null;) { if (Te = je.alternate, Te !== null && hs(Te) === null) { Me.child = je; break } Te = je.sibling, je.sibling = Fe, Fe = je, je = Te } As(Me, !0, Fe, null, Ke); break; case "together": As(Me, !1, null, null, void 0); break; default: Me.memoizedState = null }return Me.child } function Ls(Te, Me, Fe) { if (Te !== null && (Me.dependencies = Te.dependencies), io |= Me.lanes, !(Fe & Me.childLanes)) if (Te !== null) { if (or(Te, Me, Fe, !1), (Fe & Me.childLanes) === 0) return null } else return null; if (Te !== null && Me.child !== Te.child) throw Error(ge(153)); if (Me.child !== null) { for (Te = Me.child, Fe = Ya(Te, Te.pendingProps), Me.child = Fe, Fe.return = Me; Te.sibling !== null;)Te = Te.sibling, Fe = Fe.sibling = Ya(Te, Te.pendingProps), Fe.return = Me; Fe.sibling = null } return Me.child } function ca(Te, Me) { return Te.lanes & Me ? !0 : (Te = Te.dependencies, !!(Te !== null && gr(Te))) } function Xa(Te, Me, Fe) { switch (Me.tag) { case 3: nn(Me, Me.stateNode.containerInfo), wt(Me, rs, Te.memoizedState.cache), wn(); break; case 27: case 5: an(Me); break; case 4: nn(Me, Me.stateNode.containerInfo); break; case 10: wt(Me, Me.type, Me.memoizedProps.value); break; case 13: var Ve = Me.memoizedState; if (Ve !== null) return Ve.dehydrated !== null ? (gi(Me), Me.flags |= 128, null) : Fe & Me.child.childLanes ? Ma(Te, Me, Fe) : (gi(Me), Te = Ls(Te, Me, Fe), Te !== null ? Te.sibling : null); gi(Me); break; case 19: var je = (Te.flags & 128) !== 0; if (Ve = (Fe & Me.childLanes) !== 0, Ve || (or(Te, Me, Fe, !1), Ve = (Fe & Me.childLanes) !== 0), je) { if (Ve) return ps(Te, Me, Fe); Me.flags |= 128 } if (je = Me.memoizedState, je !== null && (je.rendering = null, je.tail = null, je.lastEffect = null), Ie(ds, ds.current), Ve) break; return null; case 22: case 23: return Me.lanes = 0, Ks(Te, Me, Fe); case 24: wt(Me, rs, Te.memoizedState.cache) }return Ls(Te, Me, Fe) } function Et(Te, Me, Fe) { if (Te !== null) if (Te.memoizedProps !== Me.pendingProps) gs = !0; else { if (!ca(Te, Fe) && !(Me.flags & 128)) return gs = !1, Xa(Te, Me, Fe); gs = !!(Te.flags & 131072) } else gs = !1, Ci && Me.flags & 1048576 && jt(Me, wl, Me.index); switch (Me.lanes = 0, Me.tag) { case 16: e: { Te = Me.pendingProps; var Ve = Me.elementType, je = Ve._init; if (Ve = je(Ve._payload), Me.type = Ve, typeof Ve == "function") tc(Ve) ? (Te = _i(Ve, Te), Me.tag = 1, Me = Mo(null, Me, Ve, Te, Fe)) : (Me.tag = 0, Me = co(null, Me, Ve, Te, Fe)); else { if (Ve != null) { if (je = Ve.$$typeof, je === oc) { Me.tag = 11, Me = lo(null, Me, Ve, Te, Fe); break e } else if (je === uc) { Me.tag = 14, Me = ja(null, Me, Ve, Te, Fe); break e } } throw Me = ye(Ve) || Ve, Error(ge(306, Me, "")) } } return Me; case 0: return co(Te, Me, Me.type, Me.pendingProps, Fe); case 1: return Ve = Me.type, je = _i(Ve, Me.pendingProps), Mo(Te, Me, Ve, je, Fe); case 3: e: { if (nn(Me, Me.stateNode.containerInfo), Te === null) throw Error(ge(387)); var Ke = Me.pendingProps; je = Me.memoizedState, Ve = je.element, Pn(Te, Me), Rr(Me, Ke, null, Fe); var zt = Me.memoizedState; if (Ke = zt.cache, wt(Me, rs, Ke), Ke !== je.cache && Wn(Me, [rs], Fe, !0), Er(), Ke = zt.element, ua && je.isDehydrated) if (je = { element: Ke, isDehydrated: !1, cache: zt.cache }, Me.updateQueue.baseState = je, Me.memoizedState = je, Me.flags & 256) { Me = uo(Te, Me, Ke, Fe); break e } else if (Ke !== Ve) { Ve = Nt(Error(ge(424)), Me), Bn(Ve), Me = uo(Te, Me, Ke, Fe); break e } else for (ua && (Rs = ad(Me.stateNode.containerInfo), Us = Me, Ci = !0, Ca = null, Ra = !0), Fe = ju(Me, null, Ke, Fe), Me.child = Fe; Fe;)Fe.flags = Fe.flags & -3 | 4096, Fe = Fe.sibling; else { if (wn(), Ke === Ve) { Me = Ls(Te, Me, Fe); break e } ls(Te, Me, Ke, Fe) } Me = Me.child } return Me; case 26: if (fa) return Vs(Te, Me), Te === null ? (Fe = Ou(Me.type, null, Me.pendingProps, null)) ? Me.memoizedState = Fe : Ci || (Me.stateNode = Sd(Me.type, Me.pendingProps, eo.current, Me)) : Me.memoizedState = Ou(Me.type, Te.memoizedProps, Me.pendingProps, Te.memoizedState), null; case 27: if (Ms) return an(Me), Te === null && Ms && Ci && (Ve = Me.stateNode = Vu(Me.type, Me.pendingProps, eo.current, Es.current, !1), Us = Me, Ra = !0, Rs = Iu(Ve)), Ve = Me.pendingProps.children, Te !== null || Ci ? ls(Te, Me, Ve, Fe) : Me.child = vo(Me, null, Ve, Fe), Vs(Te, Me), Me.child; case 5: return Te === null && Ci && (Ed(Me.type, Me.pendingProps, Es.current), (je = Ve = Rs) && (Ve = ld(Ve, Me.type, Me.pendingProps, Ra), Ve !== null ? (Me.stateNode = Ve, Us = Me, Rs = Iu(Ve), Ra = !1, je = !0) : je = !1), je || Mn(Me)), an(Me), je = Me.type, Ke = Me.pendingProps, zt = Te !== null ? Te.memoizedProps : null, Ve = Ke.children, bl(je, Ke) ? Ve = null : zt !== null && bl(je, zt) && (Me.flags |= 32), Me.memoizedState !== null && (je = Vt(Te, Me, Vn, null, null, Fe), ka ? xo._currentValue = je : xo._currentValue2 = je), Vs(Te, Me), ls(Te, Me, Ve, Fe), Me.child; case 6: return Te === null && Ci && (bd(Me.pendingProps, Es.current), (Te = Fe = Rs) && (Fe = cd(Fe, Me.pendingProps, Ra), Fe !== null ? (Me.stateNode = Fe, Us = Me, Rs = null, Te = !0) : Te = !1), Te || Mn(Me)), null; case 13: return Ma(Te, Me, Fe); case 4: return nn(Me, Me.stateNode.containerInfo), Ve = Me.pendingProps, Te === null ? Me.child = vo(Me, null, Ve, Fe) : ls(Te, Me, Ve, Fe), Me.child; case 11: return lo(Te, Me, Me.type, Me.pendingProps, Fe); case 7: return ls(Te, Me, Me.pendingProps, Fe), Me.child; case 8: return ls(Te, Me, Me.pendingProps.children, Fe), Me.child; case 12: return ls(Te, Me, Me.pendingProps.children, Fe), Me.child; case 10: return Ve = Me.pendingProps, wt(Me, Me.type, Ve.value), ls(Te, Me, Ve.children, Fe), Me.child; case 9: return je = Me.type._context, Ve = Me.pendingProps.children, Qn(Me), je = ur(je), Ve = Ve(je), Me.flags |= 1, ls(Te, Me, Ve, Fe), Me.child; case 14: return ja(Te, Me, Me.type, Me.pendingProps, Fe); case 15: return Hs(Te, Me, Me.type, Me.pendingProps, Fe); case 19: return ps(Te, Me, Fe); case 22: return Ks(Te, Me, Fe); case 24: return Qn(Me), Ve = ur(rs), Te === null ? (je = Zi(), je === null && (je = $i, Ke = ei(), je.pooledCache = Ke, Ke.refCount++, Ke !== null && (je.pooledCacheLanes |= Fe), je = Ke), Me.memoizedState = { parent: Ve, cache: je }, jn(Me), wt(Me, rs, je)) : (Te.lanes & Fe && (Pn(Te, Me), Rr(Me, null, null, Fe), Er()), je = Te.memoizedState, Ke = Me.memoizedState, je.parent !== Ve ? (je = { parent: Ve, cache: Ve }, Me.memoizedState = je, Me.lanes === 0 && (Me.memoizedState = Me.updateQueue.baseState = je), wt(Me, rs, Ve)) : (Ve = Ke.cache, wt(Me, rs, Ve), Ve !== je.cache && Wn(Me, [rs], Fe, !0))), ls(Te, Me, Me.pendingProps.children, Fe), Me.child; case 29: throw Me.pendingProps }throw Error(ge(156, Me.tag)) } function wt(Te, Me, Fe) { ka ? (Ie(Ol, Me._currentValue), Me._currentValue = Fe) : (Ie(Ol, Me._currentValue2), Me._currentValue2 = Fe) } function rn(Te) { var Me = Ol.current; ka ? Te._currentValue = Me : Te._currentValue2 = Me, Re(Ol) } function _n(Te, Me, Fe) { for (; Te !== null;) { var Ve = Te.alternate; if ((Te.childLanes & Me) !== Me ? (Te.childLanes |= Me, Ve !== null && (Ve.childLanes |= Me)) : Ve !== null && (Ve.childLanes & Me) !== Me && (Ve.childLanes |= Me), Te === Fe) break; Te = Te.return } } function Wn(Te, Me, Fe, Ve) { var je = Te.child; for (je !== null && (je.return = Te); je !== null;) { var Ke = je.dependencies; if (Ke !== null) { var zt = je.child; Ke = Ke.firstContext; e: for (; Ke !== null;) { var hn = Ke; Ke = je; for (var Cn = 0; Cn < Me.length; Cn++)if (hn.context === Me[Cn]) { Ke.lanes |= Fe, hn = Ke.alternate, hn !== null && (hn.lanes |= Fe), _n(Ke.return, Fe, Te), Ve || (zt = null); break e } Ke = hn.next } } else if (je.tag === 18) { if (zt = je.return, zt === null) throw Error(ge(341)); zt.lanes |= Fe, Ke = zt.alternate, Ke !== null && (Ke.lanes |= Fe), _n(zt, Fe, Te), zt = null } else zt = je.child; if (zt !== null) zt.return = je; else for (zt = je; zt !== null;) { if (zt === Te) { zt = null; break } if (je = zt.sibling, je !== null) { je.return = zt.return, zt = je; break } zt = zt.return } je = zt } } function or(Te, Me, Fe, Ve) { Te = null; for (var je = Me, Ke = !1; je !== null;) { if (!Ke) { if (je.flags & 524288) Ke = !0; else if (je.flags & 262144) break } if (je.tag === 10) { var zt = je.alternate; if (zt === null) throw Error(ge(387)); if (zt = zt.memoizedProps, zt !== null) { var hn = je.type; ra(je.pendingProps.value, zt.value) || (Te !== null ? Te.push(hn) : Te = [hn]) } } else if (je === Ml.current) { if (zt = je.alternate, zt === null) throw Error(ge(387)); zt.memoizedState.memoizedState !== je.memoizedState.memoizedState && (Te !== null ? Te.push(xo) : Te = [xo]) } je = je.return } Te !== null && Wn(Me, Te, Fe, Ve), Me.flags |= 262144 } function gr(Te) { for (Te = Te.firstContext; Te !== null;) { var Me = Te.context; if (!ra(ka ? Me._currentValue : Me._currentValue2, Te.memoizedValue)) return !0; Te = Te.next } return !1 } function Qn(Te) { Ao = Te, Va = null, Te = Te.dependencies, Te !== null && (Te.firstContext = null) } function ur(Te) { return Ir(Ao, Te) } function Tr(Te, Me) { return Ao === null && Qn(Te), Ir(Te, Me) } function Ir(Te, Me) { var Fe = ka ? Me._currentValue : Me._currentValue2; if (Me = { context: Me, memoizedValue: Fe, next: null }, Va === null) { if (Te === null) throw Error(ge(308)); Va = Me, Te.dependencies = { lanes: 0, firstContext: Me }, Te.flags |= 524288 } else Va = Va.next = Me; return Fe } function ei() { return { controller: new Vd, data: new Map, refCount: 0 } } function Kr(Te) { Te.refCount--, Te.refCount === 0 && zd(Gd, function () { Te.controller.abort() }) } function Zi() { var Te = So.current; return Te !== null ? Te : $i.pooledCache } function oi(Te, Me) { Me === null ? Ie(So, So.current) : Ie(So, Me.pool) } function ba() { var Te = Zi(); return Te === null ? null : { parent: ka ? rs._currentValue : rs._currentValue2, pool: Te } } function Wi(Te) { Te.flags |= 4 } function Ys(Te, Me) { if (Te !== null && Te.child === Me.child) return !1; if (Me.flags & 16) return !0; for (Te = Me.child; Te !== null;) { if (Te.flags & 13878 || Te.subtreeFlags & 13878) return !0; Te = Te.sibling } return !1 } function Na(Te, Me, Fe, Ve) { if (ws) for (Fe = Me.child; Fe !== null;) { if (Fe.tag === 5 || Fe.tag === 6) hc(Te, Fe.stateNode); else if (!(Fe.tag === 4 || Ms && Fe.tag === 27) && Fe.child !== null) { Fe.child.return = Fe, Fe = Fe.child; continue } if (Fe === Me) break; for (; Fe.sibling === null;) { if (Fe.return === null || Fe.return === Me) return; Fe = Fe.return } Fe.sibling.return = Fe.return, Fe = Fe.sibling } else if (Qa) for (var je = Me.child; je !== null;) { if (je.tag === 5) { var Ke = je.stateNode; Fe && Ve && (Ke = Ru(Ke, je.type, je.memoizedProps)), hc(Te, Ke) } else if (je.tag === 6) Ke = je.stateNode, Fe && Ve && (Ke = Bu(Ke, je.memoizedProps)), hc(Te, Ke); else if (je.tag !== 4) { if (je.tag === 22 && je.memoizedState !== null) Ke = je.child, Ke !== null && (Ke.return = je), Na(Te, je, !0, !0); else if (je.child !== null) { je.child.return = je, je = je.child; continue } } if (je === Me) break; for (; je.sibling === null;) { if (je.return === null || je.return === Me) return; je = je.return } je.sibling.return = je.return, je = je.sibling } } function Os(Te, Me, Fe, Ve) { if (Qa) for (var je = Me.child; je !== null;) { if (je.tag === 5) { var Ke = je.stateNode; Fe && Ve && (Ke = Ru(Ke, je.type, je.memoizedProps)), wu(Te, Ke) } else if (je.tag === 6) Ke = je.stateNode, Fe && Ve && (Ke = Bu(Ke, je.memoizedProps)), wu(Te, Ke); else if (je.tag !== 4) { if (je.tag === 22 && je.memoizedState !== null) Ke = je.child, Ke !== null && (Ke.return = je), Os(Te, je, !(je.memoizedProps !== null && je.memoizedProps.mode === "manual"), !0); else if (je.child !== null) { je.child.return = je, je = je.child; continue } } if (je === Me) break; for (; je.sibling === null;) { if (je.return === null || je.return === Me) return; je = je.return } je.sibling.return = je.return, je = je.sibling } } function Ka(Te, Me) { if (Qa && Ys(Te, Me)) { Te = Me.stateNode; var Fe = Te.containerInfo, Ve = Tu(); Os(Ve, Me, !1, !1), Te.pendingChildren = Ve, Wi(Me), ed(Fe, Ve) } } function at(Te, Me, Fe, Ve) { if (ws) Te.memoizedProps !== Ve && Wi(Me); else if (Qa) { var je = Te.stateNode, Ke = Te.memoizedProps; if ((Te = Ys(Te, Me)) || Ke !== Ve) { var zt = Es.current; Ke = Qf(je, Fe, Ke, Ve, !Te, null), Ke === je ? Me.stateNode = je : (_u(Ke, Fe, Ve, zt) && Wi(Me), Me.stateNode = Ke, Te ? Na(Ke, Me, !1, !1) : Wi(Me)) } else Me.stateNode = je } } function kt(Te, Me, Fe) { if (wf(Me, Fe)) { if (Te.flags |= 16777216, !Au(Me, Fe)) if (Jc()) Te.flags |= 8192; else throw $o = Dl, wc } else Te.flags &= -16777217 } function Kt(Te, Me) { if (Td(Me)) { if (Te.flags |= 16777216, !Hu(Me)) if (Jc()) Te.flags |= 8192; else throw $o = Dl, wc } else Te.flags &= -16777217 } function tn(Te, Me) { Me !== null && (Te.flags |= 4), Te.flags & 16384 && (Me = Te.tag !== 22 ? Ge() : 536870912, Te.lanes |= Me, Jo |= Me) } function xn(Te, Me) { if (!Ci) switch (Te.tailMode) { case "hidden": Me = Te.tail; for (var Fe = null; Me !== null;)Me.alternate !== null && (Fe = Me), Me = Me.sibling; Fe === null ? Te.tail = null : Fe.sibling = null; break; case "collapsed": Fe = Te.tail; for (var Ve = null; Fe !== null;)Fe.alternate !== null && (Ve = Fe), Fe = Fe.sibling; Ve === null ? Me || Te.tail === null ? Te.tail = null : Te.tail.sibling = null : Ve.sibling = null } } function En(Te) { var Me = Te.alternate !== null && Te.alternate.child === Te.child, Fe = 0, Ve = 0; if (Me) for (var je = Te.child; je !== null;)Fe |= je.lanes | je.childLanes, Ve |= je.subtreeFlags & 31457280, Ve |= je.flags & 31457280, je.return = Te, je = je.sibling; else for (je = Te.child; je !== null;)Fe |= je.lanes | je.childLanes, Ve |= je.subtreeFlags, Ve |= je.flags, je.return = Te, je = je.sibling; return Te.subtreeFlags |= Ve, Te.childLanes = Fe, Me } function er(Te, Me, Fe) { var Ve = Me.pendingProps; switch (ct(Me), Me.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return En(Me), null; case 1: return En(Me), null; case 3: return Fe = Me.stateNode, Ve = null, Te !== null && (Ve = Te.memoizedState.cache), Me.memoizedState.cache !== Ve && (Me.flags |= 2048), rn(rs), $t(), Fe.pendingContext && (Fe.context = Fe.pendingContext, Fe.pendingContext = null), (Te === null || Te.child === null) && (Gn(Me) ? Wi(Me) : Te === null || Te.memoizedState.isDehydrated && !(Me.flags & 256) || (Me.flags |= 1024, Ca !== null && (ql(Ca), Ca = null))), Ka(Te, Me), En(Me), null; case 26: if (fa) { Fe = Me.type; var je = Me.memoizedState; return Te === null ? (Wi(Me), je !== null ? (En(Me), Kt(Me, je)) : (En(Me), kt(Me, Fe, Ve))) : je ? je !== Te.memoizedState ? (Wi(Me), En(Me), Kt(Me, je)) : (En(Me), Me.flags &= -16777217) : (ws ? Te.memoizedProps !== Ve && Wi(Me) : at(Te, Me, Fe, Ve), En(Me), kt(Me, Fe, Ve)), null } case 27: if (Ms) { if (gn(Me), Fe = eo.current, je = Me.type, Te !== null && Me.stateNode != null) ws ? Te.memoizedProps !== Ve && Wi(Me) : at(Te, Me, je, Ve); else { if (!Ve) { if (Me.stateNode === null) throw Error(ge(166)); return En(Me), null } Te = Es.current, Gn(Me) ? Xn(Me, Te) : (Te = Vu(je, Ve, Fe, Te, !0), Me.stateNode = Te, Wi(Me)) } return En(Me), null } case 5: if (gn(Me), Fe = Me.type, Te !== null && Me.stateNode != null) at(Te, Me, Fe, Ve); else { if (!Ve) { if (Me.stateNode === null) throw Error(ge(166)); return En(Me), null } Te = Es.current, Gn(Me) ? Xn(Me, Te) : (je = _f(Fe, Ve, eo.current, Te, Me), Na(je, Me, !1, !1), Me.stateNode = je, _u(je, Fe, Ve, Te) && Wi(Me)) } return En(Me), kt(Me, Me.type, Me.pendingProps), null; case 6: if (Te && Me.stateNode != null) Fe = Te.memoizedProps, ws ? Fe !== Ve && Wi(Me) : Qa && (Fe !== Ve ? (Me.stateNode = Eu(Ve, eo.current, Es.current, Me), Wi(Me)) : Me.stateNode = Te.stateNode); else { if (typeof Ve != "string" && Me.stateNode === null) throw Error(ge(166)); if (Te = eo.current, Fe = Es.current, Gn(Me)) { if (!ua) throw Error(ge(176)); if (Te = Me.stateNode, Fe = Me.memoizedProps, Ve = null, je = Us, je !== null) switch (je.tag) { case 27: case 5: Ve = je.memoizedProps }hd(Te, Fe, Me, Ve) || Mn(Me) } else Me.stateNode = Eu(Ve, Te, Fe, Me) } return En(Me), null; case 13: if (Ve = Me.memoizedState, Te === null || Te.memoizedState !== null && Te.memoizedState.dehydrated !== null) { if (je = Gn(Me), Ve !== null && Ve.dehydrated !== null) { if (Te === null) { if (!je) throw Error(ge(318)); if (!ua) throw Error(ge(344)); if (je = Me.memoizedState, je = je !== null ? je.dehydrated : null, !je) throw Error(ge(317)); pd(je, Me) } else wn(), !(Me.flags & 128) && (Me.memoizedState = null), Me.flags |= 4; En(Me), je = !1 } else Ca !== null && (ql(Ca), Ca = null), je = !0; if (!je) return Me.flags & 256 ? (Nr(Me), Me) : (Nr(Me), null) } if (Nr(Me), Me.flags & 128) return Me.lanes = Fe, Me; if (Fe = Ve !== null, Te = Te !== null && Te.memoizedState !== null, Fe) { Ve = Me.child, je = null, Ve.alternate !== null && Ve.alternate.memoizedState !== null && Ve.alternate.memoizedState.cachePool !== null && (je = Ve.alternate.memoizedState.cachePool.pool); var Ke = null; Ve.memoizedState !== null && Ve.memoizedState.cachePool !== null && (Ke = Ve.memoizedState.cachePool.pool), Ke !== je && (Ve.flags |= 2048) } return Fe !== Te && Fe && (Me.child.flags |= 8192), tn(Me, Me.updateQueue), En(Me), null; case 4: return $t(), Ka(Te, Me), Te === null && Af(Me.stateNode.containerInfo), En(Me), null; case 10: return rn(Me.type), En(Me), null; case 19: if (Re(ds), je = Me.memoizedState, je === null) return En(Me), null; if (Ve = (Me.flags & 128) !== 0, Ke = je.rendering, Ke === null) if (Ve) xn(je, !1); else { if (os !== 0 || Te !== null && Te.flags & 128) for (Te = Me.child; Te !== null;) { if (Ke = hs(Te), Ke !== null) { for (Me.flags |= 128, xn(je, !1), Te = Ke.updateQueue, Me.updateQueue = Te, tn(Me, Te), Me.subtreeFlags = 0, Te = Fe, Fe = Me.child; Fe !== null;)ou(Fe, Te), Fe = Fe.sibling; return Ie(ds, ds.current & 1 | 2), Me.child } Te = Te.sibling } je.tail !== null && Sa() > hl && (Me.flags |= 128, Ve = !0, xn(je, !1), Me.lanes = 4194304) } else { if (!Ve) if (Te = hs(Ke), Te !== null) { if (Me.flags |= 128, Ve = !0, Te = Te.updateQueue, Me.updateQueue = Te, tn(Me, Te), xn(je, !0), je.tail === null && je.tailMode === "hidden" && !Ke.alternate && !Ci) return En(Me), null } else 2 * Sa() - je.renderingStartTime > hl && Fe !== 536870912 && (Me.flags |= 128, Ve = !0, xn(je, !1), Me.lanes = 4194304); je.isBackwards ? (Ke.sibling = Me.child, Me.child = Ke) : (Te = je.last, Te !== null ? Te.sibling = Ke : Me.child = Ke, je.last = Ke) } return je.tail !== null ? (Me = je.tail, je.rendering = Me, je.tail = Me.sibling, je.renderingStartTime = Sa(), Me.sibling = null, Te = ds.current, Ie(ds, Ve ? Te & 1 | 2 : Te & 1), Me) : (En(Me), null); case 22: case 23: return Nr(Me), Ai(), Ve = Me.memoizedState !== null, Te !== null ? Te.memoizedState !== null !== Ve && (Me.flags |= 8192) : Ve && (Me.flags |= 8192), Ve ? Fe & 536870912 && !(Me.flags & 128) && (En(Me), Me.subtreeFlags & 6 && (Me.flags |= 8192)) : En(Me), Fe = Me.updateQueue, Fe !== null && tn(Me, Fe.retryQueue), Fe = null, Te !== null && Te.memoizedState !== null && Te.memoizedState.cachePool !== null && (Fe = Te.memoizedState.cachePool.pool), Ve = null, Me.memoizedState !== null && Me.memoizedState.cachePool !== null && (Ve = Me.memoizedState.cachePool.pool), Ve !== Fe && (Me.flags |= 2048), Te !== null && Re(So), null; case 24: return Fe = null, Te !== null && (Fe = Te.memoizedState.cache), Me.memoizedState.cache !== Fe && (Me.flags |= 2048), rn(rs), En(Me), null; case 25: return null }throw Error(ge(156, Me.tag)) } function cr(Te, Me) { switch (ct(Me), Me.tag) { case 1: return Te = Me.flags, Te & 65536 ? (Me.flags = Te & -65537 | 128, Me) : null; case 3: return rn(rs), $t(), Te = Me.flags, Te & 65536 && !(Te & 128) ? (Me.flags = Te & -65537 | 128, Me) : null; case 26: case 27: case 5: return gn(Me), null; case 13: if (Nr(Me), Te = Me.memoizedState, Te !== null && Te.dehydrated !== null) { if (Me.alternate === null) throw Error(ge(340)); wn() } return Te = Me.flags, Te & 65536 ? (Me.flags = Te & -65537 | 128, Me) : null; case 19: return Re(ds), null; case 4: return $t(), null; case 10: return rn(Me.type), null; case 22: case 23: return Nr(Me), Ai(), Te !== null && Re(So), Te = Me.flags, Te & 65536 ? (Me.flags = Te & -65537 | 128, Me) : null; case 24: return rn(rs), null; case 25: return null; default: return null } } function xr(Te, Me) { switch (ct(Me), Me.tag) { case 3: rn(rs), $t(); break; case 26: case 27: case 5: gn(Me); break; case 4: $t(); break; case 13: Nr(Me); break; case 19: Re(ds); break; case 10: rn(Me.type); break; case 22: case 23: Nr(Me), Ai(), Te !== null && Re(So); break; case 24: rn(rs) } } function Cr(Te, Me) { try { var Fe = Me.updateQueue, Ve = Fe !== null ? Fe.lastEffect : null; if (Ve !== null) { var je = Ve.next; Fe = je; do { if ((Fe.tag & Te) === Te) { Ve = void 0; var Ke = Fe.create, zt = Fe.inst; Ve = Ke(), zt.destroy = Ve } Fe = Fe.next } while (Fe !== je) } } catch (hn) { Oi(Me, Me.return, hn) } } function Sr(Te, Me, Fe) { try { var Ve = Me.updateQueue, je = Ve !== null ? Ve.lastEffect : null; if (je !== null) { var Ke = je.next; Ve = Ke; do { if ((Ve.tag & Te) === Te) { var zt = Ve.inst, hn = zt.destroy; if (hn !== void 0) { zt.destroy = void 0, je = Me; var Cn = Fe; try { hn() } catch (tr) { Oi(je, Cn, tr) } } } Ve = Ve.next } while (Ve !== Ke) } } catch (tr) { Oi(Me, Me.return, tr) } } function Or(Te) { var Me = Te.updateQueue; if (Me !== null) { var Fe = Te.stateNode; try { Dn(Me, Fe) } catch (Ve) { Oi(Te, Te.return, Ve) } } } function qr(Te, Me, Fe) { Fe.props = _i(Te.type, Te.memoizedProps), Fe.state = Te.memoizedState; try { Fe.componentWillUnmount() } catch (Ve) { Oi(Te, Me, Ve) } } function ui(Te, Me) { try { var Fe = Te.ref; if (Fe !== null) { var Ve = Te.stateNode; switch (Te.tag) { case 26: case 27: case 5: var je = tl(Ve); break; default: je = Ve }typeof Fe == "function" ? Te.refCleanup = Fe(je) : Fe.current = je } } catch (Ke) { Oi(Te, Me, Ke) } } function Jr(Te, Me) { var Fe = Te.ref, Ve = Te.refCleanup; if (Fe !== null) if (typeof Ve == "function") try { Ve() } catch (je) { Oi(Te, Me, je) } finally { Te.refCleanup = null, Te = Te.alternate, Te != null && (Te.refCleanup = null) } else if (typeof Fe == "function") try { Fe(null) } catch (je) { Oi(Te, Me, je) } else Fe.current = null } function ci(Te) { var Me = Te.type, Fe = Te.memoizedProps, Ve = Te.stateNode; try { zf(Ve, Me, Fe, Te) } catch (je) { Oi(Te, Te.return, je) } } function jr(Te, Me, Fe) { try { Gf(Te.stateNode, Te.type, Fe, Me, Te) } catch (Ve) { Oi(Te, Te.return, Ve) } } function Ur(Te) { return Te.tag === 5 || Te.tag === 3 || (fa ? Te.tag === 26 : !1) || (Ms ? Te.tag === 27 : !1) || Te.tag === 4 } function Pi(Te) { e: for (; ;) { for (; Te.sibling === null;) { if (Te.return === null || Ur(Te.return)) return null; Te = Te.return } for (Te.sibling.return = Te.return, Te = Te.sibling; Te.tag !== 5 && Te.tag !== 6 && (!Ms || Te.tag !== 27) && Te.tag !== 18;) { if (Te.flags & 2 || Te.child === null || Te.tag === 4) continue e; Te.child.return = Te, Te = Te.child } if (!(Te.flags & 2)) return Te.stateNode } } function zi(Te, Me, Fe) { var Ve = Te.tag; if (Ve === 5 || Ve === 6) Te = Te.stateNode, Me ? jf(Fe, Te, Me) : Hf(Fe, Te); else if (!(Ve === 4 || Ms && Ve === 27) && (Te = Te.child, Te !== null)) for (zi(Te, Me, Fe), Te = Te.sibling; Te !== null;)zi(Te, Me, Fe), Te = Te.sibling } function Qi(Te, Me, Fe) { var Ve = Te.tag; if (Ve === 5 || Ve === 6) Te = Te.stateNode, Me ? $f(Fe, Te, Me) : Uf(Fe, Te); else if (!(Ve === 4 || Ms && Ve === 27) && (Te = Te.child, Te !== null)) for (Qi(Te, Me, Fe), Te = Te.sibling; Te !== null;)Qi(Te, Me, Fe), Te = Te.sibling } function Mi(Te, Me, Fe) { Te = Te.containerInfo; try { Mu(Te, Fe) } catch (Ve) { Oi(Me, Me.return, Ve) } } function qi(Te, Me) { for (yf(Te.containerInfo), xs = Me; xs !== null;)if (Te = xs, Me = Te.child, (Te.subtreeFlags & 1028) !== 0 && Me !== null) Me.return = Te, xs = Me; else for (; xs !== null;) { Te = xs; var Fe = Te.alternate; switch (Me = Te.flags, Te.tag) { case 0: break; case 11: case 15: break; case 1: if (Me & 1024 && Fe !== null) { Me = void 0; var Ve = Te, je = Fe.memoizedProps; Fe = Fe.memoizedState; var Ke = Ve.stateNode; try { var zt = _i(Ve.type, je, Ve.elementType === Ve.type); Me = Ke.getSnapshotBeforeUpdate(zt, Fe), Ke.__reactInternalSnapshotBeforeUpdate = Me } catch (hn) { Oi(Ve, Ve.return, hn) } } break; case 3: Me & 1024 && ws && Zf(Te.stateNode.containerInfo); break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if (Me & 1024) throw Error(ge(163)) }if (Me = Te.sibling, Me !== null) { Me.return = Te.return, xs = Me; break } xs = Te.return } return zt = Yu, Yu = !1, zt } function Ss(Te, Me, Fe) { var Ve = Fe.flags; switch (Fe.tag) { case 0: case 11: case 15: _s(Te, Fe), Ve & 4 && Cr(5, Fe); break; case 1: if (_s(Te, Fe), Ve & 4) if (Te = Fe.stateNode, Me === null) try { Te.componentDidMount() } catch (hn) { Oi(Fe, Fe.return, hn) } else { var je = _i(Fe.type, Me.memoizedProps); Me = Me.memoizedState; try { Te.componentDidUpdate(je, Me, Te.__reactInternalSnapshotBeforeUpdate) } catch (hn) { Oi(Fe, Fe.return, hn) } } Ve & 64 && Or(Fe), Ve & 512 && ui(Fe, Fe.return); break; case 3: if (_s(Te, Fe), Ve & 64 && (Ve = Fe.updateQueue, Ve !== null)) { if (Te = null, Fe.child !== null) switch (Fe.child.tag) { case 27: case 5: Te = tl(Fe.child.stateNode); break; case 1: Te = Fe.child.stateNode }try { Dn(Ve, Te) } catch (hn) { Oi(Fe, Fe.return, hn) } } break; case 26: if (fa) { _s(Te, Fe), Ve & 512 && ui(Fe, Fe.return); break } case 27: case 5: _s(Te, Fe), Me === null && Ve & 4 && ci(Fe), Ve & 512 && ui(Fe, Fe.return); break; case 12: _s(Te, Fe); break; case 13: _s(Te, Fe), Ve & 4 && Js(Te, Fe); break; case 22: if (je = Fe.memoizedState !== null || za, !je) { Me = Me !== null && Me.memoizedState !== null || as; var Ke = za, zt = as; za = je, (as = Me) && !zt ? Aa(Te, Fe, (Fe.subtreeFlags & 8772) !== 0) : _s(Te, Fe), za = Ke, as = zt } Ve & 512 && (Fe.memoizedProps.mode === "manual" ? ui(Fe, Fe.return) : Jr(Fe, Fe.return)); break; default: _s(Te, Fe) } } function ms(Te) { var Me = Te.alternate; Me !== null && (Te.alternate = null, ms(Me)), Te.child = null, Te.deletions = null, Te.sibling = null, Te.tag === 5 && (Me = Te.stateNode, Me !== null && Tf(Me)), Te.stateNode = null, Te.return = null, Te.dependencies = null, Te.memoizedProps = null, Te.memoizedState = null, Te.pendingProps = null, Te.stateNode = null, Te.updateQueue = null } function Yi(Te, Me, Fe) { for (Fe = Fe.child; Fe !== null;)Ns(Te, Me, Fe), Fe = Fe.sibling } function Ns(Te, Me, Fe) { if (na && typeof na.onCommitFiberUnmount == "function") try { na.onCommitFiberUnmount(il, Fe) } catch { } switch (Fe.tag) { case 26: if (fa) { as || Jr(Fe, Me), Yi(Te, Me, Fe), Fe.memoizedState ? Fu(Fe.memoizedState) : Fe.stateNode && Uu(Fe.stateNode); break } case 27: if (Ms) { as || Jr(Fe, Me); var Ve = fs, je = ia; fs = Fe.stateNode, Yi(Te, Me, Fe), Bd(Fe.stateNode), fs = Ve, ia = je; break } case 5: as || Jr(Fe, Me); case 6: if (ws) { if (Ve = fs, je = ia, fs = null, Yi(Te, Me, Fe), fs = Ve, ia = je, fs !== null) if (ia) try { Xf(fs, Fe.stateNode) } catch (Ke) { Oi(Fe, Me, Ke) } else try { Wf(fs, Fe.stateNode) } catch (Ke) { Oi(Fe, Me, Ke) } } else Yi(Te, Me, Fe); break; case 18: ws && fs !== null && (ia ? _d(fs, Fe.stateNode) : vd(fs, Fe.stateNode)); break; case 4: ws ? (Ve = fs, je = ia, fs = Fe.stateNode.containerInfo, ia = !0, Yi(Te, Me, Fe), fs = Ve, ia = je) : (Qa && Mi(Fe.stateNode, Fe, Tu()), Yi(Te, Me, Fe)); break; case 0: case 11: case 14: case 15: as || Sr(2, Fe, Me), as || Sr(4, Fe, Me), Yi(Te, Me, Fe); break; case 1: as || (Jr(Fe, Me), Ve = Fe.stateNode, typeof Ve.componentWillUnmount == "function" && qr(Fe, Me, Ve)), Yi(Te, Me, Fe); break; case 21: Yi(Te, Me, Fe); break; case 22: as || Jr(Fe, Me), as = (Ve = as) || Fe.memoizedState !== null, Yi(Te, Me, Fe), as = Ve; break; default: Yi(Te, Me, Fe) } } function Js(Te, Me) { if (ua && Me.memoizedState === null && (Te = Me.alternate, Te !== null && (Te = Te.memoizedState, Te !== null && (Te = Te.dehydrated, Te !== null)))) try { yd(Te) } catch (Fe) { Oi(Me, Me.return, Fe) } } function Fs(Te) { switch (Te.tag) { case 13: case 19: var Me = Te.stateNode; return Me === null && (Me = Te.stateNode = new qu), Me; case 22: return Te = Te.stateNode, Me = Te._retryCache, Me === null && (Me = Te._retryCache = new qu), Me; default: throw Error(ge(435, Te.tag)) } } function Cs(Te, Me) { var Fe = Fs(Te); Me.forEach(function (Ve) { var je = sf.bind(null, Te, Ve); Fe.has(Ve) || (Fe.add(Ve), Ve.then(je, je)) }) } function Gi(Te, Me) { var Fe = Me.deletions; if (Fe !== null) for (var Ve = 0; Ve < Fe.length; Ve++) { var je = Fe[Ve], Ke = Te, zt = Me; if (ws) { var hn = zt; e: for (; hn !== null;) { switch (hn.tag) { case 27: case 5: fs = hn.stateNode, ia = !1; break e; case 3: fs = hn.stateNode.containerInfo, ia = !0; break e; case 4: fs = hn.stateNode.containerInfo, ia = !0; break e }hn = hn.return } if (fs === null) throw Error(ge(160)); Ns(Ke, zt, je), fs = null, ia = !1 } else Ns(Ke, zt, je); Ke = je.alternate, Ke !== null && (Ke.return = null), je.return = null } if (Me.subtreeFlags & 13878) for (Me = Me.child; Me !== null;)Zs(Me, Te), Me = Me.sibling } function Zs(Te, Me) { var Fe = Te.alternate, Ve = Te.flags; switch (Te.tag) { case 0: case 11: case 14: case 15: Gi(Me, Te), Li(Te), Ve & 4 && (Sr(3, Te, Te.return), Cr(3, Te), Sr(5, Te, Te.return)); break; case 1: Gi(Me, Te), Li(Te), Ve & 512 && (as || Fe === null || Jr(Fe, Fe.return)), Ve & 64 && za && (Te = Te.updateQueue, Te !== null && (Ve = Te.callbacks, Ve !== null && (Fe = Te.shared.hiddenCallbacks, Te.shared.hiddenCallbacks = Fe === null ? Ve : Fe.concat(Ve)))); break; case 26: if (fa) { var je = Ta; Gi(Me, Te), Li(Te), Ve & 512 && (as || Fe === null || Jr(Fe, Fe.return)), Ve & 4 && (Ve = Fe !== null ? Fe.memoizedState : null, Me = Te.memoizedState, Fe === null ? Me === null ? Te.stateNode === null ? Te.stateNode = Ad(je, Te.type, Te.memoizedProps, Te) : ku(je, Te.type, Te.stateNode) : Te.stateNode = Nu(je, Me, Te.memoizedProps) : Ve !== Me ? (Ve === null ? Fe.stateNode !== null && Uu(Fe.stateNode) : Fu(Ve), Me === null ? ku(je, Te.type, Te.stateNode) : Nu(je, Me, Te.memoizedProps)) : Me === null && Te.stateNode !== null && jr(Te, Te.memoizedProps, Fe.memoizedProps)); break } case 27: if (Ms && Ve & 4 && Te.alternate === null) { je = Te.stateNode; var Ke = Te.memoizedProps; try { Md(je), Rd(Te.type, Ke, je, Te) } catch (vr) { Oi(Te, Te.return, vr) } } case 5: if (Gi(Me, Te), Li(Te), Ve & 512 && (as || Fe === null || Jr(Fe, Fe.return)), ws) { if (Te.flags & 32) { Me = Te.stateNode; try { Cu(Me) } catch (vr) { Oi(Te, Te.return, vr) } } Ve & 4 && Te.stateNode != null && (Me = Te.memoizedProps, jr(Te, Me, Fe !== null ? Fe.memoizedProps : Me)), Ve & 1024 && (Dc = !0) } break; case 6: if (Gi(Me, Te), Li(Te), Ve & 4 && ws) { if (Te.stateNode === null) throw Error(ge(162)); Ve = Te.memoizedProps, Fe = Fe !== null ? Fe.memoizedProps : Ve, Me = Te.stateNode; try { Vf(Me, Fe, Ve) } catch (vr) { Oi(Te, Te.return, vr) } } break; case 3: if (fa ? (Cd(), je = Ta, Ta = xc(Me.containerInfo), Gi(Me, Te), Ta = je) : Gi(Me, Te), Li(Te), Ve & 4) { if (ws && ua && Fe !== null && Fe.memoizedState.isDehydrated) try { xd(Me.containerInfo) } catch (vr) { Oi(Te, Te.return, vr) } if (Qa) { Ve = Me.containerInfo, Fe = Me.pendingChildren; try { Mu(Ve, Fe) } catch (vr) { Oi(Te, Te.return, vr) } } } Dc && (Dc = !1, Ts(Te)); break; case 4: fa ? (Fe = Ta, Ta = xc(Te.stateNode.containerInfo), Gi(Me, Te), Li(Te), Ta = Fe) : (Gi(Me, Te), Li(Te)), Ve & 4 && Qa && Mi(Te.stateNode, Te, Te.stateNode.pendingChildren); break; case 12: Gi(Me, Te), Li(Te); break; case 13: Gi(Me, Te), Li(Te), Te.child.flags & 8192 && Te.memoizedState !== null != (Fe !== null && Fe.memoizedState !== null) && (Oc = Sa()), Ve & 4 && (Ve = Te.updateQueue, Ve !== null && (Te.updateQueue = null, Cs(Te, Ve))); break; case 22: Ve & 512 && (as || Fe === null || Jr(Fe, Fe.return)), je = Te.memoizedState !== null; var zt = Fe !== null && Fe.memoizedState !== null, hn = za, Cn = as; if (za = hn || je, as = Cn || zt, Gi(Me, Te), as = Cn, za = hn, Li(Te), Me = Te.stateNode, Me._current = Te, Me._visibility &= -3, Me._visibility |= Me._pendingVisibility & 2, Ve & 8192 && (Me._visibility = je ? Me._visibility & -2 : Me._visibility | 1, je && (Me = za || as, Fe === null || zt || Me || ns(Te)), ws && (Te.memoizedProps === null || Te.memoizedProps.mode !== "manual"))) { e: if (Fe = null, ws) for (Me = Te; ;) { if (Me.tag === 5 || fa && Me.tag === 26 || Ms && Me.tag === 27) { if (Fe === null) { zt = Fe = Me; try { Ke = zt.stateNode, je ? Kf(Ke) : Yf(zt.stateNode, zt.memoizedProps) } catch (vr) { Oi(zt, zt.return, vr) } } } else if (Me.tag === 6) { if (Fe === null) { zt = Me; try { var tr = zt.stateNode; je ? qf(tr) : Jf(tr, zt.memoizedProps) } catch (vr) { Oi(zt, zt.return, vr) } } } else if ((Me.tag !== 22 && Me.tag !== 23 || Me.memoizedState === null || Me === Te) && Me.child !== null) { Me.child.return = Me, Me = Me.child; continue } if (Me === Te) break e; for (; Me.sibling === null;) { if (Me.return === null || Me.return === Te) break e; Fe === Me && (Fe = null), Me = Me.return } Fe === Me && (Fe = null), Me.sibling.return = Me.return, Me = Me.sibling } } Ve & 4 && (Ve = Te.updateQueue, Ve !== null && (Fe = Ve.retryQueue, Fe !== null && (Ve.retryQueue = null, Cs(Te, Fe)))); break; case 19: Gi(Me, Te), Li(Te), Ve & 4 && (Ve = Te.updateQueue, Ve !== null && (Te.updateQueue = null, Cs(Te, Ve))); break; case 21: break; default: Gi(Me, Te), Li(Te) } } function Li(Te) { var Me = Te.flags; if (Me & 2) { try { if (ws && (!Ms || Te.tag !== 27)) { e: { for (var Fe = Te.return; Fe !== null;) { if (Ur(Fe)) { var Ve = Fe; break e } Fe = Fe.return } throw Error(ge(160)) } switch (Ve.tag) { case 27: if (Ms) { var je = Ve.stateNode, Ke = Pi(Te); Qi(Te, Ke, je); break } case 5: var zt = Ve.stateNode; Ve.flags & 32 && (Cu(zt), Ve.flags &= -33); var hn = Pi(Te); Qi(Te, hn, zt); break; case 3: case 4: var Cn = Ve.stateNode.containerInfo, tr = Pi(Te); zi(Te, tr, Cn); break; default: throw Error(ge(161)) } } } catch (vr) { Oi(Te, Te.return, vr) } Te.flags &= -3 } Me & 4096 && (Te.flags &= -4097) } function Ts(Te) { if (Te.subtreeFlags & 1024) for (Te = Te.child; Te !== null;) { var Me = Te; Ts(Me), Me.tag === 5 && Me.flags & 1024 && Bf(Me.stateNode), Te = Te.sibling } } function _s(Te, Me) { if (Me.subtreeFlags & 8772) for (Me = Me.child; Me !== null;)Ss(Te, Me.alternate, Me), Me = Me.sibling } function ns(Te) { for (Te = Te.child; Te !== null;) { var Me = Te; switch (Me.tag) { case 0: case 11: case 14: case 15: Sr(4, Me, Me.return), ns(Me); break; case 1: Jr(Me, Me.return); var Fe = Me.stateNode; typeof Fe.componentWillUnmount == "function" && qr(Me, Me.return, Fe), ns(Me); break; case 26: case 27: case 5: Jr(Me, Me.return), ns(Me); break; case 22: Jr(Me, Me.return), Me.memoizedState === null && ns(Me); break; default: ns(Me) }Te = Te.sibling } } function Aa(Te, Me, Fe) { for (Fe = Fe && (Me.subtreeFlags & 8772) !== 0, Me = Me.child; Me !== null;) { var Ve = Me.alternate, je = Te, Ke = Me, zt = Ke.flags; switch (Ke.tag) { case 0: case 11: case 15: Aa(je, Ke, Fe), Cr(4, Ke); break; case 1: if (Aa(je, Ke, Fe), Ve = Ke, je = Ve.stateNode, typeof je.componentDidMount == "function") try { je.componentDidMount() } catch (tr) { Oi(Ve, Ve.return, tr) } if (Ve = Ke, je = Ve.updateQueue, je !== null) { var hn = Ve.stateNode; try { var Cn = je.shared.hiddenCallbacks; if (Cn !== null) for (je.shared.hiddenCallbacks = null, je = 0; je < Cn.length; je++)mn(Cn[je], hn) } catch (tr) { Oi(Ve, Ve.return, tr) } } Fe && zt & 64 && Or(Ke), ui(Ke, Ke.return); break; case 26: case 27: case 5: Aa(je, Ke, Fe), Fe && Ve === null && zt & 4 && ci(Ke), ui(Ke, Ke.return); break; case 12: Aa(je, Ke, Fe); break; case 13: Aa(je, Ke, Fe), Fe && zt & 4 && Js(je, Ke); break; case 22: Ke.memoizedState === null && Aa(je, Ke, Fe), ui(Ke, Ke.return); break; default: Aa(je, Ke, Fe) }Me = Me.sibling } } function Gl(Te, Me) { var Fe = null; Te !== null && Te.memoizedState !== null && Te.memoizedState.cachePool !== null && (Fe = Te.memoizedState.cachePool.pool), Te = null, Me.memoizedState !== null && Me.memoizedState.cachePool !== null && (Te = Me.memoizedState.cachePool.pool), Te !== Fe && (Te != null && Te.refCount++, Fe != null && Kr(Fe)) } function $l(Te, Me) { Te = null, Me.alternate !== null && (Te = Me.alternate.memoizedState.cache), Me = Me.memoizedState.cache, Me !== Te && (Me.refCount++, Te != null && Kr(Te)) } function qa(Te, Me, Fe, Ve) { if (Me.subtreeFlags & 10256) for (Me = Me.child; Me !== null;)Hc(Te, Me, Fe, Ve), Me = Me.sibling } function Hc(Te, Me, Fe, Ve) { var je = Me.flags; switch (Me.tag) { case 0: case 11: case 15: qa(Te, Me, Fe, Ve), je & 2048 && Cr(9, Me); break; case 3: qa(Te, Me, Fe, Ve), je & 2048 && (Te = null, Me.alternate !== null && (Te = Me.alternate.memoizedState.cache), Me = Me.memoizedState.cache, Me !== Te && (Me.refCount++, Te != null && Kr(Te))); break; case 12: if (je & 2048) { qa(Te, Me, Fe, Ve), Te = Me.stateNode; try { var Ke = Me.memoizedProps, zt = Ke.id, hn = Ke.onPostCommit; typeof hn == "function" && hn(zt, Me.alternate === null ? "mount" : "update", Te.passiveEffectDuration, -0) } catch (Cn) { Oi(Me, Me.return, Cn) } } else qa(Te, Me, Fe, Ve); break; case 23: break; case 22: Ke = Me.stateNode, Me.memoizedState !== null ? Ke._visibility & 4 ? qa(Te, Me, Fe, Ve) : Qo(Te, Me) : Ke._visibility & 4 ? qa(Te, Me, Fe, Ve) : (Ke._visibility |= 4, Ro(Te, Me, Fe, Ve, (Me.subtreeFlags & 10256) !== 0)), je & 2048 && Gl(Me.alternate, Me); break; case 24: qa(Te, Me, Fe, Ve), je & 2048 && $l(Me.alternate, Me); break; default: qa(Te, Me, Fe, Ve) } } function Ro(Te, Me, Fe, Ve, je) { for (je = je && (Me.subtreeFlags & 10256) !== 0, Me = Me.child; Me !== null;) { var Ke = Te, zt = Me, hn = Fe, Cn = Ve, tr = zt.flags; switch (zt.tag) { case 0: case 11: case 15: Ro(Ke, zt, hn, Cn, je), Cr(8, zt); break; case 23: break; case 22: var vr = zt.stateNode; zt.memoizedState !== null ? vr._visibility & 4 ? Ro(Ke, zt, hn, Cn, je) : Qo(Ke, zt) : (vr._visibility |= 4, Ro(Ke, zt, hn, Cn, je)), je && tr & 2048 && Gl(zt.alternate, zt); break; case 24: Ro(Ke, zt, hn, Cn, je), je && tr & 2048 && $l(zt.alternate, zt); break; default: Ro(Ke, zt, hn, Cn, je) }Me = Me.sibling } } function Qo(Te, Me) { if (Me.subtreeFlags & 10256) for (Me = Me.child; Me !== null;) { var Fe = Te, Ve = Me, je = Ve.flags; switch (Ve.tag) { case 22: Qo(Fe, Ve), je & 2048 && Gl(Ve.alternate, Ve); break; case 24: Qo(Fe, Ve), je & 2048 && $l(Ve.alternate, Ve); break; default: Qo(Fe, Ve) }Me = Me.sibling } } function ho(Te) { if (Te.subtreeFlags & qo) for (Te = Te.child; Te !== null;)Vc(Te), Te = Te.sibling } function Vc(Te) { switch (Te.tag) { case 26: ho(Te), Te.flags & qo && (Te.memoizedState !== null ? wd(Ta, Te.memoizedState, Te.memoizedProps) : Su(Te.type, Te.memoizedProps)); break; case 5: ho(Te), Te.flags & qo && Su(Te.type, Te.memoizedProps); break; case 3: case 4: if (fa) { var Me = Ta; Ta = xc(Te.stateNode.containerInfo), ho(Te), Ta = Me } else ho(Te); break; case 22: Te.memoizedState === null && (Me = Te.alternate, Me !== null && Me.memoizedState !== null ? (Me = qo, qo = 16777216, ho(Te), qo = Me) : ho(Te)); break; default: ho(Te) } } function zc(Te) { var Me = Te.alternate; if (Me !== null && (Te = Me.child, Te !== null)) { Me.child = null; do Me = Te.sibling, Te.sibling = null, Te = Me; while (Te !== null) } } function el(Te) { var Me = Te.deletions; if (Te.flags & 16) { if (Me !== null) for (var Fe = 0; Fe < Me.length; Fe++) { var Ve = Me[Fe]; xs = Ve, $c(Ve, Te) } zc(Te) } if (Te.subtreeFlags & 10256) for (Te = Te.child; Te !== null;)Gc(Te), Te = Te.sibling } function Gc(Te) { switch (Te.tag) { case 0: case 11: case 15: el(Te), Te.flags & 2048 && Sr(9, Te, Te.return); break; case 3: el(Te); break; case 12: el(Te); break; case 22: var Me = Te.stateNode; Te.memoizedState !== null && Me._visibility & 4 && (Te.return === null || Te.return.tag !== 13) ? (Me._visibility &= -5, xl(Te)) : el(Te); break; default: el(Te) } } function xl(Te) { var Me = Te.deletions; if (Te.flags & 16) { if (Me !== null) for (var Fe = 0; Fe < Me.length; Fe++) { var Ve = Me[Fe]; xs = Ve, $c(Ve, Te) } zc(Te) } for (Te = Te.child; Te !== null;) { switch (Me = Te, Me.tag) { case 0: case 11: case 15: Sr(8, Me, Me.return), xl(Me); break; case 22: Fe = Me.stateNode, Fe._visibility & 4 && (Fe._visibility &= -5, xl(Me)); break; default: xl(Me) }Te = Te.sibling } } function $c(Te, Me) { for (; xs !== null;) { var Fe = xs; switch (Fe.tag) { case 0: case 11: case 15: Sr(8, Fe, Me); break; case 23: case 22: if (Fe.memoizedState !== null && Fe.memoizedState.cachePool !== null) { var Ve = Fe.memoizedState.cachePool.pool; Ve != null && Ve.refCount++ } break; case 24: Kr(Fe.memoizedState.cache) }if (Ve = Fe.child, Ve !== null) Ve.return = Fe, xs = Ve; else e: for (Fe = Te; xs !== null;) { Ve = xs; var je = Ve.sibling, Ke = Ve.return; if (ms(Ve), Ve === Fe) { xs = null; break e } if (je !== null) { je.return = Ke, xs = je; break e } xs = Ke } } } function jl(Te) { var Me = bu(Te); if (Me != null) { if (typeof Me.memoizedProps["data-testname"] != "string") throw Error(ge(364)); return Me } if (Te = Pf(Te), Te === null) throw Error(ge(362)); return Te.stateNode.current } function Wl(Te, Me) { var Fe = Te.tag; switch (Me.$$typeof) { case Nl: if (Te.type === Me.value) return !0; break; case Fl: e: { for (Me = Me.value, Te = [Te, 0], Fe = 0; Fe < Te.length;) { var Ve = Te[Fe++], je = Ve.tag, Ke = Te[Fe++], zt = Me[Ke]; if (je !== 5 && je !== 26 && je !== 27 || !rl(Ve)) { for (; zt != null && Wl(Ve, zt);)Ke++, zt = Me[Ke]; if (Ke === Me.length) { Me = !0; break e } else for (Ve = Ve.child; Ve !== null;)Te.push(Ve, Ke), Ve = Ve.sibling } } Me = !1 } return Me; case kl: if ((Fe === 5 || Fe === 26 || Fe === 27) && Nf(Te.stateNode, Me.value)) return !0; break; case Hl: if ((Fe === 5 || Fe === 6 || Fe === 26 || Fe === 27) && (Te = Of(Te), Te !== null && 0 <= Te.indexOf(Me.value))) return !0; break; case Ul: if ((Fe === 5 || Fe === 26 || Fe === 27) && (Te = Te.memoizedProps["data-testname"], typeof Te == "string" && Te.toLowerCase() === Me.value.toLowerCase())) return !0; break; default: throw Error(ge(365)) }return !1 } function Xl(Te) { switch (Te.$$typeof) { case Nl: return "<" + (ye(Te.value) || "Unknown") + ">"; case Fl: return ":has(" + (Xl(Te) || "") + ")"; case kl: return '[role="' + Te.value + '"]'; case Hl: return '"' + Te.value + '"'; case Ul: return '[data-testname="' + Te.value + '"]'; default: throw Error(ge(365)) } } function jc(Te, Me) { var Fe = []; Te = [Te, 0]; for (var Ve = 0; Ve < Te.length;) { var je = Te[Ve++], Ke = je.tag, zt = Te[Ve++], hn = Me[zt]; if (Ke !== 5 && Ke !== 26 && Ke !== 27 || !rl(je)) { for (; hn != null && Wl(je, hn);)zt++, hn = Me[zt]; if (zt === Me.length) Fe.push(je); else for (je = je.child; je !== null;)Te.push(je, zt), je = je.sibling } } return Fe } function Kl(Te, Me) { if (!nl) throw Error(ge(363)); Te = jl(Te), Te = jc(Te, Me), Me = [], Te = Array.from(Te); for (var Fe = 0; Fe < Te.length;) { var Ve = Te[Fe++], je = Ve.tag; if (je === 5 || je === 26 || je === 27) rl(Ve) || Me.push(Ve.stateNode); else for (Ve = Ve.child; Ve !== null;)Te.push(Ve), Ve = Ve.sibling } return Me } function Qs() { if (Ui & 2 && Ei !== 0) return Ei & -Ei; if (Qr.T !== null) { var Te = zo; return Te !== 0 ? Te : un() } return Sf() } function Wc() { ga === 0 && (ga = !(Ei & 536870912) || Ci ? He() : 536870912); var Te = ma.current; return Te !== null && (Te.flags |= 32), ga } function ks(Te, Me, Fe) { (Te === $i && ji === 2 || Te.cancelPendingCommit !== null) && (Bo(Te, 0), Fa(Te, Ei, ga, !1)), We(Te, Fe), (!(Ui & 2) || Te !== $i) && (Te === $i && (!(Ui & 2) && (Co |= Fe), os === 4 && Fa(Te, Ei, ga, !1)), kn(Te)) } function Xc(Te, Me, Fe) { if (Ui & 6) throw Error(ge(327)); var Ve = !Fe && (Me & 60) === 0 && (Me & Te.expiredLanes) === 0 || Oe(Te, Me), je = Ve ? Qu(Te, Me) : Zl(Te, Me, !0), Ke = Ve; do { if (je === 0) { Yo && !Ve && Fa(Te, Me, 0, !1); break } else if (je === 6) Fa(Te, Me, 0, !Ga); else { if (Fe = Te.current.alternate, Ke && !Ju(Fe)) { je = Zl(Te, Me, !1), Ke = !1; continue } if (je === 2) { if (Ke = Me, Te.errorRecoveryDisabledLanes & Ke) var zt = 0; else zt = Te.pendingLanes & -536870913, zt = zt !== 0 ? zt : zt & 536870912 ? 536870912 : 0; if (zt !== 0) { Me = zt; e: { var hn = Te; je = dl; var Cn = ua && hn.current.memoizedState.isDehydrated; if (Cn && (Bo(hn, zt).flags |= 256), zt = Zl(hn, zt, !1), zt !== 2) { if (Ic && !Cn) { hn.errorRecoveryDisabledLanes |= Ke, Co |= Ke, je = 4; break e } Ke = Ia, Ia = je, Ke !== null && ql(Ke) } je = zt } if (Ke = !1, je !== 2) continue } } if (je === 1) { Bo(Te, 0), Fa(Te, Me, 0, !0); break } e: { switch (Ve = Te, je) { case 0: case 1: throw Error(ge(345)); case 4: if ((Me & 4194176) === Me) { Fa(Ve, Me, ga, !Ga); break e } break; case 2: Ia = null; break; case 3: case 5: break; default: throw Error(ge(329)) }if (Ve.finishedWork = Fe, Ve.finishedLanes = Me, (Me & 62914560) === Me && (Ke = Oc + 300 - Sa(), 10 < Ke)) { if (Fa(Ve, Me, ga, !Ga), ke(Ve, 0) !== 0) break e; Ve.timeoutHandle = Ef(Kc.bind(null, Ve, Fe, Ia, Vl, Lc, Me, ga, Co, Jo, Ga, 2, -0, 0), Ke); break e } Kc(Ve, Fe, Ia, Vl, Lc, Me, ga, Co, Jo, Ga, 0, -0, 0) } } break } while (!0); kn(Te) } function ql(Te) { Ia === null ? Ia = Te : Ia.push.apply(Ia, Te) } function Kc(Te, Me, Fe, Ve, je, Ke, zt, hn, Cn, tr, vr, Mr, Pr) { var si = Me.subtreeFlags; if ((si & 8192 || (si & 16785408) === 16785408) && (Mf(), Vc(Me), Me = Rf(), Me !== null)) { Te.cancelPendingCommit = Me(ru.bind(null, Te, Fe, Ve, je, zt, hn, Cn, 1, Mr, Pr)), Fa(Te, Ke, zt, !tr); return } ru(Te, Fe, Ve, je, zt, hn, Cn, vr, Mr, Pr) } function Ju(Te) { for (var Me = Te; ;) { var Fe = Me.tag; if ((Fe === 0 || Fe === 11 || Fe === 15) && Me.flags & 16384 && (Fe = Me.updateQueue, Fe !== null && (Fe = Fe.stores, Fe !== null))) for (var Ve = 0; Ve < Fe.length; Ve++) { var je = Fe[Ve], Ke = je.getSnapshot; je = je.value; try { if (!ra(Ke(), je)) return !1 } catch { return !1 } } if (Fe = Me.child, Me.subtreeFlags & 16384 && Fe !== null) Fe.return = Me, Me = Fe; else { if (Me === Te) break; for (; Me.sibling === null;) { if (Me.return === null || Me.return === Te) return !0; Me = Me.return } Me.sibling.return = Me.return, Me = Me.sibling } } return !0 } function Fa(Te, Me, Fe, Ve) { Me &= ~Pc, Me &= ~Co, Te.suspendedLanes |= Me, Te.pingedLanes &= ~Me, Ve && (Te.warmLanes |= Me), Ve = Te.expirationTimes; for (var je = Me; 0 < je;) { var Ke = 31 - ta(je), zt = 1 << Ke; Ve[Ke] = -1, je &= ~zt } Fe !== 0 && Ye(Te, Fe, Me) } function qc() { return Ui & 6 ? !0 : (Ht(0), !1) } function Yl() { if (pi !== null) { if (ji === 0) var Te = pi.return; else Te = pi, Va = Ao = null, Jn(Te), jo = null, ll = 0, Te = pi; for (; Te !== null;)xr(Te.alternate, Te), Te = Te.return; pi = null } } function Bo(Te, Me) { Te.finishedWork = null, Te.finishedLanes = 0; var Fe = Te.timeoutHandle; Fe !== pc && (Te.timeoutHandle = pc, bf(Fe)), Fe = Te.cancelPendingCommit, Fe !== null && (Te.cancelPendingCommit = null, Fe()), Yl(), $i = Te, pi = Fe = Ya(Te.current, null), Ei = Me, ji = 0, sa = null, Ga = !1, Yo = Oe(Te, Me), Ic = !1, Jo = ga = Pc = Co = io = os = 0, Ia = dl = null, Lc = !1, Me & 8 && (Me |= Me & 32); var Ve = Te.entangledLanes; if (Ve !== 0) for (Te = Te.entanglements, Ve &= Me; 0 < Ve;) { var je = 31 - ta(Ve), Ke = 1 << je; Me |= Te[je], Ve &= ~Ke } return $a = Me, Gt(), Fe } function Yc(Te, Me) { fi = null, Qr.H = Da, Me === ol ? (Me = dr(), ji = 3) : Me === wc ? (Me = dr(), ji = 4) : ji = Me === Xu ? 8 : Me !== null && typeof Me == "object" && typeof Me.then == "function" ? 6 : 1, sa = Me, pi === null && (os = 1, Xs(Te, Nt(Me, Te.current))) } function Jc() { var Te = ma.current; return Te === null ? !0 : (Ei & 4194176) === Ei ? Ba === null : (Ei & 62914560) === Ei || Ei & 536870912 ? Te === Ba : !1 } function Zc() { var Te = Qr.H; return Qr.H = Da, Te === null ? Da : Te } function Qc() { var Te = Qr.A; return Qr.A = $d, Te } function Jl() { os = 4, Ga || (Ei & 4194176) !== Ei && ma.current !== null || (Yo = !0), !(io & 134217727) && !(Co & 134217727) || $i === null || Fa($i, Ei, ga, !1) } function Zl(Te, Me, Fe) { var Ve = Ui; Ui |= 2; var je = Zc(), Ke = Qc(); ($i !== Te || Ei !== Me) && (Vl = null, Bo(Te, Me)), Me = !1; var zt = os; e: do try { if (ji !== 0 && pi !== null) { var hn = pi, Cn = sa; switch (ji) { case 8: Yl(), zt = 6; break e; case 3: case 2: case 6: ma.current === null && (Me = !0); var tr = ji; if (ji = 0, sa = null, Do(Te, hn, Cn, tr), Fe && Yo) { zt = 0; break e } break; default: tr = ji, ji = 0, sa = null, Do(Te, hn, Cn, tr) } } Zu(), zt = os; break } catch (vr) { Yc(Te, vr) } while (!0); return Me && Te.shellSuspendCounter++, Va = Ao = null, Ui = Ve, Qr.H = je, Qr.A = Ke, pi === null && ($i = null, Ei = 0, Gt()), zt } function Zu() { for (; pi !== null;)eu(pi) } function Qu(Te, Me) { var Fe = Ui; Ui |= 2; var Ve = Zc(), je = Qc(); $i !== Te || Ei !== Me ? (Vl = null, hl = Sa() + 500, Bo(Te, Me)) : Yo = Oe(Te, Me); e: do try { if (ji !== 0 && pi !== null) { Me = pi; var Ke = sa; t: switch (ji) { case 1: ji = 0, sa = null, Do(Te, Me, Ke, 1); break; case 2: if (qn(Ke)) { ji = 0, sa = null, tu(Me); break } Me = function () { ji === 2 && $i === Te && (ji = 7), kn(Te) }, Ke.then(Me, Me); break e; case 3: ji = 7; break e; case 4: ji = 5; break e; case 7: qn(Ke) ? (ji = 0, sa = null, tu(Me)) : (ji = 0, sa = null, Do(Te, Me, Ke, 7)); break; case 5: var zt = null; switch (pi.tag) { case 26: zt = pi.memoizedState; case 5: case 27: var hn = pi, Cn = hn.type, tr = hn.pendingProps; if (zt ? Hu(zt) : Au(Cn, tr)) { ji = 0, sa = null; var vr = hn.sibling; if (vr !== null) pi = vr; else { var Mr = hn.return; Mr !== null ? (pi = Mr, yl(Mr)) : pi = null } break t } }ji = 0, sa = null, Do(Te, Me, Ke, 5); break; case 6: ji = 0, sa = null, Do(Te, Me, Ke, 6); break; case 8: Yl(), os = 6; break e; default: throw Error(ge(462)) } } ef(); break } catch (Pr) { Yc(Te, Pr) } while (!0); return Va = Ao = null, Qr.H = Ve, Qr.A = je, Ui = Fe, pi !== null ? 0 : ($i = null, Ei = 0, Gt(), os) } function ef() { for (; pi !== null && !Pd();)eu(pi) } function eu(Te) { var Me = Et(Te.alternate, Te, $a); Te.memoizedProps = Te.pendingProps, Me === null ? yl(Te) : pi = Me } function tu(Te) { var Me = Te, Fe = Me.alternate; switch (Me.tag) { case 15: case 0: Me = Is(Fe, Me, Me.pendingProps, Me.type, void 0, Ei); break; case 11: Me = Is(Fe, Me, Me.pendingProps, Me.type.render, Me.ref, Ei); break; case 5: Jn(Me); default: xr(Fe, Me), Me = pi = ou(Me, $a), Me = Et(Fe, Me, $a) }Te.memoizedProps = Te.pendingProps, Me === null ? yl(Te) : pi = Me } function Do(Te, Me, Fe, Ve) { Va = Ao = null, Jn(Me), jo = null, ll = 0; var je = Me.return; try { if (Zo(Te, je, Me, Fe, Ei)) { os = 1, Xs(Te, Nt(Fe, Te.current)), pi = null; return } } catch (Ke) { if (je !== null) throw pi = je, Ke; os = 1, Xs(Te, Nt(Fe, Te.current)), pi = null; return } Me.flags & 32768 ? (Ci || Ve === 1 ? Te = !0 : Yo || Ei & 536870912 ? Te = !1 : (Ga = Te = !0, (Ve === 2 || Ve === 3 || Ve === 6) && (Ve = ma.current, Ve !== null && Ve.tag === 13 && (Ve.flags |= 16384))), nu(Me, Te)) : yl(Me) } function yl(Te) { var Me = Te; do { if (Me.flags & 32768) { nu(Me, Ga); return } Te = Me.return; var Fe = er(Me.alternate, Me, $a); if (Fe !== null) { pi = Fe; return } if (Me = Me.sibling, Me !== null) { pi = Me; return } pi = Me = Te } while (Me !== null); os === 0 && (os = 5) } function nu(Te, Me) { do { var Fe = cr(Te.alternate, Te); if (Fe !== null) { Fe.flags &= 32767, pi = Fe; return } if (Fe = Te.return, Fe !== null && (Fe.flags |= 32768, Fe.subtreeFlags = 0, Fe.deletions = null), !Me && (Te = Te.sibling, Te !== null)) { pi = Te; return } pi = Te = Fe } while (Te !== null); os = 6, pi = null } function ru(Te, Me, Fe, Ve, je, Ke, zt, hn, Cn, tr) { var vr = Qr.T, Mr = go(); try { zs(2), Qr.T = null, tf(Te, Me, Fe, Ve, Mr, je, Ke, zt, hn, Cn, tr) } finally { Qr.T = vr, zs(Mr) } } function tf(Te, Me, Fe, Ve, je, Ke, zt, hn) { do po(); while (To !== null); if (Ui & 6) throw Error(ge(327)); var Cn = Te.finishedWork; if (Ve = Te.finishedLanes, Cn === null) return null; if (Te.finishedWork = null, Te.finishedLanes = 0, Cn === Te.current) throw Error(ge(177)); Te.callbackNode = null, Te.callbackPriority = 0, Te.cancelPendingCommit = null; var tr = Cn.lanes | Cn.childLanes; if (tr |= bc, Xe(Te, Ve, tr, Ke, zt, hn), Te === $i && (pi = $i = null, Ei = 0), !(Cn.subtreeFlags & 10256) && !(Cn.flags & 10256) || zl || (zl = !0, Nc = tr, Fc = Fe, af(_c, function () { return po(), null })), Fe = (Cn.flags & 15990) !== 0, Cn.subtreeFlags & 15990 || Fe ? (Fe = Qr.T, Qr.T = null, Ke = go(), zs(2), zt = Ui, Ui |= 4, qi(Te, Cn), Zs(Cn, Te), vf(Te.containerInfo), Te.current = Cn, Ss(Te, Cn.alternate, Cn), Ld(), Ui = zt, zs(Ke), Qr.T = Fe) : Te.current = Cn, zl ? (zl = !1, To = Te, pl = Ve) : iu(Te, tr), tr = Te.pendingLanes, tr === 0 && (so = null), qe(Cn.stateNode), kn(Te), Me !== null) for (je = Te.onRecoverableError, Cn = 0; Cn < Me.length; Cn++)tr = Me[Cn], je(tr.value, { componentStack: tr.stack }); return pl & 3 && po(), tr = Te.pendingLanes, Ve & 4194218 && tr & 42 ? Te === kc ? ml++ : (ml = 0, kc = Te) : ml = 0, Ht(0), null } function iu(Te, Me) { (Te.pooledCacheLanes &= Me) === 0 && (Me = Te.pooledCache, Me != null && (Te.pooledCache = null, Kr(Me))) } function po() { if (To !== null) { var Te = To, Me = Nc; Nc = 0; var Fe = ot(pl), Ve = 32 > Fe ? 32 : Fe; Fe = Qr.T; var je = go(); try { if (zs(Ve), Qr.T = null, To === null) var Ke = !1; else { Ve = Fc, Fc = null; var zt = To, hn = pl; if (To = null, pl = 0, Ui & 6) throw Error(ge(331)); var Cn = Ui; if (Ui |= 4, Gc(zt.current), Hc(zt, zt.current, hn, Ve), Ui = Cn, Ht(0, !1), na && typeof na.onPostCommitFiberRoot == "function") try { na.onPostCommitFiberRoot(il, zt) } catch { } Ke = !0 } return Ke } finally { zs(je), Qr.T = Fe, iu(Te, Me) } } return !1 } function su(Te, Me, Fe) { Me = Nt(Fe, Me), Me = oo(Te.stateNode, Me, 2), Te = Yn(Te, Me, 2), Te !== null && (We(Te, 2), kn(Te)) } function Oi(Te, Me, Fe) { if (Te.tag === 3) su(Te, Te, Fe); else for (; Me !== null;) { if (Me.tag === 3) { su(Me, Te, Fe); break } else if (Me.tag === 1) { var Ve = Me.stateNode; if (typeof Me.type.getDerivedStateFromError == "function" || typeof Ve.componentDidCatch == "function" && (so === null || !so.has(Ve))) { Te = Nt(Fe, Te), Fe = Ds(2), Ve = Yn(Me, Fe, 2), Ve !== null && (bs(Fe, Ve, Me, Te), We(Ve, 2), kn(Ve)); break } } Me = Me.return } } function Ql(Te, Me, Fe) { var Ve = Te.pingCache; if (Ve === null) { Ve = Te.pingCache = new jd; var je = new Set; Ve.set(Me, je) } else je = Ve.get(Me), je === void 0 && (je = new Set, Ve.set(Me, je)); je.has(Fe) || (Ic = !0, je.add(Fe), Te = nf.bind(null, Te, Me, Fe), Me.then(Te, Te)) } function nf(Te, Me, Fe) { var Ve = Te.pingCache; Ve !== null && Ve.delete(Me), Te.pingedLanes |= Te.suspendedLanes & Fe, Te.warmLanes &= ~Fe, $i === Te && (Ei & Fe) === Fe && (os === 4 || os === 3 && (Ei & 62914560) === Ei && 300 > Sa() - Oc ? !(Ui & 2) && Bo(Te, 0) : Pc |= Fe, Jo === Ei && (Jo = 0)), kn(Te) } function au(Te, Me) { Me === 0 && (Me = Ge()), Te = vn(Te, Me), Te !== null && (We(Te, Me), kn(Te)) } function rf(Te) { var Me = Te.memoizedState, Fe = 0; Me !== null && (Fe = Me.retryLane), au(Te, Fe) } function sf(Te, Me) { var Fe = 0; switch (Te.tag) { case 13: var Ve = Te.stateNode, je = Te.memoizedState; je !== null && (Fe = je.retryLane); break; case 19: Ve = Te.stateNode; break; case 22: Ve = Te.stateNode._retryCache; break; default: throw Error(ge(314)) }Ve !== null && Ve.delete(Me), au(Te, Fe) } function af(Te, Me) { return Cl(Te, Me) } function of(Te, Me, Fe, Ve) { this.tag = Te, this.key = Fe, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = Me, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Ve, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function tc(Te) { return Te = Te.prototype, !(!Te || !Te.isReactComponent) } function Ya(Te, Me) { var Fe = Te.alternate; return Fe === null ? (Fe = pe(Te.tag, Me, Te.key, Te.mode), Fe.elementType = Te.elementType, Fe.type = Te.type, Fe.stateNode = Te.stateNode, Fe.alternate = Te, Te.alternate = Fe) : (Fe.pendingProps = Me, Fe.type = Te.type, Fe.flags = 0, Fe.subtreeFlags = 0, Fe.deletions = null), Fe.flags = Te.flags & 31457280, Fe.childLanes = Te.childLanes, Fe.lanes = Te.lanes, Fe.child = Te.child, Fe.memoizedProps = Te.memoizedProps, Fe.memoizedState = Te.memoizedState, Fe.updateQueue = Te.updateQueue, Me = Te.dependencies, Fe.dependencies = Me === null ? null : { lanes: Me.lanes, firstContext: Me.firstContext }, Fe.sibling = Te.sibling, Fe.index = Te.index, Fe.ref = Te.ref, Fe.refCleanup = Te.refCleanup, Fe } function ou(Te, Me) { Te.flags &= 31457282; var Fe = Te.alternate; return Fe === null ? (Te.childLanes = 0, Te.lanes = Me, Te.child = null, Te.subtreeFlags = 0, Te.memoizedProps = null, Te.memoizedState = null, Te.updateQueue = null, Te.dependencies = null, Te.stateNode = null) : (Te.childLanes = Fe.childLanes, Te.lanes = Fe.lanes, Te.child = Fe.child, Te.subtreeFlags = 0, Te.deletions = null, Te.memoizedProps = Fe.memoizedProps, Te.memoizedState = Fe.memoizedState, Te.updateQueue = Fe.updateQueue, Te.type = Fe.type, Me = Fe.dependencies, Te.dependencies = Me === null ? null : { lanes: Me.lanes, firstContext: Me.firstContext }), Te } function vl(Te, Me, Fe, Ve, je, Ke) { var zt = 0; if (Ve = Te, typeof Te == "function") tc(Te) && (zt = 1); else if (typeof Te == "string") zt = fa && Ms ? Lu(Te, Fe, Es.current) ? 26 : zu(Te) ? 27 : 5 : fa ? Lu(Te, Fe, Es.current) ? 26 : 5 : Ms && zu(Te) ? 27 : 5; else e: switch (Te) { case Po: return mo(Fe.children, je, Ke, Me); case pu: zt = 8, je |= 24; break; case ac: return Te = pe(12, Fe, Me, je | 2), Te.elementType = ac, Te.lanes = Ke, Te; case lc: return Te = pe(13, Fe, Me, je), Te.elementType = lc, Te.lanes = Ke, Te; case cc: return Te = pe(19, Fe, Me, je), Te.elementType = cc, Te.lanes = Ke, Te; case gu: return lu(Fe, je, Ke, Me); default: if (typeof Te == "object" && Te !== null) switch (Te.$$typeof) { case ff: case Ja: zt = 10; break e; case mu: zt = 9; break e; case oc: zt = 11; break e; case uc: zt = 14; break e; case Za: zt = 16, Ve = null; break e }zt = 29, Fe = Error(ge(130, Te === null ? "null" : typeof Te, "")), Ve = null }return Me = pe(zt, Fe, Me, je), Me.elementType = Te, Me.type = Ve, Me.lanes = Ke, Me } function mo(Te, Me, Fe, Ve) { return Te = pe(7, Te, Ve, Me), Te.lanes = Fe, Te } function lu(Te, Me, Fe, Ve) { Te = pe(22, Te, Ve, Me), Te.elementType = gu, Te.lanes = Fe; var je = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function () { var Ke = je._current; if (Ke === null) throw Error(ge(456)); if (!(je._pendingVisibility & 2)) { var zt = vn(Ke, 2); zt !== null && (je._pendingVisibility |= 2, ks(zt, Ke, 2)) } }, attach: function () { var Ke = je._current; if (Ke === null) throw Error(ge(456)); if (je._pendingVisibility & 2) { var zt = vn(Ke, 2); zt !== null && (je._pendingVisibility &= -3, ks(zt, Ke, 2)) } } }; return Te.stateNode = je, Te } function nc(Te, Me, Fe) { return Te = pe(6, Te, null, Me), Te.lanes = Fe, Te } function rc(Te, Me, Fe) { return Me = pe(4, Te.children !== null ? Te.children : [], Te.key, Me), Me.lanes = Fe, Me.stateNode = { containerInfo: Te.containerInfo, pendingChildren: null, implementation: Te.implementation }, Me } function lf(Te, Me, Fe, Ve, je, Ke, zt, hn) { this.tag = 1, this.containerInfo = Te, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = pc, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ze(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ze(0), this.hiddenUpdates = ze(null), this.identifierPrefix = Ve, this.onUncaughtError = je, this.onCaughtError = Ke, this.onRecoverableError = zt, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = hn, this.incompleteTransitions = new Map } function cu(Te, Me, Fe, Ve, je, Ke, zt, hn, Cn, tr, vr, Mr) { return Te = new lf(Te, Me, Fe, zt, hn, Cn, tr, Mr), Me = 1, Ke === !0 && (Me |= 24), Ke = pe(3, null, null, Me), Te.current = Ke, Ke.stateNode = Te, Me = ei(), Me.refCount++, Te.pooledCache = Me, Me.refCount++, Ke.memoizedState = { element: Ve, isDehydrated: Fe, cache: Me }, jn(Ke), Te } function uu(Te) { return Te ? (Te = No, Te) : No } function fu(Te) { var Me = Te._reactInternals; if (Me === void 0) throw typeof Te.render == "function" ? Error(ge(188)) : (Te = Object.keys(Te).join(","), Error(ge(268, Te))); return Te = Ce(Me), Te = Te !== null ? we(Te) : null, Te === null ? null : tl(Te.stateNode) } function du(Te, Me, Fe, Ve, je, Ke) { je = uu(je), Ve.context === null ? Ve.context = je : Ve.pendingContext = je, Ve = fr(Me), Ve.payload = { element: Fe }, Ke = Ke === void 0 ? null : Ke, Ke !== null && (Ve.callback = Ke), Fe = Yn(Te, Ve, Me), Fe !== null && (ks(Fe, Te, Me), sr(Fe, Te, Me)) } function hu(Te, Me) { if (Te = Te.memoizedState, Te !== null && Te.dehydrated !== null) { var Fe = Te.retryLane; Te.retryLane = Fe !== 0 && Fe < Me ? Fe : Me } } function ic(Te, Me) { hu(Te, Me), (Te = Te.alternate) && hu(Te, Me) } var hi = {}, cf = reactExports, ea = schedulerExports, sc = Object.assign, uf = Symbol.for("react.element"), _l = Symbol.for("react.transitional.element"), Io = Symbol.for("react.portal"), Po = Symbol.for("react.fragment"), pu = Symbol.for("react.strict_mode"), ac = Symbol.for("react.profiler"), ff = Symbol.for("react.provider"), mu = Symbol.for("react.consumer"), Ja = Symbol.for("react.context"), oc = Symbol.for("react.forward_ref"), lc = Symbol.for("react.suspense"), cc = Symbol.for("react.suspense_list"), uc = Symbol.for("react.memo"), Za = Symbol.for("react.lazy"), gu = Symbol.for("react.offscreen"), df = Symbol.for("react.memo_cache_sentinel"), xu = Symbol.iterator, hf = Symbol.for("react.client.reference"), Qr = cf.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, fc, yu, dc = !1, El = Array.isArray, pf = K.rendererVersion, mf = K.rendererPackageName, vu = K.extraDevToolsConfig, tl = K.getPublicInstance, gf = K.getRootHostContext, xf = K.getChildHostContext, yf = K.prepareForCommit, vf = K.resetAfterCommit, _f = K.createInstance, hc = K.appendInitialChild, _u = K.finalizeInitialChildren, bl = K.shouldSetTextContent, Eu = K.createTextInstance, Ef = K.scheduleTimeout, bf = K.cancelTimeout, pc = K.noTimeout, ka = K.isPrimaryRenderer; K.warnsIfNotActing; var ws = K.supportsMutation, Qa = K.supportsPersistence, ua = K.supportsHydration, bu = K.getInstanceFromNode; K.beforeActiveInstanceBlur, K.afterActiveInstanceBlur; var Af = K.preparePortalMount; K.prepareScopeUpdate, K.getInstanceFromScope; var zs = K.setCurrentUpdatePriority, go = K.getCurrentUpdatePriority, Sf = K.resolveUpdatePriority; K.resolveEventType, K.resolveEventTimeStamp; var Cf = K.shouldAttemptEagerTransition, Tf = K.detachDeletedInstance; K.requestPostPaintCallback; var wf = K.maySuspendCommit, Au = K.preloadInstance, Mf = K.startSuspendingCommit, Su = K.suspendInstance, Rf = K.waitForCommitToBeReady, Lo = K.NotPendingTransition, xo = K.HostTransitionContext, Bf = K.resetFormInstance; K.bindToConsole; var Df = K.supportsMicrotasks, If = K.scheduleMicrotask, nl = K.supportsTestSelectors, Pf = K.findFiberRoot, Lf = K.getBoundingRect, Of = K.getTextContent, rl = K.isHiddenSubtree, Nf = K.matchAccessibilityRole, Ff = K.setFocusIfFocusable, kf = K.setupIntersectionObserver, Uf = K.appendChild, Hf = K.appendChildToContainer, Vf = K.commitTextUpdate, zf = K.commitMount, Gf = K.commitUpdate, $f = K.insertBefore, jf = K.insertInContainerBefore, Wf = K.removeChild, Xf = K.removeChildFromContainer, Cu = K.resetTextContent, Kf = K.hideInstance, qf = K.hideTextInstance, Yf = K.unhideInstance, Jf = K.unhideTextInstance, Zf = K.clearContainer, Qf = K.cloneInstance, Tu = K.createContainerChildSet, wu = K.appendChildToContainerChildSet, ed = K.finalizeContainerChildren, Mu = K.replaceContainerChildren, Ru = K.cloneHiddenInstance, Bu = K.cloneHiddenTextInstance, mc = K.isSuspenseInstancePending, gc = K.isSuspenseInstanceFallback, nd = K.getSuspenseInstanceFallbackErrorDetails, rd = K.registerSuspenseInstanceRetry, id = K.canHydrateFormStateMarker, sd = K.isFormStateMarkerMatching, Du = K.getNextHydratableSibling, Iu = K.getFirstHydratableChild, ad = K.getFirstHydratableChildWithinContainer, od = K.getFirstHydratableChildWithinSuspenseInstance, ld = K.canHydrateInstance, cd = K.canHydrateTextInstance, ud = K.canHydrateSuspenseInstance, dd = K.hydrateInstance, hd = K.hydrateTextInstance, pd = K.hydrateSuspenseInstance, gd = K.getNextHydratableInstanceAfterSuspenseInstance, xd = K.commitHydratedContainer, yd = K.commitHydratedSuspenseInstance, vd = K.clearSuspenseBoundary, _d = K.clearSuspenseBoundaryFromContainer, Pu = K.shouldDeleteUnhydratedTailInstances; K.diffHydratedPropsForDevWarnings, K.diffHydratedTextForDevWarnings, K.describeHydratableInstanceForDevWarnings; var Ed = K.validateHydratableInstance, bd = K.validateHydratableTextInstance, fa = K.supportsResources, Lu = K.isHostHoistableType, xc = K.getHoistableRoot, Ou = K.getResource, Nu = K.acquireResource, Fu = K.releaseResource, Ad = K.hydrateHoistable, ku = K.mountHoistable, Uu = K.unmountHoistable, Sd = K.createHoistableInstance, Cd = K.prepareToCommitHoistables, Td = K.mayResourceSuspendCommit, Hu = K.preloadResource, wd = K.suspendResource, Ms = K.supportsSingletons, Vu = K.resolveSingletonInstance, Md = K.clearSingleton, Rd = K.acquireSingletonInstance, Bd = K.releaseSingletonInstance, zu = K.isHostSingletonType, yc = [], Oo = -1, No = {}, ta = Math.clz32 ? Math.clz32 : Pe, Dd = Math.log, Id = Math.LN2, Al = 128, Sl = 4194304, Cl = ea.unstable_scheduleCallback, vc = ea.unstable_cancelCallback, Pd = ea.unstable_shouldYield, Ld = ea.unstable_requestPaint, Sa = ea.unstable_now, Gu = ea.unstable_ImmediatePriority, Od = ea.unstable_UserBlockingPriority, _c = ea.unstable_NormalPriority, Nd = ea.unstable_IdlePriority, Fd = ea.log, kd = ea.unstable_setDisableYieldValue, il = null, na = null, ra = typeof Object.is == "function" ? Object.is : st, $u = new WeakMap, Fo = [], ko = 0, Tl = null, wl = 0, da = [], ha = 0, yo = null, Ua = 1, Ha = "", Es = De(null), sl = De(null), eo = De(null), Ml = De(null), Us = null, Rs = null, Ci = !1, Ca = null, Ra = !1, Ec = Error(ge(519)), pa = [], Uo = 0, bc = 0, Rl = null, Ho = null, Ac = !1, Bl = !1, Sc = !1, Vo = 0, al = null, Cc = 0, zo = 0, Go = null, to = !1, Tc = !1, Ud = Object.prototype.hasOwnProperty, ol = Error(ge(460)), wc = Error(ge(474)), Dl = { then: function () { } }, $o = null, jo = null, ll = 0, vo = ri(!0), ju = ri(!1), Wo = De(null), Il = De(0), ma = De(null), Ba = null, ds = De(0), no = 0, fi = null, ki = null, us = null, Pl = !1, Xo = !1, _o = !1, Ll = 0, cl = 0, Ko = null, Hd = 0, Mc = function () { return { lastEffect: null, events: null, stores: null, memoCache: null } }, Da = { readContext: ur, use: ln, useCallback: xi, useContext: xi, useEffect: xi, useImperativeHandle: xi, useLayoutEffect: xi, useInsertionEffect: xi, useMemo: xi, useReducer: xi, useRef: xi, useState: xi, useDebugValue: xi, useDeferredValue: xi, useTransition: xi, useSyncExternalStore: xi, useId: xi }; Da.useCacheRefresh = xi, Da.useMemoCache = xi, Da.useHostTransitionStatus = xi, Da.useFormState = xi, Da.useActionState = xi, Da.useOptimistic = xi; var Eo = { readContext: ur, use: ln, useCallback: function (Te, Me) { return ft().memoizedState = [Te, Me === void 0 ? null : Me], Te }, useContext: ur, useEffect: $s, useImperativeHandle: function (Te, Me, Fe) { Fe = Fe != null ? Fe.concat([Te]) : null, Gs(4194308, 4, va.bind(null, Me, Te), Fe) }, useLayoutEffect: function (Te, Me) { return Gs(4194308, 4, Te, Me) }, useInsertionEffect: function (Te, Me) { Gs(4, 2, Te, Me) }, useMemo: function (Te, Me) { var Fe = ft(); Me = Me === void 0 ? null : Me; var Ve = Te(); if (_o) { Qe(!0); try { Te() } finally { Qe(!1) } } return Fe.memoizedState = [Ve, Me], Ve }, useReducer: function (Te, Me, Fe) { var Ve = ft(); if (Fe !== void 0) { var je = Fe(Me); if (_o) { Qe(!0); try { Fe(Me) } finally { Qe(!1) } } } else je = Me; return Ve.memoizedState = Ve.baseState = je, Te = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Te, lastRenderedState: je }, Ve.queue = Te, Te = Te.dispatch = pr.bind(null, fi, Te), [Ve.memoizedState, Te] }, useRef: function (Te) { var Me = ft(); return Te = { current: Te }, Me.memoizedState = Te }, useState: function (Te) { Te = wr(Te); var Me = Te.queue, Fe = zr.bind(null, fi, Me); return Me.dispatch = Fe, [Te.memoizedState, Fe] }, useDebugValue: Pa, useDeferredValue: function (Te, Me) { var Fe = ft(); return Le(Fe, Te, Me) }, useTransition: function () { var Te = wr(!1); return Te = rt.bind(null, fi, Te.queue, !0, !1), ft().memoizedState = Te, [!1, Te] }, useSyncExternalStore: function (Te, Me, Fe) { var Ve = fi, je = ft(); if (Ci) { if (Fe === void 0) throw Error(ge(407)); Fe = Fe() } else { if (Fe = Me(), $i === null) throw Error(ge(349)); Ei & 60 || Un(Ve, Me, Fe) } je.memoizedState = Fe; var Ke = { value: Fe, getSnapshot: Me }; return je.queue = Ke, $s(Lr.bind(null, Ve, Ke, Te), [Te]), Ve.flags |= 2048, Ji(9, _r.bind(null, Ve, Ke, Fe, Me), { destroy: void 0 }, null), Fe }, useId: function () { var Te = ft(), Me = $i.identifierPrefix; if (Ci) { var Fe = Ha, Ve = Ua; Fe = (Ve & ~(1 << 32 - ta(Ve) - 1)).toString(32) + Fe, Me = ":" + Me + "R" + Fe, Fe = Ll++, 0 < Fe && (Me += "H" + Fe.toString(32)), Me += ":" } else Fe = Hd++, Me = ":" + Me + "r" + Fe.toString(32) + ":"; return Te.memoizedState = Me }, useCacheRefresh: function () { return ft().memoizedState = hr.bind(null, fi) } }; Eo.useMemoCache = pn, Eo.useHostTransitionStatus = Yt, Eo.useFormState = Xr, Eo.useActionState = Xr, Eo.useOptimistic = function (Te) { var Me = ft(); Me.memoizedState = Me.baseState = Te; var Fe = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return Me.queue = Fe, Me = Ni.bind(null, fi, !0, Fe), Fe.dispatch = Me, [Te, Me] }; var ro = { readContext: ur, use: ln, useCallback: Ws, useContext: ur, useEffect: $r, useImperativeHandle: Ki, useInsertionEffect: Bs, useLayoutEffect: oa, useMemo: wa, useReducer: $n, useRef: vs, useState: function () { return $n(Tn) }, useDebugValue: Pa, useDeferredValue: function (Te, Me) { var Fe = qt(); return $e(Fe, ki.memoizedState, Te, Me) }, useTransition: function () { var Te = $n(Tn)[0], Me = qt().memoizedState; return [typeof Te == "boolean" ? Te : sn(Te), Me] }, useSyncExternalStore: br, useId: bn }; ro.useCacheRefresh = On, ro.useMemoCache = pn, ro.useHostTransitionStatus = Yt, ro.useFormState = Ri, ro.useActionState = Ri, ro.useOptimistic = function (Te, Me) { var Fe = qt(); return Fr(Fe, ki, Te, Me) }; var bo = { readContext: ur, use: ln, useCallback: Ws, useContext: ur, useEffect: $r, useImperativeHandle: Ki, useInsertionEffect: Bs, useLayoutEffect: oa, useMemo: wa, useReducer: rr, useRef: vs, useState: function () { return rr(Tn) }, useDebugValue: Pa, useDeferredValue: function (Te, Me) { var Fe = qt(); return ki === null ? Le(Fe, Te, Me) : $e(Fe, ki.memoizedState, Te, Me) }, useTransition: function () { var Te = rr(Tn)[0], Me = qt().memoizedState; return [typeof Te == "boolean" ? Te : sn(Te), Me] }, useSyncExternalStore: br, useId: bn }; bo.useCacheRefresh = On, bo.useMemoCache = pn, bo.useHostTransitionStatus = Yt, bo.useFormState = Vi, bo.useActionState = Vi, bo.useOptimistic = function (Te, Me) { var Fe = qt(); return ki !== null ? Fr(Fe, ki, Te, Me) : (Fe.baseState = Te, [Te, Fe.queue.dispatch]) }; var Rc = { isMounted: function (Te) { return (Te = Te._reactInternals) ? Ae(Te) === Te : !1 }, enqueueSetState: function (Te, Me, Fe) { Te = Te._reactInternals; var Ve = Qs(), je = fr(Ve); je.payload = Me, Fe != null && (je.callback = Fe), Me = Yn(Te, je, Ve), Me !== null && (ks(Me, Te, Ve), sr(Me, Te, Ve)) }, enqueueReplaceState: function (Te, Me, Fe) { Te = Te._reactInternals; var Ve = Qs(), je = fr(Ve); je.tag = 1, je.payload = Me, Fe != null && (je.callback = Fe), Me = Yn(Te, je, Ve), Me !== null && (ks(Me, Te, Ve), sr(Me, Te, Ve)) }, enqueueForceUpdate: function (Te, Me) { Te = Te._reactInternals; var Fe = Qs(), Ve = fr(Fe); Ve.tag = 2, Me != null && (Ve.callback = Me), Me = Yn(Te, Ve, Fe), Me !== null && (ks(Me, Te, Fe), sr(Me, Te, Fe)) } }, Wu = typeof reportError == "function" ? reportError : function (Te) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var Me = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof Te == "object" && Te !== null && typeof Te.message == "string" ? String(Te.message) : String(Te), error: Te }); if (!window.dispatchEvent(Me)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", Te); return } console.error(Te) }, Xu = Error(ge(461)), gs = !1, Bc = { dehydrated: null, treeContext: null, retryLane: 0 }, Ol = De(null), Ao = null, Va = null, Vd = typeof AbortController < "u" ? AbortController : function () { var Te = [], Me = this.signal = { aborted: !1, addEventListener: function (Fe, Ve) { Te.push(Ve) } }; this.abort = function () { Me.aborted = !0, Te.forEach(function (Fe) { return Fe() }) } }, zd = ea.unstable_scheduleCallback, Gd = ea.unstable_NormalPriority, rs = { $$typeof: Ja, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, Ku = Qr.S; Qr.S = function (Te, Me) { typeof Me == "object" && Me !== null && typeof Me.then == "function" && Ft(Te, Me), Ku !== null && Ku(Te, Me) }; var So = De(null), za = !1, as = !1, Dc = !1, qu = typeof WeakSet == "function" ? WeakSet : Set, xs = null, Yu = !1, fs = null, ia = !1, Ta = null, qo = 8192, $d = { getCacheForType: function (Te) { var Me = ur(rs), Fe = Me.data.get(Te); return Fe === void 0 && (Fe = Te(), Me.data.set(Te, Fe)), Fe } }, Nl = 0, Fl = 1, kl = 2, Ul = 3, Hl = 4; if (typeof Symbol == "function" && Symbol.for) { var ul = Symbol.for; Nl = ul("selector.component"), Fl = ul("selector.has_pseudo_class"), kl = ul("selector.role"), Ul = ul("selector.test_id"), Hl = ul("selector.text") } var jd = typeof WeakMap == "function" ? WeakMap : Map, Ui = 0, $i = null, pi = null, Ei = 0, ji = 0, sa = null, Ga = !1, Yo = !1, Ic = !1, $a = 0, os = 0, io = 0, Co = 0, Pc = 0, ga = 0, Jo = 0, dl = null, Ia = null, Lc = !1, Oc = 0, hl = 1 / 0, Vl = null, so = null, zl = !1, To = null, pl = 0, Nc = 0, Fc = null, ml = 0, kc = null; return hi.attemptContinuousHydration = function (Te) { if (Te.tag === 13) { var Me = vn(Te, 67108864); Me !== null && ks(Me, Te, 67108864), ic(Te, 67108864) } }, hi.attemptHydrationAtCurrentPriority = function (Te) { if (Te.tag === 13) { var Me = Qs(), Fe = vn(Te, Me); Fe !== null && ks(Fe, Te, Me), ic(Te, Me) } }, hi.attemptSynchronousHydration = function (Te) { switch (Te.tag) { case 3: if (Te = Te.stateNode, Te.current.memoizedState.isDehydrated) { var Me = Ne(Te.pendingLanes); if (Me !== 0) { for (Te.pendingLanes |= 2, Te.entangledLanes |= 2; Me;) { var Fe = 1 << 31 - ta(Me); Te.entanglements[1] |= Fe, Me &= ~Fe } kn(Te), !(Ui & 6) && (hl = Sa() + 500, Ht(0)) } } break; case 13: Me = vn(Te, 2), Me !== null && ks(Me, Te, 2), qc(), ic(Te, 2) } }, hi.batchedUpdates = function (Te, Me) { return Te(Me) }, hi.createComponentSelector = function (Te) { return { $$typeof: Nl, value: Te } }, hi.createContainer = function (Te, Me, Fe, Ve, je, Ke, zt, hn, Cn, tr) { return cu(Te, Me, !1, null, Fe, Ve, Ke, zt, hn, Cn, tr, null) }, hi.createHasPseudoClassSelector = function (Te) { return { $$typeof: Fl, value: Te } }, hi.createHydrationContainer = function (Te, Me, Fe, Ve, je, Ke, zt, hn, Cn, tr, vr, Mr, Pr) { return Te = cu(Fe, Ve, !0, Te, je, Ke, hn, Cn, tr, vr, Mr, Pr), Te.context = uu(null), Fe = Te.current, Ve = Qs(), je = fr(Ve), je.callback = Me ?? null, Yn(Fe, je, Ve), Te.current.lanes = Ve, We(Te, Ve), kn(Te), Te }, hi.createPortal = function (Te, Me, Fe) { var Ve = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Io, key: Ve == null ? null : "" + Ve, children: Te, containerInfo: Me, implementation: Fe } }, hi.createRoleSelector = function (Te) { return { $$typeof: kl, value: Te } }, hi.createTestNameSelector = function (Te) { return { $$typeof: Ul, value: Te } }, hi.createTextSelector = function (Te) { return { $$typeof: Hl, value: Te } }, hi.defaultOnCaughtError = function (Te) { console.error(Te) }, hi.defaultOnRecoverableError = function (Te) { Wu(Te) }, hi.defaultOnUncaughtError = function (Te) { Wu(Te) }, hi.deferredUpdates = function (Te) { var Me = Qr.T, Fe = go(); try { return zs(32), Qr.T = null, Te() } finally { zs(Fe), Qr.T = Me } }, hi.discreteUpdates = function (Te, Me, Fe, Ve, je) { var Ke = Qr.T, zt = go(); try { return zs(2), Qr.T = null, Te(Me, Fe, Ve, je) } finally { zs(zt), Qr.T = Ke, Ui === 0 && (hl = Sa() + 500) } }, hi.findAllNodes = Kl, hi.findBoundingRects = function (Te, Me) { if (!nl) throw Error(ge(363)); Me = Kl(Te, Me), Te = []; for (var Fe = 0; Fe < Me.length; Fe++)Te.push(Lf(Me[Fe])); for (Me = Te.length - 1; 0 < Me; Me--) { Fe = Te[Me]; for (var Ve = Fe.x, je = Ve + Fe.width, Ke = Fe.y, zt = Ke + Fe.height, hn = Me - 1; 0 <= hn; hn--)if (Me !== hn) { var Cn = Te[hn], tr = Cn.x, vr = tr + Cn.width, Mr = Cn.y, Pr = Mr + Cn.height; if (Ve >= tr && Ke >= Mr && je <= vr && zt <= Pr) { Te.splice(Me, 1); break } else if (Ve !== tr || Fe.width !== Cn.width || Pr < Ke || Mr > zt) { if (!(Ke !== Mr || Fe.height !== Cn.height || vr < Ve || tr > je)) { tr > Ve && (Cn.width += tr - Ve, Cn.x = Ve), vr < je && (Cn.width = je - tr), Te.splice(Me, 1); break } } else { Mr > Ke && (Cn.height += Mr - Ke, Cn.y = Ke), Pr < zt && (Cn.height = zt - Mr), Te.splice(Me, 1); break } } } return Te }, hi.findHostInstance = fu, hi.findHostInstanceWithNoPortals = function (Te) { return Te = Ce(Te), Te = Te !== null ? Be(Te) : null, Te === null ? null : tl(Te.stateNode) }, hi.findHostInstanceWithWarning = function (Te) { return fu(Te) }, hi.flushPassiveEffects = po, hi.flushSyncFromReconciler = function (Te) { var Me = Ui; Ui |= 1; var Fe = Qr.T, Ve = go(); try { if (zs(2), Qr.T = null, Te) return Te() } finally { zs(Ve), Qr.T = Fe, Ui = Me, !(Ui & 6) && Ht(0) } }, hi.flushSyncWork = qc, hi.focusWithin = function (Te, Me) { if (!nl) throw Error(ge(363)); for (Te = jl(Te), Me = jc(Te, Me), Me = Array.from(Me), Te = 0; Te < Me.length;) { var Fe = Me[Te++], Ve = Fe.tag; if (!rl(Fe)) { if ((Ve === 5 || Ve === 26 || Ve === 27) && Ff(Fe.stateNode)) return !0; for (Fe = Fe.child; Fe !== null;)Me.push(Fe), Fe = Fe.sibling } } return !1 }, hi.getFindAllNodesFailureDescription = function (Te, Me) {
			if (!nl) throw Error(ge(363)); var Fe = 0, Ve = []; Te = [jl(Te), 0]; for (var je = 0; je < Te.length;) { var Ke = Te[je++], zt = Ke.tag, hn = Te[je++], Cn = Me[hn]; if ((zt !== 5 && zt !== 26 && zt !== 27 || !rl(Ke)) && (Wl(Ke, Cn) && (Ve.push(Xl(Cn)), hn++, hn > Fe && (Fe = hn)), hn < Me.length)) for (Ke = Ke.child; Ke !== null;)Te.push(Ke, hn), Ke = Ke.sibling } if (Fe < Me.length) {
				for (Te = []; Fe < Me.length; Fe++)Te.push(Xl(Me[Fe])); return `findAllNodes was able to match part of the selector:
  `+ (Ve.join(" > ") + `

No matching component was found for:
  `) + Te.join(" > ")
			} return null
		}, hi.getPublicRootInstance = function (Te) { if (Te = Te.current, !Te.child) return null; switch (Te.child.tag) { case 27: case 5: return tl(Te.child.stateNode); default: return Te.child.stateNode } }, hi.injectIntoDevTools = function () { var Te = { bundleType: 0, version: pf, rendererPackageName: mf, currentDispatcherRef: Qr, findFiberByHostInstance: bu, reconcilerVersion: "19.0.0" }; if (vu !== null && (Te.rendererConfig = vu), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") Te = !1; else { var Me = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (Me.isDisabled || !Me.supportsFiber) Te = !0; else { try { il = Me.inject(Te), na = Me } catch { } Te = !!Me.checkDCE } } return Te }, hi.isAlreadyRendering = function () { return !1 }, hi.observeVisibleRects = function (Te, Me, Fe, Ve) { if (!nl) throw Error(ge(363)); Te = Kl(Te, Me); var je = kf(Te, Fe, Ve).disconnect; return { disconnect: function () { je() } } }, hi.shouldError = function () { return null }, hi.shouldSuspend = function () { return !1 }, hi.startHostTransition = function (Te, Me, Fe, Ve) { if (Te.tag !== 5) throw Error(ge(476)); var je = Pt(Te).queue; rt(Te, je, Me, Lo, Fe === null ? me : function () { var Ke = Pt(Te).next.queue; return Hr(Te, Ke, {}, Qs()), Fe(Ve) }) }, hi.updateContainer = function (Te, Me, Fe, Ve) { var je = Me.current, Ke = Qs(); return du(je, Ke, Te, Me, Fe, Ve), Ke }, hi.updateContainerSync = function (Te, Me, Fe, Ve) { return Me.tag === 0 && po(), du(Me.current, 2, Te, Me, Fe, Ve), 2 }, hi
	}, fe.exports.default = fe.exports, Object.defineProperty(fe.exports, "__esModule", { value: !0 })
})(reactReconciler_production); var reactReconciler_productionExports = reactReconciler_production.exports; reactReconciler.exports = reactReconciler_productionExports; var reactReconcilerExports = reactReconciler.exports; const Reconciler = getDefaultExportFromCjs(reactReconcilerExports), isPromise = fe => typeof fe == "object" && typeof fe.then == "function", globalCache = []; function shallowEqualArrays(fe, K, pe = (me, ge) => me === ge) { if (fe === K) return !0; if (!fe || !K) return !1; const me = fe.length; if (K.length !== me) return !1; for (let ge = 0; ge < me; ge++)if (!pe(fe[ge], K[ge])) return !1; return !0 } function query$1(fe, K = null, pe = !1, me = {}) { K === null && (K = [fe]); for (const xe of globalCache) if (shallowEqualArrays(K, xe.keys, xe.equal)) { if (pe) return; if (Object.prototype.hasOwnProperty.call(xe, "error")) throw xe.error; if (Object.prototype.hasOwnProperty.call(xe, "response")) return me.lifespan && me.lifespan > 0 && (xe.timeout && clearTimeout(xe.timeout), xe.timeout = setTimeout(xe.remove, me.lifespan)), xe.response; if (!pe) throw xe.promise } const ge = { keys: K, equal: me.equal, remove: () => { const xe = globalCache.indexOf(ge); xe !== -1 && globalCache.splice(xe, 1) }, promise: (isPromise(fe) ? fe : fe(...K)).then(xe => { ge.response = xe, me.lifespan && me.lifespan > 0 && (ge.timeout = setTimeout(ge.remove, me.lifespan)) }).catch(xe => ge.error = xe) }; if (globalCache.push(ge), !pe) throw ge.promise } const suspend = (fe, K, pe) => query$1(fe, K, !1, pe), preload = (fe, K, pe) => void query$1(fe, K, !0, pe), clear = fe => { if (fe === void 0 || fe.length === 0) globalCache.splice(0, globalCache.length); else { const K = globalCache.find(pe => shallowEqualArrays(fe, pe.keys, pe.equal)); K && K.remove() } }; function i$5(fe, K, pe) { if (!fe) return; if (pe(fe) === !0) return fe; let me = K ? fe.return : fe.child; for (; me;) { const ge = i$5(me, K, pe); if (ge) return ge; me = K ? null : me.sibling } } function l(fe) { try { return Object.defineProperties(fe, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return fe } } const a$1 = l(reactExports.createContext(null)); let m$2 = class extends reactExports.Component { render() { return reactExports.createElement(a$1.Provider, { value: this._reactInternals }, this.props.children) } }; function c$1() { const fe = reactExports.useContext(a$1); if (fe === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const K = reactExports.useId(); return reactExports.useMemo(() => { for (const pe of [fe, fe?.alternate]) { if (!pe) continue; const me = i$5(pe, !1, ge => { let xe = ge.memoizedState; for (; xe;) { if (xe.memoizedState === K) return !0; xe = xe.next } }); if (me) return me } }, [fe, K]) } const p$1 = Symbol.for("react.context"), b$1 = fe => fe !== null && typeof fe == "object" && "$$typeof" in fe && fe.$$typeof === p$1; function h$1() { const fe = c$1(), [K] = reactExports.useState(() => new Map); K.clear(); let pe = fe; for (; pe;) { const me = pe.type; b$1(me) && me !== a$1 && !K.has(me) && K.set(me, reactExports.use(l(me))), pe = pe.return } return K } function x$3() { const fe = h$1(); return reactExports.useMemo(() => Array.from(fe.keys()).reduce((K, pe) => me => reactExports.createElement(K, null, reactExports.createElement(pe.Provider, { ...me, value: fe.get(pe) })), K => reactExports.createElement(m$2, { ...K })), [fe]) } function findInitialRoot(fe) { let K = fe.root; for (; K.getState().previousRoot;)K = K.getState().previousRoot; return K } const isOrthographicCamera$1 = fe => fe && fe.isOrthographicCamera, isRef$1 = fe => fe && fe.hasOwnProperty("current"), isColorRepresentation = fe => fe != null && (typeof fe == "string" || typeof fe == "number" || fe.isColor), useIsomorphicLayoutEffect = ((fe, K) => typeof window < "u" && (((fe = window.document) == null ? void 0 : fe.createElement) || ((K = window.navigator) == null ? void 0 : K.product) === "ReactNative"))() ? reactExports.useLayoutEffect : reactExports.useEffect; function useMutableCallback(fe) { const K = reactExports.useRef(fe); return useIsomorphicLayoutEffect(() => void (K.current = fe), [fe]), K } function useBridge() { const fe = c$1(), K = x$3(); return reactExports.useMemo(() => ({ children: pe }) => { const ge = !!i$5(fe, !0, xe => xe.type === reactExports.StrictMode) ? reactExports.StrictMode : reactExports.Fragment; return jsxRuntimeExports.jsx(ge, { children: jsxRuntimeExports.jsx(K, { children: pe }) }) }, [fe, K]) } function Block({ set: fe }) { return useIsomorphicLayoutEffect(() => (fe(new Promise(() => null)), () => fe(!1)), [fe]), null } const ErrorBoundary$1 = (fe => (fe = class extends reactExports.Component { constructor(...pe) { super(...pe), this.state = { error: !1 } } componentDidCatch(pe) { this.props.set(pe) } render() { return this.state.error ? null : this.props.children } }, fe.getDerivedStateFromError = () => ({ error: !0 }), fe))(); function calculateDpr(fe) { var K; const pe = typeof window < "u" ? (K = window.devicePixelRatio) != null ? K : 2 : 1; return Array.isArray(fe) ? Math.min(Math.max(fe[0], pe), fe[1]) : fe } function getRootState(fe) { var K; return (K = fe.__r3f) == null ? void 0 : K.root.getState() } const is$1 = { obj: fe => fe === Object(fe) && !is$1.arr(fe) && typeof fe != "function", fun: fe => typeof fe == "function", str: fe => typeof fe == "string", num: fe => typeof fe == "number", boo: fe => typeof fe == "boolean", und: fe => fe === void 0, nul: fe => fe === null, arr: fe => Array.isArray(fe), equ(fe, K, { arrays: pe = "shallow", objects: me = "reference", strict: ge = !0 } = {}) { if (typeof fe != typeof K || !!fe != !!K) return !1; if (is$1.str(fe) || is$1.num(fe) || is$1.boo(fe)) return fe === K; const xe = is$1.obj(fe); if (xe && me === "reference") return fe === K; const ye = is$1.arr(fe); if (ye && pe === "reference") return fe === K; if ((ye || xe) && fe === K) return !0; let ve; for (ve in fe) if (!(ve in K)) return !1; if (xe && pe === "shallow" && me === "shallow") { for (ve in ge ? K : fe) if (!is$1.equ(fe[ve], K[ve], { strict: ge, objects: "reference" })) return !1 } else for (ve in ge ? K : fe) if (fe[ve] !== K[ve]) return !1; if (is$1.und(ve)) { if (ye && fe.length === 0 && K.length === 0 || xe && Object.keys(fe).length === 0 && Object.keys(K).length === 0) return !0; if (fe !== K) return !1 } return !0 } }; function buildGraph(fe) { const K = { nodes: {}, materials: {}, meshes: {} }; return fe && fe.traverse(pe => { pe.name && (K.nodes[pe.name] = pe), pe.material && !K.materials[pe.material.name] && (K.materials[pe.material.name] = pe.material), pe.isMesh && !K.meshes[pe.name] && (K.meshes[pe.name] = pe) }), K } function dispose(fe) { fe.type !== "Scene" && (fe.dispose == null || fe.dispose()); for (const K in fe) { const pe = fe[K]; pe?.type !== "Scene" && (pe == null || pe.dispose == null || pe.dispose()) } } const REACT_INTERNAL_PROPS = ["children", "key", "ref"]; function getInstanceProps(fe) { const K = {}; for (const pe in fe) REACT_INTERNAL_PROPS.includes(pe) || (K[pe] = fe[pe]); return K } function prepare(fe, K, pe, me) { const ge = fe; let xe = ge?.__r3f; return xe || (xe = { root: K, type: pe, parent: null, children: [], props: getInstanceProps(me), object: ge, eventCount: 0, handlers: {}, isHidden: !1 }, ge && (ge.__r3f = xe)), xe } function resolve(fe, K) { let pe = fe[K]; if (!K.includes("-")) return { root: fe, key: K, target: pe }; pe = fe; for (const ge of K.split("-")) { var me; K = ge, fe = pe, pe = (me = pe) == null ? void 0 : me[K] } return { root: fe, key: K, target: pe } } const INDEX_REGEX = /-\d+$/; function attach(fe, K) { if (is$1.str(K.props.attach)) { if (INDEX_REGEX.test(K.props.attach)) { const ge = K.props.attach.replace(INDEX_REGEX, ""), { root: xe, key: ye } = resolve(fe.object, ge); Array.isArray(xe[ye]) || (xe[ye] = []) } const { root: pe, key: me } = resolve(fe.object, K.props.attach); K.previousAttach = pe[me], pe[me] = K.object } else is$1.fun(K.props.attach) && (K.previousAttach = K.props.attach(fe.object, K.object)) } function detach(fe, K) { if (is$1.str(K.props.attach)) { const { root: pe, key: me } = resolve(fe.object, K.props.attach), ge = K.previousAttach; ge === void 0 ? delete pe[me] : pe[me] = ge } else K.previousAttach == null || K.previousAttach(fe.object, K.object); delete K.previousAttach } const RESERVED_PROPS = [...REACT_INTERNAL_PROPS, "args", "dispose", "attach", "object", "onUpdate", "dispose"], MEMOIZED_PROTOTYPES = new Map; function getMemoizedPrototype(fe) { let K = MEMOIZED_PROTOTYPES.get(fe.constructor); try { K || (K = new fe.constructor, MEMOIZED_PROTOTYPES.set(fe.constructor, K)) } catch { } return K } function diffProps(fe, K) { const pe = {}; for (const me in K) if (!RESERVED_PROPS.includes(me) && !is$1.equ(K[me], fe.props[me])) { pe[me] = K[me]; for (const ge in K) ge.startsWith(`${me}-`) && (pe[ge] = K[ge]) } for (const me in fe.props) { if (RESERVED_PROPS.includes(me) || K.hasOwnProperty(me)) continue; const { root: ge, key: xe } = resolve(fe.object, me); if (ge.constructor && ge.constructor.length === 0) { const ye = getMemoizedPrototype(ge); is$1.und(ye) || (pe[xe] = ye[xe]) } else pe[xe] = 0 } return pe } const colorMaps = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"], EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/; function applyProps(fe, K) { var pe; const me = fe.__r3f, ge = me && findInitialRoot(me).getState(), xe = me?.eventCount; for (const ve in K) { let _e = K[ve]; if (RESERVED_PROPS.includes(ve)) continue; if (me && EVENT_REGEX.test(ve)) { typeof _e == "function" ? me.handlers[ve] = _e : delete me.handlers[ve], me.eventCount = Object.keys(me.handlers).length; continue } if (_e === void 0) continue; let { root: Ee, key: be, target: Ae } = resolve(fe, ve); if (Ae instanceof Layers && _e instanceof Layers) Ae.mask = _e.mask; else if (Ae instanceof Color$1 && isColorRepresentation(_e)) Ae.set(_e); else if (Ae !== null && typeof Ae == "object" && typeof Ae.set == "function" && typeof Ae.copy == "function" && _e != null && _e.constructor && Ae.constructor === _e.constructor) Ae.copy(_e); else if (Ae !== null && typeof Ae == "object" && typeof Ae.set == "function" && Array.isArray(_e)) typeof Ae.fromArray == "function" ? Ae.fromArray(_e) : Ae.set(..._e); else if (Ae !== null && typeof Ae == "object" && typeof Ae.set == "function" && typeof _e == "number") typeof Ae.setScalar == "function" ? Ae.setScalar(_e) : Ae.set(_e); else { var ye; Ee[be] = _e, ge && !ge.linear && colorMaps.includes(be) && (ye = Ee[be]) != null && ye.isTexture && Ee[be].format === RGBAFormat && Ee[be].type === UnsignedByteType && (Ee[be].colorSpace = SRGBColorSpace) } } if (me != null && me.parent && ge != null && ge.internal && (pe = me.object) != null && pe.isObject3D && xe !== me.eventCount) { const ve = me.object, _e = ge.internal.interaction.indexOf(ve); _e > -1 && ge.internal.interaction.splice(_e, 1), me.eventCount && ve.raycast !== null && ge.internal.interaction.push(ve) } return me && me.props.attach === void 0 && (me.object.isBufferGeometry ? me.props.attach = "geometry" : me.object.isMaterial && (me.props.attach = "material")), me && invalidateInstance(me), fe } function invalidateInstance(fe) { var K; if (!fe.parent) return; fe.props.onUpdate == null || fe.props.onUpdate(fe.object); const pe = (K = fe.root) == null || K.getState == null ? void 0 : K.getState(); pe && pe.internal.frames === 0 && pe.invalidate() } function updateCamera(fe, K) { fe.manual || (isOrthographicCamera$1(fe) ? (fe.left = K.width / -2, fe.right = K.width / 2, fe.top = K.height / 2, fe.bottom = K.height / -2) : fe.aspect = K.width / K.height, fe.updateProjectionMatrix()) } const isObject3D = fe => fe?.isObject3D; function makeId(fe) { return (fe.eventObject || fe.object).uuid + "/" + fe.index + fe.instanceId } function releaseInternalPointerCapture(fe, K, pe, me) { const ge = pe.get(K); ge && (pe.delete(K), pe.size === 0 && (fe.delete(me), ge.target.releasePointerCapture(me))) } function removeInteractivity(fe, K) { const { internal: pe } = fe.getState(); pe.interaction = pe.interaction.filter(me => me !== K), pe.initialHits = pe.initialHits.filter(me => me !== K), pe.hovered.forEach((me, ge) => { (me.eventObject === K || me.object === K) && pe.hovered.delete(ge) }), pe.capturedMap.forEach((me, ge) => { releaseInternalPointerCapture(pe.capturedMap, K, me, ge) }) } function createEvents(fe) { function K(_e) { const { internal: Ee } = fe.getState(), be = _e.offsetX - Ee.initialClick[0], Ae = _e.offsetY - Ee.initialClick[1]; return Math.round(Math.sqrt(be * be + Ae * Ae)) } function pe(_e) { return _e.filter(Ee => ["Move", "Over", "Enter", "Out", "Leave"].some(be => { var Ae; return (Ae = Ee.__r3f) == null ? void 0 : Ae.handlers["onPointer" + be] })) } function me(_e, Ee) { const be = fe.getState(), Ae = new Set, Se = [], Ce = Ee ? Ee(be.internal.interaction) : be.internal.interaction; for (let Re = 0; Re < Ce.length; Re++) { const Ie = getRootState(Ce[Re]); Ie && (Ie.raycaster.camera = void 0) } be.previousRoot || be.events.compute == null || be.events.compute(_e, be); function we(Re) { const Ie = getRootState(Re); if (!Ie || !Ie.events.enabled || Ie.raycaster.camera === null) return []; if (Ie.raycaster.camera === void 0) { var Pe; Ie.events.compute == null || Ie.events.compute(_e, Ie, (Pe = Ie.previousRoot) == null ? void 0 : Pe.getState()), Ie.raycaster.camera === void 0 && (Ie.raycaster.camera = null) } return Ie.raycaster.camera ? Ie.raycaster.intersectObject(Re, !0) : [] } let Be = Ce.flatMap(we).sort((Re, Ie) => { const Pe = getRootState(Re.object), Ne = getRootState(Ie.object); return !Pe || !Ne ? Re.distance - Ie.distance : Ne.events.priority - Pe.events.priority || Re.distance - Ie.distance }).filter(Re => { const Ie = makeId(Re); return Ae.has(Ie) ? !1 : (Ae.add(Ie), !0) }); be.events.filter && (Be = be.events.filter(Be, be)); for (const Re of Be) { let Ie = Re.object; for (; Ie;) { var De; (De = Ie.__r3f) != null && De.eventCount && Se.push({ ...Re, eventObject: Ie }), Ie = Ie.parent } } if ("pointerId" in _e && be.internal.capturedMap.has(_e.pointerId)) for (let Re of be.internal.capturedMap.get(_e.pointerId).values()) Ae.has(makeId(Re.intersection)) || Se.push(Re.intersection); return Se } function ge(_e, Ee, be, Ae) { if (_e.length) { const Se = { stopped: !1 }; for (const Ce of _e) { let we = getRootState(Ce.object); if (we || Ce.object.traverseAncestors(Be => { const De = getRootState(Be); if (De) return we = De, !1 }), we) { const { raycaster: Be, pointer: De, camera: Re, internal: Ie } = we, Pe = new Vector3(De.x, De.y, 0).unproject(Re), Ne = Ge => { var ze, We; return (ze = (We = Ie.capturedMap.get(Ge)) == null ? void 0 : We.has(Ce.eventObject)) != null ? ze : !1 }, ke = Ge => { const ze = { intersection: Ce, target: Ee.target }; Ie.capturedMap.has(Ge) ? Ie.capturedMap.get(Ge).set(Ce.eventObject, ze) : Ie.capturedMap.set(Ge, new Map([[Ce.eventObject, ze]])), Ee.target.setPointerCapture(Ge) }, Oe = Ge => { const ze = Ie.capturedMap.get(Ge); ze && releaseInternalPointerCapture(Ie.capturedMap, Ce.eventObject, ze, Ge) }; let Ue = {}; for (let Ge in Ee) { let ze = Ee[Ge]; typeof ze != "function" && (Ue[Ge] = ze) } let He = { ...Ce, ...Ue, pointer: De, intersections: _e, stopped: Se.stopped, delta: be, unprojectedPoint: Pe, ray: Be.ray, camera: Re, stopPropagation() { const Ge = "pointerId" in Ee && Ie.capturedMap.get(Ee.pointerId); if ((!Ge || Ge.has(Ce.eventObject)) && (He.stopped = Se.stopped = !0, Ie.hovered.size && Array.from(Ie.hovered.values()).find(ze => ze.eventObject === Ce.eventObject))) { const ze = _e.slice(0, _e.indexOf(Ce)); xe([...ze, Ce]) } }, target: { hasPointerCapture: Ne, setPointerCapture: ke, releasePointerCapture: Oe }, currentTarget: { hasPointerCapture: Ne, setPointerCapture: ke, releasePointerCapture: Oe }, nativeEvent: Ee }; if (Ae(He), Se.stopped === !0) break } } } return _e } function xe(_e) { const { internal: Ee } = fe.getState(); for (const be of Ee.hovered.values()) if (!_e.length || !_e.find(Ae => Ae.object === be.object && Ae.index === be.index && Ae.instanceId === be.instanceId)) { const Se = be.eventObject.__r3f; if (Ee.hovered.delete(makeId(be)), Se != null && Se.eventCount) { const Ce = Se.handlers, we = { ...be, intersections: _e }; Ce.onPointerOut == null || Ce.onPointerOut(we), Ce.onPointerLeave == null || Ce.onPointerLeave(we) } } } function ye(_e, Ee) { for (let be = 0; be < Ee.length; be++) { const Ae = Ee[be].__r3f; Ae == null || Ae.handlers.onPointerMissed == null || Ae.handlers.onPointerMissed(_e) } } function ve(_e) { switch (_e) { case "onPointerLeave": case "onPointerCancel": return () => xe([]); case "onLostPointerCapture": return Ee => { const { internal: be } = fe.getState(); "pointerId" in Ee && be.capturedMap.has(Ee.pointerId) && requestAnimationFrame(() => { be.capturedMap.has(Ee.pointerId) && (be.capturedMap.delete(Ee.pointerId), xe([])) }) } }return function (be) { const { onPointerMissed: Ae, internal: Se } = fe.getState(); Se.lastEvent.current = be; const Ce = _e === "onPointerMove", we = _e === "onClick" || _e === "onContextMenu" || _e === "onDoubleClick", De = me(be, Ce ? pe : void 0), Re = we ? K(be) : 0; _e === "onPointerDown" && (Se.initialClick = [be.offsetX, be.offsetY], Se.initialHits = De.map(Pe => Pe.eventObject)), we && !De.length && Re <= 2 && (ye(be, Se.interaction), Ae && Ae(be)), Ce && xe(De); function Ie(Pe) { const Ne = Pe.eventObject, ke = Ne.__r3f; if (!(ke != null && ke.eventCount)) return; const Oe = ke.handlers; if (Ce) { if (Oe.onPointerOver || Oe.onPointerEnter || Oe.onPointerOut || Oe.onPointerLeave) { const Ue = makeId(Pe), He = Se.hovered.get(Ue); He ? He.stopped && Pe.stopPropagation() : (Se.hovered.set(Ue, Pe), Oe.onPointerOver == null || Oe.onPointerOver(Pe), Oe.onPointerEnter == null || Oe.onPointerEnter(Pe)) } Oe.onPointerMove == null || Oe.onPointerMove(Pe) } else { const Ue = Oe[_e]; Ue ? (!we || Se.initialHits.includes(Ne)) && (ye(be, Se.interaction.filter(He => !Se.initialHits.includes(He))), Ue(Pe)) : we && Se.initialHits.includes(Ne) && ye(be, Se.interaction.filter(He => !Se.initialHits.includes(He))) } } ge(De, be, Re, Ie) } } return { handlePointer: ve } } const isRenderer = fe => !!(fe != null && fe.render), context$2 = reactExports.createContext(null), createStore$1 = (fe, K) => { const pe = createWithEqualityFn((ve, _e) => { const Ee = new Vector3, be = new Vector3, Ae = new Vector3; function Se(Re = _e().camera, Ie = be, Pe = _e().size) { const { width: Ne, height: ke, top: Oe, left: Ue } = Pe, He = Ne / ke; Ie.isVector3 ? Ae.copy(Ie) : Ae.set(...Ie); const Ge = Re.getWorldPosition(Ee).distanceTo(Ae); if (isOrthographicCamera$1(Re)) return { width: Ne / Re.zoom, height: ke / Re.zoom, top: Oe, left: Ue, factor: 1, distance: Ge, aspect: He }; { const ze = Re.fov * Math.PI / 180, We = 2 * Math.tan(ze / 2) * Ge, Xe = We * (Ne / ke); return { width: Xe, height: We, top: Oe, left: Ue, factor: Ne / Xe, distance: Ge, aspect: He } } } let Ce; const we = Re => ve(Ie => ({ performance: { ...Ie.performance, current: Re } })), Be = new Vector2; return { set: ve, get: _e, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, scene: null, xr: null, invalidate: (Re = 1) => fe(_e(), Re), advance: (Re, Ie) => K(Re, Ie, _e()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new Clock, pointer: Be, mouse: Be, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const Re = _e(); Ce && clearTimeout(Ce), Re.performance.current !== Re.performance.min && we(Re.performance.min), Ce = setTimeout(() => we(_e().performance.max), Re.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: Se }, setEvents: Re => ve(Ie => ({ ...Ie, events: { ...Ie.events, ...Re } })), setSize: (Re, Ie, Pe = 0, Ne = 0) => { const ke = _e().camera, Oe = { width: Re, height: Ie, top: Pe, left: Ne }; ve(Ue => ({ size: Oe, viewport: { ...Ue.viewport, ...Se(ke, be, Oe) } })) }, setDpr: Re => ve(Ie => { const Pe = calculateDpr(Re); return { viewport: { ...Ie.viewport, dpr: Pe, initialDpr: Ie.viewport.initialDpr || Pe } } }), setFrameloop: (Re = "always") => { const Ie = _e().clock; Ie.stop(), Ie.elapsedTime = 0, Re !== "never" && (Ie.start(), Ie.elapsedTime = 0), ve(() => ({ frameloop: Re })) }, previousRoot: void 0, internal: { interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, lastEvent: reactExports.createRef(), active: !1, frames: 0, priority: 0, subscribe: (Re, Ie, Pe) => { const Ne = _e().internal; return Ne.priority = Ne.priority + (Ie > 0 ? 1 : 0), Ne.subscribers.push({ ref: Re, priority: Ie, store: Pe }), Ne.subscribers = Ne.subscribers.sort((ke, Oe) => ke.priority - Oe.priority), () => { const ke = _e().internal; ke != null && ke.subscribers && (ke.priority = ke.priority - (Ie > 0 ? 1 : 0), ke.subscribers = ke.subscribers.filter(Oe => Oe.ref !== Re)) } } } } }), me = pe.getState(); let ge = me.size, xe = me.viewport.dpr, ye = me.camera; return pe.subscribe(() => { const { camera: ve, size: _e, viewport: Ee, gl: be, set: Ae } = pe.getState(); if (_e.width !== ge.width || _e.height !== ge.height || Ee.dpr !== xe) { ge = _e, xe = Ee.dpr, updateCamera(ve, _e), Ee.dpr > 0 && be.setPixelRatio(Ee.dpr); const Se = typeof HTMLCanvasElement < "u" && be.domElement instanceof HTMLCanvasElement; be.setSize(_e.width, _e.height, Se) } ve !== ye && (ye = ve, Ae(Se => ({ viewport: { ...Se.viewport, ...Se.viewport.getCurrentViewport(ve) } }))) }), pe.subscribe(ve => fe(ve)), pe }; function useStore$1() { const fe = reactExports.useContext(context$2); if (!fe) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return fe } function useThree(fe = pe => pe, K) { return useStore$1()(fe, K) } function useFrame(fe, K = 0) { const pe = useStore$1(), me = pe.getState().internal.subscribe, ge = useMutableCallback(fe); return useIsomorphicLayoutEffect(() => me(ge, K, pe), [K, me, pe]), null } const memoizedLoaders = new WeakMap, isConstructor$1 = fe => { var K; return typeof fe == "function" && (fe == null || (K = fe.prototype) == null ? void 0 : K.constructor) === fe }; function loadingFn(fe, K) { return function (pe, ...me) { let ge; return isConstructor$1(pe) ? (ge = memoizedLoaders.get(pe), ge || (ge = new pe, memoizedLoaders.set(pe, ge))) : ge = pe, fe && fe(ge), Promise.all(me.map(xe => new Promise((ye, ve) => ge.load(xe, _e => { isObject3D(_e?.scene) && Object.assign(_e, buildGraph(_e.scene)), ye(_e) }, K, _e => ve(new Error(`Could not load ${xe}: ${_e?.message}`)))))) } } function useLoader(fe, K, pe, me) { const ge = Array.isArray(K) ? K : [K], xe = suspend(loadingFn(pe, me), [fe, ...ge], { equal: is$1.equ }); return Array.isArray(K) ? xe : xe[0] } useLoader.preload = function (fe, K, pe) { const me = Array.isArray(K) ? K : [K]; return preload(loadingFn(pe), [fe, ...me]) }; useLoader.clear = function (fe, K) { const pe = Array.isArray(K) ? K : [K]; return clear([fe, ...pe]) }; function createReconciler(fe) { const K = Reconciler(fe); return K.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: reactExports.version }), K } const NoEventPriority = 0, catalogue = {}, PREFIX_REGEX = /^three(?=[A-Z])/, toPascalCase = fe => `${fe[0].toUpperCase()}${fe.slice(1)}`; let i$4 = 0; const isConstructor = fe => typeof fe == "function"; function extend$3(fe) { if (isConstructor(fe)) { const K = `${i$4++}`; return catalogue[K] = fe, K } else Object.assign(catalogue, fe) } function validateInstance(fe, K) { const pe = toPascalCase(fe), me = catalogue[pe]; if (fe !== "primitive" && !me) throw new Error(`R3F: ${pe} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (fe === "primitive" && !K.object) throw new Error("R3F: Primitives without 'object' are invalid!"); if (K.args !== void 0 && !Array.isArray(K.args)) throw new Error("R3F: The args prop must be an array!") } function createInstance(fe, K, pe) { var me; return fe = toPascalCase(fe) in catalogue ? fe : fe.replace(PREFIX_REGEX, ""), validateInstance(fe, K), fe === "primitive" && (me = K.object) != null && me.__r3f && delete K.object.__r3f, prepare(K.object, pe, fe, K) } function hideInstance(fe) { if (!fe.isHidden) { var K; fe.props.attach && (K = fe.parent) != null && K.object ? detach(fe.parent, fe) : isObject3D(fe.object) && (fe.object.visible = !1), fe.isHidden = !0, invalidateInstance(fe) } } function unhideInstance(fe) { if (fe.isHidden) { var K; fe.props.attach && (K = fe.parent) != null && K.object ? attach(fe.parent, fe) : isObject3D(fe.object) && fe.props.visible !== !1 && (fe.object.visible = !0), fe.isHidden = !1, invalidateInstance(fe) } } function handleContainerEffects(fe, K, pe) { const me = K.root.getState(); if (!(!fe.parent && fe.object !== me.scene)) { if (!K.object) { var ge, xe; const ye = catalogue[toPascalCase(K.type)]; K.object = (ge = K.props.object) != null ? ge : new ye(...(xe = K.props.args) != null ? xe : []), K.object.__r3f = K } if (applyProps(K.object, K.props), K.props.attach) attach(fe, K); else if (isObject3D(K.object) && isObject3D(fe.object)) { const ye = fe.object.children.indexOf(pe?.object); if (pe && ye !== -1) { const ve = fe.object.children.indexOf(K.object); if (ve !== -1) { fe.object.children.splice(ve, 1); const _e = ve < ye ? ye - 1 : ye; fe.object.children.splice(_e, 0, K.object) } else K.object.parent = fe.object, fe.object.children.splice(ye, 0, K.object), K.object.dispatchEvent({ type: "added" }), fe.object.dispatchEvent({ type: "childadded", child: K.object }) } else fe.object.add(K.object) } for (const ye of K.children) handleContainerEffects(K, ye); invalidateInstance(K) } } function appendChild(fe, K) { K && (K.parent = fe, fe.children.push(K), handleContainerEffects(fe, K)) } function insertBefore(fe, K, pe) { if (!K || !pe) return; K.parent = fe; const me = fe.children.indexOf(pe); me !== -1 ? fe.children.splice(me, 0, K) : fe.children.push(K), handleContainerEffects(fe, K, pe) } function disposeOnIdle(fe) { if (typeof fe.dispose == "function") { const K = () => { try { fe.dispose() } catch { } }; typeof IS_REACT_ACT_ENVIRONMENT < "u" ? K() : schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority, K) } } function removeChild(fe, K, pe) { if (!K) return; K.parent = null; const me = fe.children.indexOf(K); me !== -1 && fe.children.splice(me, 1), K.props.attach ? detach(fe, K) : isObject3D(K.object) && isObject3D(fe.object) && (fe.object.remove(K.object), removeInteractivity(findInitialRoot(K), K.object)); const ge = K.props.dispose !== null && pe !== !1; for (let xe = K.children.length - 1; xe >= 0; xe--) { const ye = K.children[xe]; removeChild(K, ye, ge) } K.children.length = 0, delete K.object.__r3f, ge && K.type !== "primitive" && K.object.type !== "Scene" && disposeOnIdle(K.object), pe === void 0 && invalidateInstance(K) } function setFiberRef(fe, K) { for (const pe of [fe, fe.alternate]) if (pe !== null) if (typeof pe.ref == "function") { pe.refCleanup == null || pe.refCleanup(); const me = pe.ref(K); typeof me == "function" && (pe.refCleanup = me) } else pe.ref && (pe.ref.current = K) } const reconstructed = []; function swapInstances() { for (const [pe] of reconstructed) { const me = pe.parent; if (me) { pe.props.attach ? detach(me, pe) : isObject3D(pe.object) && isObject3D(me.object) && me.object.remove(pe.object); for (const ge of pe.children) ge.props.attach ? detach(pe, ge) : isObject3D(ge.object) && isObject3D(pe.object) && pe.object.remove(ge.object) } pe.isHidden && unhideInstance(pe), pe.object.__r3f && delete pe.object.__r3f, pe.type !== "primitive" && disposeOnIdle(pe.object) } for (const [pe, me, ge] of reconstructed) { pe.props = me; const xe = pe.parent; if (xe) { var fe, K; const ye = catalogue[toPascalCase(pe.type)]; pe.object = (fe = pe.props.object) != null ? fe : new ye(...(K = pe.props.args) != null ? K : []), pe.object.__r3f = pe, setFiberRef(ge, pe.object), applyProps(pe.object, pe.props), pe.props.attach ? attach(xe, pe) : isObject3D(pe.object) && isObject3D(xe.object) && xe.object.add(pe.object); for (const ve of pe.children) ve.props.attach ? attach(pe, ve) : isObject3D(ve.object) && isObject3D(pe.object) && pe.object.add(ve.object); invalidateInstance(pe) } } reconstructed.length = 0 } const handleTextInstance = () => { }, NO_CONTEXT = {}; let currentUpdatePriority = NoEventPriority; const NoFlags = 0, Update = 4, reconciler = createReconciler({ isPrimaryRenderer: !1, warnsIfNotActing: !1, supportsMutation: !0, supportsPersistence: !1, supportsHydration: !1, createInstance, removeChild, appendChild, appendInitialChild: appendChild, insertBefore, appendChildToContainer(fe, K) { const pe = fe.getState().scene.__r3f; !K || !pe || appendChild(pe, K) }, removeChildFromContainer(fe, K) { const pe = fe.getState().scene.__r3f; !K || !pe || removeChild(pe, K) }, insertInContainerBefore(fe, K, pe) { const me = fe.getState().scene.__r3f; !K || !pe || !me || insertBefore(me, K, pe) }, getRootHostContext: () => NO_CONTEXT, getChildHostContext: () => NO_CONTEXT, commitUpdate(fe, K, pe, me, ge) { var xe, ye, ve; validateInstance(K, me); let _e = !1; if ((fe.type === "primitive" && pe.object !== me.object || ((xe = me.args) == null ? void 0 : xe.length) !== ((ye = pe.args) == null ? void 0 : ye.length) || (ve = me.args) != null && ve.some((be, Ae) => { var Se; return be !== ((Se = pe.args) == null ? void 0 : Se[Ae]) })) && (_e = !0), _e) reconstructed.push([fe, { ...me }, ge]); else { const be = diffProps(fe, me); Object.keys(be).length && (Object.assign(fe.props, be), applyProps(fe.object, be)) } (ge.sibling === null || (ge.flags & Update) === NoFlags) && swapInstances() }, finalizeInitialChildren: () => !1, commitMount() { }, getPublicInstance: fe => fe?.object, prepareForCommit: () => null, preparePortalMount: fe => prepare(fe.getState().scene, fe, "", {}), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance, unhideInstance, createTextInstance: handleTextInstance, hideTextInstance: handleTextInstance, unhideTextInstance: handleTextInstance, scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0, cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0, noTimeout: -1, getInstanceFromNode: () => null, beforeActiveInstanceBlur() { }, afterActiveInstanceBlur() { }, detachDeletedInstance() { }, prepareScopeUpdate() { }, getInstanceFromScope: () => null, shouldAttemptEagerTransition: () => !1, trackSchedulerEvent: () => { }, resolveEventType: () => null, resolveEventTimeStamp: () => -1.1, requestPostPaintCallback() { }, maySuspendCommit: () => !1, preloadInstance: () => !0, startSuspendingCommit() { }, suspendInstance() { }, waitForCommitToBeReady: () => null, NotPendingTransition: null, HostTransitionContext: reactExports.createContext(null), setCurrentUpdatePriority(fe) { currentUpdatePriority = fe }, getCurrentUpdatePriority() { return currentUpdatePriority }, resolveUpdatePriority() { var fe; if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority; switch (typeof window < "u" && ((fe = window.event) == null ? void 0 : fe.type)) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return constantsExports.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return constantsExports.ContinuousEventPriority; default: return constantsExports.DefaultEventPriority } }, resetFormInstance() { } }), _roots = new Map, shallowLoose = { objects: "shallow", strict: !1 }; function computeInitialSize(fe, K) { if (!K && typeof HTMLCanvasElement < "u" && fe instanceof HTMLCanvasElement && fe.parentElement) { const { width: pe, height: me, top: ge, left: xe } = fe.parentElement.getBoundingClientRect(); return { width: pe, height: me, top: ge, left: xe } } else if (!K && typeof OffscreenCanvas < "u" && fe instanceof OffscreenCanvas) return { width: fe.width, height: fe.height, top: 0, left: 0 }; return { width: 0, height: 0, top: 0, left: 0, ...K } } function createRoot(fe) { const K = _roots.get(fe), pe = K?.fiber, me = K?.store; K && console.warn("R3F.createRoot should only be called once!"); const ge = typeof reportError == "function" ? reportError : console.error, xe = me || createStore$1(invalidate, advance), ye = pe || reconciler.createContainer(xe, constantsExports.ConcurrentRoot, null, !1, null, "", ge, ge, ge, null); K || _roots.set(fe, { fiber: ye, store: xe }); let ve, _e, Ee = !1, be = null; return { async configure(Ae = {}) { let Se; be = new Promise(jt => Se = jt); let { gl: Ce, size: we, scene: Be, events: De, onCreated: Re, shadows: Ie = !1, linear: Pe = !1, flat: Ne = !1, legacy: ke = !1, orthographic: Oe = !1, frameloop: Ue = "always", dpr: He = [1, 2], performance: Ge, raycaster: ze, camera: We, onPointerMissed: Xe } = Ae, Ye = xe.getState(), Ze = Ye.gl; if (!Ye.gl) { const jt = { canvas: fe, powerPreference: "high-performance", antialias: !0, alpha: !0 }, Xt = typeof Ce == "function" ? await Ce(jt) : Ce; isRenderer(Xt) ? Ze = Xt : Ze = new WebGLRenderer({ ...jt, ...Ce }), Ye.set({ gl: Ze }) } let ot = Ye.raycaster; ot || Ye.set({ raycaster: ot = new Raycaster }); const { params: qe, ...Qe } = ze || {}; if (is$1.equ(Qe, ot, shallowLoose) || applyProps(ot, { ...Qe }), is$1.equ(qe, ot.params, shallowLoose) || applyProps(ot, { params: { ...ot.params, ...qe } }), !Ye.camera || Ye.camera === _e && !is$1.equ(_e, We, shallowLoose)) { _e = We; const jt = We?.isCamera, Xt = jt ? We : Oe ? new OrthographicCamera(0, 0, 0, 0, .1, 1e3) : new PerspectiveCamera(75, 0, .1, 1e3); jt || (Xt.position.z = 5, We && (applyProps(Xt, We), Xt.manual || ("aspect" in We || "left" in We || "right" in We || "bottom" in We || "top" in We) && (Xt.manual = !0, Xt.updateProjectionMatrix())), !Ye.camera && !(We != null && We.rotation) && Xt.lookAt(0, 0, 0)), Ye.set({ camera: Xt }), ot.camera = Xt } if (!Ye.scene) { let jt; Be != null && Be.isScene ? (jt = Be, prepare(jt, xe, "", {})) : (jt = new Scene, prepare(jt, xe, "", {}), Be && applyProps(jt, Be)), Ye.set({ scene: jt }) } De && !Ye.events.handlers && Ye.set({ events: De(xe) }); const st = computeInitialSize(fe, we); if (is$1.equ(st, Ye.size, shallowLoose) || Ye.setSize(st.width, st.height, st.top, st.left), He && Ye.viewport.dpr !== calculateDpr(He) && Ye.setDpr(He), Ye.frameloop !== Ue && Ye.setFrameloop(Ue), Ye.onPointerMissed || Ye.set({ onPointerMissed: Xe }), Ge && !is$1.equ(Ge, Ye.performance, shallowLoose) && Ye.set(jt => ({ performance: { ...jt.performance, ...Ge } })), !Ye.xr) { var Nt; const jt = (nn, $t) => { const an = xe.getState(); an.frameloop !== "never" && advance(nn, !0, an, $t) }, Xt = () => { const nn = xe.getState(); nn.gl.xr.enabled = nn.gl.xr.isPresenting, nn.gl.xr.setAnimationLoop(nn.gl.xr.isPresenting ? jt : null), nn.gl.xr.isPresenting || invalidate(nn) }, ct = { connect() { const nn = xe.getState().gl; nn.xr.addEventListener("sessionstart", Xt), nn.xr.addEventListener("sessionend", Xt) }, disconnect() { const nn = xe.getState().gl; nn.xr.removeEventListener("sessionstart", Xt), nn.xr.removeEventListener("sessionend", Xt) } }; typeof ((Nt = Ze.xr) == null ? void 0 : Nt.addEventListener) == "function" && ct.connect(), Ye.set({ xr: ct }) } if (Ze.shadowMap) { const jt = Ze.shadowMap.enabled, Xt = Ze.shadowMap.type; if (Ze.shadowMap.enabled = !!Ie, is$1.boo(Ie)) Ze.shadowMap.type = PCFSoftShadowMap; else if (is$1.str(Ie)) { var Je; const ct = { basic: BasicShadowMap, percentage: PCFShadowMap, soft: PCFSoftShadowMap, variance: VSMShadowMap }; Ze.shadowMap.type = (Je = ct[Ie]) != null ? Je : PCFSoftShadowMap } else is$1.obj(Ie) && Object.assign(Ze.shadowMap, Ie); (jt !== Ze.shadowMap.enabled || Xt !== Ze.shadowMap.type) && (Ze.shadowMap.needsUpdate = !0) } return ColorManagement.enabled = !ke, Ee || (Ze.outputColorSpace = Pe ? LinearSRGBColorSpace : SRGBColorSpace, Ze.toneMapping = Ne ? NoToneMapping : ACESFilmicToneMapping), Ye.legacy !== ke && Ye.set(() => ({ legacy: ke })), Ye.linear !== Pe && Ye.set(() => ({ linear: Pe })), Ye.flat !== Ne && Ye.set(() => ({ flat: Ne })), Ce && !is$1.fun(Ce) && !isRenderer(Ce) && !is$1.equ(Ce, Ze, shallowLoose) && applyProps(Ze, Ce), ve = Re, Ee = !0, Se(), this }, render(Ae) { return !Ee && !be && this.configure(), be.then(() => { reconciler.updateContainer(jsxRuntimeExports.jsx(Provider, { store: xe, children: Ae, onCreated: ve, rootElement: fe }), ye, null, () => { }) }), xe }, unmount() { unmountComponentAtNode(fe) } } } function Provider({ store: fe, children: K, onCreated: pe, rootElement: me }) { return useIsomorphicLayoutEffect(() => { const ge = fe.getState(); ge.set(xe => ({ internal: { ...xe.internal, active: !0 } })), pe && pe(ge), fe.getState().events.connected || ge.events.connect == null || ge.events.connect(me) }, []), jsxRuntimeExports.jsx(context$2.Provider, { value: fe, children: K }) } function unmountComponentAtNode(fe, K) { const pe = _roots.get(fe), me = pe?.fiber; if (me) { const ge = pe?.store.getState(); ge && (ge.internal.active = !1), reconciler.updateContainer(null, me, null, () => { ge && setTimeout(() => { try { var xe, ye, ve, _e; ge.events.disconnect == null || ge.events.disconnect(), (xe = ge.gl) == null || (ye = xe.renderLists) == null || ye.dispose == null || ye.dispose(), (ve = ge.gl) == null || ve.forceContextLoss == null || ve.forceContextLoss(), (_e = ge.gl) != null && _e.xr && ge.xr.disconnect(), dispose(ge.scene), _roots.delete(fe) } catch { } }, 500) }) } } function createPortal(fe, K, pe) { return jsxRuntimeExports.jsx(Portal, { children: fe, container: K, state: pe }) } function Portal({ state: fe = {}, children: K, container: pe }) { const { events: me, size: ge, ...xe } = fe, ye = useStore$1(), [ve] = reactExports.useState(() => new Raycaster), [_e] = reactExports.useState(() => new Vector2), Ee = useMutableCallback((Ae, Se) => { let Ce; if (Se.camera && ge) { const we = Se.camera; Ce = Ae.viewport.getCurrentViewport(we, new Vector3, ge), we !== Ae.camera && updateCamera(we, ge) } return { ...Ae, ...Se, scene: pe, raycaster: ve, pointer: _e, mouse: _e, previousRoot: ye, events: { ...Ae.events, ...Se.events, ...me }, size: { ...Ae.size, ...ge }, viewport: { ...Ae.viewport, ...Ce }, setEvents: we => Se.set(Be => ({ ...Be, events: { ...Be.events, ...we } })) } }), be = reactExports.useMemo(() => { const Ae = createWithEqualityFn((Ce, we) => ({ ...xe, set: Ce, get: we })), Se = Ce => Ae.setState(we => Ee.current(Ce, we)); return Se(ye.getState()), ye.subscribe(Se), Ae }, [ye, pe]); return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: reconciler.createPortal(jsxRuntimeExports.jsx(context$2.Provider, { value: be, children: K }), be, null) }) } function createSubs(fe, K) { const pe = { callback: fe }; return K.add(pe), () => void K.delete(pe) } const globalEffects = new Set, globalAfterEffects = new Set, globalTailEffects = new Set, addEffect = fe => createSubs(fe, globalEffects), addAfterEffect = fe => createSubs(fe, globalAfterEffects); function run$1(fe, K) { if (fe.size) for (const { callback: pe } of fe.values()) pe(K) } function flushGlobalEffects(fe, K) { switch (fe) { case "before": return run$1(globalEffects, K); case "after": return run$1(globalAfterEffects, K); case "tail": return run$1(globalTailEffects, K) } } let subscribers, subscription; function update(fe, K, pe) { let me = K.clock.getDelta(); K.frameloop === "never" && typeof fe == "number" && (me = fe - K.clock.elapsedTime, K.clock.oldTime = K.clock.elapsedTime, K.clock.elapsedTime = fe), subscribers = K.internal.subscribers; for (let ge = 0; ge < subscribers.length; ge++)subscription = subscribers[ge], subscription.ref.current(subscription.store.getState(), me, pe); return !K.internal.priority && K.gl.render && K.gl.render(K.scene, K.camera), K.internal.frames = Math.max(0, K.internal.frames - 1), K.frameloop === "always" ? 1 : K.internal.frames } let running = !1, useFrameInProgress = !1, repeat, frame, state; function loop(fe) { frame = requestAnimationFrame(loop), running = !0, repeat = 0, flushGlobalEffects("before", fe), useFrameInProgress = !0; for (const pe of _roots.values()) { var K; state = pe.store.getState(), state.internal.active && (state.frameloop === "always" || state.internal.frames > 0) && !((K = state.gl.xr) != null && K.isPresenting) && (repeat += update(fe, state)) } if (useFrameInProgress = !1, flushGlobalEffects("after", fe), repeat === 0) return flushGlobalEffects("tail", fe), running = !1, cancelAnimationFrame(frame) } function invalidate(fe, K = 1) { var pe; if (!fe) return _roots.forEach(me => invalidate(me.store.getState(), K)); (pe = fe.gl.xr) != null && pe.isPresenting || !fe.internal.active || fe.frameloop === "never" || (K > 1 ? fe.internal.frames = Math.min(60, fe.internal.frames + K) : useFrameInProgress ? fe.internal.frames = 2 : fe.internal.frames = 1, running || (running = !0, requestAnimationFrame(loop))) } function advance(fe, K = !0, pe, me) { if (K && flushGlobalEffects("before", fe), pe) update(fe, pe, me); else for (const ge of _roots.values()) update(fe, ge.store.getState()); K && flushGlobalEffects("after", fe) } const DOM_EVENTS = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function createPointerEvents(fe) { const { handlePointer: K } = createEvents(fe); return { priority: 1, enabled: !0, compute(pe, me, ge) { me.pointer.set(pe.offsetX / me.size.width * 2 - 1, -(pe.offsetY / me.size.height) * 2 + 1), me.raycaster.setFromCamera(me.pointer, me.camera) }, connected: void 0, handlers: Object.keys(DOM_EVENTS).reduce((pe, me) => ({ ...pe, [me]: K(me) }), {}), update: () => { var pe; const { events: me, internal: ge } = fe.getState(); (pe = ge.lastEvent) != null && pe.current && me.handlers && me.handlers.onPointerMove(ge.lastEvent.current) }, connect: pe => { const { set: me, events: ge } = fe.getState(); if (ge.disconnect == null || ge.disconnect(), me(xe => ({ events: { ...xe.events, connected: pe } })), ge.handlers) for (const xe in ge.handlers) { const ye = ge.handlers[xe], [ve, _e] = DOM_EVENTS[xe]; pe.addEventListener(ve, ye, { passive: _e }) } }, disconnect: () => { const { set: pe, events: me } = fe.getState(); if (me.connected) { if (me.handlers) for (const ge in me.handlers) { const xe = me.handlers[ge], [ye] = DOM_EVENTS[ge]; me.connected.removeEventListener(ye, xe) } pe(ge => ({ events: { ...ge.events, connected: void 0 } })) } } } } function g$2(fe, K) { let pe; return (...me) => { window.clearTimeout(pe), pe = window.setTimeout(() => fe(...me), K) } } function j$1({ debounce: fe, scroll: K, polyfill: pe, offsetSize: me } = { debounce: 0, scroll: !1, offsetSize: !1 }) { const ge = pe || (typeof window > "u" ? class { } : window.ResizeObserver); if (!ge) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [xe, ye] = reactExports.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), ve = reactExports.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: xe, orientationHandler: null }), _e = fe ? typeof fe == "number" ? fe : fe.scroll : null, Ee = fe ? typeof fe == "number" ? fe : fe.resize : null, be = reactExports.useRef(!1); reactExports.useEffect(() => (be.current = !0, () => void (be.current = !1))); const [Ae, Se, Ce] = reactExports.useMemo(() => { const Re = () => { if (!ve.current.element) return; const { left: Ie, top: Pe, width: Ne, height: ke, bottom: Oe, right: Ue, x: He, y: Ge } = ve.current.element.getBoundingClientRect(), ze = { left: Ie, top: Pe, width: Ne, height: ke, bottom: Oe, right: Ue, x: He, y: Ge }; ve.current.element instanceof HTMLElement && me && (ze.height = ve.current.element.offsetHeight, ze.width = ve.current.element.offsetWidth), Object.freeze(ze), be.current && !D$2(ve.current.lastBounds, ze) && ye(ve.current.lastBounds = ze) }; return [Re, Ee ? g$2(Re, Ee) : Re, _e ? g$2(Re, _e) : Re] }, [ye, me, _e, Ee]); function we() { ve.current.scrollContainers && (ve.current.scrollContainers.forEach(Re => Re.removeEventListener("scroll", Ce, !0)), ve.current.scrollContainers = null), ve.current.resizeObserver && (ve.current.resizeObserver.disconnect(), ve.current.resizeObserver = null), ve.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", ve.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", ve.current.orientationHandler)) } function Be() { ve.current.element && (ve.current.resizeObserver = new ge(Ce), ve.current.resizeObserver.observe(ve.current.element), K && ve.current.scrollContainers && ve.current.scrollContainers.forEach(Re => Re.addEventListener("scroll", Ce, { capture: !0, passive: !0 })), ve.current.orientationHandler = () => { Ce() }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", ve.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", ve.current.orientationHandler)) } const De = Re => { !Re || Re === ve.current.element || (we(), ve.current.element = Re, ve.current.scrollContainers = E$1(Re), Be()) }; return X$3(Ce, !!K), W$2(Se), reactExports.useEffect(() => { we(), Be() }, [K, Ce, Se]), reactExports.useEffect(() => we, []), [De, xe, Ae] } function W$2(fe) { reactExports.useEffect(() => { const K = fe; return window.addEventListener("resize", K), () => void window.removeEventListener("resize", K) }, [fe]) } function X$3(fe, K) { reactExports.useEffect(() => { if (K) { const pe = fe; return window.addEventListener("scroll", pe, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", pe, !0) } }, [fe, K]) } function E$1(fe) { const K = []; if (!fe || fe === document.body) return K; const { overflow: pe, overflowX: me, overflowY: ge } = window.getComputedStyle(fe); return [pe, me, ge].some(xe => xe === "auto" || xe === "scroll") && K.push(fe), [...K, ...E$1(fe.parentElement)] } const k$1 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], D$2 = (fe, K) => k$1.every(pe => fe[pe] === K[pe]); function CanvasImpl({ ref: fe, children: K, fallback: pe, resize: me, style: ge, gl: xe, events: ye = createPointerEvents, eventSource: ve, eventPrefix: _e, shadows: Ee, linear: be, flat: Ae, legacy: Se, orthographic: Ce, frameloop: we, dpr: Be, performance: De, raycaster: Re, camera: Ie, scene: Pe, onPointerMissed: Ne, onCreated: ke, ...Oe }) { reactExports.useMemo(() => extend$3(THREE$1), []); const Ue = useBridge(), [He, Ge] = j$1({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...me }), ze = reactExports.useRef(null), We = reactExports.useRef(null); reactExports.useImperativeHandle(fe, () => ze.current); const Xe = useMutableCallback(Ne), [Ye, Ze] = reactExports.useState(!1), [ot, qe] = reactExports.useState(!1); if (Ye) throw Ye; if (ot) throw ot; const Qe = reactExports.useRef(null); useIsomorphicLayoutEffect(() => { const Nt = ze.current; if (Ge.width > 0 && Ge.height > 0 && Nt) { Qe.current || (Qe.current = createRoot(Nt)); async function Je() { await Qe.current.configure({ gl: xe, scene: Pe, events: ye, shadows: Ee, linear: be, flat: Ae, legacy: Se, orthographic: Ce, frameloop: we, dpr: Be, performance: De, raycaster: Re, camera: Ie, size: Ge, onPointerMissed: (...jt) => Xe.current == null ? void 0 : Xe.current(...jt), onCreated: jt => { jt.events.connect == null || jt.events.connect(ve ? isRef$1(ve) ? ve.current : ve : We.current), _e && jt.setEvents({ compute: (Xt, ct) => { const nn = Xt[_e + "X"], $t = Xt[_e + "Y"]; ct.pointer.set(nn / ct.size.width * 2 - 1, -($t / ct.size.height) * 2 + 1), ct.raycaster.setFromCamera(ct.pointer, ct.camera) } }), ke?.(jt) } }), Qe.current.render(jsxRuntimeExports.jsx(Ue, { children: jsxRuntimeExports.jsx(ErrorBoundary$1, { set: qe, children: jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: jsxRuntimeExports.jsx(Block, { set: Ze }), children: K ?? null }) }) })) } Je() } }), reactExports.useEffect(() => { const Nt = ze.current; if (Nt) return () => unmountComponentAtNode(Nt) }, []); const st = ve ? "none" : "auto"; return jsxRuntimeExports.jsx("div", { ref: We, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: st, ...ge }, ...Oe, children: jsxRuntimeExports.jsx("div", { ref: He, style: { width: "100%", height: "100%" }, children: jsxRuntimeExports.jsx("canvas", { ref: ze, style: { display: "block" }, children: pe }) }) }) } function Canvas(fe) { return jsxRuntimeExports.jsx(m$2, { children: jsxRuntimeExports.jsx(CanvasImpl, { ...fe }) }) } const v1 = new Vector3, v2 = new Vector3, v3 = new Vector3, v4$1 = new Vector2; function defaultCalculatePosition(fe, K, pe) { const me = v1.setFromMatrixPosition(fe.matrixWorld); me.project(K); const ge = pe.width / 2, xe = pe.height / 2; return [me.x * ge + ge, -(me.y * xe) + xe] } function isObjectBehindCamera(fe, K) { const pe = v1.setFromMatrixPosition(fe.matrixWorld), me = v2.setFromMatrixPosition(K.matrixWorld), ge = pe.sub(me), xe = K.getWorldDirection(v3); return ge.angleTo(xe) > Math.PI / 2 } function isObjectVisible(fe, K, pe, me) { const ge = v1.setFromMatrixPosition(fe.matrixWorld), xe = ge.clone(); xe.project(K), v4$1.set(xe.x, xe.y), pe.setFromCamera(v4$1, K); const ye = pe.intersectObjects(me, !0); if (ye.length) { const ve = ye[0].distance; return ge.distanceTo(pe.ray.origin) < ve } return !0 } function objectScale(fe, K) { if (K instanceof OrthographicCamera) return K.zoom; if (K instanceof PerspectiveCamera) { const pe = v1.setFromMatrixPosition(fe.matrixWorld), me = v2.setFromMatrixPosition(K.matrixWorld), ge = K.fov * Math.PI / 180, xe = pe.distanceTo(me); return 1 / (2 * Math.tan(ge / 2) * xe) } else return 1 } function objectZIndex(fe, K, pe) { if (K instanceof PerspectiveCamera || K instanceof OrthographicCamera) { const me = v1.setFromMatrixPosition(fe.matrixWorld), ge = v2.setFromMatrixPosition(K.matrixWorld), xe = me.distanceTo(ge), ye = (pe[1] - pe[0]) / (K.far - K.near), ve = pe[1] - ye * K.far; return Math.round(ye * xe + ve) } } const epsilon = fe => Math.abs(fe) < 1e-10 ? 0 : fe; function getCSSMatrix(fe, K, pe = "") { let me = "matrix3d("; for (let ge = 0; ge !== 16; ge++)me += epsilon(K[ge] * fe.elements[ge]) + (ge !== 15 ? "," : ")"); return pe + me } const getCameraCSSMatrix = (fe => K => getCSSMatrix(K, fe))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), getObjectCSSMatrix = (fe => (K, pe) => getCSSMatrix(K, fe(pe), "translate(-50%,-50%)"))(fe => [1 / fe, 1 / fe, 1 / fe, 1, -1 / fe, -1 / fe, -1 / fe, -1, 1 / fe, 1 / fe, 1 / fe, 1, 1, 1, 1, 1]); function isRefObject(fe) { return fe && typeof fe == "object" && "current" in fe } const Html = reactExports.forwardRef(({ children: fe, eps: K = .001, style: pe, className: me, prepend: ge, center: xe, fullscreen: ye, portal: ve, distanceFactor: _e, sprite: Ee = !1, transform: be = !1, occlude: Ae, onOcclude: Se, castShadow: Ce, receiveShadow: we, material: Be, geometry: De, zIndexRange: Re = [16777271, 0], calculatePosition: Ie = defaultCalculatePosition, as: Pe = "div", wrapperClass: Ne, pointerEvents: ke = "auto", ...Oe }, Ue) => {
	const { gl: He, camera: Ge, scene: ze, size: We, raycaster: Xe, events: Ye, viewport: Ze } = useThree(), [ot] = reactExports.useState(() => document.createElement(Pe)), qe = reactExports.useRef(null), Qe = reactExports.useRef(null), st = reactExports.useRef(0), Nt = reactExports.useRef([0, 0]), Je = reactExports.useRef(null), jt = reactExports.useRef(null), Xt = ve?.current || Ye.connected || He.domElement.parentNode, ct = reactExports.useRef(null), nn = reactExports.useRef(!1), $t = reactExports.useMemo(() => Ae && Ae !== "blending" || Array.isArray(Ae) && Ae.length && isRefObject(Ae[0]), [Ae]); reactExports.useLayoutEffect(() => { const Ln = He.domElement; Ae && Ae === "blending" ? (Ln.style.zIndex = `${Math.floor(Re[0] / 2)}`, Ln.style.position = "absolute", Ln.style.pointerEvents = "none") : (Ln.style.zIndex = null, Ln.style.position = null, Ln.style.pointerEvents = null) }, [Ae]), reactExports.useLayoutEffect(() => { if (Qe.current) { const Ln = qe.current = clientExports.createRoot(ot); if (ze.updateMatrixWorld(), be) ot.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"; else { const Gn = Ie(Qe.current, Ge, We); ot.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Gn[0]}px,${Gn[1]}px,0);transform-origin:0 0;` } return Xt && (ge ? Xt.prepend(ot) : Xt.appendChild(ot)), () => { Xt && Xt.removeChild(ot), Ln.unmount() } } }, [Xt, be]), reactExports.useLayoutEffect(() => { Ne && (ot.className = Ne) }, [Ne]); const an = reactExports.useMemo(() => be ? { position: "absolute", top: 0, left: 0, width: We.width, height: We.height, transformStyle: "preserve-3d", pointerEvents: "none" } : { position: "absolute", transform: xe ? "translate3d(-50%,-50%,0)" : "none", ...ye && { top: -We.height / 2, left: -We.width / 2, width: We.width, height: We.height }, ...pe }, [pe, xe, ye, We, be]), gn = reactExports.useMemo(() => ({ position: "absolute", pointerEvents: ke }), [ke]); reactExports.useLayoutEffect(() => { if (nn.current = !1, be) { var Ln; (Ln = qe.current) == null || Ln.render(reactExports.createElement("div", { ref: Je, style: an }, reactExports.createElement("div", { ref: jt, style: gn }, reactExports.createElement("div", { ref: Ue, className: me, style: pe, children: fe })))) } else { var Gn; (Gn = qe.current) == null || Gn.render(reactExports.createElement("div", { ref: Ue, style: an, className: me, children: fe })) } }); const Mn = reactExports.useRef(!0); useFrame(Ln => { if (Qe.current) { Ge.updateMatrixWorld(), Qe.current.updateWorldMatrix(!0, !1); const Gn = be ? Nt.current : Ie(Qe.current, Ge, We); if (be || Math.abs(st.current - Ge.zoom) > K || Math.abs(Nt.current[0] - Gn[0]) > K || Math.abs(Nt.current[1] - Gn[1]) > K) { const wn = isObjectBehindCamera(Qe.current, Ge); let Bn = !1; $t && (Array.isArray(Ae) ? Bn = Ae.map(vn => vn.current) : Ae !== "blending" && (Bn = [ze])); const Gt = Mn.current; if (Bn) { const vn = isObjectVisible(Qe.current, Ge, Xe, Bn); Mn.current = vn && !wn } else Mn.current = !wn; Gt !== Mn.current && (Se ? Se(!Mn.current) : ot.style.display = Mn.current ? "block" : "none"); const nr = Math.floor(Re[0] / 2), Kn = Ae ? $t ? [Re[0], nr] : [nr - 1, 0] : Re; if (ot.style.zIndex = `${objectZIndex(Qe.current, Ge, Kn)}`, be) { const [vn, yn] = [We.width / 2, We.height / 2], Hn = Ge.projectionMatrix.elements[5] * yn, { isOrthographicCamera: kn, top: Ht, left: Dt, bottom: fn, right: en } = Ge, cn = getCameraCSSMatrix(Ge.matrixWorldInverse), Wt = kn ? `scale(${Hn})translate(${epsilon(-(en + Dt) / 2)}px,${epsilon((Ht + fn) / 2)}px)` : `translateZ(${Hn}px)`; let un = Qe.current.matrixWorld; Ee && (un = Ge.matrixWorldInverse.clone().transpose().copyPosition(un).scale(Qe.current.scale), un.elements[3] = un.elements[7] = un.elements[11] = 0, un.elements[15] = 1), ot.style.width = We.width + "px", ot.style.height = We.height + "px", ot.style.perspective = kn ? "" : `${Hn}px`, Je.current && jt.current && (Je.current.style.transform = `${Wt}${cn}translate(${vn}px,${yn}px)`, jt.current.style.transform = getObjectCSSMatrix(un, 1 / ((_e || 10) / 400))) } else { const vn = _e === void 0 ? 1 : objectScale(Qe.current, Ge) * _e; ot.style.transform = `translate3d(${Gn[0]}px,${Gn[1]}px,0) scale(${vn})` } Nt.current = Gn, st.current = Ge.zoom } } if (!$t && ct.current && !nn.current) if (be) { if (Je.current) { const Gn = Je.current.children[0]; if (Gn != null && Gn.clientWidth && Gn != null && Gn.clientHeight) { const { isOrthographicCamera: wn } = Ge; if (wn || De) Oe.scale && (Array.isArray(Oe.scale) ? Oe.scale instanceof Vector3 ? ct.current.scale.copy(Oe.scale.clone().divideScalar(1)) : ct.current.scale.set(1 / Oe.scale[0], 1 / Oe.scale[1], 1 / Oe.scale[2]) : ct.current.scale.setScalar(1 / Oe.scale)); else { const Bn = (_e || 10) / 400, Gt = Gn.clientWidth * Bn, nr = Gn.clientHeight * Bn; ct.current.scale.set(Gt, nr, 1) } nn.current = !0 } } } else { const Gn = ot.children[0]; if (Gn != null && Gn.clientWidth && Gn != null && Gn.clientHeight) { const wn = 1 / Ze.factor, Bn = Gn.clientWidth * wn, Gt = Gn.clientHeight * wn; ct.current.scale.set(Bn, Gt, 1), nn.current = !0 } ct.current.lookAt(Ln.camera.position) } }); const Xn = reactExports.useMemo(() => ({
		vertexShader: be ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `, fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}), [be]); return reactExports.createElement("group", _extends$2({}, Oe, { ref: Qe }), Ae && !$t && reactExports.createElement("mesh", { castShadow: Ce, receiveShadow: we, ref: ct }, De || reactExports.createElement("planeGeometry", null), Be || reactExports.createElement("shaderMaterial", { side: DoubleSide, vertexShader: Xn.vertexShader, fragmentShader: Xn.fragmentShader })))
}), version$1 = parseInt(REVISION.replace(/\D+/g, "")), UV1 = version$1 >= 125 ? "uv1" : "uv2"; function toCreasedNormals(fe, K = Math.PI / 3) { const pe = Math.cos(K), me = (1 + 1e-10) * 100, ge = [new Vector3, new Vector3, new Vector3], xe = new Vector3, ye = new Vector3, ve = new Vector3, _e = new Vector3; function Ee(Be) { const De = ~~(Be.x * me), Re = ~~(Be.y * me), Ie = ~~(Be.z * me); return `${De},${Re},${Ie}` } const be = fe.index ? fe.toNonIndexed() : fe, Ae = be.attributes.position, Se = {}; for (let Be = 0, De = Ae.count / 3; Be < De; Be++) { const Re = 3 * Be, Ie = ge[0].fromBufferAttribute(Ae, Re + 0), Pe = ge[1].fromBufferAttribute(Ae, Re + 1), Ne = ge[2].fromBufferAttribute(Ae, Re + 2); xe.subVectors(Ne, Pe), ye.subVectors(Ie, Pe); const ke = new Vector3().crossVectors(xe, ye).normalize(); for (let Oe = 0; Oe < 3; Oe++) { const Ue = ge[Oe], He = Ee(Ue); He in Se || (Se[He] = []), Se[He].push(ke) } } const Ce = new Float32Array(Ae.count * 3), we = new BufferAttribute(Ce, 3, !1); for (let Be = 0, De = Ae.count / 3; Be < De; Be++) { const Re = 3 * Be, Ie = ge[0].fromBufferAttribute(Ae, Re + 0), Pe = ge[1].fromBufferAttribute(Ae, Re + 1), Ne = ge[2].fromBufferAttribute(Ae, Re + 2); xe.subVectors(Ne, Pe), ye.subVectors(Ie, Pe), ve.crossVectors(xe, ye).normalize(); for (let ke = 0; ke < 3; ke++) { const Oe = ge[ke], Ue = Ee(Oe), He = Se[Ue]; _e.set(0, 0, 0); for (let Ge = 0, ze = He.length; Ge < ze; Ge++) { const We = He[Ge]; ve.dot(We) > pe && _e.add(We) } _e.normalize(), we.setXYZ(Re + ke, _e.x, _e.y, _e.z) } } return be.setAttribute("normal", we), be } var u8$1 = Uint8Array, u16$1 = Uint16Array, u32 = Uint32Array, fleb$1 = new u8$1([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), fdeb$1 = new u8$1([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), clim$1 = new u8$1([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), freb$1 = function (fe, K) { for (var pe = new u16$1(31), me = 0; me < 31; ++me)pe[me] = K += 1 << fe[me - 1]; for (var ge = new u32(pe[30]), me = 1; me < 30; ++me)for (var xe = pe[me]; xe < pe[me + 1]; ++xe)ge[xe] = xe - pe[me] << 5 | me; return [pe, ge] }, _a$2 = freb$1(fleb$1, 2), fl$1 = _a$2[0], revfl$1 = _a$2[1]; fl$1[28] = 258, revfl$1[258] = 28; var _b$1 = freb$1(fdeb$1, 0), fd$1 = _b$1[0], rev$1 = new u16$1(32768); for (var i$3 = 0; i$3 < 32768; ++i$3) { var x$2 = (i$3 & 43690) >>> 1 | (i$3 & 21845) << 1; x$2 = (x$2 & 52428) >>> 2 | (x$2 & 13107) << 2, x$2 = (x$2 & 61680) >>> 4 | (x$2 & 3855) << 4, rev$1[i$3] = ((x$2 & 65280) >>> 8 | (x$2 & 255) << 8) >>> 1 } var hMap$1 = function (fe, K, pe) { for (var me = fe.length, ge = 0, xe = new u16$1(K); ge < me; ++ge)++xe[fe[ge] - 1]; var ye = new u16$1(K); for (ge = 0; ge < K; ++ge)ye[ge] = ye[ge - 1] + xe[ge - 1] << 1; var ve; if (pe) { ve = new u16$1(1 << K); var _e = 15 - K; for (ge = 0; ge < me; ++ge)if (fe[ge]) for (var Ee = ge << 4 | fe[ge], be = K - fe[ge], Ae = ye[fe[ge] - 1]++ << be, Se = Ae | (1 << be) - 1; Ae <= Se; ++Ae)ve[rev$1[Ae] >>> _e] = Ee } else for (ve = new u16$1(me), ge = 0; ge < me; ++ge)fe[ge] && (ve[ge] = rev$1[ye[fe[ge] - 1]++] >>> 15 - fe[ge]); return ve }, flt$1 = new u8$1(288); for (var i$3 = 0; i$3 < 144; ++i$3)flt$1[i$3] = 8; for (var i$3 = 144; i$3 < 256; ++i$3)flt$1[i$3] = 9; for (var i$3 = 256; i$3 < 280; ++i$3)flt$1[i$3] = 7; for (var i$3 = 280; i$3 < 288; ++i$3)flt$1[i$3] = 8; var fdt$1 = new u8$1(32); for (var i$3 = 0; i$3 < 32; ++i$3)fdt$1[i$3] = 5; var flrm$1 = hMap$1(flt$1, 9, 1), fdrm$1 = hMap$1(fdt$1, 5, 1), max$2 = function (fe) { for (var K = fe[0], pe = 1; pe < fe.length; ++pe)fe[pe] > K && (K = fe[pe]); return K }, bits$1 = function (fe, K, pe) { var me = K / 8 | 0; return (fe[me] | fe[me + 1] << 8) >> (K & 7) & pe }, bits16$1 = function (fe, K) { var pe = K / 8 | 0; return (fe[pe] | fe[pe + 1] << 8 | fe[pe + 2] << 16) >> (K & 7) }, shft$1 = function (fe) { return (fe / 8 | 0) + (fe & 7 && 1) }, slc$1 = function (fe, K, pe) { (pe == null || pe > fe.length) && (pe = fe.length); var me = new (fe instanceof u16$1 ? u16$1 : fe instanceof u32 ? u32 : u8$1)(pe - K); return me.set(fe.subarray(K, pe)), me }, inflt$1 = function (fe, K, pe) { var me = fe.length; if (!me || pe && !pe.l && me < 5) return K || new u8$1(0); var ge = !K || pe, xe = !pe || pe.i; pe || (pe = {}), K || (K = new u8$1(me * 3)); var ye = function (an) { var gn = K.length; if (an > gn) { var Mn = new u8$1(Math.max(gn * 2, an)); Mn.set(K), K = Mn } }, ve = pe.f || 0, _e = pe.p || 0, Ee = pe.b || 0, be = pe.l, Ae = pe.d, Se = pe.m, Ce = pe.n, we = me * 8; do { if (!be) { pe.f = ve = bits$1(fe, _e, 1); var Be = bits$1(fe, _e + 1, 3); if (_e += 3, Be) if (Be == 1) be = flrm$1, Ae = fdrm$1, Se = 9, Ce = 5; else if (Be == 2) { var Pe = bits$1(fe, _e, 31) + 257, Ne = bits$1(fe, _e + 10, 15) + 4, ke = Pe + bits$1(fe, _e + 5, 31) + 1; _e += 14; for (var Oe = new u8$1(ke), Ue = new u8$1(19), He = 0; He < Ne; ++He)Ue[clim$1[He]] = bits$1(fe, _e + He * 3, 7); _e += Ne * 3; for (var Ge = max$2(Ue), ze = (1 << Ge) - 1, We = hMap$1(Ue, Ge, 1), He = 0; He < ke;) { var Xe = We[bits$1(fe, _e, ze)]; _e += Xe & 15; var De = Xe >>> 4; if (De < 16) Oe[He++] = De; else { var Ye = 0, Ze = 0; for (De == 16 ? (Ze = 3 + bits$1(fe, _e, 3), _e += 2, Ye = Oe[He - 1]) : De == 17 ? (Ze = 3 + bits$1(fe, _e, 7), _e += 3) : De == 18 && (Ze = 11 + bits$1(fe, _e, 127), _e += 7); Ze--;)Oe[He++] = Ye } } var ot = Oe.subarray(0, Pe), qe = Oe.subarray(Pe); Se = max$2(ot), Ce = max$2(qe), be = hMap$1(ot, Se, 1), Ae = hMap$1(qe, Ce, 1) } else throw "invalid block type"; else { var De = shft$1(_e) + 4, Re = fe[De - 4] | fe[De - 3] << 8, Ie = De + Re; if (Ie > me) { if (xe) throw "unexpected EOF"; break } ge && ye(Ee + Re), K.set(fe.subarray(De, Ie), Ee), pe.b = Ee += Re, pe.p = _e = Ie * 8; continue } if (_e > we) { if (xe) throw "unexpected EOF"; break } } ge && ye(Ee + 131072); for (var Qe = (1 << Se) - 1, st = (1 << Ce) - 1, Nt = _e; ; Nt = _e) { var Ye = be[bits16$1(fe, _e) & Qe], Je = Ye >>> 4; if (_e += Ye & 15, _e > we) { if (xe) throw "unexpected EOF"; break } if (!Ye) throw "invalid length/literal"; if (Je < 256) K[Ee++] = Je; else if (Je == 256) { Nt = _e, be = null; break } else { var jt = Je - 254; if (Je > 264) { var He = Je - 257, Xt = fleb$1[He]; jt = bits$1(fe, _e, (1 << Xt) - 1) + fl$1[He], _e += Xt } var ct = Ae[bits16$1(fe, _e) & st], nn = ct >>> 4; if (!ct) throw "invalid distance"; _e += ct & 15; var qe = fd$1[nn]; if (nn > 3) { var Xt = fdeb$1[nn]; qe += bits16$1(fe, _e) & (1 << Xt) - 1, _e += Xt } if (_e > we) { if (xe) throw "unexpected EOF"; break } ge && ye(Ee + 131072); for (var $t = Ee + jt; Ee < $t; Ee += 4)K[Ee] = K[Ee - qe], K[Ee + 1] = K[Ee + 1 - qe], K[Ee + 2] = K[Ee + 2 - qe], K[Ee + 3] = K[Ee + 3 - qe]; Ee = $t } } pe.l = be, pe.p = Nt, pe.b = Ee, be && (ve = 1, pe.m = Se, pe.d = Ae, pe.n = Ce) } while (!ve); return Ee == K.length ? K : slc$1(K, 0, Ee) }, et$2 = new u8$1(0), zlv = function (fe) { if ((fe[0] & 15) != 8 || fe[0] >>> 4 > 7 || (fe[0] << 8 | fe[1]) % 31) throw "invalid zlib data"; if (fe[1] & 32) throw "invalid zlib data: preset dictionaries not supported" }; function unzlibSync$1(fe, K) { return inflt$1((zlv(fe), fe.subarray(2, -4)), K) } var td$1 = typeof TextDecoder < "u" && new TextDecoder, tds$1 = 0; try { td$1.decode(et$2, { stream: !0 }), tds$1 = 1 } catch { } const isCubeTexture = fe => fe && fe.isCubeTexture; class GroundProjectedEnv extends Mesh {
	constructor(K, pe) {
		var me, ge; const xe = isCubeTexture(K), ve = ((ge = xe ? (me = K.image[0]) == null ? void 0 : me.width : K.image.width) != null ? ge : 1024) / 4, _e = Math.floor(Math.log2(ve)), Ee = Math.pow(2, _e), be = 3 * Math.max(Ee, 16 * 7), Ae = 4 * Ee, Se = [xe ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / be}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / Ae}`, `#define CUBEUV_MAX_MIP ${_e}.0`], Ce = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `, we = Se.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${version$1 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `, Be = { map: { value: K }, height: { value: pe?.height || 15 }, radius: { value: pe?.radius || 100 } }, De = new IcosahedronGeometry(1, 16), Re = new ShaderMaterial({ uniforms: Be, fragmentShader: we, vertexShader: Ce, side: DoubleSide }); super(De, Re)
	} set radius(K) { this.material.uniforms.radius.value = K } get radius() { return this.material.uniforms.radius.value } set height(K) { this.material.uniforms.height.value = K } get height() { return this.material.uniforms.height.value }
} class RGBELoader extends DataTextureLoader {
	constructor(K) { super(K), this.type = HalfFloatType } parse(K) {
		const ye = function (He, Ge) { switch (He) { case 1: throw new Error("THREE.RGBELoader: Read Error: " + (Ge || "")); case 2: throw new Error("THREE.RGBELoader: Write Error: " + (Ge || "")); case 3: throw new Error("THREE.RGBELoader: Bad File Format: " + (Ge || "")); default: case 4: throw new Error("THREE.RGBELoader: Memory Error: " + (Ge || "")) } }, be = `
`, Ae = function (He, Ge, ze) { Ge = Ge || 1024; let Xe = He.pos, Ye = -1, Ze = 0, ot = "", qe = String.fromCharCode.apply(null, new Uint16Array(He.subarray(Xe, Xe + 128))); for (; 0 > (Ye = qe.indexOf(be)) && Ze < Ge && Xe < He.byteLength;)ot += qe, Ze += qe.length, Xe += 128, qe += String.fromCharCode.apply(null, new Uint16Array(He.subarray(Xe, Xe + 128))); return -1 < Ye ? (He.pos += Ze + Ye + 1, ot + qe.slice(0, Ye)) : !1 }, Se = function (He) {
			const Ge = /^#\?(\S+)/, ze = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, We = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, Xe = /^\s*FORMAT=(\S+)\s*$/, Ye = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, Ze = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 }; let ot, qe; for ((He.pos >= He.byteLength || !(ot = Ae(He))) && ye(1, "no header found"), (qe = ot.match(Ge)) || ye(3, "bad initial token"), Ze.valid |= 1, Ze.programtype = qe[1], Ze.string += ot + `
`; ot = Ae(He), ot !== !1;) {
				if (Ze.string += ot + `
`, ot.charAt(0) === "#") {
					Ze.comments += ot + `
`; continue
				} if ((qe = ot.match(ze)) && (Ze.gamma = parseFloat(qe[1])), (qe = ot.match(We)) && (Ze.exposure = parseFloat(qe[1])), (qe = ot.match(Xe)) && (Ze.valid |= 2, Ze.format = qe[1]), (qe = ot.match(Ye)) && (Ze.valid |= 4, Ze.height = parseInt(qe[1], 10), Ze.width = parseInt(qe[2], 10)), Ze.valid & 2 && Ze.valid & 4) break
			} return Ze.valid & 2 || ye(3, "missing format specifier"), Ze.valid & 4 || ye(3, "missing image size specifier"), Ze
		}, Ce = function (He, Ge, ze) { const We = Ge; if (We < 8 || We > 32767 || He[0] !== 2 || He[1] !== 2 || He[2] & 128) return new Uint8Array(He); We !== (He[2] << 8 | He[3]) && ye(3, "wrong scanline width"); const Xe = new Uint8Array(4 * Ge * ze); Xe.length || ye(4, "unable to allocate buffer space"); let Ye = 0, Ze = 0; const ot = 4 * We, qe = new Uint8Array(4), Qe = new Uint8Array(ot); let st = ze; for (; st > 0 && Ze < He.byteLength;) { Ze + 4 > He.byteLength && ye(1), qe[0] = He[Ze++], qe[1] = He[Ze++], qe[2] = He[Ze++], qe[3] = He[Ze++], (qe[0] != 2 || qe[1] != 2 || (qe[2] << 8 | qe[3]) != We) && ye(3, "bad rgbe scanline format"); let Nt = 0, Je; for (; Nt < ot && Ze < He.byteLength;) { Je = He[Ze++]; const Xt = Je > 128; if (Xt && (Je -= 128), (Je === 0 || Nt + Je > ot) && ye(3, "bad scanline data"), Xt) { const ct = He[Ze++]; for (let nn = 0; nn < Je; nn++)Qe[Nt++] = ct } else Qe.set(He.subarray(Ze, Ze + Je), Nt), Nt += Je, Ze += Je } const jt = We; for (let Xt = 0; Xt < jt; Xt++) { let ct = 0; Xe[Ye] = Qe[Xt + ct], ct += We, Xe[Ye + 1] = Qe[Xt + ct], ct += We, Xe[Ye + 2] = Qe[Xt + ct], ct += We, Xe[Ye + 3] = Qe[Xt + ct], Ye += 4 } st-- } return Xe }, we = function (He, Ge, ze, We) { const Xe = He[Ge + 3], Ye = Math.pow(2, Xe - 128) / 255; ze[We + 0] = He[Ge + 0] * Ye, ze[We + 1] = He[Ge + 1] * Ye, ze[We + 2] = He[Ge + 2] * Ye, ze[We + 3] = 1 }, Be = function (He, Ge, ze, We) { const Xe = He[Ge + 3], Ye = Math.pow(2, Xe - 128) / 255; ze[We + 0] = DataUtils.toHalfFloat(Math.min(He[Ge + 0] * Ye, 65504)), ze[We + 1] = DataUtils.toHalfFloat(Math.min(He[Ge + 1] * Ye, 65504)), ze[We + 2] = DataUtils.toHalfFloat(Math.min(He[Ge + 2] * Ye, 65504)), ze[We + 3] = DataUtils.toHalfFloat(1) }, De = new Uint8Array(K); De.pos = 0; const Re = Se(De), Ie = Re.width, Pe = Re.height, Ne = Ce(De.subarray(De.pos), Ie, Pe); let ke, Oe, Ue; switch (this.type) { case FloatType: Ue = Ne.length / 4; const He = new Float32Array(Ue * 4); for (let ze = 0; ze < Ue; ze++)we(Ne, ze * 4, He, ze * 4); ke = He, Oe = FloatType; break; case HalfFloatType: Ue = Ne.length / 4; const Ge = new Uint16Array(Ue * 4); for (let ze = 0; ze < Ue; ze++)Be(Ne, ze * 4, Ge, ze * 4); ke = Ge, Oe = HalfFloatType; break; default: throw new Error("THREE.RGBELoader: Unsupported type: " + this.type) }return { width: Ie, height: Pe, data: ke, header: Re.string, gamma: Re.gamma, exposure: Re.exposure, type: Oe }
	} setDataType(K) { return this.type = K, this } load(K, pe, me, ge) { function xe(ye, ve) { switch (ye.type) { case FloatType: case HalfFloatType: "colorSpace" in ye ? ye.colorSpace = "srgb-linear" : ye.encoding = 3e3, ye.minFilter = LinearFilter, ye.magFilter = LinearFilter, ye.generateMipmaps = !1, ye.flipY = !0; break }pe && pe(ye, ve) } return super.load(K, xe, me, ge) }
} const hasColorSpace = version$1 >= 152; class EXRLoader extends DataTextureLoader { constructor(K) { super(K), this.type = HalfFloatType } parse(K) { const Ge = Math.pow(2.7182818, 2.2); function ze(Rt, Vt) { for (var dn = 0, In = 0; In < 65536; ++In)(In == 0 || Rt[In >> 3] & 1 << (In & 7)) && (Vt[dn++] = In); for (var Vn = dn - 1; dn < 65536;)Vt[dn++] = 0; return Vn } function We(Rt) { for (var Vt = 0; Vt < 16384; Vt++)Rt[Vt] = {}, Rt[Vt].len = 0, Rt[Vt].lit = 0, Rt[Vt].p = null } const Xe = { l: 0, c: 0, lc: 0 }; function Ye(Rt, Vt, dn, In, Vn) { for (; dn < Rt;)Vt = Vt << 8 | sr(In, Vn), dn += 8; dn -= Rt, Xe.l = Vt >> dn & (1 << Rt) - 1, Xe.c = Vt, Xe.lc = dn } const Ze = new Array(59); function ot(Rt) { for (var Vt = 0; Vt <= 58; ++Vt)Ze[Vt] = 0; for (var Vt = 0; Vt < 65537; ++Vt)Ze[Rt[Vt]] += 1; for (var dn = 0, Vt = 58; Vt > 0; --Vt) { var In = dn + Ze[Vt] >> 1; Ze[Vt] = dn, dn = In } for (var Vt = 0; Vt < 65537; ++Vt) { var Vn = Rt[Vt]; Vn > 0 && (Rt[Vt] = Vn | Ze[Vn]++ << 6) } } function qe(Rt, Vt, dn, In, Vn, Nn, ir) { for (var Jn = dn, ft = 0, qt = 0; Vn <= Nn; Vn++) { if (Jn.value - dn.value > In) return !1; Ye(6, ft, qt, Rt, Jn); var sn = Xe.l; if (ft = Xe.c, qt = Xe.lc, ir[Vn] = sn, sn == 63) { if (Jn.value - dn.value > In) throw "Something wrong with hufUnpackEncTable"; Ye(8, ft, qt, Rt, Jn); var ln = Xe.l + 6; if (ft = Xe.c, qt = Xe.lc, Vn + ln > Nn + 1) throw "Something wrong with hufUnpackEncTable"; for (; ln--;)ir[Vn++] = 0; Vn-- } else if (sn >= 59) { var ln = sn - 59 + 2; if (Vn + ln > Nn + 1) throw "Something wrong with hufUnpackEncTable"; for (; ln--;)ir[Vn++] = 0; Vn-- } } ot(ir) } function Qe(Rt) { return Rt & 63 } function st(Rt) { return Rt >> 6 } function Nt(Rt, Vt, dn, In) { for (; Vt <= dn; Vt++) { var Vn = st(Rt[Vt]), Nn = Qe(Rt[Vt]); if (Vn >> Nn) throw "Invalid table entry"; if (Nn > 14) { var ir = In[Vn >> Nn - 14]; if (ir.len) throw "Invalid table entry"; if (ir.lit++, ir.p) { var Jn = ir.p; ir.p = new Array(ir.lit); for (var ft = 0; ft < ir.lit - 1; ++ft)ir.p[ft] = Jn[ft] } else ir.p = new Array(1); ir.p[ir.lit - 1] = Vt } else if (Nn) for (var qt = 0, ft = 1 << 14 - Nn; ft > 0; ft--) { var ir = In[(Vn << 14 - Nn) + qt]; if (ir.len || ir.p) throw "Invalid table entry"; ir.len = Nn, ir.lit = Vt, qt++ } } return !0 } const Je = { c: 0, lc: 0 }; function jt(Rt, Vt, dn, In) { Rt = Rt << 8 | sr(dn, In), Vt += 8, Je.c = Rt, Je.lc = Vt } const Xt = { c: 0, lc: 0 }; function ct(Rt, Vt, dn, In, Vn, Nn, ir, Jn, ft, qt) { if (Rt == Vt) { In < 8 && (jt(dn, In, Vn, ir), dn = Je.c, In = Je.lc), In -= 8; var sn = dn >> In, sn = new Uint8Array([sn])[0]; if (ft.value + sn > qt) return !1; for (var ln = Jn[ft.value - 1]; sn-- > 0;)Jn[ft.value++] = ln } else if (ft.value < qt) Jn[ft.value++] = Rt; else return !1; Xt.c = dn, Xt.lc = In } function nn(Rt) { return Rt & 65535 } function $t(Rt) { var Vt = nn(Rt); return Vt > 32767 ? Vt - 65536 : Vt } const an = { a: 0, b: 0 }; function gn(Rt, Vt) { var dn = $t(Rt), In = $t(Vt), Vn = In, Nn = dn + (Vn & 1) + (Vn >> 1), ir = Nn, Jn = Nn - Vn; an.a = ir, an.b = Jn } function Mn(Rt, Vt) { var dn = nn(Rt), In = nn(Vt), Vn = dn - (In >> 1) & 65535, Nn = In + Vn - 32768 & 65535; an.a = Nn, an.b = Vn } function Xn(Rt, Vt, dn, In, Vn, Nn, ir) { for (var Jn = ir < 16384, ft = dn > Vn ? Vn : dn, qt = 1, sn; qt <= ft;)qt <<= 1; for (qt >>= 1, sn = qt, qt >>= 1; qt >= 1;) { for (var ln = 0, pn = ln + Nn * (Vn - sn), Tn = Nn * qt, $n = Nn * sn, Zn = In * qt, rr = In * sn, br, Un, _r, Lr; ln <= pn; ln += $n) { for (var Br = ln, ni = ln + In * (dn - sn); Br <= ni; Br += rr) { var wr = Br + Zn, Fr = Br + Tn, Dr = Fr + Zn; Jn ? (gn(Rt[Br + Vt], Rt[Fr + Vt]), br = an.a, _r = an.b, gn(Rt[wr + Vt], Rt[Dr + Vt]), Un = an.a, Lr = an.b, gn(br, Un), Rt[Br + Vt] = an.a, Rt[wr + Vt] = an.b, gn(_r, Lr), Rt[Fr + Vt] = an.a, Rt[Dr + Vt] = an.b) : (Mn(Rt[Br + Vt], Rt[Fr + Vt]), br = an.a, _r = an.b, Mn(Rt[wr + Vt], Rt[Dr + Vt]), Un = an.a, Lr = an.b, Mn(br, Un), Rt[Br + Vt] = an.a, Rt[wr + Vt] = an.b, Mn(_r, Lr), Rt[Fr + Vt] = an.a, Rt[Dr + Vt] = an.b) } if (dn & qt) { var Fr = Br + Tn; Jn ? gn(Rt[Br + Vt], Rt[Fr + Vt]) : Mn(Rt[Br + Vt], Rt[Fr + Vt]), br = an.a, Rt[Fr + Vt] = an.b, Rt[Br + Vt] = br } } if (Vn & qt) for (var Br = ln, ni = ln + In * (dn - sn); Br <= ni; Br += rr) { var wr = Br + Zn; Jn ? gn(Rt[Br + Vt], Rt[wr + Vt]) : Mn(Rt[Br + Vt], Rt[wr + Vt]), br = an.a, Rt[wr + Vt] = an.b, Rt[Br + Vt] = br } sn = qt, qt >>= 1 } return ln } function Ln(Rt, Vt, dn, In, Vn, Nn, ir, Jn, ft, qt) { for (var sn = 0, ln = 0, pn = Jn, Tn = Math.trunc(Vn.value + (Nn + 7) / 8); Vn.value < Tn;)for (jt(sn, ln, dn, Vn), sn = Je.c, ln = Je.lc; ln >= 14;) { var $n = sn >> ln - 14 & 16383, Zn = Vt[$n]; if (Zn.len) ln -= Zn.len, ct(Zn.lit, ir, sn, ln, dn, In, Vn, ft, qt, pn), sn = Xt.c, ln = Xt.lc; else { if (!Zn.p) throw "hufDecode issues"; var rr; for (rr = 0; rr < Zn.lit; rr++) { for (var br = Qe(Rt[Zn.p[rr]]); ln < br && Vn.value < Tn;)jt(sn, ln, dn, Vn), sn = Je.c, ln = Je.lc; if (ln >= br && st(Rt[Zn.p[rr]]) == (sn >> ln - br & (1 << br) - 1)) { ln -= br, ct(Zn.p[rr], ir, sn, ln, dn, In, Vn, ft, qt, pn), sn = Xt.c, ln = Xt.lc; break } } if (rr == Zn.lit) throw "hufDecode issues" } } var Un = 8 - Nn & 7; for (sn >>= Un, ln -= Un; ln > 0;) { var Zn = Vt[sn << 14 - ln & 16383]; if (Zn.len) ln -= Zn.len, ct(Zn.lit, ir, sn, ln, dn, In, Vn, ft, qt, pn), sn = Xt.c, ln = Xt.lc; else throw "hufDecode issues" } return !0 } function Gn(Rt, Vt, dn, In, Vn, Nn) { var ir = { value: 0 }, Jn = dn.value, ft = Yn(Vt, dn), qt = Yn(Vt, dn); dn.value += 4; var sn = Yn(Vt, dn); if (dn.value += 4, ft < 0 || ft >= 65537 || qt < 0 || qt >= 65537) throw "Something wrong with HUF_ENCSIZE"; var ln = new Array(65537), pn = new Array(16384); We(pn); var Tn = In - (dn.value - Jn); if (qe(Rt, Vt, dn, Tn, ft, qt, ln), sn > 8 * (In - (dn.value - Jn))) throw "Something wrong with hufUncompress"; Nt(ln, ft, qt, pn), Ln(ln, pn, Rt, Vt, dn, sn, qt, Nn, Vn, ir) } function wn(Rt, Vt, dn) { for (var In = 0; In < dn; ++In)Vt[In] = Rt[Vt[In]] } function Bn(Rt) { for (var Vt = 1; Vt < Rt.length; Vt++) { var dn = Rt[Vt - 1] + Rt[Vt] - 128; Rt[Vt] = dn } } function Gt(Rt, Vt) { for (var dn = 0, In = Math.floor((Rt.length + 1) / 2), Vn = 0, Nn = Rt.length - 1; !(Vn > Nn || (Vt[Vn++] = Rt[dn++], Vn > Nn));)Vt[Vn++] = Rt[In++] } function nr(Rt) { for (var Vt = Rt.byteLength, dn = new Array, In = 0, Vn = new DataView(Rt); Vt > 0;) { var Nn = Vn.getInt8(In++); if (Nn < 0) { var ir = -Nn; Vt -= ir + 1; for (var Jn = 0; Jn < ir; Jn++)dn.push(Vn.getUint8(In++)) } else { var ir = Nn; Vt -= 2; for (var ft = Vn.getUint8(In++), Jn = 0; Jn < ir + 1; Jn++)dn.push(ft) } } return dn } function Kn(Rt, Vt, dn, In, Vn, Nn) { var wr = new DataView(Nn.buffer), ir = dn[Rt.idx[0]].width, Jn = dn[Rt.idx[0]].height, ft = 3, qt = Math.floor(ir / 8), sn = Math.ceil(ir / 8), ln = Math.ceil(Jn / 8), pn = ir - (sn - 1) * 8, Tn = Jn - (ln - 1) * 8, $n = { value: 0 }, Zn = new Array(ft), rr = new Array(ft), br = new Array(ft), Un = new Array(ft), _r = new Array(ft); for (let Wr = 0; Wr < ft; ++Wr)_r[Wr] = Vt[Rt.idx[Wr]], Zn[Wr] = Wr < 1 ? 0 : Zn[Wr - 1] + sn * ln, rr[Wr] = new Float32Array(64), br[Wr] = new Uint16Array(64), Un[Wr] = new Uint16Array(sn * 64); for (let Wr = 0; Wr < ln; ++Wr) { var Lr = 8; Wr == ln - 1 && (Lr = Tn); var Br = 8; for (let kr = 0; kr < sn; ++kr) { kr == sn - 1 && (Br = pn); for (let Zr = 0; Zr < ft; ++Zr)br[Zr].fill(0), br[Zr][0] = Vn[Zn[Zr]++], vn($n, In, br[Zr]), yn(br[Zr], rr[Zr]), Hn(rr[Zr]); kn(rr); for (let Zr = 0; Zr < ft; ++Zr)Ht(rr[Zr], Un[Zr], kr * 64) } let ii = 0; for (let kr = 0; kr < ft; ++kr) { const Zr = dn[Rt.idx[kr]].type; for (let Xr = 8 * Wr; Xr < 8 * Wr + Lr; ++Xr) { ii = _r[kr][Xr]; for (let Ri = 0; Ri < qt; ++Ri) { const di = Ri * 64 + (Xr & 7) * 8; wr.setUint16(ii + 0 * 2 * Zr, Un[kr][di + 0], !0), wr.setUint16(ii + 1 * 2 * Zr, Un[kr][di + 1], !0), wr.setUint16(ii + 2 * 2 * Zr, Un[kr][di + 2], !0), wr.setUint16(ii + 3 * 2 * Zr, Un[kr][di + 3], !0), wr.setUint16(ii + 4 * 2 * Zr, Un[kr][di + 4], !0), wr.setUint16(ii + 5 * 2 * Zr, Un[kr][di + 5], !0), wr.setUint16(ii + 6 * 2 * Zr, Un[kr][di + 6], !0), wr.setUint16(ii + 7 * 2 * Zr, Un[kr][di + 7], !0), ii += 8 * 2 * Zr } } if (qt != sn) for (let Xr = 8 * Wr; Xr < 8 * Wr + Lr; ++Xr) { const Ri = _r[kr][Xr] + 8 * qt * 2 * Zr, di = qt * 64 + (Xr & 7) * 8; for (let yi = 0; yi < Br; ++yi)wr.setUint16(Ri + yi * 2 * Zr, Un[kr][di + yi], !0) } } } for (var ni = new Uint16Array(ir), wr = new DataView(Nn.buffer), Fr = 0; Fr < ft; ++Fr) { dn[Rt.idx[Fr]].decoded = !0; var Dr = dn[Rt.idx[Fr]].type; if (dn[Fr].type == 2) for (var li = 0; li < Jn; ++li) { const Wr = _r[Fr][li]; for (var Gr = 0; Gr < ir; ++Gr)ni[Gr] = wr.getUint16(Wr + Gr * 2 * Dr, !0); for (var Gr = 0; Gr < ir; ++Gr)wr.setFloat32(Wr + Gr * 2 * Dr, Dn(ni[Gr]), !0) } } } function vn(Rt, Vt, dn) { for (var In, Vn = 1; Vn < 64;)In = Vt[Rt.value], In == 65280 ? Vn = 64 : In >> 8 == 255 ? Vn += In & 255 : (dn[Vn] = In, Vn++), Rt.value++ } function yn(Rt, Vt) { Vt[0] = Dn(Rt[0]), Vt[1] = Dn(Rt[1]), Vt[2] = Dn(Rt[5]), Vt[3] = Dn(Rt[6]), Vt[4] = Dn(Rt[14]), Vt[5] = Dn(Rt[15]), Vt[6] = Dn(Rt[27]), Vt[7] = Dn(Rt[28]), Vt[8] = Dn(Rt[2]), Vt[9] = Dn(Rt[4]), Vt[10] = Dn(Rt[7]), Vt[11] = Dn(Rt[13]), Vt[12] = Dn(Rt[16]), Vt[13] = Dn(Rt[26]), Vt[14] = Dn(Rt[29]), Vt[15] = Dn(Rt[42]), Vt[16] = Dn(Rt[3]), Vt[17] = Dn(Rt[8]), Vt[18] = Dn(Rt[12]), Vt[19] = Dn(Rt[17]), Vt[20] = Dn(Rt[25]), Vt[21] = Dn(Rt[30]), Vt[22] = Dn(Rt[41]), Vt[23] = Dn(Rt[43]), Vt[24] = Dn(Rt[9]), Vt[25] = Dn(Rt[11]), Vt[26] = Dn(Rt[18]), Vt[27] = Dn(Rt[24]), Vt[28] = Dn(Rt[31]), Vt[29] = Dn(Rt[40]), Vt[30] = Dn(Rt[44]), Vt[31] = Dn(Rt[53]), Vt[32] = Dn(Rt[10]), Vt[33] = Dn(Rt[19]), Vt[34] = Dn(Rt[23]), Vt[35] = Dn(Rt[32]), Vt[36] = Dn(Rt[39]), Vt[37] = Dn(Rt[45]), Vt[38] = Dn(Rt[52]), Vt[39] = Dn(Rt[54]), Vt[40] = Dn(Rt[20]), Vt[41] = Dn(Rt[22]), Vt[42] = Dn(Rt[33]), Vt[43] = Dn(Rt[38]), Vt[44] = Dn(Rt[46]), Vt[45] = Dn(Rt[51]), Vt[46] = Dn(Rt[55]), Vt[47] = Dn(Rt[60]), Vt[48] = Dn(Rt[21]), Vt[49] = Dn(Rt[34]), Vt[50] = Dn(Rt[37]), Vt[51] = Dn(Rt[47]), Vt[52] = Dn(Rt[50]), Vt[53] = Dn(Rt[56]), Vt[54] = Dn(Rt[59]), Vt[55] = Dn(Rt[61]), Vt[56] = Dn(Rt[35]), Vt[57] = Dn(Rt[36]), Vt[58] = Dn(Rt[48]), Vt[59] = Dn(Rt[49]), Vt[60] = Dn(Rt[57]), Vt[61] = Dn(Rt[58]), Vt[62] = Dn(Rt[62]), Vt[63] = Dn(Rt[63]) } function Hn(Rt) { const Vt = .5 * Math.cos(.7853975), dn = .5 * Math.cos(3.14159 / 16), In = .5 * Math.cos(3.14159 / 8), Vn = .5 * Math.cos(3 * 3.14159 / 16), Nn = .5 * Math.cos(5 * 3.14159 / 16), ir = .5 * Math.cos(3 * 3.14159 / 8), Jn = .5 * Math.cos(7 * 3.14159 / 16); for (var ft = new Array(4), qt = new Array(4), sn = new Array(4), ln = new Array(4), pn = 0; pn < 8; ++pn) { var Tn = pn * 8; ft[0] = In * Rt[Tn + 2], ft[1] = ir * Rt[Tn + 2], ft[2] = In * Rt[Tn + 6], ft[3] = ir * Rt[Tn + 6], qt[0] = dn * Rt[Tn + 1] + Vn * Rt[Tn + 3] + Nn * Rt[Tn + 5] + Jn * Rt[Tn + 7], qt[1] = Vn * Rt[Tn + 1] - Jn * Rt[Tn + 3] - dn * Rt[Tn + 5] - Nn * Rt[Tn + 7], qt[2] = Nn * Rt[Tn + 1] - dn * Rt[Tn + 3] + Jn * Rt[Tn + 5] + Vn * Rt[Tn + 7], qt[3] = Jn * Rt[Tn + 1] - Nn * Rt[Tn + 3] + Vn * Rt[Tn + 5] - dn * Rt[Tn + 7], sn[0] = Vt * (Rt[Tn + 0] + Rt[Tn + 4]), sn[3] = Vt * (Rt[Tn + 0] - Rt[Tn + 4]), sn[1] = ft[0] + ft[3], sn[2] = ft[1] - ft[2], ln[0] = sn[0] + sn[1], ln[1] = sn[3] + sn[2], ln[2] = sn[3] - sn[2], ln[3] = sn[0] - sn[1], Rt[Tn + 0] = ln[0] + qt[0], Rt[Tn + 1] = ln[1] + qt[1], Rt[Tn + 2] = ln[2] + qt[2], Rt[Tn + 3] = ln[3] + qt[3], Rt[Tn + 4] = ln[3] - qt[3], Rt[Tn + 5] = ln[2] - qt[2], Rt[Tn + 6] = ln[1] - qt[1], Rt[Tn + 7] = ln[0] - qt[0] } for (var $n = 0; $n < 8; ++$n)ft[0] = In * Rt[16 + $n], ft[1] = ir * Rt[16 + $n], ft[2] = In * Rt[48 + $n], ft[3] = ir * Rt[48 + $n], qt[0] = dn * Rt[8 + $n] + Vn * Rt[24 + $n] + Nn * Rt[40 + $n] + Jn * Rt[56 + $n], qt[1] = Vn * Rt[8 + $n] - Jn * Rt[24 + $n] - dn * Rt[40 + $n] - Nn * Rt[56 + $n], qt[2] = Nn * Rt[8 + $n] - dn * Rt[24 + $n] + Jn * Rt[40 + $n] + Vn * Rt[56 + $n], qt[3] = Jn * Rt[8 + $n] - Nn * Rt[24 + $n] + Vn * Rt[40 + $n] - dn * Rt[56 + $n], sn[0] = Vt * (Rt[$n] + Rt[32 + $n]), sn[3] = Vt * (Rt[$n] - Rt[32 + $n]), sn[1] = ft[0] + ft[3], sn[2] = ft[1] - ft[2], ln[0] = sn[0] + sn[1], ln[1] = sn[3] + sn[2], ln[2] = sn[3] - sn[2], ln[3] = sn[0] - sn[1], Rt[0 + $n] = ln[0] + qt[0], Rt[8 + $n] = ln[1] + qt[1], Rt[16 + $n] = ln[2] + qt[2], Rt[24 + $n] = ln[3] + qt[3], Rt[32 + $n] = ln[3] - qt[3], Rt[40 + $n] = ln[2] - qt[2], Rt[48 + $n] = ln[1] - qt[1], Rt[56 + $n] = ln[0] - qt[0] } function kn(Rt) { for (var Vt = 0; Vt < 64; ++Vt) { var dn = Rt[0][Vt], In = Rt[1][Vt], Vn = Rt[2][Vt]; Rt[0][Vt] = dn + 1.5747 * Vn, Rt[1][Vt] = dn - .1873 * In - .4682 * Vn, Rt[2][Vt] = dn + 1.8556 * In } } function Ht(Rt, Vt, dn) { for (var In = 0; In < 64; ++In)Vt[dn + In] = DataUtils.toHalfFloat(Dt(Rt[In])) } function Dt(Rt) { return Rt <= 1 ? Math.sign(Rt) * Math.pow(Math.abs(Rt), 2.2) : Math.sign(Rt) * Math.pow(Ge, Math.abs(Rt) - 1) } function fn(Rt) { return new DataView(Rt.array.buffer, Rt.offset.value, Rt.size) } function en(Rt) { var Vt = Rt.viewer.buffer.slice(Rt.offset.value, Rt.offset.value + Rt.size), dn = new Uint8Array(nr(Vt)), In = new Uint8Array(dn.length); return Bn(dn), Gt(dn, In), new DataView(In.buffer) } function cn(Rt) { var Vt = Rt.array.slice(Rt.offset.value, Rt.offset.value + Rt.size), dn = unzlibSync$1(Vt), In = new Uint8Array(dn.length); return Bn(dn), Gt(dn, In), new DataView(In.buffer) } function Wt(Rt) { for (var Vt = Rt.viewer, dn = { value: Rt.offset.value }, In = new Uint16Array(Rt.width * Rt.scanlineBlockSize * (Rt.channels * Rt.type)), Vn = new Uint8Array(8192), Nn = 0, ir = new Array(Rt.channels), Jn = 0; Jn < Rt.channels; Jn++)ir[Jn] = {}, ir[Jn].start = Nn, ir[Jn].end = ir[Jn].start, ir[Jn].nx = Rt.width, ir[Jn].ny = Rt.lines, ir[Jn].size = Rt.type, Nn += ir[Jn].nx * ir[Jn].ny * ir[Jn].size; var ft = Rn(Vt, dn), qt = Rn(Vt, dn); if (qt >= 8192) throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"; if (ft <= qt) for (var Jn = 0; Jn < qt - ft + 1; Jn++)Vn[Jn + ft] = Ar(Vt, dn); var sn = new Uint16Array(65536), ln = ze(Vn, sn), pn = Yn(Vt, dn); Gn(Rt.array, Vt, dn, pn, In, Nn); for (var Jn = 0; Jn < Rt.channels; ++Jn)for (var Tn = ir[Jn], $n = 0; $n < ir[Jn].size; ++$n)Xn(In, Tn.start + $n, Tn.nx, Tn.size, Tn.ny, Tn.nx * Tn.size, ln); wn(sn, In, Nn); for (var Zn = 0, rr = new Uint8Array(In.buffer.byteLength), br = 0; br < Rt.lines; br++)for (var Un = 0; Un < Rt.channels; Un++) { var Tn = ir[Un], _r = Tn.nx * Tn.size, Lr = new Uint8Array(In.buffer, Tn.end * 2, _r * 2); rr.set(Lr, Zn), Zn += _r * 2, Tn.end += _r } return new DataView(rr.buffer) } function un(Rt) { var Vt = Rt.array.slice(Rt.offset.value, Rt.offset.value + Rt.size), dn = unzlibSync$1(Vt); const In = Rt.lines * Rt.channels * Rt.width, Vn = Rt.type == 1 ? new Uint16Array(In) : new Uint32Array(In); let Nn = 0, ir = 0; const Jn = new Array(4); for (let ft = 0; ft < Rt.lines; ft++)for (let qt = 0; qt < Rt.channels; qt++) { let sn = 0; switch (Rt.type) { case 1: Jn[0] = Nn, Jn[1] = Jn[0] + Rt.width, Nn = Jn[1] + Rt.width; for (let ln = 0; ln < Rt.width; ++ln) { const pn = dn[Jn[0]++] << 8 | dn[Jn[1]++]; sn += pn, Vn[ir] = sn, ir++ } break; case 2: Jn[0] = Nn, Jn[1] = Jn[0] + Rt.width, Jn[2] = Jn[1] + Rt.width, Nn = Jn[2] + Rt.width; for (let ln = 0; ln < Rt.width; ++ln) { const pn = dn[Jn[0]++] << 24 | dn[Jn[1]++] << 16 | dn[Jn[2]++] << 8; sn += pn, Vn[ir] = sn, ir++ } break } } return new DataView(Vn.buffer) } function Ft(Rt) { var Vt = Rt.viewer, dn = { value: Rt.offset.value }, In = new Uint8Array(Rt.width * Rt.lines * (Rt.channels * Rt.type * 2)), Vn = { version: Er(Vt, dn), unknownUncompressedSize: Er(Vt, dn), unknownCompressedSize: Er(Vt, dn), acCompressedSize: Er(Vt, dn), dcCompressedSize: Er(Vt, dn), rleCompressedSize: Er(Vt, dn), rleUncompressedSize: Er(Vt, dn), rleRawSize: Er(Vt, dn), totalAcUncompressedCount: Er(Vt, dn), totalDcUncompressedCount: Er(Vt, dn), acCompression: Er(Vt, dn) }; if (Vn.version < 2) throw "EXRLoader.parse: " + Ii.compression + " version " + Vn.version + " is unsupported"; for (var Nn = new Array, ir = Rn(Vt, dn) - 2; ir > 0;) { var Jn = Sn(Vt.buffer, dn), ft = Ar(Vt, dn), qt = ft >> 2 & 3, sn = (ft >> 4) - 1, ln = new Int8Array([sn])[0], pn = Ar(Vt, dn); Nn.push({ name: Jn, index: ln, type: pn, compression: qt }), ir -= Jn.length + 3 } for (var Tn = Ii.channels, $n = new Array(Rt.channels), Zn = 0; Zn < Rt.channels; ++Zn) { var rr = $n[Zn] = {}, br = Tn[Zn]; rr.name = br.name, rr.compression = 0, rr.decoded = !1, rr.type = br.pixelType, rr.pLinear = br.pLinear, rr.width = Rt.width, rr.height = Rt.lines } for (var Un = { idx: new Array(3) }, _r = 0; _r < Rt.channels; ++_r)for (var rr = $n[_r], Zn = 0; Zn < Nn.length; ++Zn) { var Lr = Nn[Zn]; rr.name == Lr.name && (rr.compression = Lr.compression, Lr.index >= 0 && (Un.idx[Lr.index] = _r), rr.offset = _r) } if (Vn.acCompressedSize > 0) switch (Vn.acCompression) { case 0: var wr = new Uint16Array(Vn.totalAcUncompressedCount); Gn(Rt.array, Vt, dn, Vn.acCompressedSize, wr, Vn.totalAcUncompressedCount); break; case 1: var Br = Rt.array.slice(dn.value, dn.value + Vn.totalAcUncompressedCount), ni = unzlibSync$1(Br), wr = new Uint16Array(ni.buffer); dn.value += Vn.totalAcUncompressedCount; break }if (Vn.dcCompressedSize > 0) { var Fr = { array: Rt.array, offset: dn, size: Vn.dcCompressedSize }, Dr = new Uint16Array(cn(Fr).buffer); dn.value += Vn.dcCompressedSize } if (Vn.rleRawSize > 0) { var Br = Rt.array.slice(dn.value, dn.value + Vn.rleCompressedSize), ni = unzlibSync$1(Br), li = nr(ni.buffer); dn.value += Vn.rleCompressedSize } for (var Gr = 0, Wr = new Array($n.length), Zn = 0; Zn < Wr.length; ++Zn)Wr[Zn] = new Array; for (var ii = 0; ii < Rt.lines; ++ii)for (var kr = 0; kr < $n.length; ++kr)Wr[kr].push(Gr), Gr += $n[kr].width * Rt.type * 2; Kn(Un, Wr, $n, wr, Dr, In); for (var Zn = 0; Zn < $n.length; ++Zn) { var rr = $n[Zn]; if (!rr.decoded) switch (rr.compression) { case 2: for (var Zr = 0, Xr = 0, ii = 0; ii < Rt.lines; ++ii) { for (var Ri = Wr[Zn][Zr], di = 0; di < rr.width; ++di) { for (var yi = 0; yi < 2 * rr.type; ++yi)In[Ri++] = li[Xr + yi * rr.width * rr.height]; Xr++ } Zr++ } break; case 1: default: throw "EXRLoader.parse: unsupported channel compression" } } return new DataView(In.buffer) } function Sn(Rt, Vt) { for (var dn = new Uint8Array(Rt), In = 0; dn[Vt.value + In] != 0;)In += 1; var Vn = new TextDecoder().decode(dn.slice(Vt.value, Vt.value + In)); return Vt.value = Vt.value + In + 1, Vn } function lr(Rt, Vt, dn) { var In = new TextDecoder().decode(new Uint8Array(Rt).slice(Vt.value, Vt.value + dn)); return Vt.value = Vt.value + dn, In } function jn(Rt, Vt) { var dn = fr(Rt, Vt), In = Yn(Rt, Vt); return [dn, In] } function Pn(Rt, Vt) { var dn = Yn(Rt, Vt), In = Yn(Rt, Vt); return [dn, In] } function fr(Rt, Vt) { var dn = Rt.getInt32(Vt.value, !0); return Vt.value = Vt.value + 4, dn } function Yn(Rt, Vt) { var dn = Rt.getUint32(Vt.value, !0); return Vt.value = Vt.value + 4, dn } function sr(Rt, Vt) { var dn = Rt[Vt.value]; return Vt.value = Vt.value + 1, dn } function Ar(Rt, Vt) { var dn = Rt.getUint8(Vt.value); return Vt.value = Vt.value + 1, dn } const Er = function (Rt, Vt) { let dn; return "getBigInt64" in DataView.prototype ? dn = Number(Rt.getBigInt64(Vt.value, !0)) : dn = Rt.getUint32(Vt.value + 4, !0) + Number(Rt.getUint32(Vt.value, !0) << 32), Vt.value += 8, dn }; function Rr(Rt, Vt) { var dn = Rt.getFloat32(Vt.value, !0); return Vt.value += 4, dn } function mn(Rt, Vt) { return DataUtils.toHalfFloat(Rr(Rt, Vt)) } function Dn(Rt) { var Vt = (Rt & 31744) >> 10, dn = Rt & 1023; return (Rt >> 15 ? -1 : 1) * (Vt ? Vt === 31 ? dn ? NaN : 1 / 0 : Math.pow(2, Vt - 15) * (1 + dn / 1024) : 6103515625e-14 * (dn / 1024)) } function Rn(Rt, Vt) { var dn = Rt.getUint16(Vt.value, !0); return Vt.value += 2, dn } function qn(Rt, Vt) { return Dn(Rn(Rt, Vt)) } function ar(Rt, Vt, dn, In) { for (var Vn = dn.value, Nn = []; dn.value < Vn + In - 1;) { var ir = Sn(Vt, dn), Jn = fr(Rt, dn), ft = Ar(Rt, dn); dn.value += 3; var qt = fr(Rt, dn), sn = fr(Rt, dn); Nn.push({ name: ir, pixelType: Jn, pLinear: ft, xSampling: qt, ySampling: sn }) } return dn.value += 1, Nn } function yr(Rt, Vt) { var dn = Rr(Rt, Vt), In = Rr(Rt, Vt), Vn = Rr(Rt, Vt), Nn = Rr(Rt, Vt), ir = Rr(Rt, Vt), Jn = Rr(Rt, Vt), ft = Rr(Rt, Vt), qt = Rr(Rt, Vt); return { redX: dn, redY: In, greenX: Vn, greenY: Nn, blueX: ir, blueY: Jn, whiteX: ft, whiteY: qt } } function dr(Rt, Vt) { var dn = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"], In = Ar(Rt, Vt); return dn[In] } function mi(Rt, Vt) { var dn = Yn(Rt, Vt), In = Yn(Rt, Vt), Vn = Yn(Rt, Vt), Nn = Yn(Rt, Vt); return { xMin: dn, yMin: In, xMax: Vn, yMax: Nn } } function bi(Rt, Vt) { var dn = ["INCREASING_Y"], In = Ar(Rt, Vt); return dn[In] } function ti(Rt, Vt) { var dn = Rr(Rt, Vt), In = Rr(Rt, Vt); return [dn, In] } function Si(Rt, Vt) { var dn = Rr(Rt, Vt), In = Rr(Rt, Vt), Vn = Rr(Rt, Vt); return [dn, In, Vn] } function ri(Rt, Vt, dn, In, Vn) { if (In === "string" || In === "stringvector" || In === "iccProfile") return lr(Vt, dn, Vn); if (In === "chlist") return ar(Rt, Vt, dn, Vn); if (In === "chromaticities") return yr(Rt, dn); if (In === "compression") return dr(Rt, dn); if (In === "box2i") return mi(Rt, dn); if (In === "lineOrder") return bi(Rt, dn); if (In === "float") return Rr(Rt, dn); if (In === "v2f") return ti(Rt, dn); if (In === "v3f") return Si(Rt, dn); if (In === "int") return fr(Rt, dn); if (In === "rational") return jn(Rt, dn); if (In === "timecode") return Pn(Rt, dn); if (In === "preview") return dn.value += Vn, "skipped"; dn.value += Vn } function es(Rt, Vt, dn) { const In = {}; if (Rt.getUint32(0, !0) != 20000630) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."; In.version = Rt.getUint8(4); const Vn = Rt.getUint8(5); In.spec = { singleTile: !!(Vn & 2), longName: !!(Vn & 4), deepFormat: !!(Vn & 8), multiPart: !!(Vn & 16) }, dn.value = 8; for (var Nn = !0; Nn;) { var ir = Sn(Vt, dn); if (ir == 0) Nn = !1; else { var Jn = Sn(Vt, dn), ft = Yn(Rt, dn), qt = ri(Rt, Vt, dn, Jn, ft); qt === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Jn}'.`) : In[ir] = qt } } if (Vn & -5) throw console.error("EXRHeader:", In), "THREE.EXRLoader: provided file is currently unsupported."; return In } function Hi(Rt, Vt, dn, In, Vn) { const Nn = { size: 0, viewer: Vt, array: dn, offset: In, width: Rt.dataWindow.xMax - Rt.dataWindow.xMin + 1, height: Rt.dataWindow.yMax - Rt.dataWindow.yMin + 1, channels: Rt.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: Rt.channels[0].pixelType, uncompress: null, getter: null, format: null, [hasColorSpace ? "colorSpace" : "encoding"]: null }; switch (Rt.compression) { case "NO_COMPRESSION": Nn.lines = 1, Nn.uncompress = fn; break; case "RLE_COMPRESSION": Nn.lines = 1, Nn.uncompress = en; break; case "ZIPS_COMPRESSION": Nn.lines = 1, Nn.uncompress = cn; break; case "ZIP_COMPRESSION": Nn.lines = 16, Nn.uncompress = cn; break; case "PIZ_COMPRESSION": Nn.lines = 32, Nn.uncompress = Wt; break; case "PXR24_COMPRESSION": Nn.lines = 16, Nn.uncompress = un; break; case "DWAA_COMPRESSION": Nn.lines = 32, Nn.uncompress = Ft; break; case "DWAB_COMPRESSION": Nn.lines = 256, Nn.uncompress = Ft; break; default: throw "EXRLoader.parse: " + Rt.compression + " is unsupported" }if (Nn.scanlineBlockSize = Nn.lines, Nn.type == 1) switch (Vn) { case FloatType: Nn.getter = qn, Nn.inputSize = 2; break; case HalfFloatType: Nn.getter = Rn, Nn.inputSize = 2; break } else if (Nn.type == 2) switch (Vn) { case FloatType: Nn.getter = Rr, Nn.inputSize = 4; break; case HalfFloatType: Nn.getter = mn, Nn.inputSize = 4 } else throw "EXRLoader.parse: unsupported pixelType " + Nn.type + " for " + Rt.compression + "."; Nn.blockCount = (Rt.dataWindow.yMax + 1) / Nn.scanlineBlockSize; for (var ir = 0; ir < Nn.blockCount; ir++)Er(Vt, In); Nn.outputChannels = Nn.channels == 3 ? 4 : Nn.channels; const Jn = Nn.width * Nn.height * Nn.outputChannels; switch (Vn) { case FloatType: Nn.byteArray = new Float32Array(Jn), Nn.channels < Nn.outputChannels && Nn.byteArray.fill(1, 0, Jn); break; case HalfFloatType: Nn.byteArray = new Uint16Array(Jn), Nn.channels < Nn.outputChannels && Nn.byteArray.fill(15360, 0, Jn); break; default: console.error("THREE.EXRLoader: unsupported type: ", Vn); break }return Nn.bytesPerLine = Nn.width * Nn.inputSize * Nn.channels, Nn.outputChannels == 4 ? Nn.format = RGBAFormat : Nn.format = RedFormat, hasColorSpace ? Nn.colorSpace = "srgb-linear" : Nn.encoding = 3e3, Nn } const Ai = new DataView(K), gi = new Uint8Array(K), ts = { value: 0 }, Ii = es(Ai, K, ts), Nr = Hi(Ii, Ai, gi, ts, this.type), hs = { value: 0 }, xi = { R: 0, G: 1, B: 2, A: 3, Y: 0 }; for (let Rt = 0; Rt < Nr.height / Nr.scanlineBlockSize; Rt++) { const Vt = Yn(Ai, ts); Nr.size = Yn(Ai, ts), Nr.lines = Vt + Nr.scanlineBlockSize > Nr.height ? Nr.height - Vt : Nr.scanlineBlockSize; const In = Nr.size < Nr.lines * Nr.bytesPerLine ? Nr.uncompress(Nr) : fn(Nr); ts.value += Nr.size; for (let Vn = 0; Vn < Nr.scanlineBlockSize; Vn++) { const Nn = Vn + Rt * Nr.scanlineBlockSize; if (Nn >= Nr.height) break; for (let ir = 0; ir < Nr.channels; ir++) { const Jn = xi[Ii.channels[ir].name]; for (let ft = 0; ft < Nr.width; ft++) { hs.value = (Vn * (Nr.channels * Nr.width) + ir * Nr.width + ft) * Nr.inputSize; const qt = (Nr.height - 1 - Nn) * (Nr.width * Nr.outputChannels) + ft * Nr.outputChannels + Jn; Nr.byteArray[qt] = Nr.getter(In, hs) } } } } return { header: Ii, width: Nr.width, height: Nr.height, data: Nr.byteArray, format: Nr.format, [hasColorSpace ? "colorSpace" : "encoding"]: Nr[hasColorSpace ? "colorSpace" : "encoding"], type: this.type } } setDataType(K) { return this.type = K, this } load(K, pe, me, ge) { function xe(ye, ve) { hasColorSpace ? ye.colorSpace = ve.colorSpace : ye.encoding = ve.encoding, ye.minFilter = LinearFilter, ye.magFilter = LinearFilter, ye.generateMipmaps = !1, ye.flipY = !1, pe && pe(ye, ve) } return super.load(K, xe, me, ge) } } const _box$1 = new Box3, _vector = new Vector3; class LineSegmentsGeometry extends InstancedBufferGeometry { constructor() { super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry"; const K = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], pe = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], me = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]; this.setIndex(me), this.setAttribute("position", new Float32BufferAttribute(K, 3)), this.setAttribute("uv", new Float32BufferAttribute(pe, 2)) } applyMatrix4(K) { const pe = this.attributes.instanceStart, me = this.attributes.instanceEnd; return pe !== void 0 && (pe.applyMatrix4(K), me.applyMatrix4(K), pe.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } setPositions(K) { let pe; K instanceof Float32Array ? pe = K : Array.isArray(K) && (pe = new Float32Array(K)); const me = new InstancedInterleavedBuffer(pe, 6, 1); return this.setAttribute("instanceStart", new InterleavedBufferAttribute(me, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(me, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } setColors(K, pe = 3) { let me; K instanceof Float32Array ? me = K : Array.isArray(K) && (me = new Float32Array(K)); const ge = new InstancedInterleavedBuffer(me, pe * 2, 1); return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(ge, pe, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(ge, pe, pe)), this } fromWireframeGeometry(K) { return this.setPositions(K.attributes.position.array), this } fromEdgesGeometry(K) { return this.setPositions(K.attributes.position.array), this } fromMesh(K) { return this.fromWireframeGeometry(new WireframeGeometry(K.geometry)), this } fromLineSegments(K) { const pe = K.geometry; return this.setPositions(pe.attributes.position.array), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Box3); const K = this.attributes.instanceStart, pe = this.attributes.instanceEnd; K !== void 0 && pe !== void 0 && (this.boundingBox.setFromBufferAttribute(K), _box$1.setFromBufferAttribute(pe), this.boundingBox.union(_box$1)) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingBox === null && this.computeBoundingBox(); const K = this.attributes.instanceStart, pe = this.attributes.instanceEnd; if (K !== void 0 && pe !== void 0) { const me = this.boundingSphere.center; this.boundingBox.getCenter(me); let ge = 0; for (let xe = 0, ye = K.count; xe < ye; xe++)_vector.fromBufferAttribute(K, xe), ge = Math.max(ge, me.distanceToSquared(_vector)), _vector.fromBufferAttribute(pe, xe), ge = Math.max(ge, me.distanceToSquared(_vector)); this.boundingSphere.radius = Math.sqrt(ge), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } applyMatrix(K) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(K) } } class LineGeometry extends LineSegmentsGeometry { constructor() { super(), this.isLineGeometry = !0, this.type = "LineGeometry" } setPositions(K) { const pe = K.length - 3, me = new Float32Array(2 * pe); for (let ge = 0; ge < pe; ge += 3)me[2 * ge] = K[ge], me[2 * ge + 1] = K[ge + 1], me[2 * ge + 2] = K[ge + 2], me[2 * ge + 3] = K[ge + 3], me[2 * ge + 4] = K[ge + 4], me[2 * ge + 5] = K[ge + 5]; return super.setPositions(me), this } setColors(K, pe = 3) { const me = K.length - pe, ge = new Float32Array(2 * me); if (pe === 3) for (let xe = 0; xe < me; xe += pe)ge[2 * xe] = K[xe], ge[2 * xe + 1] = K[xe + 1], ge[2 * xe + 2] = K[xe + 2], ge[2 * xe + 3] = K[xe + 3], ge[2 * xe + 4] = K[xe + 4], ge[2 * xe + 5] = K[xe + 5]; else for (let xe = 0; xe < me; xe += pe)ge[2 * xe] = K[xe], ge[2 * xe + 1] = K[xe + 1], ge[2 * xe + 2] = K[xe + 2], ge[2 * xe + 3] = K[xe + 3], ge[2 * xe + 4] = K[xe + 4], ge[2 * xe + 5] = K[xe + 5], ge[2 * xe + 6] = K[xe + 6], ge[2 * xe + 7] = K[xe + 7]; return super.setColors(ge, pe), this } fromLine(K) { const pe = K.geometry; return this.setPositions(pe.attributes.position.array), this } } class LineMaterial extends ShaderMaterial {
	constructor(K) {
		super({
			type: "LineMaterial", uniforms: UniformsUtils.clone(UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new Vector2(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }])), vertexShader: `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`, fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${version$1 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`, clipping: !0
		}), this.isLineMaterial = !0, this.onBeforeCompile = function () { this.transparent ? this.defines.USE_LINE_COLOR_ALPHA = "1" : delete this.defines.USE_LINE_COLOR_ALPHA }, Object.defineProperties(this, { color: { enumerable: !0, get: function () { return this.uniforms.diffuse.value }, set: function (pe) { this.uniforms.diffuse.value = pe } }, worldUnits: { enumerable: !0, get: function () { return "WORLD_UNITS" in this.defines }, set: function (pe) { pe === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS } }, linewidth: { enumerable: !0, get: function () { return this.uniforms.linewidth.value }, set: function (pe) { this.uniforms.linewidth.value = pe } }, dashed: { enumerable: !0, get: function () { return "USE_DASH" in this.defines }, set(pe) { !!pe != "USE_DASH" in this.defines && (this.needsUpdate = !0), pe === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH } }, dashScale: { enumerable: !0, get: function () { return this.uniforms.dashScale.value }, set: function (pe) { this.uniforms.dashScale.value = pe } }, dashSize: { enumerable: !0, get: function () { return this.uniforms.dashSize.value }, set: function (pe) { this.uniforms.dashSize.value = pe } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (pe) { this.uniforms.dashOffset.value = pe } }, gapSize: { enumerable: !0, get: function () { return this.uniforms.gapSize.value }, set: function (pe) { this.uniforms.gapSize.value = pe } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (pe) { this.uniforms.opacity.value = pe } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (pe) { this.uniforms.resolution.value.copy(pe) } }, alphaToCoverage: { enumerable: !0, get: function () { return "USE_ALPHA_TO_COVERAGE" in this.defines }, set: function (pe) { !!pe != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), pe === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1) } } }), this.setValues(K)
	}
} const _viewport = new Vector4, _start = new Vector3, _end = new Vector3, _start4 = new Vector4, _end4 = new Vector4, _ssOrigin = new Vector4, _ssOrigin3 = new Vector3, _mvMatrix = new Matrix4, _line = new Line3, _closestPoint = new Vector3, _box = new Box3, _sphere$1 = new Sphere, _clipToWorldVector = new Vector4; let _ray, _lineWidth; function getWorldSpaceHalfWidth(fe, K, pe) { return _clipToWorldVector.set(0, 0, -K, 1).applyMatrix4(fe.projectionMatrix), _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w), _clipToWorldVector.x = _lineWidth / pe.width, _clipToWorldVector.y = _lineWidth / pe.height, _clipToWorldVector.applyMatrix4(fe.projectionMatrixInverse), _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w), Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y)) } function raycastWorldUnits(fe, K) { const pe = fe.matrixWorld, me = fe.geometry, ge = me.attributes.instanceStart, xe = me.attributes.instanceEnd, ye = Math.min(me.instanceCount, ge.count); for (let ve = 0, _e = ye; ve < _e; ve++) { _line.start.fromBufferAttribute(ge, ve), _line.end.fromBufferAttribute(xe, ve), _line.applyMatrix4(pe); const Ee = new Vector3, be = new Vector3; _ray.distanceSqToSegment(_line.start, _line.end, be, Ee), be.distanceTo(Ee) < _lineWidth * .5 && K.push({ point: be, pointOnLine: Ee, distance: _ray.origin.distanceTo(be), object: fe, face: null, faceIndex: ve, uv: null, [UV1]: null }) } } function raycastScreenSpace(fe, K, pe) { const me = K.projectionMatrix, xe = fe.material.resolution, ye = fe.matrixWorld, ve = fe.geometry, _e = ve.attributes.instanceStart, Ee = ve.attributes.instanceEnd, be = Math.min(ve.instanceCount, _e.count), Ae = -K.near; _ray.at(1, _ssOrigin), _ssOrigin.w = 1, _ssOrigin.applyMatrix4(K.matrixWorldInverse), _ssOrigin.applyMatrix4(me), _ssOrigin.multiplyScalar(1 / _ssOrigin.w), _ssOrigin.x *= xe.x / 2, _ssOrigin.y *= xe.y / 2, _ssOrigin.z = 0, _ssOrigin3.copy(_ssOrigin), _mvMatrix.multiplyMatrices(K.matrixWorldInverse, ye); for (let Se = 0, Ce = be; Se < Ce; Se++) { if (_start4.fromBufferAttribute(_e, Se), _end4.fromBufferAttribute(Ee, Se), _start4.w = 1, _end4.w = 1, _start4.applyMatrix4(_mvMatrix), _end4.applyMatrix4(_mvMatrix), _start4.z > Ae && _end4.z > Ae) continue; if (_start4.z > Ae) { const Pe = _start4.z - _end4.z, Ne = (_start4.z - Ae) / Pe; _start4.lerp(_end4, Ne) } else if (_end4.z > Ae) { const Pe = _end4.z - _start4.z, Ne = (_end4.z - Ae) / Pe; _end4.lerp(_start4, Ne) } _start4.applyMatrix4(me), _end4.applyMatrix4(me), _start4.multiplyScalar(1 / _start4.w), _end4.multiplyScalar(1 / _end4.w), _start4.x *= xe.x / 2, _start4.y *= xe.y / 2, _end4.x *= xe.x / 2, _end4.y *= xe.y / 2, _line.start.copy(_start4), _line.start.z = 0, _line.end.copy(_end4), _line.end.z = 0; const Be = _line.closestPointToPointParameter(_ssOrigin3, !0); _line.at(Be, _closestPoint); const De = MathUtils.lerp(_start4.z, _end4.z, Be), Re = De >= -1 && De <= 1, Ie = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * .5; if (Re && Ie) { _line.start.fromBufferAttribute(_e, Se), _line.end.fromBufferAttribute(Ee, Se), _line.start.applyMatrix4(ye), _line.end.applyMatrix4(ye); const Pe = new Vector3, Ne = new Vector3; _ray.distanceSqToSegment(_line.start, _line.end, Ne, Pe), pe.push({ point: Ne, pointOnLine: Pe, distance: _ray.origin.distanceTo(Ne), object: fe, face: null, faceIndex: Se, uv: null, [UV1]: null }) } } } class LineSegments2 extends Mesh { constructor(K = new LineSegmentsGeometry, pe = new LineMaterial({ color: Math.random() * 16777215 })) { super(K, pe), this.isLineSegments2 = !0, this.type = "LineSegments2" } computeLineDistances() { const K = this.geometry, pe = K.attributes.instanceStart, me = K.attributes.instanceEnd, ge = new Float32Array(2 * pe.count); for (let ye = 0, ve = 0, _e = pe.count; ye < _e; ye++, ve += 2)_start.fromBufferAttribute(pe, ye), _end.fromBufferAttribute(me, ye), ge[ve] = ve === 0 ? 0 : ge[ve - 1], ge[ve + 1] = ge[ve] + _start.distanceTo(_end); const xe = new InstancedInterleavedBuffer(ge, 2, 1); return K.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(xe, 1, 0)), K.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(xe, 1, 1)), this } raycast(K, pe) { const me = this.material.worldUnits, ge = K.camera; ge === null && !me && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'); const xe = K.params.Line2 !== void 0 && K.params.Line2.threshold || 0; _ray = K.ray; const ye = this.matrixWorld, ve = this.geometry, _e = this.material; _lineWidth = _e.linewidth + xe, ve.boundingSphere === null && ve.computeBoundingSphere(), _sphere$1.copy(ve.boundingSphere).applyMatrix4(ye); let Ee; if (me) Ee = _lineWidth * .5; else { const Ae = Math.max(ge.near, _sphere$1.distanceToPoint(_ray.origin)); Ee = getWorldSpaceHalfWidth(ge, Ae, _e.resolution) } if (_sphere$1.radius += Ee, _ray.intersectsSphere(_sphere$1) === !1) return; ve.boundingBox === null && ve.computeBoundingBox(), _box.copy(ve.boundingBox).applyMatrix4(ye); let be; if (me) be = _lineWidth * .5; else { const Ae = Math.max(ge.near, _box.distanceToPoint(_ray.origin)); be = getWorldSpaceHalfWidth(ge, Ae, _e.resolution) } _box.expandByScalar(be), _ray.intersectsBox(_box) !== !1 && (me ? raycastWorldUnits(this, pe) : raycastScreenSpace(this, ge, pe)) } onBeforeRender(K) { const pe = this.material.uniforms; pe && pe.resolution && (K.getViewport(_viewport), this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w)) } } class Line2 extends LineSegments2 { constructor(K = new LineGeometry, pe = new LineMaterial({ color: Math.random() * 16777215 })) { super(K, pe), this.isLine2 = !0, this.type = "Line2" } } const tV0 = new Vector3, tV1 = new Vector3, tV2 = new Vector3, getPoint2 = (fe, K, pe) => { const me = pe.width / 2, ge = pe.height / 2; K.updateMatrixWorld(!1); const xe = fe.project(K); return xe.x = xe.x * me + me, xe.y = -(xe.y * ge) + ge, xe }, getPoint3 = (fe, K, pe, me = 1) => { const ge = tV0.set(fe.x / pe.width * 2 - 1, -(fe.y / pe.height) * 2 + 1, me); return ge.unproject(K), ge }, calculateScaleFactor = (fe, K, pe, me) => { const ge = getPoint2(tV2.copy(fe), pe, me); let xe = 0; for (let ye = 0; ye < 2; ++ye) { const ve = tV1.copy(ge).setComponent(ye, ge.getComponent(ye) + K), _e = getPoint3(ve, pe, me, ve.z); xe = Math.max(xe, fe.distanceTo(_e)) } return xe }, Line$1 = reactExports.forwardRef(function ({ points: K, color: pe = 16777215, vertexColors: me, linewidth: ge, lineWidth: xe, segments: ye, dashed: ve, ..._e }, Ee) { var be, Ae; const Se = useThree(Re => Re.size), Ce = reactExports.useMemo(() => ye ? new LineSegments2 : new Line2, [ye]), [we] = reactExports.useState(() => new LineMaterial), Be = (me == null || (be = me[0]) == null ? void 0 : be.length) === 4 ? 4 : 3, De = reactExports.useMemo(() => { const Re = ye ? new LineSegmentsGeometry : new LineGeometry, Ie = K.map(Pe => { const Ne = Array.isArray(Pe); return Pe instanceof Vector3 || Pe instanceof Vector4 ? [Pe.x, Pe.y, Pe.z] : Pe instanceof Vector2 ? [Pe.x, Pe.y, 0] : Ne && Pe.length === 3 ? [Pe[0], Pe[1], Pe[2]] : Ne && Pe.length === 2 ? [Pe[0], Pe[1], 0] : Pe }); if (Re.setPositions(Ie.flat()), me) { pe = 16777215; const Pe = me.map(Ne => Ne instanceof Color$1 ? Ne.toArray() : Ne); Re.setColors(Pe.flat(), Be) } return Re }, [K, ye, me, Be]); return reactExports.useLayoutEffect(() => { Ce.computeLineDistances() }, [K, Ce]), reactExports.useLayoutEffect(() => { ve ? we.defines.USE_DASH = "" : delete we.defines.USE_DASH, we.needsUpdate = !0 }, [ve, we]), reactExports.useEffect(() => () => { De.dispose(), we.dispose() }, [De]), reactExports.createElement("primitive", _extends$2({ object: Ce, ref: Ee }, _e), reactExports.createElement("primitive", { object: De, attach: "geometry" }), reactExports.createElement("primitive", _extends$2({ object: we, attach: "material", color: pe, vertexColors: !!me, resolution: [Se.width, Se.height], linewidth: (Ae = ge ?? xe) !== null && Ae !== void 0 ? Ae : 1, dashed: ve, transparent: Be === 4 }, _e))) }), CubicBezierLine = reactExports.forwardRef(function ({ start: K, end: pe, midA: me, midB: ge, segments: xe = 20, ...ye }, ve) { const _e = reactExports.useMemo(() => { const Ee = K instanceof Vector3 ? K : new Vector3(...K), be = pe instanceof Vector3 ? pe : new Vector3(...pe), Ae = me instanceof Vector3 ? me : new Vector3(...me), Se = ge instanceof Vector3 ? ge : new Vector3(...ge); return new CubicBezierCurve3(Ee, Ae, Se, be).getPoints(xe) }, [K, pe, me, ge, xe]); return reactExports.createElement(Line$1, _extends$2({ ref: ve, points: _e }, ye)) }), CatmullRomLine = reactExports.forwardRef(function ({ points: K, closed: pe = !1, curveType: me = "centripetal", tension: ge = .5, segments: xe = 20, vertexColors: ye, ...ve }, _e) { const Ee = reactExports.useMemo(() => { const Se = K.map(Ce => Ce instanceof Vector3 ? Ce : new Vector3(...Ce)); return new CatmullRomCurve3(Se, pe, me, ge) }, [K, pe, me, ge]), be = reactExports.useMemo(() => Ee.getPoints(xe), [Ee, xe]), Ae = reactExports.useMemo(() => { if (!ye || ye.length < 2) return; if (ye.length === xe + 1) return ye; const Se = ye.map(Be => Be instanceof Color$1 ? Be : new Color$1(...Be)); pe && Se.push(Se[0].clone()); const Ce = [Se[0]], we = xe / (Se.length - 1); for (let Be = 1; Be < xe; Be++) { const De = Be % we / we, Re = Math.floor(Be / we); Ce.push(Se[Re].clone().lerp(Se[Re + 1], De)) } return Ce.push(Se[Se.length - 1]), Ce }, [ye, xe]); return reactExports.createElement(Line$1, _extends$2({ ref: _e, points: be, vertexColors: Ae }, ve)) }); function shaderMaterial(fe, K, pe, me) { var ge; return ge = class extends ShaderMaterial { constructor(xe) { super({ vertexShader: K, fragmentShader: pe, ...xe }); for (const ye in fe) this.uniforms[ye] = new Uniform(fe[ye]), Object.defineProperty(this, ye, { get() { return this.uniforms[ye].value }, set(ve) { this.uniforms[ye].value = ve } }); this.uniforms = UniformsUtils.clone(this.uniforms) } }, ge.key = MathUtils.generateUUID(), ge } const getVersion = () => parseInt(REVISION.replace(/\D+/g, "")), version = getVersion();/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const MOUSE_BUTTON = { LEFT: 1, RIGHT: 2, MIDDLE: 4 }, ACTION = Object.freeze({ NONE: 0, ROTATE: 1, TRUCK: 2, SCREEN_PAN: 4, OFFSET: 8, DOLLY: 16, ZOOM: 32, TOUCH_ROTATE: 64, TOUCH_TRUCK: 128, TOUCH_SCREEN_PAN: 256, TOUCH_OFFSET: 512, TOUCH_DOLLY: 1024, TOUCH_ZOOM: 2048, TOUCH_DOLLY_TRUCK: 4096, TOUCH_DOLLY_SCREEN_PAN: 8192, TOUCH_DOLLY_OFFSET: 16384, TOUCH_DOLLY_ROTATE: 32768, TOUCH_ZOOM_TRUCK: 65536, TOUCH_ZOOM_OFFSET: 131072, TOUCH_ZOOM_SCREEN_PAN: 262144, TOUCH_ZOOM_ROTATE: 524288 }), DOLLY_DIRECTION = { NONE: 0, IN: 1, OUT: -1 }; function isPerspectiveCamera(fe) { return fe.isPerspectiveCamera } function isOrthographicCamera(fe) { return fe.isOrthographicCamera } const PI_2 = Math.PI * 2, PI_HALF = Math.PI / 2, EPSILON = 1e-5, DEG2RAD = Math.PI / 180; function clamp$2(fe, K, pe) { return Math.max(K, Math.min(pe, fe)) } function approxZero(fe, K = EPSILON) { return Math.abs(fe) < K } function approxEquals(fe, K, pe = EPSILON) { return approxZero(fe - K, pe) } function roundToStep(fe, K) { return Math.round(fe / K) * K } function infinityToMaxNumber(fe) { return isFinite(fe) ? fe : fe < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE } function maxNumberToInfinity(fe) { return Math.abs(fe) < Number.MAX_VALUE ? fe : fe * (1 / 0) } function smoothDamp(fe, K, pe, me, ge = 1 / 0, xe) { me = Math.max(1e-4, me); const ye = 2 / me, ve = ye * xe, _e = 1 / (1 + ve + .48 * ve * ve + .235 * ve * ve * ve); let Ee = fe - K; const be = K, Ae = ge * me; Ee = clamp$2(Ee, -Ae, Ae), K = fe - Ee; const Se = (pe.value + ye * Ee) * xe; pe.value = (pe.value - ye * Se) * _e; let Ce = K + (Ee + Se) * _e; return be - fe > 0 == Ce > be && (Ce = be, pe.value = (Ce - be) / xe), Ce } function smoothDampVec3(fe, K, pe, me, ge = 1 / 0, xe, ye) { me = Math.max(1e-4, me); const ve = 2 / me, _e = ve * xe, Ee = 1 / (1 + _e + .48 * _e * _e + .235 * _e * _e * _e); let be = K.x, Ae = K.y, Se = K.z, Ce = fe.x - be, we = fe.y - Ae, Be = fe.z - Se; const De = be, Re = Ae, Ie = Se, Pe = ge * me, Ne = Pe * Pe, ke = Ce * Ce + we * we + Be * Be; if (ke > Ne) { const ot = Math.sqrt(ke); Ce = Ce / ot * Pe, we = we / ot * Pe, Be = Be / ot * Pe } be = fe.x - Ce, Ae = fe.y - we, Se = fe.z - Be; const Oe = (pe.x + ve * Ce) * xe, Ue = (pe.y + ve * we) * xe, He = (pe.z + ve * Be) * xe; pe.x = (pe.x - ve * Oe) * Ee, pe.y = (pe.y - ve * Ue) * Ee, pe.z = (pe.z - ve * He) * Ee, ye.x = be + (Ce + Oe) * Ee, ye.y = Ae + (we + Ue) * Ee, ye.z = Se + (Be + He) * Ee; const Ge = De - fe.x, ze = Re - fe.y, We = Ie - fe.z, Xe = ye.x - De, Ye = ye.y - Re, Ze = ye.z - Ie; return Ge * Xe + ze * Ye + We * Ze > 0 && (ye.x = De, ye.y = Re, ye.z = Ie, pe.x = (ye.x - De) / xe, pe.y = (ye.y - Re) / xe, pe.z = (ye.z - Ie) / xe), ye } function extractClientCoordFromEvent(fe, K) { K.set(0, 0), fe.forEach(pe => { K.x += pe.clientX, K.y += pe.clientY }), K.x /= fe.length, K.y /= fe.length } function notSupportedInOrthographicCamera(fe, K) { return isOrthographicCamera(fe) ? (console.warn(`${K} is not supported in OrthographicCamera`), !0) : !1 } let EventDispatcher$1 = class { constructor() { this._listeners = {} } addEventListener(K, pe) { const me = this._listeners; me[K] === void 0 && (me[K] = []), me[K].indexOf(pe) === -1 && me[K].push(pe) } hasEventListener(K, pe) { const me = this._listeners; return me[K] !== void 0 && me[K].indexOf(pe) !== -1 } removeEventListener(K, pe) { const ge = this._listeners[K]; if (ge !== void 0) { const xe = ge.indexOf(pe); xe !== -1 && ge.splice(xe, 1) } } removeAllEventListeners(K) { if (!K) { this._listeners = {}; return } Array.isArray(this._listeners[K]) && (this._listeners[K].length = 0) } dispatchEvent(K) { const me = this._listeners[K.type]; if (me !== void 0) { K.target = this; const ge = me.slice(0); for (let xe = 0, ye = ge.length; xe < ye; xe++)ge[xe].call(this, K) } } }; var _a$1; const VERSION = "2.10.0", TOUCH_DOLLY_FACTOR = 1 / 8, isMac = /Mac/.test((_a$1 = globalThis?.navigator) === null || _a$1 === void 0 ? void 0 : _a$1.platform); let THREE, _ORIGIN, _AXIS_Y, _AXIS_Z, _v2, _v3A, _v3B, _v3C, _cameraDirection, _xColumn, _yColumn, _zColumn, _deltaTarget, _deltaOffset, _sphericalA, _sphericalB, _box3A, _box3B, _sphere, _quaternionA, _quaternionB, _rotationMatrix, _raycaster, CameraControls$1 = class Uc extends EventDispatcher$1 { static install(K) { THREE = K.THREE, _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0)), _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0)), _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1)), _v2 = new THREE.Vector2, _v3A = new THREE.Vector3, _v3B = new THREE.Vector3, _v3C = new THREE.Vector3, _cameraDirection = new THREE.Vector3, _xColumn = new THREE.Vector3, _yColumn = new THREE.Vector3, _zColumn = new THREE.Vector3, _deltaTarget = new THREE.Vector3, _deltaOffset = new THREE.Vector3, _sphericalA = new THREE.Spherical, _sphericalB = new THREE.Spherical, _box3A = new THREE.Box3, _box3B = new THREE.Box3, _sphere = new THREE.Sphere, _quaternionA = new THREE.Quaternion, _quaternionB = new THREE.Quaternion, _rotationMatrix = new THREE.Matrix4, _raycaster = new THREE.Raycaster } static get ACTION() { return ACTION } constructor(K, pe) { super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = .01, this.maxZoom = 1 / 0, this.smoothTime = .25, this.draggingSmoothTime = .125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.boundaryFriction = 0, this.restThreshold = .01, this.colliderMeshes = [], this.cancel = () => { }, this._enabled = !0, this._state = ACTION.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect, this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = DOLLY_DIRECTION.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new THREE.Vector3, this._focalOffsetVelocity = new THREE.Vector3, this._zoomVelocity = { value: 0 }, this._truckInternal = (Re, Ie, Pe, Ne) => { let ke, Oe; if (isPerspectiveCamera(this._camera)) { const Ue = _v3A.copy(this._camera.position).sub(this._target), He = this._camera.getEffectiveFOV() * DEG2RAD, Ge = Ue.length() * Math.tan(He * .5); ke = this.truckSpeed * Re * Ge / this._elementRect.height, Oe = this.truckSpeed * Ie * Ge / this._elementRect.height } else if (isOrthographicCamera(this._camera)) { const Ue = this._camera; ke = this.truckSpeed * Re * (Ue.right - Ue.left) / Ue.zoom / this._elementRect.width, Oe = this.truckSpeed * Ie * (Ue.top - Ue.bottom) / Ue.zoom / this._elementRect.height } else return; Ne ? (Pe ? this.setFocalOffset(this._focalOffsetEnd.x + ke, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(ke, 0, !0), this.forward(-Oe, !0)) : Pe ? this.setFocalOffset(this._focalOffsetEnd.x + ke, this._focalOffsetEnd.y + Oe, this._focalOffsetEnd.z, !0) : this.truck(ke, Oe, !0) }, this._rotateInternal = (Re, Ie) => { const Pe = PI_2 * this.azimuthRotateSpeed * Re / this._elementRect.height, Ne = PI_2 * this.polarRotateSpeed * Ie / this._elementRect.height; this.rotate(Pe, Ne, !0) }, this._dollyInternal = (Re, Ie, Pe) => { const Ne = Math.pow(.95, -Re * this.dollySpeed), ke = this._sphericalEnd.radius, Oe = this._sphericalEnd.radius * Ne, Ue = clamp$2(Oe, this.minDistance, this.maxDistance), He = Ue - Oe; this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(Oe, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(He, !0), this._dollyToNoClamp(Ue, !0)) : this._dollyToNoClamp(Ue, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? Oe : Ue) - ke, this._dollyControlCoord.set(Ie, Pe)), this._lastDollyDirection = Math.sign(-Re) }, this._zoomInternal = (Re, Ie, Pe) => { const Ne = Math.pow(.95, Re * this.dollySpeed), ke = this._zoom, Oe = this._zoom * Ne; this.zoomTo(Oe, !0), this.dollyToCursor && (this._changedZoom += Oe - ke, this._dollyControlCoord.set(Ie, Pe)) }, typeof THREE > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = K, this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = ACTION.NONE, this._target = new THREE.Vector3, this._targetEnd = this._target.clone(), this._focalOffset = new THREE.Vector3, this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this._updateNearPlaneCorners(), this._boundary = new THREE.Box3(new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0), new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new THREE.Vector2, this.mouseButtons = { left: ACTION.ROTATE, middle: ACTION.DOLLY, right: ACTION.TRUCK, wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE }, this.touches = { one: ACTION.TOUCH_ROTATE, two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE, three: ACTION.TOUCH_TRUCK }; const me = new THREE.Vector2, ge = new THREE.Vector2, xe = new THREE.Vector2, ye = Re => { if (!this._enabled || !this._domElement) return; if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) { const Ne = this._domElement.getBoundingClientRect(), ke = Re.clientX / Ne.width, Oe = Re.clientY / Ne.height; if (ke < this._interactiveArea.left || ke > this._interactiveArea.right || Oe < this._interactiveArea.top || Oe > this._interactiveArea.bottom) return } const Ie = Re.pointerType !== "mouse" ? null : (Re.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (Re.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (Re.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null; if (Ie !== null) { const Ne = this._findPointerByMouseButton(Ie); Ne && this._disposePointer(Ne) } if ((Re.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer) return; const Pe = { pointerId: Re.pointerId, clientX: Re.clientX, clientY: Re.clientY, deltaX: 0, deltaY: 0, mouseButton: Ie }; this._activePointers.push(Pe), this._domElement.ownerDocument.removeEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", _e), this._domElement.ownerDocument.addEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", _e), this._isDragging = !0, Se(Re) }, ve = Re => { Re.cancelable && Re.preventDefault(); const Ie = Re.pointerId, Pe = this._lockedPointer || this._findPointerById(Ie); if (Pe) { if (Pe.clientX = Re.clientX, Pe.clientY = Re.clientY, Pe.deltaX = Re.movementX, Pe.deltaY = Re.movementY, this._state = 0, Re.pointerType === "touch") switch (this._activePointers.length) { case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three; break } else (!this._isDragging && this._lockedPointer || this._isDragging && (Re.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (Re.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (Re.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT && (this._state = this._state | this.mouseButtons.right); Ce() } }, _e = Re => { const Ie = this._findPointerById(Re.pointerId); if (!(Ie && Ie === this._lockedPointer)) { if (Ie && this._disposePointer(Ie), Re.pointerType === "touch") switch (this._activePointers.length) { case 0: this._state = ACTION.NONE; break; case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three; break } else this._state = ACTION.NONE; we() } }; let Ee = -1; const be = Re => { if (!this._domElement || !this._enabled || this.mouseButtons.wheel === ACTION.NONE) return; if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) { const Oe = this._domElement.getBoundingClientRect(), Ue = Re.clientX / Oe.width, He = Re.clientY / Oe.height; if (Ue < this._interactiveArea.left || Ue > this._interactiveArea.right || He < this._interactiveArea.top || He > this._interactiveArea.bottom) return } if (Re.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) { const Oe = performance.now(); Ee - Oe < 1e3 && this._getClientRect(this._elementRect), Ee = Oe } const Ie = isMac ? -1 : -3, Pe = Re.deltaMode === 1 ? Re.deltaY / Ie : Re.deltaY / (Ie * 10), Ne = this.dollyToCursor ? (Re.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, ke = this.dollyToCursor ? (Re.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0; switch (this.mouseButtons.wheel) { case ACTION.ROTATE: { this._rotateInternal(Re.deltaX, Re.deltaY), this._isUserControllingRotate = !0; break } case ACTION.TRUCK: { this._truckInternal(Re.deltaX, Re.deltaY, !1, !1), this._isUserControllingTruck = !0; break } case ACTION.SCREEN_PAN: { this._truckInternal(Re.deltaX, Re.deltaY, !1, !0), this._isUserControllingTruck = !0; break } case ACTION.OFFSET: { this._truckInternal(Re.deltaX, Re.deltaY, !0, !1), this._isUserControllingOffset = !0; break } case ACTION.DOLLY: { this._dollyInternal(-Pe, Ne, ke), this._isUserControllingDolly = !0; break } case ACTION.ZOOM: { this._zoomInternal(-Pe, Ne, ke), this._isUserControllingZoom = !0; break } }this.dispatchEvent({ type: "control" }) }, Ae = Re => { if (!(!this._domElement || !this._enabled)) { if (this.mouseButtons.right === Uc.ACTION.NONE) { const Ie = Re instanceof PointerEvent ? Re.pointerId : 0, Pe = this._findPointerById(Ie); Pe && this._disposePointer(Pe), this._domElement.ownerDocument.removeEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", _e); return } Re.preventDefault() } }, Se = Re => { if (!this._enabled) return; if (extractClientCoordFromEvent(this._activePointers, _v2), this._getClientRect(this._elementRect), me.copy(_v2), ge.copy(_v2), this._activePointers.length >= 2) { const Pe = _v2.x - this._activePointers[1].clientX, Ne = _v2.y - this._activePointers[1].clientY, ke = Math.sqrt(Pe * Pe + Ne * Ne); xe.set(0, ke); const Oe = (this._activePointers[0].clientX + this._activePointers[1].clientX) * .5, Ue = (this._activePointers[0].clientY + this._activePointers[1].clientY) * .5; ge.set(Oe, Ue) } if (this._state = 0, !Re) this._lockedPointer && (this._state = this._state | this.mouseButtons.left); else if ("pointerType" in Re && Re.pointerType === "touch") switch (this._activePointers.length) { case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three; break } else !this._lockedPointer && (Re.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && (this._state = this._state | this.mouseButtons.left), (Re.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (Re.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT && (this._state = this._state | this.mouseButtons.right); ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" }) }, Ce = () => { if (!this._enabled || !this._dragNeedsUpdate) return; this._dragNeedsUpdate = !1, extractClientCoordFromEvent(this._activePointers, _v2); const Ie = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, Pe = Ie ? -Ie.deltaX : ge.x - _v2.x, Ne = Ie ? -Ie.deltaY : ge.y - _v2.y; if (ge.copy(_v2), ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(Pe, Ne), this._isUserControllingRotate = !0), (this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) { const ke = this.dollyToCursor ? (me.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, Oe = this.dollyToCursor ? (me.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, Ue = this.dollyDragInverted ? -1 : 1; (this._state & ACTION.DOLLY) === ACTION.DOLLY ? (this._dollyInternal(Ue * Ne * TOUCH_DOLLY_FACTOR, ke, Oe), this._isUserControllingDolly = !0) : (this._zoomInternal(Ue * Ne * TOUCH_DOLLY_FACTOR, ke, Oe), this._isUserControllingZoom = !0) } if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) { const ke = _v2.x - this._activePointers[1].clientX, Oe = _v2.y - this._activePointers[1].clientY, Ue = Math.sqrt(ke * ke + Oe * Oe), He = xe.y - Ue; xe.set(0, Ue); const Ge = this.dollyToCursor ? (ge.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, ze = this.dollyToCursor ? (ge.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0; (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(He * TOUCH_DOLLY_FACTOR, Ge, ze), this._isUserControllingDolly = !0) : (this._zoomInternal(He * TOUCH_DOLLY_FACTOR, Ge, ze), this._isUserControllingZoom = !0) } ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) && (this._truckInternal(Pe, Ne, !1, !1), this._isUserControllingTruck = !0), ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) && (this._truckInternal(Pe, Ne, !1, !0), this._isUserControllingTruck = !0), ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) && (this._truckInternal(Pe, Ne, !0, !1), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" }) }, we = () => { extractClientCoordFromEvent(this._activePointers, _v2), ge.copy(_v2), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", _e), this.dispatchEvent({ type: "controlend" })) }; this.lockPointer = () => { !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = { pointerId: -1, clientX: 0, clientY: 0, deltaX: 0, deltaY: 0, mouseButton: null }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", _e), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", Be), this._domElement.ownerDocument.addEventListener("pointerlockerror", De), this._domElement.ownerDocument.addEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", _e), Se()) }, this.unlockPointer = () => { var Re, Ie, Pe; this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (Re = this._domElement) === null || Re === void 0 || Re.ownerDocument.exitPointerLock(), (Ie = this._domElement) === null || Ie === void 0 || Ie.ownerDocument.removeEventListener("pointerlockchange", Be), (Pe = this._domElement) === null || Pe === void 0 || Pe.ownerDocument.removeEventListener("pointerlockerror", De), this.cancel() }; const Be = () => { this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer() }, De = () => { this.unlockPointer() }; this._addAllEventListeners = Re => { this._domElement = Re, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", ye), this._domElement.addEventListener("pointercancel", _e), this._domElement.addEventListener("wheel", be, { passive: !1 }), this._domElement.addEventListener("contextmenu", Ae) }, this._removeAllEventListeners = () => { this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", ye), this._domElement.removeEventListener("pointercancel", _e), this._domElement.removeEventListener("wheel", be, { passive: !1 }), this._domElement.removeEventListener("contextmenu", Ae), this._domElement.ownerDocument.removeEventListener("pointermove", ve, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", _e), this._domElement.ownerDocument.removeEventListener("pointerlockchange", Be), this._domElement.ownerDocument.removeEventListener("pointerlockerror", De)) }, this.cancel = () => { this._state !== ACTION.NONE && (this._state = ACTION.NONE, this._activePointers.length = 0, we()) }, pe && this.connect(pe), this.update(0) } get camera() { return this._camera } set camera(K) { this._camera = K, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0 } get enabled() { return this._enabled } set enabled(K) { this._enabled = K, this._domElement && (K ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "")) } get active() { return !this._hasRested } get currentAction() { return this._state } get distance() { return this._spherical.radius } set distance(K) { this._spherical.radius === K && this._sphericalEnd.radius === K || (this._spherical.radius = K, this._sphericalEnd.radius = K, this._needsUpdate = !0) } get azimuthAngle() { return this._spherical.theta } set azimuthAngle(K) { this._spherical.theta === K && this._sphericalEnd.theta === K || (this._spherical.theta = K, this._sphericalEnd.theta = K, this._needsUpdate = !0) } get polarAngle() { return this._spherical.phi } set polarAngle(K) { this._spherical.phi === K && this._sphericalEnd.phi === K || (this._spherical.phi = K, this._sphericalEnd.phi = K, this._needsUpdate = !0) } get boundaryEnclosesCamera() { return this._boundaryEnclosesCamera } set boundaryEnclosesCamera(K) { this._boundaryEnclosesCamera = K, this._needsUpdate = !0 } set interactiveArea(K) { this._interactiveArea.width = clamp$2(K.width, 0, 1), this._interactiveArea.height = clamp$2(K.height, 0, 1), this._interactiveArea.x = clamp$2(K.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = clamp$2(K.y, 0, 1 - this._interactiveArea.height) } addEventListener(K, pe) { super.addEventListener(K, pe) } removeEventListener(K, pe) { super.removeEventListener(K, pe) } rotate(K, pe, me = !1) { return this.rotateTo(this._sphericalEnd.theta + K, this._sphericalEnd.phi + pe, me) } rotateAzimuthTo(K, pe = !1) { return this.rotateTo(K, this._sphericalEnd.phi, pe) } rotatePolarTo(K, pe = !1) { return this.rotateTo(this._sphericalEnd.theta, K, pe) } rotateTo(K, pe, me = !1) { this._isUserControllingRotate = !1; const ge = clamp$2(K, this.minAzimuthAngle, this.maxAzimuthAngle), xe = clamp$2(pe, this.minPolarAngle, this.maxPolarAngle); this._sphericalEnd.theta = ge, this._sphericalEnd.phi = xe, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, me || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi); const ye = !me || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold); return this._createOnRestPromise(ye) } dolly(K, pe = !1) { return this.dollyTo(this._sphericalEnd.radius - K, pe) } dollyTo(K, pe = !1) { return this._isUserControllingDolly = !1, this._lastDollyDirection = DOLLY_DIRECTION.NONE, this._changedDolly = 0, this._dollyToNoClamp(clamp$2(K, this.minDistance, this.maxDistance), pe) } _dollyToNoClamp(K, pe = !1) { const me = this._sphericalEnd.radius; if (this.colliderMeshes.length >= 1) { const ye = this._collisionTest(), ve = approxEquals(ye, this._spherical.radius); if (!(me > K) && ve) return Promise.resolve(); this._sphericalEnd.radius = Math.min(K, ye) } else this._sphericalEnd.radius = K; this._needsUpdate = !0, pe || (this._spherical.radius = this._sphericalEnd.radius); const xe = !pe || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(xe) } dollyInFixed(K, pe = !1) { this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(K)), pe || this._target.copy(this._targetEnd); const me = !pe || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold); return this._createOnRestPromise(me) } zoom(K, pe = !1) { return this.zoomTo(this._zoomEnd + K, pe) } zoomTo(K, pe = !1) { this._isUserControllingZoom = !1, this._zoomEnd = clamp$2(K, this.minZoom, this.maxZoom), this._needsUpdate = !0, pe || (this._zoom = this._zoomEnd); const me = !pe || approxEquals(this._zoom, this._zoomEnd, this.restThreshold); return this._changedZoom = 0, this._createOnRestPromise(me) } pan(K, pe, me = !1) { return console.warn("`pan` has been renamed to `truck`"), this.truck(K, pe, me) } truck(K, pe, me = !1) { this._camera.updateMatrix(), _xColumn.setFromMatrixColumn(this._camera.matrix, 0), _yColumn.setFromMatrixColumn(this._camera.matrix, 1), _xColumn.multiplyScalar(K), _yColumn.multiplyScalar(-pe); const ge = _v3A.copy(_xColumn).add(_yColumn), xe = _v3B.copy(this._targetEnd).add(ge); return this.moveTo(xe.x, xe.y, xe.z, me) } forward(K, pe = !1) { _v3A.setFromMatrixColumn(this._camera.matrix, 0), _v3A.crossVectors(this._camera.up, _v3A), _v3A.multiplyScalar(K); const me = _v3B.copy(this._targetEnd).add(_v3A); return this.moveTo(me.x, me.y, me.z, pe) } elevate(K, pe = !1) { return _v3A.copy(this._camera.up).multiplyScalar(K), this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, pe) } moveTo(K, pe, me, ge = !1) { this._isUserControllingTruck = !1; const xe = _v3A.set(K, pe, me).sub(this._targetEnd); this._encloseToBoundary(this._targetEnd, xe, this.boundaryFriction), this._needsUpdate = !0, ge || this._target.copy(this._targetEnd); const ye = !ge || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold); return this._createOnRestPromise(ye) } lookInDirectionOf(K, pe, me, ge = !1) { const ve = _v3A.set(K, pe, me).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd); return this.setPosition(ve.x, ve.y, ve.z, ge) } fitToBox(K, pe, { cover: me = !1, paddingLeft: ge = 0, paddingRight: xe = 0, paddingBottom: ye = 0, paddingTop: ve = 0 } = {}) { const _e = [], Ee = K.isBox3 ? _box3A.copy(K) : _box3A.setFromObject(K); Ee.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve()); const be = roundToStep(this._sphericalEnd.theta, PI_HALF), Ae = roundToStep(this._sphericalEnd.phi, PI_HALF); _e.push(this.rotateTo(be, Ae, pe)); const Se = _v3A.setFromSpherical(this._sphericalEnd).normalize(), Ce = _quaternionA.setFromUnitVectors(Se, _AXIS_Z), we = approxEquals(Math.abs(Se.y), 1); we && Ce.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, be)), Ce.multiply(this._yAxisUpSpaceInverse); const Be = _box3B.makeEmpty(); _v3B.copy(Ee.min).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.min).setX(Ee.max.x).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.min).setY(Ee.max.y).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.max).setZ(Ee.min.z).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.min).setZ(Ee.max.z).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.max).setY(Ee.min.y).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.max).setX(Ee.min.x).applyQuaternion(Ce), Be.expandByPoint(_v3B), _v3B.copy(Ee.max).applyQuaternion(Ce), Be.expandByPoint(_v3B), Be.min.x -= ge, Be.min.y -= ye, Be.max.x += xe, Be.max.y += ve, Ce.setFromUnitVectors(_AXIS_Z, Se), we && Ce.premultiply(_quaternionB.invert()), Ce.premultiply(this._yAxisUpSpace); const De = Be.getSize(_v3A), Re = Be.getCenter(_v3B).applyQuaternion(Ce); if (isPerspectiveCamera(this._camera)) { const Ie = this.getDistanceToFitBox(De.x, De.y, De.z, me); _e.push(this.moveTo(Re.x, Re.y, Re.z, pe)), _e.push(this.dollyTo(Ie, pe)), _e.push(this.setFocalOffset(0, 0, 0, pe)) } else if (isOrthographicCamera(this._camera)) { const Ie = this._camera, Pe = Ie.right - Ie.left, Ne = Ie.top - Ie.bottom, ke = me ? Math.max(Pe / De.x, Ne / De.y) : Math.min(Pe / De.x, Ne / De.y); _e.push(this.moveTo(Re.x, Re.y, Re.z, pe)), _e.push(this.zoomTo(ke, pe)), _e.push(this.setFocalOffset(0, 0, 0, pe)) } return Promise.all(_e) } fitToSphere(K, pe) { const me = [], xe = "isObject3D" in K ? Uc.createBoundingSphere(K, _sphere) : _sphere.copy(K); if (me.push(this.moveTo(xe.center.x, xe.center.y, xe.center.z, pe)), isPerspectiveCamera(this._camera)) { const ye = this.getDistanceToFitSphere(xe.radius); me.push(this.dollyTo(ye, pe)) } else if (isOrthographicCamera(this._camera)) { const ye = this._camera.right - this._camera.left, ve = this._camera.top - this._camera.bottom, _e = 2 * xe.radius, Ee = Math.min(ye / _e, ve / _e); me.push(this.zoomTo(Ee, pe)) } return me.push(this.setFocalOffset(0, 0, 0, pe)), Promise.all(me) } setLookAt(K, pe, me, ge, xe, ye, ve = !1) { this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = DOLLY_DIRECTION.NONE, this._changedDolly = 0; const _e = _v3B.set(ge, xe, ye), Ee = _v3A.set(K, pe, me); this._targetEnd.copy(_e), this._sphericalEnd.setFromVector3(Ee.sub(_e).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, ve || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)); const be = !ve || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(be) } lerpLookAt(K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we = !1) { this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = DOLLY_DIRECTION.NONE, this._changedDolly = 0; const Be = _v3A.set(ge, xe, ye), De = _v3B.set(K, pe, me); _sphericalA.setFromVector3(De.sub(Be).applyQuaternion(this._yAxisUpSpace)); const Re = _v3C.set(be, Ae, Se), Ie = _v3B.set(ve, _e, Ee); _sphericalB.setFromVector3(Ie.sub(Re).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(Be.lerp(Re, Ce)); const Pe = _sphericalB.theta - _sphericalA.theta, Ne = _sphericalB.phi - _sphericalA.phi, ke = _sphericalB.radius - _sphericalA.radius; this._sphericalEnd.set(_sphericalA.radius + ke * Ce, _sphericalA.phi + Ne * Ce, _sphericalA.theta + Pe * Ce), this.normalizeRotations(), this._needsUpdate = !0, we || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)); const Oe = !we || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(Oe) } setPosition(K, pe, me, ge = !1) { return this.setLookAt(K, pe, me, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, ge) } setTarget(K, pe, me, ge = !1) { const xe = this.getPosition(_v3A), ye = this.setLookAt(xe.x, xe.y, xe.z, K, pe, me, ge); return this._sphericalEnd.phi = clamp$2(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), ye } setFocalOffset(K, pe, me, ge = !1) { this._isUserControllingOffset = !1, this._focalOffsetEnd.set(K, pe, me), this._needsUpdate = !0, ge || this._focalOffset.copy(this._focalOffsetEnd); const xe = !ge || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold); return this._createOnRestPromise(xe) } setOrbitPoint(K, pe, me) { this._camera.updateMatrixWorld(), _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2); const ge = _v3A.set(K, pe, me), xe = ge.distanceTo(this._camera.position), ye = ge.sub(this._camera.position); _xColumn.multiplyScalar(ye.x), _yColumn.multiplyScalar(ye.y), _zColumn.multiplyScalar(ye.z), _v3A.copy(_xColumn).add(_yColumn).add(_zColumn), _v3A.z = _v3A.z + xe, this.dollyTo(xe, !1), this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, !1), this.moveTo(K, pe, me, !1) } setBoundary(K) { if (!K) { this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0; return } this._boundary.copy(K), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0 } setViewport(K, pe, me, ge) { if (K === null) { this._viewport = null; return } this._viewport = this._viewport || new THREE.Vector4, typeof K == "number" ? this._viewport.set(K, pe, me, ge) : this._viewport.copy(K) } getDistanceToFitBox(K, pe, me, ge = !1) { if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox")) return this._spherical.radius; const xe = K / pe, ye = this._camera.getEffectiveFOV() * DEG2RAD, ve = this._camera.aspect; return ((ge ? xe > ve : xe < ve) ? pe : K / ve) * .5 / Math.tan(ye * .5) + me * .5 } getDistanceToFitSphere(K) { if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere")) return this._spherical.radius; const pe = this._camera.getEffectiveFOV() * DEG2RAD, me = Math.atan(Math.tan(pe * .5) * this._camera.aspect) * 2, ge = 1 < this._camera.aspect ? pe : me; return K / Math.sin(ge * .5) } getTarget(K, pe = !0) { return (K && K.isVector3 ? K : new THREE.Vector3).copy(pe ? this._targetEnd : this._target) } getPosition(K, pe = !0) { return (K && K.isVector3 ? K : new THREE.Vector3).setFromSpherical(pe ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(pe ? this._targetEnd : this._target) } getSpherical(K, pe = !0) { return (K || new THREE.Spherical).copy(pe ? this._sphericalEnd : this._spherical) } getFocalOffset(K, pe = !0) { return (K && K.isVector3 ? K : new THREE.Vector3).copy(pe ? this._focalOffsetEnd : this._focalOffset) } normalizeRotations() { this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += PI_2), this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2) } stop() { this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd } reset(K = !1) { if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) { this._camera.up.copy(this._cameraUp0); const me = this.getPosition(_v3A); this.updateCameraUp(), this.setPosition(me.x, me.y, me.z) } const pe = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, K), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, K), this.zoomTo(this._zoom0, K)]; return Promise.all(pe) } saveState() { this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset) } updateCameraUp() { this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert() } applyCameraUp() { const K = _v3A.subVectors(this._target, this._camera.position).normalize(), pe = _v3B.crossVectors(K, this._camera.up); this._camera.up.crossVectors(pe, K).normalize(), this._camera.updateMatrixWorld(); const me = this.getPosition(_v3A); this.updateCameraUp(), this.setPosition(me.x, me.y, me.z) } update(K) { const pe = this._sphericalEnd.theta - this._spherical.theta, me = this._sphericalEnd.phi - this._spherical.phi, ge = this._sphericalEnd.radius - this._spherical.radius, xe = _deltaTarget.subVectors(this._targetEnd, this._target), ye = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset), ve = this._zoomEnd - this._zoom; if (approxZero(pe)) this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta; else { const Ae = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime; this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, Ae, 1 / 0, K), this._needsUpdate = !0 } if (approxZero(me)) this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi; else { const Ae = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime; this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, Ae, 1 / 0, K), this._needsUpdate = !0 } if (approxZero(ge)) this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius; else { const Ae = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime; this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, Ae, this.maxSpeed, K), this._needsUpdate = !0 } if (approxZero(xe.x) && approxZero(xe.y) && approxZero(xe.z)) this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd); else { const Ae = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime; smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, Ae, this.maxSpeed, K, this._target), this._needsUpdate = !0 } if (approxZero(ye.x) && approxZero(ye.y) && approxZero(ye.z)) this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd); else { const Ae = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime; smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, Ae, this.maxSpeed, K, this._focalOffset), this._needsUpdate = !0 } if (approxZero(ve)) this._zoomVelocity.value = 0, this._zoom = this._zoomEnd; else { const Ae = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime; this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, Ae, 1 / 0, K) } if (this.dollyToCursor) { if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) { const Ae = this._spherical.radius - this._lastDistance, Se = this._camera, Ce = this._getCameraDirection(_cameraDirection), we = _v3A.copy(Ce).cross(Se.up).normalize(); we.lengthSq() === 0 && (we.x = 1); const Be = _v3B.crossVectors(we, Ce), De = this._sphericalEnd.radius * Math.tan(Se.getEffectiveFOV() * DEG2RAD * .5), Ie = (this._sphericalEnd.radius - Ae - this._sphericalEnd.radius) / this._sphericalEnd.radius, Pe = _v3C.copy(this._targetEnd).add(we.multiplyScalar(this._dollyControlCoord.x * De * Se.aspect)).add(Be.multiplyScalar(this._dollyControlCoord.y * De)), Ne = _v3A.copy(this._targetEnd).lerp(Pe, Ie), ke = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance, Oe = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius; if (this.infinityDolly && (ke || Oe)) { this._sphericalEnd.radius -= Ae, this._spherical.radius -= Ae; const He = _v3B.copy(Ce).multiplyScalar(-Ae); Ne.add(He) } this._boundary.clampPoint(Ne, Ne); const Ue = _v3B.subVectors(Ne, this._targetEnd); this._targetEnd.copy(Ne), this._target.add(Ue), this._changedDolly -= Ae, approxZero(this._changedDolly) && (this._changedDolly = 0) } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) { const Ae = this._zoom - this._lastZoom, Se = this._camera, Ce = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (Se.near + Se.far) / (Se.near - Se.far)).unproject(Se), we = _v3B.set(0, 0, -1).applyQuaternion(Se.quaternion), Be = _v3C.copy(Ce).add(we.multiplyScalar(-Ce.dot(Se.up))), Re = -(this._zoom - Ae - this._zoom) / this._zoom, Ie = this._getCameraDirection(_cameraDirection), Pe = this._targetEnd.dot(Ie), Ne = _v3A.copy(this._targetEnd).lerp(Be, Re), ke = Ne.dot(Ie), Oe = Ie.multiplyScalar(ke - Pe); Ne.sub(Oe), this._boundary.clampPoint(Ne, Ne); const Ue = _v3B.subVectors(Ne, this._targetEnd); this._targetEnd.copy(Ne), this._target.add(Ue), this._changedZoom -= Ae, approxZero(this._changedZoom) && (this._changedZoom = 0) } } this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0; const _e = this._collisionTest(); this._spherical.radius = Math.min(this._spherical.radius, _e), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z)) && (_xColumn.setFromMatrixColumn(this._camera.matrix, 0), _yColumn.setFromMatrixColumn(this._camera.matrix, 1), _zColumn.setFromMatrixColumn(this._camera.matrix, 2), _xColumn.multiplyScalar(this._focalOffset.x), _yColumn.multiplyScalar(-this._focalOffset.y), _zColumn.multiplyScalar(this._focalOffset.z), _v3A.copy(_xColumn).add(_yColumn).add(_zColumn), this._camera.position.add(_v3A), this._camera.updateMatrixWorld()), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1); const be = this._needsUpdate; return be && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : be ? (this.dispatchEvent({ type: "update" }), approxZero(pe, this.restThreshold) && approxZero(me, this.restThreshold) && approxZero(ge, this.restThreshold) && approxZero(xe.x, this.restThreshold) && approxZero(xe.y, this.restThreshold) && approxZero(xe.z, this.restThreshold) && approxZero(ye.x, this.restThreshold) && approxZero(ye.y, this.restThreshold) && approxZero(ye.z, this.restThreshold) && approxZero(ve, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !be && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = be, this._needsUpdate = !1, be } toJSON() { return JSON.stringify({ enabled: this._enabled, minDistance: this.minDistance, maxDistance: infinityToMaxNumber(this.maxDistance), minZoom: this.minZoom, maxZoom: infinityToMaxNumber(this.maxZoom), minPolarAngle: this.minPolarAngle, maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle), minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle), maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle), smoothTime: this.smoothTime, draggingSmoothTime: this.draggingSmoothTime, dollySpeed: this.dollySpeed, truckSpeed: this.truckSpeed, dollyToCursor: this.dollyToCursor, target: this._targetEnd.toArray(), position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(), zoom: this._zoomEnd, focalOffset: this._focalOffsetEnd.toArray(), target0: this._target0.toArray(), position0: this._position0.toArray(), zoom0: this._zoom0, focalOffset0: this._focalOffset0.toArray() }) } fromJSON(K, pe = !1) { const me = JSON.parse(K); this.enabled = me.enabled, this.minDistance = me.minDistance, this.maxDistance = maxNumberToInfinity(me.maxDistance), this.minZoom = me.minZoom, this.maxZoom = maxNumberToInfinity(me.maxZoom), this.minPolarAngle = me.minPolarAngle, this.maxPolarAngle = maxNumberToInfinity(me.maxPolarAngle), this.minAzimuthAngle = maxNumberToInfinity(me.minAzimuthAngle), this.maxAzimuthAngle = maxNumberToInfinity(me.maxAzimuthAngle), this.smoothTime = me.smoothTime, this.draggingSmoothTime = me.draggingSmoothTime, this.dollySpeed = me.dollySpeed, this.truckSpeed = me.truckSpeed, this.dollyToCursor = me.dollyToCursor, this._target0.fromArray(me.target0), this._position0.fromArray(me.position0), this._zoom0 = me.zoom0, this._focalOffset0.fromArray(me.focalOffset0), this.moveTo(me.target[0], me.target[1], me.target[2], pe), _sphericalA.setFromVector3(_v3A.fromArray(me.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(_sphericalA.theta, _sphericalA.phi, pe), this.dollyTo(_sphericalA.radius, pe), this.zoomTo(me.zoom, pe), this.setFocalOffset(me.focalOffset[0], me.focalOffset[1], me.focalOffset[2], pe), this._needsUpdate = !0 } connect(K) { if (this._domElement) { console.warn("camera-controls is already connected."); return } K.setAttribute("data-camera-controls-version", VERSION), this._addAllEventListeners(K), this._getClientRect(this._elementRect) } disconnect() { this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0) } dispose() { this.removeAllEventListeners(), this.disconnect() } _getTargetDirection(K) { return K.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse) } _getCameraDirection(K) { return this._getTargetDirection(K).negate() } _findPointerById(K) { return this._activePointers.find(pe => pe.pointerId === K) } _findPointerByMouseButton(K) { return this._activePointers.find(pe => pe.mouseButton === K) } _disposePointer(K) { this._activePointers.splice(this._activePointers.indexOf(K), 1) } _encloseToBoundary(K, pe, me) { const ge = pe.lengthSq(); if (ge === 0) return K; const xe = _v3B.copy(pe).add(K), ve = this._boundary.clampPoint(xe, _v3C).sub(xe), _e = ve.lengthSq(); if (_e === 0) return K.add(pe); if (_e === ge) return K; if (me === 0) return K.add(pe).add(ve); { const Ee = 1 + me * _e / pe.dot(ve); return K.add(_v3B.copy(pe).multiplyScalar(Ee)).add(ve.multiplyScalar(1 - me)) } } _updateNearPlaneCorners() { if (isPerspectiveCamera(this._camera)) { const K = this._camera, pe = K.near, me = K.getEffectiveFOV() * DEG2RAD, ge = Math.tan(me * .5) * pe, xe = ge * K.aspect; this._nearPlaneCorners[0].set(-xe, -ge, 0), this._nearPlaneCorners[1].set(xe, -ge, 0), this._nearPlaneCorners[2].set(xe, ge, 0), this._nearPlaneCorners[3].set(-xe, ge, 0) } else if (isOrthographicCamera(this._camera)) { const K = this._camera, pe = 1 / K.zoom, me = K.left * pe, ge = K.right * pe, xe = K.top * pe, ye = K.bottom * pe; this._nearPlaneCorners[0].set(me, xe, 0), this._nearPlaneCorners[1].set(ge, xe, 0), this._nearPlaneCorners[2].set(ge, ye, 0), this._nearPlaneCorners[3].set(me, ye, 0) } } _collisionTest() { let K = 1 / 0; if (!(this.colliderMeshes.length >= 1) || notSupportedInOrthographicCamera(this._camera, "_collisionTest")) return K; const me = this._getTargetDirection(_cameraDirection); _rotationMatrix.lookAt(_ORIGIN, me, this._camera.up); for (let ge = 0; ge < 4; ge++) { const xe = _v3B.copy(this._nearPlaneCorners[ge]); xe.applyMatrix4(_rotationMatrix); const ye = _v3C.addVectors(this._target, xe); _raycaster.set(ye, me), _raycaster.far = this._spherical.radius + 1; const ve = _raycaster.intersectObjects(this.colliderMeshes); ve.length !== 0 && ve[0].distance < K && (K = ve[0].distance) } return K } _getClientRect(K) { if (!this._domElement) return; const pe = this._domElement.getBoundingClientRect(); return K.x = pe.left, K.y = pe.top, this._viewport ? (K.x += this._viewport.x, K.y += pe.height - this._viewport.w - this._viewport.y, K.width = this._viewport.z, K.height = this._viewport.w) : (K.width = pe.width, K.height = pe.height), K } _createOnRestPromise(K) { return K ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise(pe => { const me = () => { this.removeEventListener("rest", me), pe() }; this.addEventListener("rest", me) })) } _addAllEventListeners(K) { } _removeAllEventListeners() { } get dampingFactor() { return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0 } set dampingFactor(K) { console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.") } get draggingDampingFactor() { return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0 } set draggingDampingFactor(K) { console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.") } static createBoundingSphere(K, pe = new THREE.Sphere) { const me = pe, ge = me.center; _box3A.makeEmpty(), K.traverseVisible(ye => { ye.isMesh && _box3A.expandByObject(ye) }), _box3A.getCenter(ge); let xe = 0; return K.traverseVisible(ye => { if (!ye.isMesh) return; const ve = ye; if (!ve.geometry) return; const _e = ve.geometry.clone(); _e.applyMatrix4(ve.matrixWorld); const be = _e.attributes.position; for (let Ae = 0, Se = be.count; Ae < Se; Ae++)_v3A.fromBufferAttribute(be, Ae), xe = Math.max(xe, ge.distanceToSquared(_v3A)) }), me.radius = Math.sqrt(xe), me } }; const CameraControls = reactExports.forwardRef((fe, K) => { reactExports.useMemo(() => { const ke = { Box3, MathUtils: { clamp: MathUtils.clamp }, Matrix4, Quaternion, Raycaster, Sphere, Spherical, Vector2, Vector3, Vector4 }; CameraControls$1.install({ THREE: ke }), extend$3({ CameraControlsImpl: CameraControls$1 }) }, []); const { camera: pe, domElement: me, makeDefault: ge, onStart: xe, onEnd: ye, onChange: ve, regress: _e, ...Ee } = fe, be = useThree(ke => ke.camera), Ae = useThree(ke => ke.gl), Se = useThree(ke => ke.invalidate), Ce = useThree(ke => ke.events), we = useThree(ke => ke.setEvents), Be = useThree(ke => ke.set), De = useThree(ke => ke.get), Re = useThree(ke => ke.performance), Ie = pe || be, Pe = me || Ce.connected || Ae.domElement, Ne = reactExports.useMemo(() => new CameraControls$1(Ie), [Ie]); return useFrame((ke, Oe) => { Ne.enabled && Ne.update(Oe) }, -1), reactExports.useEffect(() => (Ne.connect(Pe), () => void Ne.disconnect()), [Pe, Ne]), reactExports.useEffect(() => { const ke = He => { Se(), _e && Re.regress(), ve && ve(He) }, Oe = He => { xe && xe(He) }, Ue = He => { ye && ye(He) }; return Ne.addEventListener("update", ke), Ne.addEventListener("controlstart", Oe), Ne.addEventListener("controlend", Ue), Ne.addEventListener("control", ke), Ne.addEventListener("transitionstart", ke), Ne.addEventListener("wake", ke), () => { Ne.removeEventListener("update", ke), Ne.removeEventListener("controlstart", Oe), Ne.removeEventListener("controlend", Ue), Ne.removeEventListener("control", ke), Ne.removeEventListener("transitionstart", ke), Ne.removeEventListener("wake", ke) } }, [Ne, xe, ye, Se, we, _e, ve]), reactExports.useEffect(() => { if (ge) { const ke = De().controls; return Be({ controls: Ne }), () => Be({ controls: ke }) } }, [ge, Ne]), reactExports.createElement("primitive", _extends$2({ ref: K, object: Ne }, Ee)) }), GridMaterial = shaderMaterial({ cellSize: .5, sectionSize: 1, fadeDistance: 100, fadeStrength: 1, fadeFrom: 1, cellThickness: .5, sectionThickness: 1, cellColor: new Color$1, sectionColor: new Color$1, infiniteGrid: !1, followCamera: !1, worldCamProjPosition: new Vector3, worldPlanePosition: new Vector3 }, `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `, `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }
  `), Grid = reactExports.forwardRef(({ args: fe, cellColor: K = "#000000", sectionColor: pe = "#2080ff", cellSize: me = .5, sectionSize: ge = 1, followCamera: xe = !1, infiniteGrid: ye = !1, fadeDistance: ve = 100, fadeStrength: _e = 1, fadeFrom: Ee = 1, cellThickness: be = .5, sectionThickness: Ae = 1, side: Se = BackSide, ...Ce }, we) => { extend$3({ GridMaterial }); const Be = reactExports.useRef(null); reactExports.useImperativeHandle(we, () => Be.current, []); const De = new Plane, Re = new Vector3(0, 1, 0), Ie = new Vector3(0, 0, 0); useFrame(ke => { De.setFromNormalAndCoplanarPoint(Re, Ie).applyMatrix4(Be.current.matrixWorld); const Oe = Be.current.material, Ue = Oe.uniforms.worldCamProjPosition, He = Oe.uniforms.worldPlanePosition; De.projectPoint(ke.camera.position, Ue.value), He.value.set(0, 0, 0).applyMatrix4(Be.current.matrixWorld) }); const Pe = { cellSize: me, sectionSize: ge, cellColor: K, sectionColor: pe, cellThickness: be, sectionThickness: Ae }, Ne = { fadeDistance: ve, fadeStrength: _e, fadeFrom: Ee, infiniteGrid: ye, followCamera: xe }; return reactExports.createElement("mesh", _extends$2({ ref: Be, frustumCulled: !1 }, Ce), reactExports.createElement("gridMaterial", _extends$2({ transparent: !0, "extensions-derivatives": !0, side: Se }, Pe, Ne)), reactExports.createElement("planeGeometry", { args: fe })) }), scriptRel = "modulepreload", assetsURL = function (fe, K) { return new URL(fe, K).href }, seen = {}, __vitePreload = function (K, pe, me) { let ge = Promise.resolve(); if (pe && pe.length > 0) { const ye = document.getElementsByTagName("link"), ve = document.querySelector("meta[property=csp-nonce]"), _e = ve?.nonce || ve?.getAttribute("nonce"); ge = Promise.allSettled(pe.map(Ee => { if (Ee = assetsURL(Ee, me), Ee in seen) return; seen[Ee] = !0; const be = Ee.endsWith(".css"), Ae = be ? '[rel="stylesheet"]' : ""; if (!!me) for (let we = ye.length - 1; we >= 0; we--) { const Be = ye[we]; if (Be.href === Ee && (!be || Be.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${Ee}"]${Ae}`)) return; const Ce = document.createElement("link"); if (Ce.rel = be ? "stylesheet" : scriptRel, be || (Ce.as = "script"), Ce.crossOrigin = "", Ce.href = Ee, _e && Ce.setAttribute("nonce", _e), document.head.appendChild(Ce), be) return new Promise((we, Be) => { Ce.addEventListener("load", we), Ce.addEventListener("error", () => Be(new Error(`Unable to preload CSS for ${Ee}`))) }) })) } function xe(ye) { const ve = new Event("vite:preloadError", { cancelable: !0 }); if (ve.payload = ye, window.dispatchEvent(ve), !ve.defaultPrevented) throw ye } return ge.then(ye => { for (const ve of ye || []) ve.status === "rejected" && xe(ve.reason); return K().catch(xe) }) }; var stats_min = { exports: {} }; (function (fe, K) { (function (pe, me) { fe.exports = me() })(commonjsGlobal, function () { var pe = function () { function me(Ce) { return ye.appendChild(Ce.dom), Ce } function ge(Ce) { for (var we = 0; we < ye.children.length; we++)ye.children[we].style.display = we === Ce ? "block" : "none"; xe = Ce } var xe = 0, ye = document.createElement("div"); ye.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", ye.addEventListener("click", function (Ce) { Ce.preventDefault(), ge(++xe % ye.children.length) }, !1); var ve = (performance || Date).now(), _e = ve, Ee = 0, be = me(new pe.Panel("FPS", "#0ff", "#002")), Ae = me(new pe.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var Se = me(new pe.Panel("MB", "#f08", "#201")); return ge(0), { REVISION: 16, dom: ye, addPanel: me, showPanel: ge, begin: function () { ve = (performance || Date).now() }, end: function () { Ee++; var Ce = (performance || Date).now(); if (Ae.update(Ce - ve, 200), Ce > _e + 1e3 && (be.update(1e3 * Ee / (Ce - _e), 100), _e = Ce, Ee = 0, Se)) { var we = performance.memory; Se.update(we.usedJSHeapSize / 1048576, we.jsHeapSizeLimit / 1048576) } return Ce }, update: function () { ve = this.end() }, domElement: ye, setMode: ge } }; return pe.Panel = function (me, ge, xe) { var ye = 1 / 0, ve = 0, _e = Math.round, Ee = _e(window.devicePixelRatio || 1), be = 80 * Ee, Ae = 48 * Ee, Se = 3 * Ee, Ce = 2 * Ee, we = 3 * Ee, Be = 15 * Ee, De = 74 * Ee, Re = 30 * Ee, Ie = document.createElement("canvas"); Ie.width = be, Ie.height = Ae, Ie.style.cssText = "width:80px;height:48px"; var Pe = Ie.getContext("2d"); return Pe.font = "bold " + 9 * Ee + "px Helvetica,Arial,sans-serif", Pe.textBaseline = "top", Pe.fillStyle = xe, Pe.fillRect(0, 0, be, Ae), Pe.fillStyle = ge, Pe.fillText(me, Se, Ce), Pe.fillRect(we, Be, De, Re), Pe.fillStyle = xe, Pe.globalAlpha = .9, Pe.fillRect(we, Be, De, Re), { dom: Ie, update: function (Ne, ke) { ye = Math.min(ye, Ne), ve = Math.max(ve, Ne), Pe.fillStyle = xe, Pe.globalAlpha = 1, Pe.fillRect(0, 0, be, Be), Pe.fillStyle = ge, Pe.fillText(_e(Ne) + " " + me + " (" + _e(ye) + "-" + _e(ve) + ")", Se, Ce), Pe.drawImage(Ie, we + Ee, Be, De - Ee, Re, we, Be, De - Ee, Re), Pe.fillRect(we + De - Ee, Be, Ee, Re), Pe.fillStyle = xe, Pe.globalAlpha = .9, Pe.fillRect(we + De - Ee, Be, Ee, _e((1 - Ne / ke) * Re)) } } }, pe }) })(stats_min); var stats_minExports = stats_min.exports; const StatsImpl = getDefaultExportFromCjs(stats_minExports); function call(fe, K) { } function useEffectfulState(fe, K = [], pe) { const [me, ge] = reactExports.useState(); return reactExports.useLayoutEffect(() => { const xe = fe(); return ge(xe), () => void 0 }, K), me } function Stats({ showPanel: fe = 0, className: K, parent: pe }) { const me = useEffectfulState(() => new StatsImpl, []); return reactExports.useEffect(() => { if (me) { const ge = pe && pe.current || document.body; me.showPanel(fe), ge?.appendChild(me.dom); const xe = (K ?? "").split(" ").filter(_e => _e); xe.length && me.dom.classList.add(...xe); const ye = addEffect(() => me.begin()), ve = addAfterEffect(() => me.end()); return () => { xe.length && me.dom.classList.remove(...xe), ge?.removeChild(me.dom), ye(), ve() } } }, [pe, me, K, fe]), null } const CENTER = 0, AVERAGE = 1, SAH = 2, CONTAINED = 2, TRIANGLE_INTERSECT_COST = 1.25, TRAVERSAL_COST = 1, BYTES_PER_NODE = 6 * 4 + 4 + 4, IS_LEAFNODE_FLAG = 65535, FLOAT32_EPSILON = Math.pow(2, -24), SKIP_GENERATION = Symbol("SKIP_GENERATION"); function getVertexCount(fe) { return fe.index ? fe.index.count : fe.attributes.position.count } function getTriCount(fe) { return getVertexCount(fe) / 3 } function getIndexArray(fe, K = ArrayBuffer) { return fe > 65535 ? new Uint32Array(new K(4 * fe)) : new Uint16Array(new K(2 * fe)) } function ensureIndex(fe, K) { if (!fe.index) { const pe = fe.attributes.position.count, me = K.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, ge = getIndexArray(pe, me); fe.setIndex(new BufferAttribute(ge, 1)); for (let xe = 0; xe < pe; xe++)ge[xe] = xe } } function getFullGeometryRange(fe, K) { const pe = getTriCount(fe), me = K || fe.drawRange, ge = me.start / 3, xe = (me.start + me.count) / 3, ye = Math.max(0, ge), ve = Math.min(pe, xe) - ye; return [{ offset: Math.floor(ye), count: Math.floor(ve) }] } function getRootIndexRanges(fe, K) { if (!fe.groups || !fe.groups.length) return getFullGeometryRange(fe, K); const pe = [], me = new Set, ge = K || fe.drawRange, xe = ge.start / 3, ye = (ge.start + ge.count) / 3; for (const _e of fe.groups) { const Ee = _e.start / 3, be = (_e.start + _e.count) / 3; me.add(Math.max(xe, Ee)), me.add(Math.min(ye, be)) } const ve = Array.from(me.values()).sort((_e, Ee) => _e - Ee); for (let _e = 0; _e < ve.length - 1; _e++) { const Ee = ve[_e], be = ve[_e + 1]; pe.push({ offset: Math.floor(Ee), count: Math.floor(be - Ee) }) } return pe } function hasGroupGaps(fe, K) { const pe = getTriCount(fe), me = getRootIndexRanges(fe, K).sort((ye, ve) => ye.offset - ve.offset), ge = me[me.length - 1]; ge.count = Math.min(pe - ge.offset, ge.count); let xe = 0; return me.forEach(({ count: ye }) => xe += ye), pe !== xe } function getBounds(fe, K, pe, me, ge) { let xe = 1 / 0, ye = 1 / 0, ve = 1 / 0, _e = -1 / 0, Ee = -1 / 0, be = -1 / 0, Ae = 1 / 0, Se = 1 / 0, Ce = 1 / 0, we = -1 / 0, Be = -1 / 0, De = -1 / 0; for (let Re = K * 6, Ie = (K + pe) * 6; Re < Ie; Re += 6) { const Pe = fe[Re + 0], Ne = fe[Re + 1], ke = Pe - Ne, Oe = Pe + Ne; ke < xe && (xe = ke), Oe > _e && (_e = Oe), Pe < Ae && (Ae = Pe), Pe > we && (we = Pe); const Ue = fe[Re + 2], He = fe[Re + 3], Ge = Ue - He, ze = Ue + He; Ge < ye && (ye = Ge), ze > Ee && (Ee = ze), Ue < Se && (Se = Ue), Ue > Be && (Be = Ue); const We = fe[Re + 4], Xe = fe[Re + 5], Ye = We - Xe, Ze = We + Xe; Ye < ve && (ve = Ye), Ze > be && (be = Ze), We < Ce && (Ce = We), We > De && (De = We) } me[0] = xe, me[1] = ye, me[2] = ve, me[3] = _e, me[4] = Ee, me[5] = be, ge[0] = Ae, ge[1] = Se, ge[2] = Ce, ge[3] = we, ge[4] = Be, ge[5] = De } function computeTriangleBounds(fe, K = null, pe = null, me = null) { const ge = fe.attributes.position, xe = fe.index ? fe.index.array : null, ye = getTriCount(fe), ve = ge.normalized; let _e; K === null ? (_e = new Float32Array(ye * 6), pe = 0, me = ye) : (_e = K, pe = pe || 0, me = me || ye); const Ee = ge.array, be = ge.offset || 0; let Ae = 3; ge.isInterleavedBufferAttribute && (Ae = ge.data.stride); const Se = ["getX", "getY", "getZ"]; for (let Ce = pe; Ce < pe + me; Ce++) { const we = Ce * 3, Be = Ce * 6; let De = we + 0, Re = we + 1, Ie = we + 2; xe && (De = xe[De], Re = xe[Re], Ie = xe[Ie]), ve || (De = De * Ae + be, Re = Re * Ae + be, Ie = Ie * Ae + be); for (let Pe = 0; Pe < 3; Pe++) { let Ne, ke, Oe; ve ? (Ne = ge[Se[Pe]](De), ke = ge[Se[Pe]](Re), Oe = ge[Se[Pe]](Ie)) : (Ne = Ee[De + Pe], ke = Ee[Re + Pe], Oe = Ee[Ie + Pe]); let Ue = Ne; ke < Ue && (Ue = ke), Oe < Ue && (Ue = Oe); let He = Ne; ke > He && (He = ke), Oe > He && (He = Oe); const Ge = (He - Ue) / 2, ze = Pe * 2; _e[Be + ze + 0] = Ue + Ge, _e[Be + ze + 1] = Ge + (Math.abs(Ue) + Ge) * FLOAT32_EPSILON } } return _e } function arrayToBox(fe, K, pe) { return pe.min.x = K[fe], pe.min.y = K[fe + 1], pe.min.z = K[fe + 2], pe.max.x = K[fe + 3], pe.max.y = K[fe + 4], pe.max.z = K[fe + 5], pe } function getLongestEdgeIndex(fe) { let K = -1, pe = -1 / 0; for (let me = 0; me < 3; me++) { const ge = fe[me + 3] - fe[me]; ge > pe && (pe = ge, K = me) } return K } function copyBounds(fe, K) { K.set(fe) } function unionBounds(fe, K, pe) { let me, ge; for (let xe = 0; xe < 3; xe++) { const ye = xe + 3; me = fe[xe], ge = K[xe], pe[xe] = me < ge ? me : ge, me = fe[ye], ge = K[ye], pe[ye] = me > ge ? me : ge } } function expandByTriangleBounds(fe, K, pe) { for (let me = 0; me < 3; me++) { const ge = K[fe + 2 * me], xe = K[fe + 2 * me + 1], ye = ge - xe, ve = ge + xe; ye < pe[me] && (pe[me] = ye), ve > pe[me + 3] && (pe[me + 3] = ve) } } function computeSurfaceArea(fe) { const K = fe[3] - fe[0], pe = fe[4] - fe[1], me = fe[5] - fe[2]; return 2 * (K * pe + pe * me + me * K) } const BIN_COUNT = 32, binsSort = (fe, K) => fe.candidate - K.candidate, sahBins = new Array(BIN_COUNT).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), leftBounds = new Float32Array(6); function getOptimalSplit(fe, K, pe, me, ge, xe) { let ye = -1, ve = 0; if (xe === CENTER) ye = getLongestEdgeIndex(K), ye !== -1 && (ve = (K[ye] + K[ye + 3]) / 2); else if (xe === AVERAGE) ye = getLongestEdgeIndex(fe), ye !== -1 && (ve = getAverage(pe, me, ge, ye)); else if (xe === SAH) { const _e = computeSurfaceArea(fe); let Ee = TRIANGLE_INTERSECT_COST * ge; const be = me * 6, Ae = (me + ge) * 6; for (let Se = 0; Se < 3; Se++) { const Ce = K[Se], De = (K[Se + 3] - Ce) / BIN_COUNT; if (ge < BIN_COUNT / 4) { const Re = [...sahBins]; Re.length = ge; let Ie = 0; for (let Ne = be; Ne < Ae; Ne += 6, Ie++) { const ke = Re[Ie]; ke.candidate = pe[Ne + 2 * Se], ke.count = 0; const { bounds: Oe, leftCacheBounds: Ue, rightCacheBounds: He } = ke; for (let Ge = 0; Ge < 3; Ge++)He[Ge] = 1 / 0, He[Ge + 3] = -1 / 0, Ue[Ge] = 1 / 0, Ue[Ge + 3] = -1 / 0, Oe[Ge] = 1 / 0, Oe[Ge + 3] = -1 / 0; expandByTriangleBounds(Ne, pe, Oe) } Re.sort(binsSort); let Pe = ge; for (let Ne = 0; Ne < Pe; Ne++) { const ke = Re[Ne]; for (; Ne + 1 < Pe && Re[Ne + 1].candidate === ke.candidate;)Re.splice(Ne + 1, 1), Pe-- } for (let Ne = be; Ne < Ae; Ne += 6) { const ke = pe[Ne + 2 * Se]; for (let Oe = 0; Oe < Pe; Oe++) { const Ue = Re[Oe]; ke >= Ue.candidate ? expandByTriangleBounds(Ne, pe, Ue.rightCacheBounds) : (expandByTriangleBounds(Ne, pe, Ue.leftCacheBounds), Ue.count++) } } for (let Ne = 0; Ne < Pe; Ne++) { const ke = Re[Ne], Oe = ke.count, Ue = ge - ke.count, He = ke.leftCacheBounds, Ge = ke.rightCacheBounds; let ze = 0; Oe !== 0 && (ze = computeSurfaceArea(He) / _e); let We = 0; Ue !== 0 && (We = computeSurfaceArea(Ge) / _e); const Xe = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (ze * Oe + We * Ue); Xe < Ee && (ye = Se, Ee = Xe, ve = ke.candidate) } } else { for (let Pe = 0; Pe < BIN_COUNT; Pe++) { const Ne = sahBins[Pe]; Ne.count = 0, Ne.candidate = Ce + De + Pe * De; const ke = Ne.bounds; for (let Oe = 0; Oe < 3; Oe++)ke[Oe] = 1 / 0, ke[Oe + 3] = -1 / 0 } for (let Pe = be; Pe < Ae; Pe += 6) { let Oe = ~~((pe[Pe + 2 * Se] - Ce) / De); Oe >= BIN_COUNT && (Oe = BIN_COUNT - 1); const Ue = sahBins[Oe]; Ue.count++, expandByTriangleBounds(Pe, pe, Ue.bounds) } const Re = sahBins[BIN_COUNT - 1]; copyBounds(Re.bounds, Re.rightCacheBounds); for (let Pe = BIN_COUNT - 2; Pe >= 0; Pe--) { const Ne = sahBins[Pe], ke = sahBins[Pe + 1]; unionBounds(Ne.bounds, ke.rightCacheBounds, Ne.rightCacheBounds) } let Ie = 0; for (let Pe = 0; Pe < BIN_COUNT - 1; Pe++) { const Ne = sahBins[Pe], ke = Ne.count, Oe = Ne.bounds, He = sahBins[Pe + 1].rightCacheBounds; ke !== 0 && (Ie === 0 ? copyBounds(Oe, leftBounds) : unionBounds(Oe, leftBounds, leftBounds)), Ie += ke; let Ge = 0, ze = 0; Ie !== 0 && (Ge = computeSurfaceArea(leftBounds) / _e); const We = ge - Ie; We !== 0 && (ze = computeSurfaceArea(He) / _e); const Xe = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (Ge * Ie + ze * We); Xe < Ee && (ye = Se, Ee = Xe, ve = Ne.candidate) } } } } else console.warn(`MeshBVH: Invalid build strategy value ${xe} used.`); return { axis: ye, pos: ve } } function getAverage(fe, K, pe, me) { let ge = 0; for (let xe = K, ye = K + pe; xe < ye; xe++)ge += fe[xe * 6 + me * 2]; return ge / pe } class MeshBVHNode { constructor() { this.boundingData = new Float32Array(6) } } function partition(fe, K, pe, me, ge, xe) { let ye = me, ve = me + ge - 1; const _e = xe.pos, Ee = xe.axis * 2; for (; ;) { for (; ye <= ve && pe[ye * 6 + Ee] < _e;)ye++; for (; ye <= ve && pe[ve * 6 + Ee] >= _e;)ve--; if (ye < ve) { for (let be = 0; be < 3; be++) { let Ae = K[ye * 3 + be]; K[ye * 3 + be] = K[ve * 3 + be], K[ve * 3 + be] = Ae } for (let be = 0; be < 6; be++) { let Ae = pe[ye * 6 + be]; pe[ye * 6 + be] = pe[ve * 6 + be], pe[ve * 6 + be] = Ae } ye++, ve-- } else return ye } } function partition_indirect(fe, K, pe, me, ge, xe) { let ye = me, ve = me + ge - 1; const _e = xe.pos, Ee = xe.axis * 2; for (; ;) { for (; ye <= ve && pe[ye * 6 + Ee] < _e;)ye++; for (; ye <= ve && pe[ve * 6 + Ee] >= _e;)ve--; if (ye < ve) { let be = fe[ye]; fe[ye] = fe[ve], fe[ve] = be; for (let Ae = 0; Ae < 6; Ae++) { let Se = pe[ye * 6 + Ae]; pe[ye * 6 + Ae] = pe[ve * 6 + Ae], pe[ve * 6 + Ae] = Se } ye++, ve-- } else return ye } } function IS_LEAF(fe, K) { return K[fe + 15] === 65535 } function OFFSET(fe, K) { return K[fe + 6] } function COUNT(fe, K) { return K[fe + 14] } function LEFT_NODE(fe) { return fe + 8 } function RIGHT_NODE(fe, K) { return K[fe + 6] } function SPLIT_AXIS(fe, K) { return K[fe + 7] } function BOUNDING_DATA_INDEX(fe) { return fe } let float32Array, uint32Array, uint16Array, uint8Array; const MAX_POINTER = Math.pow(2, 32); function countNodes(fe) { return "count" in fe ? 1 : 1 + countNodes(fe.left) + countNodes(fe.right) } function populateBuffer(fe, K, pe) { return float32Array = new Float32Array(pe), uint32Array = new Uint32Array(pe), uint16Array = new Uint16Array(pe), uint8Array = new Uint8Array(pe), _populateBuffer(fe, K) } function _populateBuffer(fe, K) { const pe = fe / 4, me = fe / 2, ge = "count" in K, xe = K.boundingData; for (let ye = 0; ye < 6; ye++)float32Array[pe + ye] = xe[ye]; if (ge) if (K.buffer) { const ye = K.buffer; uint8Array.set(new Uint8Array(ye), fe); for (let ve = fe, _e = fe + ye.byteLength; ve < _e; ve += BYTES_PER_NODE) { const Ee = ve / 2; IS_LEAF(Ee, uint16Array) || (uint32Array[ve / 4 + 6] += pe) } return fe + ye.byteLength } else { const ye = K.offset, ve = K.count; return uint32Array[pe + 6] = ye, uint16Array[me + 14] = ve, uint16Array[me + 15] = IS_LEAFNODE_FLAG, fe + BYTES_PER_NODE } else { const ye = K.left, ve = K.right, _e = K.splitAxis; let Ee; if (Ee = _populateBuffer(fe + BYTES_PER_NODE, ye), Ee / 4 > MAX_POINTER) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits."); return uint32Array[pe + 6] = Ee / 4, Ee = _populateBuffer(Ee, ve), uint32Array[pe + 7] = _e, Ee } } function generateIndirectBuffer(fe, K) { const pe = (fe.index ? fe.index.count : fe.attributes.position.count) / 3, me = pe > 2 ** 16, ge = me ? 4 : 2, xe = K ? new SharedArrayBuffer(pe * ge) : new ArrayBuffer(pe * ge), ye = me ? new Uint32Array(xe) : new Uint16Array(xe); for (let ve = 0, _e = ye.length; ve < _e; ve++)ye[ve] = ve; return ye } function buildTree(fe, K, pe, me, ge) { const { maxDepth: xe, verbose: ye, maxLeafTris: ve, strategy: _e, onProgress: Ee, indirect: be } = ge, Ae = fe._indirectBuffer, Se = fe.geometry, Ce = Se.index ? Se.index.array : null, we = be ? partition_indirect : partition, Be = getTriCount(Se), De = new Float32Array(6); let Re = !1; const Ie = new MeshBVHNode; return getBounds(K, pe, me, Ie.boundingData, De), Ne(Ie, pe, me, De), Ie; function Pe(ke) { Ee && Ee(ke / Be) } function Ne(ke, Oe, Ue, He = null, Ge = 0) { if (!Re && Ge >= xe && (Re = !0, ye && (console.warn(`MeshBVH: Max depth of ${xe} reached when generating BVH. Consider increasing maxDepth.`), console.warn(Se))), Ue <= ve || Ge >= xe) return Pe(Oe + Ue), ke.offset = Oe, ke.count = Ue, ke; const ze = getOptimalSplit(ke.boundingData, He, K, Oe, Ue, _e); if (ze.axis === -1) return Pe(Oe + Ue), ke.offset = Oe, ke.count = Ue, ke; const We = we(Ae, Ce, K, Oe, Ue, ze); if (We === Oe || We === Oe + Ue) Pe(Oe + Ue), ke.offset = Oe, ke.count = Ue; else { ke.splitAxis = ze.axis; const Xe = new MeshBVHNode, Ye = Oe, Ze = We - Oe; ke.left = Xe, getBounds(K, Ye, Ze, Xe.boundingData, De), Ne(Xe, Ye, Ze, De, Ge + 1); const ot = new MeshBVHNode, qe = We, Qe = Ue - Ze; ke.right = ot, getBounds(K, qe, Qe, ot.boundingData, De), Ne(ot, qe, Qe, De, Ge + 1) } return ke } } function buildPackedTree(fe, K) { const pe = fe.geometry; K.indirect && (fe._indirectBuffer = generateIndirectBuffer(pe, K.useSharedArrayBuffer), hasGroupGaps(pe, K.range) && !K.verbose && console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), fe._indirectBuffer || ensureIndex(pe, K); const me = K.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, ge = computeTriangleBounds(pe), xe = K.indirect ? getFullGeometryRange(pe, K.range) : getRootIndexRanges(pe, K.range); fe._roots = xe.map(ye => { const ve = buildTree(fe, ge, ye.offset, ye.count, K), _e = countNodes(ve), Ee = new me(BYTES_PER_NODE * _e); return populateBuffer(0, ve, Ee), Ee }) } class SeparatingAxisBounds { constructor() { this.min = 1 / 0, this.max = -1 / 0 } setFromPointsField(K, pe) { let me = 1 / 0, ge = -1 / 0; for (let xe = 0, ye = K.length; xe < ye; xe++) { const _e = K[xe][pe]; me = _e < me ? _e : me, ge = _e > ge ? _e : ge } this.min = me, this.max = ge } setFromPoints(K, pe) { let me = 1 / 0, ge = -1 / 0; for (let xe = 0, ye = pe.length; xe < ye; xe++) { const ve = pe[xe], _e = K.dot(ve); me = _e < me ? _e : me, ge = _e > ge ? _e : ge } this.min = me, this.max = ge } isSeparated(K) { return this.min > K.max || K.min > this.max } } SeparatingAxisBounds.prototype.setFromBox = function () { const fe = new Vector3; return function (pe, me) { const ge = me.min, xe = me.max; let ye = 1 / 0, ve = -1 / 0; for (let _e = 0; _e <= 1; _e++)for (let Ee = 0; Ee <= 1; Ee++)for (let be = 0; be <= 1; be++) { fe.x = ge.x * _e + xe.x * (1 - _e), fe.y = ge.y * Ee + xe.y * (1 - Ee), fe.z = ge.z * be + xe.z * (1 - be); const Ae = pe.dot(fe); ye = Math.min(Ae, ye), ve = Math.max(Ae, ve) } this.min = ye, this.max = ve } }(); const closestPointLineToLine = function () { const fe = new Vector3, K = new Vector3, pe = new Vector3; return function (ge, xe, ye) { const ve = ge.start, _e = fe, Ee = xe.start, be = K; pe.subVectors(ve, Ee), fe.subVectors(ge.end, ge.start), K.subVectors(xe.end, xe.start); const Ae = pe.dot(be), Se = be.dot(_e), Ce = be.dot(be), we = pe.dot(_e), De = _e.dot(_e) * Ce - Se * Se; let Re, Ie; De !== 0 ? Re = (Ae * Se - we * Ce) / De : Re = 0, Ie = (Ae + Re * Se) / Ce, ye.x = Re, ye.y = Ie } }(), closestPointsSegmentToSegment = function () { const fe = new Vector2, K = new Vector3, pe = new Vector3; return function (ge, xe, ye, ve) { closestPointLineToLine(ge, xe, fe); let _e = fe.x, Ee = fe.y; if (_e >= 0 && _e <= 1 && Ee >= 0 && Ee <= 1) { ge.at(_e, ye), xe.at(Ee, ve); return } else if (_e >= 0 && _e <= 1) { Ee < 0 ? xe.at(0, ve) : xe.at(1, ve), ge.closestPointToPoint(ve, !0, ye); return } else if (Ee >= 0 && Ee <= 1) { _e < 0 ? ge.at(0, ye) : ge.at(1, ye), xe.closestPointToPoint(ye, !0, ve); return } else { let be; _e < 0 ? be = ge.start : be = ge.end; let Ae; Ee < 0 ? Ae = xe.start : Ae = xe.end; const Se = K, Ce = pe; if (ge.closestPointToPoint(Ae, !0, K), xe.closestPointToPoint(be, !0, pe), Se.distanceToSquared(Ae) <= Ce.distanceToSquared(be)) { ye.copy(Se), ve.copy(Ae); return } else { ye.copy(be), ve.copy(Ce); return } } } }(), sphereIntersectTriangle = function () { const fe = new Vector3, K = new Vector3, pe = new Plane, me = new Line3; return function (xe, ye) { const { radius: ve, center: _e } = xe, { a: Ee, b: be, c: Ae } = ye; if (me.start = Ee, me.end = be, me.closestPointToPoint(_e, !0, fe).distanceTo(_e) <= ve || (me.start = Ee, me.end = Ae, me.closestPointToPoint(_e, !0, fe).distanceTo(_e) <= ve) || (me.start = be, me.end = Ae, me.closestPointToPoint(_e, !0, fe).distanceTo(_e) <= ve)) return !0; const Be = ye.getPlane(pe); if (Math.abs(Be.distanceToPoint(_e)) <= ve) { const Re = Be.projectPoint(_e, K); if (ye.containsPoint(Re)) return !0 } return !1 } }(), ZERO_EPSILON = 1e-15; function isNearZero(fe) { return Math.abs(fe) < ZERO_EPSILON } class ExtendedTriangle extends Triangle { constructor(...K) { super(...K), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new Vector3), this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds), this.points = [this.a, this.b, this.c], this.sphere = new Sphere, this.plane = new Plane, this.needsUpdate = !0 } intersectsSphere(K) { return sphereIntersectTriangle(K, this) } update() { const K = this.a, pe = this.b, me = this.c, ge = this.points, xe = this.satAxes, ye = this.satBounds, ve = xe[0], _e = ye[0]; this.getNormal(ve), _e.setFromPoints(ve, ge); const Ee = xe[1], be = ye[1]; Ee.subVectors(K, pe), be.setFromPoints(Ee, ge); const Ae = xe[2], Se = ye[2]; Ae.subVectors(pe, me), Se.setFromPoints(Ae, ge); const Ce = xe[3], we = ye[3]; Ce.subVectors(me, K), we.setFromPoints(Ce, ge), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(ve, K), this.needsUpdate = !1 } } ExtendedTriangle.prototype.closestPointToSegment = function () { const fe = new Vector3, K = new Vector3, pe = new Line3; return function (ge, xe = null, ye = null) { const { start: ve, end: _e } = ge, Ee = this.points; let be, Ae = 1 / 0; for (let Se = 0; Se < 3; Se++) { const Ce = (Se + 1) % 3; pe.start.copy(Ee[Se]), pe.end.copy(Ee[Ce]), closestPointsSegmentToSegment(pe, ge, fe, K), be = fe.distanceToSquared(K), be < Ae && (Ae = be, xe && xe.copy(fe), ye && ye.copy(K)) } return this.closestPointToPoint(ve, fe), be = ve.distanceToSquared(fe), be < Ae && (Ae = be, xe && xe.copy(fe), ye && ye.copy(ve)), this.closestPointToPoint(_e, fe), be = _e.distanceToSquared(fe), be < Ae && (Ae = be, xe && xe.copy(fe), ye && ye.copy(_e)), Math.sqrt(Ae) } }(); ExtendedTriangle.prototype.intersectsTriangle = function () { const fe = new ExtendedTriangle, K = new Array(3), pe = new Array(3), me = new SeparatingAxisBounds, ge = new SeparatingAxisBounds, xe = new Vector3, ye = new Vector3, ve = new Vector3, _e = new Vector3, Ee = new Vector3, be = new Line3, Ae = new Line3, Se = new Line3, Ce = new Vector3; function we(Be, De, Re) { const Ie = Be.points; let Pe = 0, Ne = -1; for (let ke = 0; ke < 3; ke++) { const { start: Oe, end: Ue } = be; Oe.copy(Ie[ke]), Ue.copy(Ie[(ke + 1) % 3]), be.delta(ye); const He = isNearZero(De.distanceToPoint(Oe)); if (isNearZero(De.normal.dot(ye)) && He) { Re.copy(be), Pe = 2; break } const Ge = De.intersectLine(be, Ce); if (!Ge && He && Ce.copy(Oe), (Ge || He) && !isNearZero(Ce.distanceTo(Ue))) { if (Pe <= 1) (Pe === 1 ? Re.start : Re.end).copy(Ce), He && (Ne = Pe); else if (Pe >= 2) { (Ne === 1 ? Re.start : Re.end).copy(Ce), Pe = 2; break } if (Pe++, Pe === 2 && Ne === -1) break } } return Pe } return function (De, Re = null, Ie = !1) { this.needsUpdate && this.update(), De.isExtendedTriangle ? De.needsUpdate && De.update() : (fe.copy(De), fe.update(), De = fe); const Pe = this.plane, Ne = De.plane; if (Math.abs(Pe.normal.dot(Ne.normal)) > 1 - 1e-10) { const ke = this.satBounds, Oe = this.satAxes; pe[0] = De.a, pe[1] = De.b, pe[2] = De.c; for (let Ge = 0; Ge < 4; Ge++) { const ze = ke[Ge], We = Oe[Ge]; if (me.setFromPoints(We, pe), ze.isSeparated(me)) return !1 } const Ue = De.satBounds, He = De.satAxes; K[0] = this.a, K[1] = this.b, K[2] = this.c; for (let Ge = 0; Ge < 4; Ge++) { const ze = Ue[Ge], We = He[Ge]; if (me.setFromPoints(We, K), ze.isSeparated(me)) return !1 } for (let Ge = 0; Ge < 4; Ge++) { const ze = Oe[Ge]; for (let We = 0; We < 4; We++) { const Xe = He[We]; if (xe.crossVectors(ze, Xe), me.setFromPoints(xe, K), ge.setFromPoints(xe, pe), me.isSeparated(ge)) return !1 } } return Re && (Ie || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), Re.start.set(0, 0, 0), Re.end.set(0, 0, 0)), !0 } else { const ke = we(this, Ne, Ae); if (ke === 1 && De.containsPoint(Ae.end)) return Re && (Re.start.copy(Ae.end), Re.end.copy(Ae.end)), !0; if (ke !== 2) return !1; const Oe = we(De, Pe, Se); if (Oe === 1 && this.containsPoint(Se.end)) return Re && (Re.start.copy(Se.end), Re.end.copy(Se.end)), !0; if (Oe !== 2) return !1; if (Ae.delta(ve), Se.delta(_e), ve.dot(_e) < 0) { let Ye = Se.start; Se.start = Se.end, Se.end = Ye } const Ue = Ae.start.dot(ve), He = Ae.end.dot(ve), Ge = Se.start.dot(ve), ze = Se.end.dot(ve), We = He < Ge, Xe = Ue < ze; return Ue !== ze && Ge !== He && We === Xe ? !1 : (Re && (Ee.subVectors(Ae.start, Se.start), Ee.dot(ve) > 0 ? Re.start.copy(Ae.start) : Re.start.copy(Se.start), Ee.subVectors(Ae.end, Se.end), Ee.dot(ve) < 0 ? Re.end.copy(Ae.end) : Re.end.copy(Se.end)), !0) } } }(); ExtendedTriangle.prototype.distanceToPoint = function () { const fe = new Vector3; return function (pe) { return this.closestPointToPoint(pe, fe), pe.distanceTo(fe) } }(); ExtendedTriangle.prototype.distanceToTriangle = function () { const fe = new Vector3, K = new Vector3, pe = ["a", "b", "c"], me = new Line3, ge = new Line3; return function (ye, ve = null, _e = null) { const Ee = ve || _e ? me : null; if (this.intersectsTriangle(ye, Ee)) return (ve || _e) && (ve && Ee.getCenter(ve), _e && Ee.getCenter(_e)), 0; let be = 1 / 0; for (let Ae = 0; Ae < 3; Ae++) { let Se; const Ce = pe[Ae], we = ye[Ce]; this.closestPointToPoint(we, fe), Se = we.distanceToSquared(fe), Se < be && (be = Se, ve && ve.copy(fe), _e && _e.copy(we)); const Be = this[Ce]; ye.closestPointToPoint(Be, fe), Se = Be.distanceToSquared(fe), Se < be && (be = Se, ve && ve.copy(Be), _e && _e.copy(fe)) } for (let Ae = 0; Ae < 3; Ae++) { const Se = pe[Ae], Ce = pe[(Ae + 1) % 3]; me.set(this[Se], this[Ce]); for (let we = 0; we < 3; we++) { const Be = pe[we], De = pe[(we + 1) % 3]; ge.set(ye[Be], ye[De]), closestPointsSegmentToSegment(me, ge, fe, K); const Re = fe.distanceToSquared(K); Re < be && (be = Re, ve && ve.copy(fe), _e && _e.copy(K)) } } return Math.sqrt(be) } }(); class OrientedBox { constructor(K, pe, me) { this.isOrientedBox = !0, this.min = new Vector3, this.max = new Vector3, this.matrix = new Matrix4, this.invMatrix = new Matrix4, this.points = new Array(8).fill().map(() => new Vector3), this.satAxes = new Array(3).fill().map(() => new Vector3), this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds), this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds), this.needsUpdate = !1, K && this.min.copy(K), pe && this.max.copy(pe), me && this.matrix.copy(me) } set(K, pe, me) { this.min.copy(K), this.max.copy(pe), this.matrix.copy(me), this.needsUpdate = !0 } copy(K) { this.min.copy(K.min), this.max.copy(K.max), this.matrix.copy(K.matrix), this.needsUpdate = !0 } } OrientedBox.prototype.update = function () { return function () { const K = this.matrix, pe = this.min, me = this.max, ge = this.points; for (let Ee = 0; Ee <= 1; Ee++)for (let be = 0; be <= 1; be++)for (let Ae = 0; Ae <= 1; Ae++) { const Se = 1 * Ee | 2 * be | 4 * Ae, Ce = ge[Se]; Ce.x = Ee ? me.x : pe.x, Ce.y = be ? me.y : pe.y, Ce.z = Ae ? me.z : pe.z, Ce.applyMatrix4(K) } const xe = this.satBounds, ye = this.satAxes, ve = ge[0]; for (let Ee = 0; Ee < 3; Ee++) { const be = ye[Ee], Ae = xe[Ee], Se = 1 << Ee, Ce = ge[Se]; be.subVectors(ve, Ce), Ae.setFromPoints(be, ge) } const _e = this.alignedSatBounds; _e[0].setFromPointsField(ge, "x"), _e[1].setFromPointsField(ge, "y"), _e[2].setFromPointsField(ge, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1 } }(); OrientedBox.prototype.intersectsBox = function () { const fe = new SeparatingAxisBounds; return function (pe) { this.needsUpdate && this.update(); const me = pe.min, ge = pe.max, xe = this.satBounds, ye = this.satAxes, ve = this.alignedSatBounds; if (fe.min = me.x, fe.max = ge.x, ve[0].isSeparated(fe) || (fe.min = me.y, fe.max = ge.y, ve[1].isSeparated(fe)) || (fe.min = me.z, fe.max = ge.z, ve[2].isSeparated(fe))) return !1; for (let _e = 0; _e < 3; _e++) { const Ee = ye[_e], be = xe[_e]; if (fe.setFromBox(Ee, pe), be.isSeparated(fe)) return !1 } return !0 } }(); OrientedBox.prototype.intersectsTriangle = function () { const fe = new ExtendedTriangle, K = new Array(3), pe = new SeparatingAxisBounds, me = new SeparatingAxisBounds, ge = new Vector3; return function (ye) { this.needsUpdate && this.update(), ye.isExtendedTriangle ? ye.needsUpdate && ye.update() : (fe.copy(ye), fe.update(), ye = fe); const ve = this.satBounds, _e = this.satAxes; K[0] = ye.a, K[1] = ye.b, K[2] = ye.c; for (let Se = 0; Se < 3; Se++) { const Ce = ve[Se], we = _e[Se]; if (pe.setFromPoints(we, K), Ce.isSeparated(pe)) return !1 } const Ee = ye.satBounds, be = ye.satAxes, Ae = this.points; for (let Se = 0; Se < 3; Se++) { const Ce = Ee[Se], we = be[Se]; if (pe.setFromPoints(we, Ae), Ce.isSeparated(pe)) return !1 } for (let Se = 0; Se < 3; Se++) { const Ce = _e[Se]; for (let we = 0; we < 4; we++) { const Be = be[we]; if (ge.crossVectors(Ce, Be), pe.setFromPoints(ge, K), me.setFromPoints(ge, Ae), pe.isSeparated(me)) return !1 } } return !0 } }(); OrientedBox.prototype.closestPointToPoint = function () { return function (K, pe) { return this.needsUpdate && this.update(), pe.copy(K).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), pe } }(); OrientedBox.prototype.distanceToPoint = function () { const fe = new Vector3; return function (pe) { return this.closestPointToPoint(pe, fe), pe.distanceTo(fe) } }(); OrientedBox.prototype.distanceToBox = function () { const fe = ["x", "y", "z"], K = new Array(12).fill().map(() => new Line3), pe = new Array(12).fill().map(() => new Line3), me = new Vector3, ge = new Vector3; return function (ye, ve = 0, _e = null, Ee = null) { if (this.needsUpdate && this.update(), this.intersectsBox(ye)) return (_e || Ee) && (ye.getCenter(ge), this.closestPointToPoint(ge, me), ye.closestPointToPoint(me, ge), _e && _e.copy(me), Ee && Ee.copy(ge)), 0; const be = ve * ve, Ae = ye.min, Se = ye.max, Ce = this.points; let we = 1 / 0; for (let De = 0; De < 8; De++) { const Re = Ce[De]; ge.copy(Re).clamp(Ae, Se); const Ie = Re.distanceToSquared(ge); if (Ie < we && (we = Ie, _e && _e.copy(Re), Ee && Ee.copy(ge), Ie < be)) return Math.sqrt(Ie) } let Be = 0; for (let De = 0; De < 3; De++)for (let Re = 0; Re <= 1; Re++)for (let Ie = 0; Ie <= 1; Ie++) { const Pe = (De + 1) % 3, Ne = (De + 2) % 3, ke = Re << Pe | Ie << Ne, Oe = 1 << De | Re << Pe | Ie << Ne, Ue = Ce[ke], He = Ce[Oe]; K[Be].set(Ue, He); const ze = fe[De], We = fe[Pe], Xe = fe[Ne], Ye = pe[Be], Ze = Ye.start, ot = Ye.end; Ze[ze] = Ae[ze], Ze[We] = Re ? Ae[We] : Se[We], Ze[Xe] = Ie ? Ae[Xe] : Se[We], ot[ze] = Se[ze], ot[We] = Re ? Ae[We] : Se[We], ot[Xe] = Ie ? Ae[Xe] : Se[We], Be++ } for (let De = 0; De <= 1; De++)for (let Re = 0; Re <= 1; Re++)for (let Ie = 0; Ie <= 1; Ie++) { ge.x = De ? Se.x : Ae.x, ge.y = Re ? Se.y : Ae.y, ge.z = Ie ? Se.z : Ae.z, this.closestPointToPoint(ge, me); const Pe = ge.distanceToSquared(me); if (Pe < we && (we = Pe, _e && _e.copy(me), Ee && Ee.copy(ge), Pe < be)) return Math.sqrt(Pe) } for (let De = 0; De < 12; De++) { const Re = K[De]; for (let Ie = 0; Ie < 12; Ie++) { const Pe = pe[Ie]; closestPointsSegmentToSegment(Re, Pe, me, ge); const Ne = me.distanceToSquared(ge); if (Ne < we && (we = Ne, _e && _e.copy(me), Ee && Ee.copy(ge), Ne < be)) return Math.sqrt(Ne) } } return Math.sqrt(we) } }(); class PrimitivePool { constructor(K) { this._getNewPrimitive = K, this._primitives = [] } getPrimitive() { const K = this._primitives; return K.length === 0 ? this._getNewPrimitive() : K.pop() } releasePrimitive(K) { this._primitives.push(K) } } class ExtendedTrianglePoolBase extends PrimitivePool { constructor() { super(() => new ExtendedTriangle) } } const ExtendedTrianglePool = new ExtendedTrianglePoolBase; class _BufferStack { constructor() { this.float32Array = null, this.uint16Array = null, this.uint32Array = null; const K = []; let pe = null; this.setBuffer = me => { pe && K.push(pe), pe = me, this.float32Array = new Float32Array(me), this.uint16Array = new Uint16Array(me), this.uint32Array = new Uint32Array(me) }, this.clearBuffer = () => { pe = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, K.length !== 0 && this.setBuffer(K.pop()) } } } const BufferStack = new _BufferStack; let _box1, _box2; const boxStack = [], boxPool = new PrimitivePool(() => new Box3); function shapecast(fe, K, pe, me, ge, xe) { _box1 = boxPool.getPrimitive(), _box2 = boxPool.getPrimitive(), boxStack.push(_box1, _box2), BufferStack.setBuffer(fe._roots[K]); const ye = shapecastTraverse(0, fe.geometry, pe, me, ge, xe); BufferStack.clearBuffer(), boxPool.releasePrimitive(_box1), boxPool.releasePrimitive(_box2), boxStack.pop(), boxStack.pop(); const ve = boxStack.length; return ve > 0 && (_box2 = boxStack[ve - 1], _box1 = boxStack[ve - 2]), ye } function shapecastTraverse(fe, K, pe, me, ge = null, xe = 0, ye = 0) { const { float32Array: ve, uint16Array: _e, uint32Array: Ee } = BufferStack; let be = fe * 2; if (IS_LEAF(be, _e)) { const Se = OFFSET(fe, Ee), Ce = COUNT(be, _e); return arrayToBox(fe, ve, _box1), me(Se, Ce, !1, ye, xe + fe, _box1) } else { let ze = function (Xe) { const { uint16Array: Ye, uint32Array: Ze } = BufferStack; let ot = Xe * 2; for (; !IS_LEAF(ot, Ye);)Xe = LEFT_NODE(Xe), ot = Xe * 2; return OFFSET(Xe, Ze) }, We = function (Xe) { const { uint16Array: Ye, uint32Array: Ze } = BufferStack; let ot = Xe * 2; for (; !IS_LEAF(ot, Ye);)Xe = RIGHT_NODE(Xe, Ze), ot = Xe * 2; return OFFSET(Xe, Ze) + COUNT(ot, Ye) }; const Se = LEFT_NODE(fe), Ce = RIGHT_NODE(fe, Ee); let we = Se, Be = Ce, De, Re, Ie, Pe; if (ge && (Ie = _box1, Pe = _box2, arrayToBox(we, ve, Ie), arrayToBox(Be, ve, Pe), De = ge(Ie), Re = ge(Pe), Re < De)) { we = Ce, Be = Se; const Xe = De; De = Re, Re = Xe, Ie = Pe } Ie || (Ie = _box1, arrayToBox(we, ve, Ie)); const Ne = IS_LEAF(we * 2, _e), ke = pe(Ie, Ne, De, ye + 1, xe + we); let Oe; if (ke === CONTAINED) { const Xe = ze(we), Ze = We(we) - Xe; Oe = me(Xe, Ze, !0, ye + 1, xe + we, Ie) } else Oe = ke && shapecastTraverse(we, K, pe, me, ge, xe, ye + 1); if (Oe) return !0; Pe = _box2, arrayToBox(Be, ve, Pe); const Ue = IS_LEAF(Be * 2, _e), He = pe(Pe, Ue, Re, ye + 1, xe + Be); let Ge; if (He === CONTAINED) { const Xe = ze(Be), Ze = We(Be) - Xe; Ge = me(Xe, Ze, !0, ye + 1, xe + Be, Pe) } else Ge = He && shapecastTraverse(Be, K, pe, me, ge, xe, ye + 1); return !!Ge } } const temp = new Vector3, temp1$2 = new Vector3; function closestPointToPoint(fe, K, pe = {}, me = 0, ge = 1 / 0) { const xe = me * me, ye = ge * ge; let ve = 1 / 0, _e = null; if (fe.shapecast({ boundsTraverseOrder: be => (temp.copy(K).clamp(be.min, be.max), temp.distanceToSquared(K)), intersectsBounds: (be, Ae, Se) => Se < ve && Se < ye, intersectsTriangle: (be, Ae) => { be.closestPointToPoint(K, temp); const Se = K.distanceToSquared(temp); return Se < ve && (temp1$2.copy(temp), ve = Se, _e = Ae), Se < xe } }), ve === 1 / 0) return null; const Ee = Math.sqrt(ve); return pe.point ? pe.point.copy(temp1$2) : pe.point = temp1$2.clone(), pe.distance = Ee, pe.faceIndex = _e, pe } const IS_GT_REVISION_169 = parseInt(REVISION) >= 169, _vA = new Vector3, _vB = new Vector3, _vC = new Vector3, _uvA = new Vector2, _uvB = new Vector2, _uvC = new Vector2, _normalA = new Vector3, _normalB = new Vector3, _normalC = new Vector3, _intersectionPoint = new Vector3; function checkIntersection(fe, K, pe, me, ge, xe, ye, ve) { let _e; if (xe === BackSide ? _e = fe.intersectTriangle(me, pe, K, !0, ge) : _e = fe.intersectTriangle(K, pe, me, xe !== DoubleSide, ge), _e === null) return null; const Ee = fe.origin.distanceTo(ge); return Ee < ye || Ee > ve ? null : { distance: Ee, point: ge.clone() } } function checkBufferGeometryIntersection(fe, K, pe, me, ge, xe, ye, ve, _e, Ee, be) { _vA.fromBufferAttribute(K, xe), _vB.fromBufferAttribute(K, ye), _vC.fromBufferAttribute(K, ve); const Ae = checkIntersection(fe, _vA, _vB, _vC, _intersectionPoint, _e, Ee, be); if (Ae) { const Se = new Vector3; Triangle.getBarycoord(_intersectionPoint, _vA, _vB, _vC, Se), me && (_uvA.fromBufferAttribute(me, xe), _uvB.fromBufferAttribute(me, ye), _uvC.fromBufferAttribute(me, ve), Ae.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)), ge && (_uvA.fromBufferAttribute(ge, xe), _uvB.fromBufferAttribute(ge, ye), _uvC.fromBufferAttribute(ge, ve), Ae.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)), pe && (_normalA.fromBufferAttribute(pe, xe), _normalB.fromBufferAttribute(pe, ye), _normalC.fromBufferAttribute(pe, ve), Ae.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3), Ae.normal.dot(fe.direction) > 0 && Ae.normal.multiplyScalar(-1)); const Ce = { a: xe, b: ye, c: ve, normal: new Vector3, materialIndex: 0 }; Triangle.getNormal(_vA, _vB, _vC, Ce.normal), Ae.face = Ce, Ae.faceIndex = xe, IS_GT_REVISION_169 && (Ae.barycoord = Se) } return Ae } function intersectTri(fe, K, pe, me, ge, xe, ye) { const ve = me * 3; let _e = ve + 0, Ee = ve + 1, be = ve + 2; const Ae = fe.index; fe.index && (_e = Ae.getX(_e), Ee = Ae.getX(Ee), be = Ae.getX(be)); const { position: Se, normal: Ce, uv: we, uv1: Be } = fe.attributes, De = checkBufferGeometryIntersection(pe, Se, Ce, we, Be, _e, Ee, be, K, xe, ye); return De ? (De.faceIndex = me, ge && ge.push(De), De) : null } function setTriangle(fe, K, pe, me) { const ge = fe.a, xe = fe.b, ye = fe.c; let ve = K, _e = K + 1, Ee = K + 2; pe && (ve = pe.getX(ve), _e = pe.getX(_e), Ee = pe.getX(Ee)), ge.x = me.getX(ve), ge.y = me.getY(ve), ge.z = me.getZ(ve), xe.x = me.getX(_e), xe.y = me.getY(_e), xe.z = me.getZ(_e), ye.x = me.getX(Ee), ye.y = me.getY(Ee), ye.z = me.getZ(Ee) } function intersectTris(fe, K, pe, me, ge, xe, ye, ve) { const { geometry: _e, _indirectBuffer: Ee } = fe; for (let be = me, Ae = me + ge; be < Ae; be++)intersectTri(_e, K, pe, be, xe, ye, ve) } function intersectClosestTri(fe, K, pe, me, ge, xe, ye) { const { geometry: ve, _indirectBuffer: _e } = fe; let Ee = 1 / 0, be = null; for (let Ae = me, Se = me + ge; Ae < Se; Ae++) { let Ce; Ce = intersectTri(ve, K, pe, Ae, null, xe, ye), Ce && Ce.distance < Ee && (be = Ce, Ee = Ce.distance) } return be } function iterateOverTriangles(fe, K, pe, me, ge, xe, ye) { const { geometry: ve } = pe, { index: _e } = ve, Ee = ve.attributes.position; for (let be = fe, Ae = K + fe; be < Ae; be++) { let Se; if (Se = be, setTriangle(ye, Se * 3, _e, Ee), ye.needsUpdate = !0, me(ye, Se, ge, xe)) return !0 } return !1 } function refit(fe, K = null) { K && Array.isArray(K) && (K = new Set(K)); const pe = fe.geometry, me = pe.index ? pe.index.array : null, ge = pe.attributes.position; let xe, ye, ve, _e, Ee = 0; const be = fe._roots; for (let Se = 0, Ce = be.length; Se < Ce; Se++)xe = be[Se], ye = new Uint32Array(xe), ve = new Uint16Array(xe), _e = new Float32Array(xe), Ae(0, Ee), Ee += xe.byteLength; function Ae(Se, Ce, we = !1) { const Be = Se * 2; if (ve[Be + 15] === IS_LEAFNODE_FLAG) { const Re = ye[Se + 6], Ie = ve[Be + 14]; let Pe = 1 / 0, Ne = 1 / 0, ke = 1 / 0, Oe = -1 / 0, Ue = -1 / 0, He = -1 / 0; for (let Ge = 3 * Re, ze = 3 * (Re + Ie); Ge < ze; Ge++) { let We = me[Ge]; const Xe = ge.getX(We), Ye = ge.getY(We), Ze = ge.getZ(We); Xe < Pe && (Pe = Xe), Xe > Oe && (Oe = Xe), Ye < Ne && (Ne = Ye), Ye > Ue && (Ue = Ye), Ze < ke && (ke = Ze), Ze > He && (He = Ze) } return _e[Se + 0] !== Pe || _e[Se + 1] !== Ne || _e[Se + 2] !== ke || _e[Se + 3] !== Oe || _e[Se + 4] !== Ue || _e[Se + 5] !== He ? (_e[Se + 0] = Pe, _e[Se + 1] = Ne, _e[Se + 2] = ke, _e[Se + 3] = Oe, _e[Se + 4] = Ue, _e[Se + 5] = He, !0) : !1 } else { const Re = Se + 8, Ie = ye[Se + 6], Pe = Re + Ce, Ne = Ie + Ce; let ke = we, Oe = !1, Ue = !1; K ? ke || (Oe = K.has(Pe), Ue = K.has(Ne), ke = !Oe && !Ue) : (Oe = !0, Ue = !0); const He = ke || Oe, Ge = ke || Ue; let ze = !1; He && (ze = Ae(Re, Ce, ke)); let We = !1; Ge && (We = Ae(Ie, Ce, ke)); const Xe = ze || We; if (Xe) for (let Ye = 0; Ye < 3; Ye++) { const Ze = Re + Ye, ot = Ie + Ye, qe = _e[Ze], Qe = _e[Ze + 3], st = _e[ot], Nt = _e[ot + 3]; _e[Se + Ye] = qe < st ? qe : st, _e[Se + Ye + 3] = Qe > Nt ? Qe : Nt } return Xe } } } function intersectRay(fe, K, pe, me, ge) { let xe, ye, ve, _e, Ee, be; const Ae = 1 / pe.direction.x, Se = 1 / pe.direction.y, Ce = 1 / pe.direction.z, we = pe.origin.x, Be = pe.origin.y, De = pe.origin.z; let Re = K[fe], Ie = K[fe + 3], Pe = K[fe + 1], Ne = K[fe + 3 + 1], ke = K[fe + 2], Oe = K[fe + 3 + 2]; return Ae >= 0 ? (xe = (Re - we) * Ae, ye = (Ie - we) * Ae) : (xe = (Ie - we) * Ae, ye = (Re - we) * Ae), Se >= 0 ? (ve = (Pe - Be) * Se, _e = (Ne - Be) * Se) : (ve = (Ne - Be) * Se, _e = (Pe - Be) * Se), xe > _e || ve > ye || ((ve > xe || isNaN(xe)) && (xe = ve), (_e < ye || isNaN(ye)) && (ye = _e), Ce >= 0 ? (Ee = (ke - De) * Ce, be = (Oe - De) * Ce) : (Ee = (Oe - De) * Ce, be = (ke - De) * Ce), xe > be || Ee > ye) ? !1 : ((Ee > xe || xe !== xe) && (xe = Ee), (be < ye || ye !== ye) && (ye = be), xe <= ge && ye >= me) } function intersectTris_indirect(fe, K, pe, me, ge, xe, ye, ve) { const { geometry: _e, _indirectBuffer: Ee } = fe; for (let be = me, Ae = me + ge; be < Ae; be++) { let Se = Ee ? Ee[be] : be; intersectTri(_e, K, pe, Se, xe, ye, ve) } } function intersectClosestTri_indirect(fe, K, pe, me, ge, xe, ye) { const { geometry: ve, _indirectBuffer: _e } = fe; let Ee = 1 / 0, be = null; for (let Ae = me, Se = me + ge; Ae < Se; Ae++) { let Ce; Ce = intersectTri(ve, K, pe, _e ? _e[Ae] : Ae, null, xe, ye), Ce && Ce.distance < Ee && (be = Ce, Ee = Ce.distance) } return be } function iterateOverTriangles_indirect(fe, K, pe, me, ge, xe, ye) { const { geometry: ve } = pe, { index: _e } = ve, Ee = ve.attributes.position; for (let be = fe, Ae = K + fe; be < Ae; be++) { let Se; if (Se = pe.resolveTriangleIndex(be), setTriangle(ye, Se * 3, _e, Ee), ye.needsUpdate = !0, me(ye, Se, ge, xe)) return !0 } return !1 } function raycast(fe, K, pe, me, ge, xe, ye) { BufferStack.setBuffer(fe._roots[K]), _raycast$1(0, fe, pe, me, ge, xe, ye), BufferStack.clearBuffer() } function _raycast$1(fe, K, pe, me, ge, xe, ye) { const { float32Array: ve, uint16Array: _e, uint32Array: Ee } = BufferStack, be = fe * 2; if (IS_LEAF(be, _e)) { const Se = OFFSET(fe, Ee), Ce = COUNT(be, _e); intersectTris(K, pe, me, Se, Ce, ge, xe, ye) } else { const Se = LEFT_NODE(fe); intersectRay(Se, ve, me, xe, ye) && _raycast$1(Se, K, pe, me, ge, xe, ye); const Ce = RIGHT_NODE(fe, Ee); intersectRay(Ce, ve, me, xe, ye) && _raycast$1(Ce, K, pe, me, ge, xe, ye) } } const _xyzFields$1 = ["x", "y", "z"]; function raycastFirst(fe, K, pe, me, ge, xe) { BufferStack.setBuffer(fe._roots[K]); const ye = _raycastFirst$1(0, fe, pe, me, ge, xe); return BufferStack.clearBuffer(), ye } function _raycastFirst$1(fe, K, pe, me, ge, xe) { const { float32Array: ye, uint16Array: ve, uint32Array: _e } = BufferStack; let Ee = fe * 2; if (IS_LEAF(Ee, ve)) { const Ae = OFFSET(fe, _e), Se = COUNT(Ee, ve); return intersectClosestTri(K, pe, me, Ae, Se, ge, xe) } else { const Ae = SPLIT_AXIS(fe, _e), Se = _xyzFields$1[Ae], we = me.direction[Se] >= 0; let Be, De; we ? (Be = LEFT_NODE(fe), De = RIGHT_NODE(fe, _e)) : (Be = RIGHT_NODE(fe, _e), De = LEFT_NODE(fe)); const Ie = intersectRay(Be, ye, me, ge, xe) ? _raycastFirst$1(Be, K, pe, me, ge, xe) : null; if (Ie) { const ke = Ie.point[Se]; if (we ? ke <= ye[De + Ae] : ke >= ye[De + Ae + 3]) return Ie } const Ne = intersectRay(De, ye, me, ge, xe) ? _raycastFirst$1(De, K, pe, me, ge, xe) : null; return Ie && Ne ? Ie.distance <= Ne.distance ? Ie : Ne : Ie || Ne || null } } const boundingBox$1 = new Box3, triangle$1 = new ExtendedTriangle, triangle2$1 = new ExtendedTriangle, invertedMat$1 = new Matrix4, obb$4 = new OrientedBox, obb2$3 = new OrientedBox; function intersectsGeometry(fe, K, pe, me) { BufferStack.setBuffer(fe._roots[K]); const ge = _intersectsGeometry$1(0, fe, pe, me); return BufferStack.clearBuffer(), ge } function _intersectsGeometry$1(fe, K, pe, me, ge = null) { const { float32Array: xe, uint16Array: ye, uint32Array: ve } = BufferStack; let _e = fe * 2; if (ge === null && (pe.boundingBox || pe.computeBoundingBox(), obb$4.set(pe.boundingBox.min, pe.boundingBox.max, me), ge = obb$4), IS_LEAF(_e, ye)) { const be = K.geometry, Ae = be.index, Se = be.attributes.position, Ce = pe.index, we = pe.attributes.position, Be = OFFSET(fe, ve), De = COUNT(_e, ye); if (invertedMat$1.copy(me).invert(), pe.boundsTree) return arrayToBox(fe, xe, obb2$3), obb2$3.matrix.copy(invertedMat$1), obb2$3.needsUpdate = !0, pe.boundsTree.shapecast({ intersectsBounds: Ie => obb2$3.intersectsBox(Ie), intersectsTriangle: Ie => { Ie.a.applyMatrix4(me), Ie.b.applyMatrix4(me), Ie.c.applyMatrix4(me), Ie.needsUpdate = !0; for (let Pe = Be * 3, Ne = (De + Be) * 3; Pe < Ne; Pe += 3)if (setTriangle(triangle2$1, Pe, Ae, Se), triangle2$1.needsUpdate = !0, Ie.intersectsTriangle(triangle2$1)) return !0; return !1 } }); for (let Re = Be * 3, Ie = (De + Be) * 3; Re < Ie; Re += 3) { setTriangle(triangle$1, Re, Ae, Se), triangle$1.a.applyMatrix4(invertedMat$1), triangle$1.b.applyMatrix4(invertedMat$1), triangle$1.c.applyMatrix4(invertedMat$1), triangle$1.needsUpdate = !0; for (let Pe = 0, Ne = Ce.count; Pe < Ne; Pe += 3)if (setTriangle(triangle2$1, Pe, Ce, we), triangle2$1.needsUpdate = !0, triangle$1.intersectsTriangle(triangle2$1)) return !0 } } else { const be = fe + 8, Ae = ve[fe + 6]; return arrayToBox(be, xe, boundingBox$1), !!(ge.intersectsBox(boundingBox$1) && _intersectsGeometry$1(be, K, pe, me, ge) || (arrayToBox(Ae, xe, boundingBox$1), ge.intersectsBox(boundingBox$1) && _intersectsGeometry$1(Ae, K, pe, me, ge))) } } const tempMatrix$2 = new Matrix4, obb$3 = new OrientedBox, obb2$2 = new OrientedBox, temp1$1 = new Vector3, temp2$1 = new Vector3, temp3$1 = new Vector3, temp4$1 = new Vector3; function closestPointToGeometry(fe, K, pe, me = {}, ge = {}, xe = 0, ye = 1 / 0) { K.boundingBox || K.computeBoundingBox(), obb$3.set(K.boundingBox.min, K.boundingBox.max, pe), obb$3.needsUpdate = !0; const ve = fe.geometry, _e = ve.attributes.position, Ee = ve.index, be = K.attributes.position, Ae = K.index, Se = ExtendedTrianglePool.getPrimitive(), Ce = ExtendedTrianglePool.getPrimitive(); let we = temp1$1, Be = temp2$1, De = null, Re = null; ge && (De = temp3$1, Re = temp4$1); let Ie = 1 / 0, Pe = null, Ne = null; return tempMatrix$2.copy(pe).invert(), obb2$2.matrix.copy(tempMatrix$2), fe.shapecast({ boundsTraverseOrder: ke => obb$3.distanceToBox(ke), intersectsBounds: (ke, Oe, Ue) => Ue < Ie && Ue < ye ? (Oe && (obb2$2.min.copy(ke.min), obb2$2.max.copy(ke.max), obb2$2.needsUpdate = !0), !0) : !1, intersectsRange: (ke, Oe) => { if (K.boundsTree) return K.boundsTree.shapecast({ boundsTraverseOrder: He => obb2$2.distanceToBox(He), intersectsBounds: (He, Ge, ze) => ze < Ie && ze < ye, intersectsRange: (He, Ge) => { for (let ze = He, We = He + Ge; ze < We; ze++) { setTriangle(Ce, 3 * ze, Ae, be), Ce.a.applyMatrix4(pe), Ce.b.applyMatrix4(pe), Ce.c.applyMatrix4(pe), Ce.needsUpdate = !0; for (let Xe = ke, Ye = ke + Oe; Xe < Ye; Xe++) { setTriangle(Se, 3 * Xe, Ee, _e), Se.needsUpdate = !0; const Ze = Se.distanceToTriangle(Ce, we, De); if (Ze < Ie && (Be.copy(we), Re && Re.copy(De), Ie = Ze, Pe = Xe, Ne = ze), Ze < xe) return !0 } } } }); { const Ue = getTriCount(K); for (let He = 0, Ge = Ue; He < Ge; He++) { setTriangle(Ce, 3 * He, Ae, be), Ce.a.applyMatrix4(pe), Ce.b.applyMatrix4(pe), Ce.c.applyMatrix4(pe), Ce.needsUpdate = !0; for (let ze = ke, We = ke + Oe; ze < We; ze++) { setTriangle(Se, 3 * ze, Ee, _e), Se.needsUpdate = !0; const Xe = Se.distanceToTriangle(Ce, we, De); if (Xe < Ie && (Be.copy(we), Re && Re.copy(De), Ie = Xe, Pe = ze, Ne = He), Xe < xe) return !0 } } } } }), ExtendedTrianglePool.releasePrimitive(Se), ExtendedTrianglePool.releasePrimitive(Ce), Ie === 1 / 0 ? null : (me.point ? me.point.copy(Be) : me.point = Be.clone(), me.distance = Ie, me.faceIndex = Pe, ge && (ge.point ? ge.point.copy(Re) : ge.point = Re.clone(), ge.point.applyMatrix4(tempMatrix$2), Be.applyMatrix4(tempMatrix$2), ge.distance = Be.sub(ge.point).length(), ge.faceIndex = Ne), me) } function refit_indirect(fe, K = null) { K && Array.isArray(K) && (K = new Set(K)); const pe = fe.geometry, me = pe.index ? pe.index.array : null, ge = pe.attributes.position; let xe, ye, ve, _e, Ee = 0; const be = fe._roots; for (let Se = 0, Ce = be.length; Se < Ce; Se++)xe = be[Se], ye = new Uint32Array(xe), ve = new Uint16Array(xe), _e = new Float32Array(xe), Ae(0, Ee), Ee += xe.byteLength; function Ae(Se, Ce, we = !1) { const Be = Se * 2; if (ve[Be + 15] === IS_LEAFNODE_FLAG) { const Re = ye[Se + 6], Ie = ve[Be + 14]; let Pe = 1 / 0, Ne = 1 / 0, ke = 1 / 0, Oe = -1 / 0, Ue = -1 / 0, He = -1 / 0; for (let Ge = Re, ze = Re + Ie; Ge < ze; Ge++) { const We = 3 * fe.resolveTriangleIndex(Ge); for (let Xe = 0; Xe < 3; Xe++) { let Ye = We + Xe; Ye = me ? me[Ye] : Ye; const Ze = ge.getX(Ye), ot = ge.getY(Ye), qe = ge.getZ(Ye); Ze < Pe && (Pe = Ze), Ze > Oe && (Oe = Ze), ot < Ne && (Ne = ot), ot > Ue && (Ue = ot), qe < ke && (ke = qe), qe > He && (He = qe) } } return _e[Se + 0] !== Pe || _e[Se + 1] !== Ne || _e[Se + 2] !== ke || _e[Se + 3] !== Oe || _e[Se + 4] !== Ue || _e[Se + 5] !== He ? (_e[Se + 0] = Pe, _e[Se + 1] = Ne, _e[Se + 2] = ke, _e[Se + 3] = Oe, _e[Se + 4] = Ue, _e[Se + 5] = He, !0) : !1 } else { const Re = Se + 8, Ie = ye[Se + 6], Pe = Re + Ce, Ne = Ie + Ce; let ke = we, Oe = !1, Ue = !1; K ? ke || (Oe = K.has(Pe), Ue = K.has(Ne), ke = !Oe && !Ue) : (Oe = !0, Ue = !0); const He = ke || Oe, Ge = ke || Ue; let ze = !1; He && (ze = Ae(Re, Ce, ke)); let We = !1; Ge && (We = Ae(Ie, Ce, ke)); const Xe = ze || We; if (Xe) for (let Ye = 0; Ye < 3; Ye++) { const Ze = Re + Ye, ot = Ie + Ye, qe = _e[Ze], Qe = _e[Ze + 3], st = _e[ot], Nt = _e[ot + 3]; _e[Se + Ye] = qe < st ? qe : st, _e[Se + Ye + 3] = Qe > Nt ? Qe : Nt } return Xe } } } function raycast_indirect(fe, K, pe, me, ge, xe, ye) { BufferStack.setBuffer(fe._roots[K]), _raycast(0, fe, pe, me, ge, xe, ye), BufferStack.clearBuffer() } function _raycast(fe, K, pe, me, ge, xe, ye) { const { float32Array: ve, uint16Array: _e, uint32Array: Ee } = BufferStack, be = fe * 2; if (IS_LEAF(be, _e)) { const Se = OFFSET(fe, Ee), Ce = COUNT(be, _e); intersectTris_indirect(K, pe, me, Se, Ce, ge, xe, ye) } else { const Se = LEFT_NODE(fe); intersectRay(Se, ve, me, xe, ye) && _raycast(Se, K, pe, me, ge, xe, ye); const Ce = RIGHT_NODE(fe, Ee); intersectRay(Ce, ve, me, xe, ye) && _raycast(Ce, K, pe, me, ge, xe, ye) } } const _xyzFields = ["x", "y", "z"]; function raycastFirst_indirect(fe, K, pe, me, ge, xe) { BufferStack.setBuffer(fe._roots[K]); const ye = _raycastFirst(0, fe, pe, me, ge, xe); return BufferStack.clearBuffer(), ye } function _raycastFirst(fe, K, pe, me, ge, xe) { const { float32Array: ye, uint16Array: ve, uint32Array: _e } = BufferStack; let Ee = fe * 2; if (IS_LEAF(Ee, ve)) { const Ae = OFFSET(fe, _e), Se = COUNT(Ee, ve); return intersectClosestTri_indirect(K, pe, me, Ae, Se, ge, xe) } else { const Ae = SPLIT_AXIS(fe, _e), Se = _xyzFields[Ae], we = me.direction[Se] >= 0; let Be, De; we ? (Be = LEFT_NODE(fe), De = RIGHT_NODE(fe, _e)) : (Be = RIGHT_NODE(fe, _e), De = LEFT_NODE(fe)); const Ie = intersectRay(Be, ye, me, ge, xe) ? _raycastFirst(Be, K, pe, me, ge, xe) : null; if (Ie) { const ke = Ie.point[Se]; if (we ? ke <= ye[De + Ae] : ke >= ye[De + Ae + 3]) return Ie } const Ne = intersectRay(De, ye, me, ge, xe) ? _raycastFirst(De, K, pe, me, ge, xe) : null; return Ie && Ne ? Ie.distance <= Ne.distance ? Ie : Ne : Ie || Ne || null } } const boundingBox = new Box3, triangle = new ExtendedTriangle, triangle2 = new ExtendedTriangle, invertedMat = new Matrix4, obb$2 = new OrientedBox, obb2$1 = new OrientedBox; function intersectsGeometry_indirect(fe, K, pe, me) { BufferStack.setBuffer(fe._roots[K]); const ge = _intersectsGeometry(0, fe, pe, me); return BufferStack.clearBuffer(), ge } function _intersectsGeometry(fe, K, pe, me, ge = null) { const { float32Array: xe, uint16Array: ye, uint32Array: ve } = BufferStack; let _e = fe * 2; if (ge === null && (pe.boundingBox || pe.computeBoundingBox(), obb$2.set(pe.boundingBox.min, pe.boundingBox.max, me), ge = obb$2), IS_LEAF(_e, ye)) { const be = K.geometry, Ae = be.index, Se = be.attributes.position, Ce = pe.index, we = pe.attributes.position, Be = OFFSET(fe, ve), De = COUNT(_e, ye); if (invertedMat.copy(me).invert(), pe.boundsTree) return arrayToBox(fe, xe, obb2$1), obb2$1.matrix.copy(invertedMat), obb2$1.needsUpdate = !0, pe.boundsTree.shapecast({ intersectsBounds: Ie => obb2$1.intersectsBox(Ie), intersectsTriangle: Ie => { Ie.a.applyMatrix4(me), Ie.b.applyMatrix4(me), Ie.c.applyMatrix4(me), Ie.needsUpdate = !0; for (let Pe = Be, Ne = De + Be; Pe < Ne; Pe++)if (setTriangle(triangle2, 3 * K.resolveTriangleIndex(Pe), Ae, Se), triangle2.needsUpdate = !0, Ie.intersectsTriangle(triangle2)) return !0; return !1 } }); for (let Re = Be, Ie = De + Be; Re < Ie; Re++) { const Pe = K.resolveTriangleIndex(Re); setTriangle(triangle, 3 * Pe, Ae, Se), triangle.a.applyMatrix4(invertedMat), triangle.b.applyMatrix4(invertedMat), triangle.c.applyMatrix4(invertedMat), triangle.needsUpdate = !0; for (let Ne = 0, ke = Ce.count; Ne < ke; Ne += 3)if (setTriangle(triangle2, Ne, Ce, we), triangle2.needsUpdate = !0, triangle.intersectsTriangle(triangle2)) return !0 } } else { const be = fe + 8, Ae = ve[fe + 6]; return arrayToBox(be, xe, boundingBox), !!(ge.intersectsBox(boundingBox) && _intersectsGeometry(be, K, pe, me, ge) || (arrayToBox(Ae, xe, boundingBox), ge.intersectsBox(boundingBox) && _intersectsGeometry(Ae, K, pe, me, ge))) } } const tempMatrix$1 = new Matrix4, obb$1 = new OrientedBox, obb2 = new OrientedBox, temp1 = new Vector3, temp2 = new Vector3, temp3 = new Vector3, temp4 = new Vector3; function closestPointToGeometry_indirect(fe, K, pe, me = {}, ge = {}, xe = 0, ye = 1 / 0) { K.boundingBox || K.computeBoundingBox(), obb$1.set(K.boundingBox.min, K.boundingBox.max, pe), obb$1.needsUpdate = !0; const ve = fe.geometry, _e = ve.attributes.position, Ee = ve.index, be = K.attributes.position, Ae = K.index, Se = ExtendedTrianglePool.getPrimitive(), Ce = ExtendedTrianglePool.getPrimitive(); let we = temp1, Be = temp2, De = null, Re = null; ge && (De = temp3, Re = temp4); let Ie = 1 / 0, Pe = null, Ne = null; return tempMatrix$1.copy(pe).invert(), obb2.matrix.copy(tempMatrix$1), fe.shapecast({ boundsTraverseOrder: ke => obb$1.distanceToBox(ke), intersectsBounds: (ke, Oe, Ue) => Ue < Ie && Ue < ye ? (Oe && (obb2.min.copy(ke.min), obb2.max.copy(ke.max), obb2.needsUpdate = !0), !0) : !1, intersectsRange: (ke, Oe) => { if (K.boundsTree) { const Ue = K.boundsTree; return Ue.shapecast({ boundsTraverseOrder: He => obb2.distanceToBox(He), intersectsBounds: (He, Ge, ze) => ze < Ie && ze < ye, intersectsRange: (He, Ge) => { for (let ze = He, We = He + Ge; ze < We; ze++) { const Xe = Ue.resolveTriangleIndex(ze); setTriangle(Ce, 3 * Xe, Ae, be), Ce.a.applyMatrix4(pe), Ce.b.applyMatrix4(pe), Ce.c.applyMatrix4(pe), Ce.needsUpdate = !0; for (let Ye = ke, Ze = ke + Oe; Ye < Ze; Ye++) { const ot = fe.resolveTriangleIndex(Ye); setTriangle(Se, 3 * ot, Ee, _e), Se.needsUpdate = !0; const qe = Se.distanceToTriangle(Ce, we, De); if (qe < Ie && (Be.copy(we), Re && Re.copy(De), Ie = qe, Pe = Ye, Ne = ze), qe < xe) return !0 } } } }) } else { const Ue = getTriCount(K); for (let He = 0, Ge = Ue; He < Ge; He++) { setTriangle(Ce, 3 * He, Ae, be), Ce.a.applyMatrix4(pe), Ce.b.applyMatrix4(pe), Ce.c.applyMatrix4(pe), Ce.needsUpdate = !0; for (let ze = ke, We = ke + Oe; ze < We; ze++) { const Xe = fe.resolveTriangleIndex(ze); setTriangle(Se, 3 * Xe, Ee, _e), Se.needsUpdate = !0; const Ye = Se.distanceToTriangle(Ce, we, De); if (Ye < Ie && (Be.copy(we), Re && Re.copy(De), Ie = Ye, Pe = ze, Ne = He), Ye < xe) return !0 } } } } }), ExtendedTrianglePool.releasePrimitive(Se), ExtendedTrianglePool.releasePrimitive(Ce), Ie === 1 / 0 ? null : (me.point ? me.point.copy(Be) : me.point = Be.clone(), me.distance = Ie, me.faceIndex = Pe, ge && (ge.point ? ge.point.copy(Re) : ge.point = Re.clone(), ge.point.applyMatrix4(tempMatrix$1), Be.applyMatrix4(tempMatrix$1), ge.distance = Be.sub(ge.point).length(), ge.faceIndex = Ne), me) } function isSharedArrayBufferSupported() { return typeof SharedArrayBuffer < "u" } const _bufferStack1 = new BufferStack.constructor, _bufferStack2 = new BufferStack.constructor, _boxPool = new PrimitivePool(() => new Box3), _leftBox1 = new Box3, _rightBox1 = new Box3, _leftBox2 = new Box3, _rightBox2 = new Box3; let _active = !1; function bvhcast(fe, K, pe, me) { if (_active) throw new Error("MeshBVH: Recursive calls to bvhcast not supported."); _active = !0; const ge = fe._roots, xe = K._roots; let ye, ve = 0, _e = 0; const Ee = new Matrix4().copy(pe).invert(); for (let be = 0, Ae = ge.length; be < Ae; be++) { _bufferStack1.setBuffer(ge[be]), _e = 0; const Se = _boxPool.getPrimitive(); arrayToBox(0, _bufferStack1.float32Array, Se), Se.applyMatrix4(Ee); for (let Ce = 0, we = xe.length; Ce < we && (_bufferStack2.setBuffer(xe[Ce]), ye = _traverse(0, 0, pe, Ee, me, ve, _e, 0, 0, Se), _bufferStack2.clearBuffer(), _e += xe[Ce].length, !ye); Ce++); if (_boxPool.releasePrimitive(Se), _bufferStack1.clearBuffer(), ve += ge[be].length, ye) break } return _active = !1, ye } function _traverse(fe, K, pe, me, ge, xe = 0, ye = 0, ve = 0, _e = 0, Ee = null, be = !1) { let Ae, Se; be ? (Ae = _bufferStack2, Se = _bufferStack1) : (Ae = _bufferStack1, Se = _bufferStack2); const Ce = Ae.float32Array, we = Ae.uint32Array, Be = Ae.uint16Array, De = Se.float32Array, Re = Se.uint32Array, Ie = Se.uint16Array, Pe = fe * 2, Ne = K * 2, ke = IS_LEAF(Pe, Be), Oe = IS_LEAF(Ne, Ie); let Ue = !1; if (Oe && ke) be ? Ue = ge(OFFSET(K, Re), COUNT(K * 2, Ie), OFFSET(fe, we), COUNT(fe * 2, Be), _e, ye + K, ve, xe + fe) : Ue = ge(OFFSET(fe, we), COUNT(fe * 2, Be), OFFSET(K, Re), COUNT(K * 2, Ie), ve, xe + fe, _e, ye + K); else if (Oe) { const He = _boxPool.getPrimitive(); arrayToBox(K, De, He), He.applyMatrix4(pe); const Ge = LEFT_NODE(fe), ze = RIGHT_NODE(fe, we); arrayToBox(Ge, Ce, _leftBox1), arrayToBox(ze, Ce, _rightBox1); const We = He.intersectsBox(_leftBox1), Xe = He.intersectsBox(_rightBox1); Ue = We && _traverse(K, Ge, me, pe, ge, ye, xe, _e, ve + 1, He, !be) || Xe && _traverse(K, ze, me, pe, ge, ye, xe, _e, ve + 1, He, !be), _boxPool.releasePrimitive(He) } else { const He = LEFT_NODE(K), Ge = RIGHT_NODE(K, Re); arrayToBox(He, De, _leftBox2), arrayToBox(Ge, De, _rightBox2); const ze = Ee.intersectsBox(_leftBox2), We = Ee.intersectsBox(_rightBox2); if (ze && We) Ue = _traverse(fe, He, pe, me, ge, xe, ye, ve, _e + 1, Ee, be) || _traverse(fe, Ge, pe, me, ge, xe, ye, ve, _e + 1, Ee, be); else if (ze) if (ke) Ue = _traverse(fe, He, pe, me, ge, xe, ye, ve, _e + 1, Ee, be); else { const Xe = _boxPool.getPrimitive(); Xe.copy(_leftBox2).applyMatrix4(pe); const Ye = LEFT_NODE(fe), Ze = RIGHT_NODE(fe, we); arrayToBox(Ye, Ce, _leftBox1), arrayToBox(Ze, Ce, _rightBox1); const ot = Xe.intersectsBox(_leftBox1), qe = Xe.intersectsBox(_rightBox1); Ue = ot && _traverse(He, Ye, me, pe, ge, ye, xe, _e, ve + 1, Xe, !be) || qe && _traverse(He, Ze, me, pe, ge, ye, xe, _e, ve + 1, Xe, !be), _boxPool.releasePrimitive(Xe) } else if (We) if (ke) Ue = _traverse(fe, Ge, pe, me, ge, xe, ye, ve, _e + 1, Ee, be); else { const Xe = _boxPool.getPrimitive(); Xe.copy(_rightBox2).applyMatrix4(pe); const Ye = LEFT_NODE(fe), Ze = RIGHT_NODE(fe, we); arrayToBox(Ye, Ce, _leftBox1), arrayToBox(Ze, Ce, _rightBox1); const ot = Xe.intersectsBox(_leftBox1), qe = Xe.intersectsBox(_rightBox1); Ue = ot && _traverse(Ge, Ye, me, pe, ge, ye, xe, _e, ve + 1, Xe, !be) || qe && _traverse(Ge, Ze, me, pe, ge, ye, xe, _e, ve + 1, Xe, !be), _boxPool.releasePrimitive(Xe) } } return Ue } const obb = new OrientedBox, tempBox = new Box3, DEFAULT_OPTIONS = { strategy: CENTER, maxDepth: 40, maxLeafTris: 10, useSharedArrayBuffer: !1, setBoundingBox: !0, onProgress: null, indirect: !1, verbose: !0, range: null }; class MeshBVH { static serialize(K, pe = {}) { pe = { cloneBuffers: !0, ...pe }; const me = K.geometry, ge = K._roots, xe = K._indirectBuffer, ye = me.getIndex(); let ve; return pe.cloneBuffers ? ve = { roots: ge.map(_e => _e.slice()), index: ye ? ye.array.slice() : null, indirectBuffer: xe ? xe.slice() : null } : ve = { roots: ge, index: ye ? ye.array : null, indirectBuffer: xe }, ve } static deserialize(K, pe, me = {}) { me = { setIndex: !0, indirect: !!K.indirectBuffer, ...me }; const { index: ge, roots: xe, indirectBuffer: ye } = K, ve = new MeshBVH(pe, { ...me, [SKIP_GENERATION]: !0 }); if (ve._roots = xe, ve._indirectBuffer = ye || null, me.setIndex) { const _e = pe.getIndex(); if (_e === null) { const Ee = new BufferAttribute(K.index, 1, !1); pe.setIndex(Ee) } else _e.array !== ge && (_e.array.set(ge), _e.needsUpdate = !0) } return ve } get indirect() { return !!this._indirectBuffer } constructor(K, pe = {}) { if (K.isBufferGeometry) { if (K.index && K.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.") } else throw new Error("MeshBVH: Only BufferGeometries are supported."); if (pe = Object.assign({ ...DEFAULT_OPTIONS, [SKIP_GENERATION]: !1 }, pe), pe.useSharedArrayBuffer && !isSharedArrayBufferSupported()) throw new Error("MeshBVH: SharedArrayBuffer is not available."); this.geometry = K, this._roots = null, this._indirectBuffer = null, pe[SKIP_GENERATION] || (buildPackedTree(this, pe), !K.boundingBox && pe.setBoundingBox && (K.boundingBox = this.getBoundingBox(new Box3))), this.resolveTriangleIndex = pe.indirect ? me => this._indirectBuffer[me] : me => me } refit(K = null) { return (this.indirect ? refit_indirect : refit)(this, K) } traverse(K, pe = 0) { const me = this._roots[pe], ge = new Uint32Array(me), xe = new Uint16Array(me); ye(0); function ye(ve, _e = 0) { const Ee = ve * 2, be = xe[Ee + 15] === IS_LEAFNODE_FLAG; if (be) { const Ae = ge[ve + 6], Se = xe[Ee + 14]; K(_e, be, new Float32Array(me, ve * 4, 6), Ae, Se) } else { const Ae = ve + BYTES_PER_NODE / 4, Se = ge[ve + 6], Ce = ge[ve + 7]; K(_e, be, new Float32Array(me, ve * 4, 6), Ce) || (ye(Ae, _e + 1), ye(Se, _e + 1)) } } } raycast(K, pe = FrontSide, me = 0, ge = 1 / 0) { const xe = this._roots, ye = this.geometry, ve = [], _e = pe.isMaterial, Ee = Array.isArray(pe), be = ye.groups, Ae = _e ? pe.side : pe, Se = this.indirect ? raycast_indirect : raycast; for (let Ce = 0, we = xe.length; Ce < we; Ce++) { const Be = Ee ? pe[be[Ce].materialIndex].side : Ae, De = ve.length; if (Se(this, Ce, Be, K, ve, me, ge), Ee) { const Re = be[Ce].materialIndex; for (let Ie = De, Pe = ve.length; Ie < Pe; Ie++)ve[Ie].face.materialIndex = Re } } return ve } raycastFirst(K, pe = FrontSide, me = 0, ge = 1 / 0) { const xe = this._roots, ye = this.geometry, ve = pe.isMaterial, _e = Array.isArray(pe); let Ee = null; const be = ye.groups, Ae = ve ? pe.side : pe, Se = this.indirect ? raycastFirst_indirect : raycastFirst; for (let Ce = 0, we = xe.length; Ce < we; Ce++) { const Be = _e ? pe[be[Ce].materialIndex].side : Ae, De = Se(this, Ce, Be, K, me, ge); De != null && (Ee == null || De.distance < Ee.distance) && (Ee = De, _e && (De.face.materialIndex = be[Ce].materialIndex)) } return Ee } intersectsGeometry(K, pe) { let me = !1; const ge = this._roots, xe = this.indirect ? intersectsGeometry_indirect : intersectsGeometry; for (let ye = 0, ve = ge.length; ye < ve && (me = xe(this, ye, K, pe), !me); ye++); return me } shapecast(K) { const pe = ExtendedTrianglePool.getPrimitive(), me = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles; let { boundsTraverseOrder: ge, intersectsBounds: xe, intersectsRange: ye, intersectsTriangle: ve } = K; if (ye && ve) { const Ae = ye; ye = (Se, Ce, we, Be, De) => Ae(Se, Ce, we, Be, De) ? !0 : me(Se, Ce, this, ve, we, Be, pe) } else ye || (ve ? ye = (Ae, Se, Ce, we) => me(Ae, Se, this, ve, Ce, we, pe) : ye = (Ae, Se, Ce) => Ce); let _e = !1, Ee = 0; const be = this._roots; for (let Ae = 0, Se = be.length; Ae < Se; Ae++) { const Ce = be[Ae]; if (_e = shapecast(this, Ae, xe, ye, ge, Ee), _e) break; Ee += Ce.byteLength } return ExtendedTrianglePool.releasePrimitive(pe), _e } bvhcast(K, pe, me) { let { intersectsRanges: ge, intersectsTriangles: xe } = me; const ye = ExtendedTrianglePool.getPrimitive(), ve = this.geometry.index, _e = this.geometry.attributes.position, Ee = this.indirect ? we => { const Be = this.resolveTriangleIndex(we); setTriangle(ye, Be * 3, ve, _e) } : we => { setTriangle(ye, we * 3, ve, _e) }, be = ExtendedTrianglePool.getPrimitive(), Ae = K.geometry.index, Se = K.geometry.attributes.position, Ce = K.indirect ? we => { const Be = K.resolveTriangleIndex(we); setTriangle(be, Be * 3, Ae, Se) } : we => { setTriangle(be, we * 3, Ae, Se) }; if (xe) { const we = (Be, De, Re, Ie, Pe, Ne, ke, Oe) => { for (let Ue = Re, He = Re + Ie; Ue < He; Ue++) { Ce(Ue), be.a.applyMatrix4(pe), be.b.applyMatrix4(pe), be.c.applyMatrix4(pe), be.needsUpdate = !0; for (let Ge = Be, ze = Be + De; Ge < ze; Ge++)if (Ee(Ge), ye.needsUpdate = !0, xe(ye, be, Ge, Ue, Pe, Ne, ke, Oe)) return !0 } return !1 }; if (ge) { const Be = ge; ge = function (De, Re, Ie, Pe, Ne, ke, Oe, Ue) { return Be(De, Re, Ie, Pe, Ne, ke, Oe, Ue) ? !0 : we(De, Re, Ie, Pe, Ne, ke, Oe, Ue) } } else ge = we } return bvhcast(this, K, pe, ge) } intersectsBox(K, pe) { return obb.set(K.min, K.max, pe), obb.needsUpdate = !0, this.shapecast({ intersectsBounds: me => obb.intersectsBox(me), intersectsTriangle: me => obb.intersectsTriangle(me) }) } intersectsSphere(K) { return this.shapecast({ intersectsBounds: pe => K.intersectsBox(pe), intersectsTriangle: pe => pe.intersectsSphere(K) }) } closestPointToGeometry(K, pe, me = {}, ge = {}, xe = 0, ye = 1 / 0) { return (this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry)(this, K, pe, me, ge, xe, ye) } closestPointToPoint(K, pe = {}, me = 0, ge = 1 / 0) { return closestPointToPoint(this, K, pe, me, ge) } getBoundingBox(K) { return K.makeEmpty(), this._roots.forEach(me => { arrayToBox(0, new Float32Array(me), tempBox), K.union(tempBox) }), K } } function convertRaycastIntersect(fe, K, pe) { return fe === null ? null : (fe.point.applyMatrix4(K.matrixWorld), fe.distance = fe.point.distanceTo(pe.ray.origin), fe.object = K, fe) } const ray$2 = new Ray, direction = new Vector3, tmpInverseMatrix = new Matrix4, origMeshRaycastFunc = Mesh.prototype.raycast, origBatchedRaycastFunc = BatchedMesh$1.prototype.raycast, _worldScale = new Vector3, _mesh$1 = new Mesh, _batchIntersects = []; function acceleratedRaycast(fe, K) { this.isBatchedMesh ? acceleratedBatchedMeshRaycast.call(this, fe, K) : acceleratedMeshRaycast.call(this, fe, K) } function acceleratedBatchedMeshRaycast(fe, K) { if (this.boundsTrees) { const pe = this.boundsTrees, me = this._drawInfo || this._instanceInfo, ge = this._drawRanges || this._geometryInfo, xe = this.matrixWorld; _mesh$1.material = this.material, _mesh$1.geometry = this.geometry; const ye = _mesh$1.geometry.boundsTree, ve = _mesh$1.geometry.drawRange; _mesh$1.geometry.boundingSphere === null && (_mesh$1.geometry.boundingSphere = new Sphere); for (let _e = 0, Ee = me.length; _e < Ee; _e++) { if (!this.getVisibleAt(_e)) continue; const be = me[_e].geometryIndex; if (_mesh$1.geometry.boundsTree = pe[be], this.getMatrixAt(_e, _mesh$1.matrixWorld).premultiply(xe), !_mesh$1.geometry.boundsTree) { this.getBoundingBoxAt(be, _mesh$1.geometry.boundingBox), this.getBoundingSphereAt(be, _mesh$1.geometry.boundingSphere); const Ae = ge[be]; _mesh$1.geometry.setDrawRange(Ae.start, Ae.count) } _mesh$1.raycast(fe, _batchIntersects); for (let Ae = 0, Se = _batchIntersects.length; Ae < Se; Ae++) { const Ce = _batchIntersects[Ae]; Ce.object = this, Ce.batchId = _e, K.push(Ce) } _batchIntersects.length = 0 } _mesh$1.geometry.boundsTree = ye, _mesh$1.geometry.drawRange = ve, _mesh$1.material = null, _mesh$1.geometry = null } else origBatchedRaycastFunc.call(this, fe, K) } function acceleratedMeshRaycast(fe, K) { if (this.geometry.boundsTree) { if (this.material === void 0) return; tmpInverseMatrix.copy(this.matrixWorld).invert(), ray$2.copy(fe.ray).applyMatrix4(tmpInverseMatrix), _worldScale.setFromMatrixScale(this.matrixWorld), direction.copy(ray$2.direction).multiply(_worldScale); const pe = direction.length(), me = fe.near / pe, ge = fe.far / pe, xe = this.geometry.boundsTree; if (fe.firstHitOnly === !0) { const ye = convertRaycastIntersect(xe.raycastFirst(ray$2, this.material, me, ge), this, fe); ye && K.push(ye) } else { const ye = xe.raycast(ray$2, this.material, me, ge); for (let ve = 0, _e = ye.length; ve < _e; ve++) { const Ee = convertRaycastIntersect(ye[ve], this, fe); Ee && K.push(Ee) } } } else origMeshRaycastFunc.call(this, fe, K) } function computeBoundsTree(fe = {}) { return this.boundsTree = new MeshBVH(this, fe), this.boundsTree } function disposeBoundsTree() { this.boundsTree = null } const isMesh = fe => fe.isMesh, Bvh = reactExports.forwardRef(({ enabled: fe = !0, firstHitOnly: K = !1, children: pe, strategy: me = SAH, verbose: ge = !1, setBoundingBox: xe = !0, maxDepth: ye = 40, maxLeafTris: ve = 10, indirect: _e = !1, ...Ee }, be) => { const Ae = reactExports.useRef(null), Se = useThree(Ce => Ce.raycaster); return reactExports.useImperativeHandle(be, () => Ae.current, []), reactExports.useEffect(() => { if (fe) { const Ce = { strategy: me, verbose: ge, setBoundingBox: xe, maxDepth: ye, maxLeafTris: ve, indirect: _e }, we = Ae.current; return Se.firstHitOnly = K, we.traverse(Be => { isMesh(Be) && !Be.geometry.boundsTree && Be.raycast === Mesh.prototype.raycast && (Be.raycast = acceleratedRaycast, Be.geometry.computeBoundsTree = computeBoundsTree, Be.geometry.disposeBoundsTree = disposeBoundsTree, Be.geometry.computeBoundsTree(Ce)) }), () => { delete Se.firstHitOnly, we.traverse(Be => { isMesh(Be) && Be.geometry.boundsTree && (Be.geometry.disposeBoundsTree(), Be.raycast = Mesh.prototype.raycast) }) } } }, []), reactExports.createElement("group", _extends$2({ ref: Ae }, Ee), pe) }), setUpdateRange = (fe, K) => { fe.updateRanges[0] = K }; function isFunctionChild(fe) { return typeof fe == "function" } const _instanceLocalMatrix = new Matrix4, _instanceWorldMatrix = new Matrix4, _instanceIntersects = [], _mesh = new Mesh; class PositionMesh extends Group { constructor() { super(), this.color = new Color$1("white"), this.instance = { current: void 0 }, this.instanceKey = { current: void 0 } } get geometry() { var K; return (K = this.instance.current) == null ? void 0 : K.geometry } raycast(K, pe) { const me = this.instance.current; if (!me || !me.geometry || !me.material) return; _mesh.geometry = me.geometry; const ge = me.matrixWorld, xe = me.userData.instances.indexOf(this.instanceKey); if (!(xe === -1 || xe > me.count)) { me.getMatrixAt(xe, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(ge, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, me.material instanceof Material ? _mesh.material.side = me.material.side : _mesh.material.side = me.material[0].side, _mesh.raycast(K, _instanceIntersects); for (let ye = 0, ve = _instanceIntersects.length; ye < ve; ye++) { const _e = _instanceIntersects[ye]; _e.instanceId = xe, _e.object = this, pe.push(_e) } _instanceIntersects.length = 0 } } } const globalContext = reactExports.createContext(null), parentMatrix = new Matrix4, instanceMatrix = new Matrix4, tempMatrix = new Matrix4, translation = new Vector3, rotation = new Quaternion, scale = new Vector3, isInstancedBufferAttribute = fe => fe.isInstancedBufferAttribute, Instance = reactExports.forwardRef(({ context: fe, children: K, ...pe }, me) => { reactExports.useMemo(() => extend$3({ PositionMesh }), []); const ge = reactExports.useRef(null); reactExports.useImperativeHandle(me, () => ge.current, []); const { subscribe: xe, getParent: ye } = reactExports.useContext(fe || globalContext); return reactExports.useLayoutEffect(() => xe(ge), []), reactExports.createElement("positionMesh", _extends$2({ instance: ye(), instanceKey: ge, ref: ge }, pe), K) }), Instances = reactExports.forwardRef(({ context: fe, children: K, range: pe, limit: me = 1e3, frames: ge = 1 / 0, ...xe }, ye) => { const [{ localContext: ve, instance: _e }] = reactExports.useState(() => { const Ie = reactExports.createContext(null); return { localContext: Ie, instance: reactExports.forwardRef((Pe, Ne) => reactExports.createElement(Instance, _extends$2({ context: Ie }, Pe, { ref: Ne }))) } }), Ee = reactExports.useRef(null); reactExports.useImperativeHandle(ye, () => Ee.current, []); const [be, Ae] = reactExports.useState([]), [[Se, Ce]] = reactExports.useState(() => { const Ie = new Float32Array(me * 16); for (let Pe = 0; Pe < me; Pe++)tempMatrix.identity().toArray(Ie, Pe * 16); return [Ie, new Float32Array([...new Array(me * 3)].map(() => 1))] }); reactExports.useEffect(() => { Ee.current.instanceMatrix.needsUpdate = !0 }); let we = 0, Be = 0; const De = reactExports.useRef([]); reactExports.useLayoutEffect(() => { De.current = Object.entries(Ee.current.geometry.attributes).filter(([Ie, Pe]) => isInstancedBufferAttribute(Pe)) }), useFrame(() => { if (ge === 1 / 0 || we < ge) { Ee.current.updateMatrix(), Ee.current.updateMatrixWorld(), parentMatrix.copy(Ee.current.matrixWorld).invert(), Be = Math.min(me, pe !== void 0 ? pe : me, be.length), Ee.current.count = Be, setUpdateRange(Ee.current.instanceMatrix, { start: 0, count: Be * 16 }), setUpdateRange(Ee.current.instanceColor, { start: 0, count: Be * 3 }); for (let Ie = 0; Ie < be.length; Ie++) { const Pe = be[Ie].current; Pe.matrixWorld.decompose(translation, rotation, scale), instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix), instanceMatrix.toArray(Se, Ie * 16), Ee.current.instanceMatrix.needsUpdate = !0, Pe.color.toArray(Ce, Ie * 3), Ee.current.instanceColor.needsUpdate = !0 } we++ } }); const Re = reactExports.useMemo(() => ({ getParent: () => Ee, subscribe: Ie => (Ae(Pe => [...Pe, Ie]), () => Ae(Pe => Pe.filter(Ne => Ne.current !== Ie.current))) }), []); return reactExports.createElement("instancedMesh", _extends$2({ userData: { instances: be, limit: me, frames: ge }, matrixAutoUpdate: !1, ref: Ee, args: [null, null, 0], raycast: () => null }, xe), reactExports.createElement("instancedBufferAttribute", { attach: "instanceMatrix", args: [Se, 16], usage: DynamicDrawUsage }), reactExports.createElement("instancedBufferAttribute", { attach: "instanceColor", args: [Ce, 3], usage: DynamicDrawUsage }), isFunctionChild(K) ? reactExports.createElement(ve.Provider, { value: Re }, K(_e)) : fe ? reactExports.createElement(fe.Provider, { value: Re }, K) : reactExports.createElement(globalContext.Provider, { value: Re }, K)) }), getBufferForType = (fe, K, pe) => { let me; switch (fe) { case UnsignedByteType: me = new Uint8ClampedArray(K * pe * 4); break; case HalfFloatType: me = new Uint16Array(K * pe * 4); break; case UnsignedIntType: me = new Uint32Array(K * pe * 4); break; case ByteType: me = new Int8Array(K * pe * 4); break; case ShortType: me = new Int16Array(K * pe * 4); break; case IntType: me = new Int32Array(K * pe * 4); break; case FloatType: me = new Float32Array(K * pe * 4); break; default: throw new Error("Unsupported data type") }return me }; let _canReadPixelsResult; const canReadPixels = (fe, K, pe, me) => { if (_canReadPixelsResult !== void 0) return _canReadPixelsResult; const ge = new WebGLRenderTarget(1, 1, me); K.setRenderTarget(ge); const xe = new Mesh(new PlaneGeometry, new MeshBasicMaterial({ color: 16777215 })); K.render(xe, pe), K.setRenderTarget(null); const ye = getBufferForType(fe, ge.width, ge.height); return K.readRenderTargetPixels(ge, 0, 0, ge.width, ge.height, ye), ge.dispose(), xe.geometry.dispose(), xe.material.dispose(), _canReadPixelsResult = ye[0] !== 0, _canReadPixelsResult }; class QuadRenderer { constructor(K) { var pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De, Re; this._rendererIsDisposable = !1, this._supportsReadPixels = !0, this.render = () => { this._renderer.setRenderTarget(this._renderTarget); try { this._renderer.render(this._scene, this._camera) } catch (Pe) { throw this._renderer.setRenderTarget(null), Pe } this._renderer.setRenderTarget(null) }, this._width = K.width, this._height = K.height, this._type = K.type, this._colorSpace = K.colorSpace; const Ie = { format: RGBAFormat, depthBuffer: !1, stencilBuffer: !1, type: this._type, colorSpace: this._colorSpace, anisotropy: ((pe = K.renderTargetOptions) === null || pe === void 0 ? void 0 : pe.anisotropy) !== void 0 ? (me = K.renderTargetOptions) === null || me === void 0 ? void 0 : me.anisotropy : 1, generateMipmaps: ((ge = K.renderTargetOptions) === null || ge === void 0 ? void 0 : ge.generateMipmaps) !== void 0 ? (xe = K.renderTargetOptions) === null || xe === void 0 ? void 0 : xe.generateMipmaps : !1, magFilter: ((ye = K.renderTargetOptions) === null || ye === void 0 ? void 0 : ye.magFilter) !== void 0 ? (ve = K.renderTargetOptions) === null || ve === void 0 ? void 0 : ve.magFilter : LinearFilter, minFilter: ((_e = K.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.minFilter) !== void 0 ? (Ee = K.renderTargetOptions) === null || Ee === void 0 ? void 0 : Ee.minFilter : LinearFilter, samples: ((be = K.renderTargetOptions) === null || be === void 0 ? void 0 : be.samples) !== void 0 ? (Ae = K.renderTargetOptions) === null || Ae === void 0 ? void 0 : Ae.samples : void 0, wrapS: ((Se = K.renderTargetOptions) === null || Se === void 0 ? void 0 : Se.wrapS) !== void 0 ? (Ce = K.renderTargetOptions) === null || Ce === void 0 ? void 0 : Ce.wrapS : ClampToEdgeWrapping, wrapT: ((we = K.renderTargetOptions) === null || we === void 0 ? void 0 : we.wrapT) !== void 0 ? (Be = K.renderTargetOptions) === null || Be === void 0 ? void 0 : Be.wrapT : ClampToEdgeWrapping }; if (this._material = K.material, K.renderer ? this._renderer = K.renderer : (this._renderer = QuadRenderer.instantiateRenderer(), this._rendererIsDisposable = !0), this._scene = new Scene, this._camera = new OrthographicCamera, this._camera.position.set(0, 0, 10), this._camera.left = -.5, this._camera.right = .5, this._camera.top = .5, this._camera.bottom = -.5, this._camera.updateProjectionMatrix(), !canReadPixels(this._type, this._renderer, this._camera, Ie)) { let Pe; switch (this._type) { case HalfFloatType: Pe = this._renderer.extensions.has("EXT_color_buffer_float") ? FloatType : void 0; break }Pe !== void 0 ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`), this._type = Pe) : (this._supportsReadPixels = !1, console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown")) } this._quad = new Mesh(new PlaneGeometry, this._material), this._quad.geometry.computeBoundingBox(), this._scene.add(this._quad), this._renderTarget = new WebGLRenderTarget(this.width, this.height, Ie), this._renderTarget.texture.mapping = ((De = K.renderTargetOptions) === null || De === void 0 ? void 0 : De.mapping) !== void 0 ? (Re = K.renderTargetOptions) === null || Re === void 0 ? void 0 : Re.mapping : UVMapping } static instantiateRenderer() { const K = new WebGLRenderer; return K.setSize(128, 128), K } toArray() { if (!this._supportsReadPixels) throw new Error("Can't read pixels in this browser"); const K = getBufferForType(this._type, this._width, this._height); return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, K), K } toDataTexture(K) { const pe = new DataTexture(this.toArray(), this.width, this.height, RGBAFormat, this._type, K?.mapping || UVMapping, K?.wrapS || ClampToEdgeWrapping, K?.wrapT || ClampToEdgeWrapping, K?.magFilter || LinearFilter, K?.minFilter || LinearFilter, K?.anisotropy || 1, LinearSRGBColorSpace); return pe.generateMipmaps = K?.generateMipmaps !== void 0 ? K?.generateMipmaps : !1, pe } disposeOnDemandRenderer() { this._renderer.setRenderTarget(null), this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss()) } dispose(K) { this.disposeOnDemandRenderer(), K && this.renderTarget.dispose(), this.material instanceof ShaderMaterial && Object.values(this.material.uniforms).forEach(pe => { pe.value instanceof Texture && pe.value.dispose() }), Object.values(this.material).forEach(pe => { pe instanceof Texture && pe.dispose() }), this.material.dispose(), this._quad.geometry.dispose() } get width() { return this._width } set width(K) { this._width = K, this._renderTarget.setSize(this._width, this._height) } get height() { return this._height } set height(K) { this._height = K, this._renderTarget.setSize(this._width, this._height) } get renderer() { return this._renderer } get renderTarget() { return this._renderTarget } set renderTarget(K) { this._renderTarget = K, this._width = K.width, this._height = K.height } get material() { return this._material } get type() { return this._type } get colorSpace() { return this._colorSpace } } const vertexShader = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, fragmentShader = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`; class GainMapDecoderMaterial extends ShaderMaterial { constructor({ gamma: K, offsetHdr: pe, offsetSdr: me, gainMapMin: ge, gainMapMax: xe, maxDisplayBoost: ye, hdrCapacityMin: ve, hdrCapacityMax: _e, sdr: Ee, gainMap: be }) { super({ name: "GainMapDecoderMaterial", vertexShader, fragmentShader, uniforms: { sdr: { value: Ee }, gainMap: { value: be }, gamma: { value: new Vector3(1 / K[0], 1 / K[1], 1 / K[2]) }, offsetHdr: { value: new Vector3().fromArray(pe) }, offsetSdr: { value: new Vector3().fromArray(me) }, gainMapMin: { value: new Vector3().fromArray(ge) }, gainMapMax: { value: new Vector3().fromArray(xe) }, weightFactor: { value: (Math.log2(ye) - ve) / (_e - ve) } }, blending: NoBlending, depthTest: !1, depthWrite: !1 }), this._maxDisplayBoost = ye, this._hdrCapacityMin = ve, this._hdrCapacityMax = _e, this.needsUpdate = !0, this.uniformsNeedUpdate = !0 } get sdr() { return this.uniforms.sdr.value } set sdr(K) { this.uniforms.sdr.value = K } get gainMap() { return this.uniforms.gainMap.value } set gainMap(K) { this.uniforms.gainMap.value = K } get offsetHdr() { return this.uniforms.offsetHdr.value.toArray() } set offsetHdr(K) { this.uniforms.offsetHdr.value.fromArray(K) } get offsetSdr() { return this.uniforms.offsetSdr.value.toArray() } set offsetSdr(K) { this.uniforms.offsetSdr.value.fromArray(K) } get gainMapMin() { return this.uniforms.gainMapMin.value.toArray() } set gainMapMin(K) { this.uniforms.gainMapMin.value.fromArray(K) } get gainMapMax() { return this.uniforms.gainMapMax.value.toArray() } set gainMapMax(K) { this.uniforms.gainMapMax.value.fromArray(K) } get gamma() { const K = this.uniforms.gamma.value; return [1 / K.x, 1 / K.y, 1 / K.z] } set gamma(K) { const pe = this.uniforms.gamma.value; pe.x = 1 / K[0], pe.y = 1 / K[1], pe.z = 1 / K[2] } get hdrCapacityMin() { return this._hdrCapacityMin } set hdrCapacityMin(K) { this._hdrCapacityMin = K, this.calculateWeight() } get hdrCapacityMax() { return this._hdrCapacityMax } set hdrCapacityMax(K) { this._hdrCapacityMax = K, this.calculateWeight() } get maxDisplayBoost() { return this._maxDisplayBoost } set maxDisplayBoost(K) { this._maxDisplayBoost = Math.max(1, Math.min(65504, K)), this.calculateWeight() } calculateWeight() { const K = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin); this.uniforms.weightFactor.value = Math.max(0, Math.min(1, K)) } } class GainMapNotFoundError extends Error { } class XMPMetadataNotFoundError extends Error { } const getXMLValue = (fe, K, pe) => { const me = new RegExp(`${K}="([^"]*)"`, "i").exec(fe); if (me) return me[1]; const ge = new RegExp(`<${K}[^>]*>([\\s\\S]*?)</${K}>`, "i").exec(fe); if (ge) { const xe = ge[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g); return xe && xe.length === 3 ? xe.map(ye => ye.replace(/<\/?rdf:li>/g, "")) : ge[1].trim() } if (pe !== void 0) return pe; throw new Error(`Can't find ${K} in gainmap metadata`) }, extractXMP = fe => { let K; typeof TextDecoder < "u" ? K = new TextDecoder().decode(fe) : K = fe.toString(); let pe = K.indexOf("<x:xmpmeta"); for (; pe !== -1;) { const me = K.indexOf("x:xmpmeta>", pe), ge = K.slice(pe, me + 10); try { const xe = getXMLValue(ge, "hdrgm:GainMapMin", "0"), ye = getXMLValue(ge, "hdrgm:GainMapMax"), ve = getXMLValue(ge, "hdrgm:Gamma", "1"), _e = getXMLValue(ge, "hdrgm:OffsetSDR", "0.015625"), Ee = getXMLValue(ge, "hdrgm:OffsetHDR", "0.015625"), be = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(ge), Ae = be ? be[1] : "0", Se = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(ge); if (!Se) throw new Error("Incomplete gainmap metadata"); const Ce = Se[1]; return { gainMapMin: Array.isArray(xe) ? xe.map(we => parseFloat(we)) : [parseFloat(xe), parseFloat(xe), parseFloat(xe)], gainMapMax: Array.isArray(ye) ? ye.map(we => parseFloat(we)) : [parseFloat(ye), parseFloat(ye), parseFloat(ye)], gamma: Array.isArray(ve) ? ve.map(we => parseFloat(we)) : [parseFloat(ve), parseFloat(ve), parseFloat(ve)], offsetSdr: Array.isArray(_e) ? _e.map(we => parseFloat(we)) : [parseFloat(_e), parseFloat(_e), parseFloat(_e)], offsetHdr: Array.isArray(Ee) ? Ee.map(we => parseFloat(we)) : [parseFloat(Ee), parseFloat(Ee), parseFloat(Ee)], hdrCapacityMin: parseFloat(Ae), hdrCapacityMax: parseFloat(Ce) } } catch { } pe = K.indexOf("<x:xmpmeta", me) } }; class MPFExtractor { constructor(K) { this.options = { debug: K && K.debug !== void 0 ? K.debug : !1, extractFII: K && K.extractFII !== void 0 ? K.extractFII : !0, extractNonFII: K && K.extractNonFII !== void 0 ? K.extractNonFII : !0 } } extract(K) { return new Promise((pe, me) => { const ge = this.options.debug, xe = new DataView(K.buffer); if (xe.getUint16(0) !== 65496) { me(new Error("Not a valid jpeg")); return } const ye = xe.byteLength; let ve = 2, _e = 0, Ee; for (; ve < ye;) { if (++_e > 250) { me(new Error(`Found no marker after ${_e} loops `)); return } if (xe.getUint8(ve) !== 255) { me(new Error(`Not a valid marker at offset 0x${ve.toString(16)}, found: 0x${xe.getUint8(ve).toString(16)}`)); return } if (Ee = xe.getUint8(ve + 1), ge && console.log(`Marker: ${Ee.toString(16)}`), Ee === 226) { ge && console.log("Found APP2 marker (0xffe2)"); const be = ve + 4; if (xe.getUint32(be) === 1297106432) { const Ae = be + 4; let Se; if (xe.getUint16(Ae) === 18761) Se = !1; else if (xe.getUint16(Ae) === 19789) Se = !0; else { me(new Error("No valid endianness marker found in TIFF header")); return } if (xe.getUint16(Ae + 2, !Se) !== 42) { me(new Error("Not valid TIFF data! (no 0x002A marker)")); return } const Ce = xe.getUint32(Ae + 4, !Se); if (Ce < 8) { me(new Error("Not valid TIFF data! (First offset less than 8)")); return } const we = Ae + Ce, Be = xe.getUint16(we, !Se), De = we + 2; let Re = 0; for (let ke = De; ke < De + 12 * Be; ke += 12)xe.getUint16(ke, !Se) === 45057 && (Re = xe.getUint32(ke + 8, !Se)); const Pe = we + 2 + Be * 12 + 4, Ne = []; for (let ke = Pe; ke < Pe + Re * 16; ke += 16) { const Oe = { MPType: xe.getUint32(ke, !Se), size: xe.getUint32(ke + 4, !Se), dataOffset: xe.getUint32(ke + 8, !Se), dependantImages: xe.getUint32(ke + 12, !Se), start: -1, end: -1, isFII: !1 }; Oe.dataOffset ? (Oe.start = Ae + Oe.dataOffset, Oe.isFII = !1) : (Oe.start = 0, Oe.isFII = !0), Oe.end = Oe.start + Oe.size, Ne.push(Oe) } if (this.options.extractNonFII && Ne.length) { const ke = new Blob([xe]), Oe = []; for (const Ue of Ne) { if (Ue.isFII && !this.options.extractFII) continue; const He = ke.slice(Ue.start, Ue.end + 1, "image/jpeg"); Oe.push(He) } pe(Oe) } } } ve += 2 + xe.getUint16(ve + 2) } }) } } const extractGainmapFromJPEG = async fe => { const K = extractXMP(fe); if (!K) throw new XMPMetadataNotFoundError("Gain map XMP metadata not found"); const me = await new MPFExtractor({ extractFII: !0, extractNonFII: !0 }).extract(fe); if (me.length !== 2) throw new GainMapNotFoundError("Gain map recovery image not found"); return { sdr: new Uint8Array(await me[0].arrayBuffer()), gainMap: new Uint8Array(await me[1].arrayBuffer()), metadata: K } }, getHTMLImageFromBlob = fe => new Promise((K, pe) => { const me = document.createElement("img"); me.onload = () => { K(me) }, me.onerror = ge => { pe(ge) }, me.src = URL.createObjectURL(fe) }); class LoaderBase extends Loader { constructor(K, pe) { super(pe), K && (this._renderer = K), this._internalLoadingManager = new LoadingManager } setRenderer(K) { return this._renderer = K, this } setRenderTargetOptions(K) { return this._renderTargetOptions = K, this } prepareQuadRenderer() { this._renderer || console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer."); const K = new GainMapDecoderMaterial({ gainMapMax: [1, 1, 1], gainMapMin: [0, 0, 0], gamma: [1, 1, 1], offsetHdr: [1, 1, 1], offsetSdr: [1, 1, 1], hdrCapacityMax: 1, hdrCapacityMin: 0, maxDisplayBoost: 1, gainMap: new Texture, sdr: new Texture }); return new QuadRenderer({ width: 16, height: 16, type: HalfFloatType, colorSpace: LinearSRGBColorSpace, material: K, renderer: this._renderer, renderTargetOptions: this._renderTargetOptions }) } async render(K, pe, me, ge) { const xe = ge ? new Blob([ge], { type: "image/jpeg" }) : void 0, ye = new Blob([me], { type: "image/jpeg" }); let ve, _e, Ee = !1; if (typeof createImageBitmap > "u") { const Se = await Promise.all([xe ? getHTMLImageFromBlob(xe) : Promise.resolve(void 0), getHTMLImageFromBlob(ye)]); _e = Se[0], ve = Se[1], Ee = !0 } else { const Se = await Promise.all([xe ? createImageBitmap(xe, { imageOrientation: "flipY" }) : Promise.resolve(void 0), createImageBitmap(ye, { imageOrientation: "flipY" })]); _e = Se[0], ve = Se[1] } const be = new Texture(_e || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace); be.flipY = Ee, be.needsUpdate = !0; const Ae = new Texture(ve, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace); Ae.flipY = Ee, Ae.needsUpdate = !0, K.width = ve.width, K.height = ve.height, K.material.gainMap = be, K.material.sdr = Ae, K.material.gainMapMin = pe.gainMapMin, K.material.gainMapMax = pe.gainMapMax, K.material.offsetHdr = pe.offsetHdr, K.material.offsetSdr = pe.offsetSdr, K.material.gamma = pe.gamma, K.material.hdrCapacityMin = pe.hdrCapacityMin, K.material.hdrCapacityMax = pe.hdrCapacityMax, K.material.maxDisplayBoost = Math.pow(2, pe.hdrCapacityMax), K.material.needsUpdate = !0, K.render() } } class GainMapLoader extends LoaderBase { load([K, pe, me], ge, xe, ye) { const ve = this.prepareQuadRenderer(); let _e, Ee, be; const Ae = async () => { if (_e && Ee && be) { try { await this.render(ve, be, _e, Ee) } catch (Ge) { this.manager.itemError(K), this.manager.itemError(pe), this.manager.itemError(me), typeof ye == "function" && ye(Ge), ve.disposeOnDemandRenderer(); return } typeof ge == "function" && ge(ve), this.manager.itemEnd(K), this.manager.itemEnd(pe), this.manager.itemEnd(me), ve.disposeOnDemandRenderer() } }; let Se = !0, Ce = 0, we = 0, Be = !0, De = 0, Re = 0, Ie = !0, Pe = 0, Ne = 0; const ke = () => { if (typeof xe == "function") { const Ge = Ce + De + Pe, ze = we + Re + Ne, We = Se && Be && Ie; xe(new ProgressEvent("progress", { lengthComputable: We, loaded: ze, total: Ge })) } }; this.manager.itemStart(K), this.manager.itemStart(pe), this.manager.itemStart(me); const Oe = new FileLoader(this._internalLoadingManager); Oe.setResponseType("arraybuffer"), Oe.setRequestHeader(this.requestHeader), Oe.setPath(this.path), Oe.setWithCredentials(this.withCredentials), Oe.load(K, async Ge => { if (typeof Ge == "string") throw new Error("Invalid sdr buffer"); _e = Ge, await Ae() }, Ge => { Se = Ge.lengthComputable, we = Ge.loaded, Ce = Ge.total, ke() }, Ge => { this.manager.itemError(K), typeof ye == "function" && ye(Ge) }); const Ue = new FileLoader(this._internalLoadingManager); Ue.setResponseType("arraybuffer"), Ue.setRequestHeader(this.requestHeader), Ue.setPath(this.path), Ue.setWithCredentials(this.withCredentials), Ue.load(pe, async Ge => { if (typeof Ge == "string") throw new Error("Invalid gainmap buffer"); Ee = Ge, await Ae() }, Ge => { Be = Ge.lengthComputable, Re = Ge.loaded, De = Ge.total, ke() }, Ge => { this.manager.itemError(pe), typeof ye == "function" && ye(Ge) }); const He = new FileLoader(this._internalLoadingManager); return He.setRequestHeader(this.requestHeader), He.setPath(this.path), He.setWithCredentials(this.withCredentials), He.load(me, async Ge => { if (typeof Ge != "string") throw new Error("Invalid metadata string"); be = JSON.parse(Ge), await Ae() }, Ge => { Ie = Ge.lengthComputable, Ne = Ge.loaded, Pe = Ge.total, ke() }, Ge => { this.manager.itemError(me), typeof ye == "function" && ye(Ge) }), ve } } class HDRJPGLoader extends LoaderBase { load(K, pe, me, ge) { const xe = this.prepareQuadRenderer(), ye = new FileLoader(this._internalLoadingManager); return ye.setResponseType("arraybuffer"), ye.setRequestHeader(this.requestHeader), ye.setPath(this.path), ye.setWithCredentials(this.withCredentials), this.manager.itemStart(K), ye.load(K, async ve => { if (typeof ve == "string") throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]"); const _e = new Uint8Array(ve); let Ee, be, Ae; try { const Se = await extractGainmapFromJPEG(_e); Ee = Se.sdr, be = Se.gainMap, Ae = Se.metadata } catch (Se) { if (Se instanceof XMPMetadataNotFoundError || Se instanceof GainMapNotFoundError) console.warn(`Failure to reconstruct an HDR image from ${K}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`), Ae = { gainMapMin: [0, 0, 0], gainMapMax: [1, 1, 1], gamma: [1, 1, 1], hdrCapacityMin: 0, hdrCapacityMax: 1, offsetHdr: [0, 0, 0], offsetSdr: [0, 0, 0] }, Ee = _e; else throw Se } try { await this.render(xe, Ae, Ee, be) } catch (Se) { this.manager.itemError(K), typeof ge == "function" && ge(Se), xe.disposeOnDemandRenderer(); return } typeof pe == "function" && pe(xe), this.manager.itemEnd(K), xe.disposeOnDemandRenderer() }, me, ve => { this.manager.itemError(K), typeof ge == "function" && ge(ve) }), xe } } const presetsObj = { apartment: "lebombo_1k.hdr", city: "potsdamer_platz_1k.hdr", dawn: "kiara_1_dawn_1k.hdr", forest: "forest_slope_1k.hdr", lobby: "st_fagans_interior_1k.hdr", night: "dikhololo_night_1k.hdr", park: "rooitou_park_1k.hdr", studio: "studio_small_03_1k.hdr", sunset: "venice_sunset_1k.hdr", warehouse: "empty_warehouse_01_1k.hdr" }, CUBEMAP_ROOT = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/", isArray$1 = fe => Array.isArray(fe), defaultFiles = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"]; function useEnvironment({ files: fe = defaultFiles, path: K = "", preset: pe = void 0, colorSpace: me = void 0, extensions: ge } = {}) { pe && (validatePreset(pe), fe = presetsObj[pe], K = CUBEMAP_ROOT); const xe = isArray$1(fe), { extension: ye, isCubemap: ve } = getExtension(fe), _e = getLoader(ye); if (!_e) throw new Error("useEnvironment: Unrecognized file extension: " + fe); const Ee = useThree(Ce => Ce.gl); reactExports.useLayoutEffect(() => { if (ye !== "webp" && ye !== "jpg" && ye !== "jpeg") return; function Ce() { useLoader.clear(_e, xe ? [fe] : fe) } Ee.domElement.addEventListener("webglcontextlost", Ce, { once: !0 }) }, [fe, Ee.domElement]); const be = useLoader(_e, xe ? [fe] : fe, Ce => { (ye === "webp" || ye === "jpg" || ye === "jpeg") && Ce.setRenderer(Ee), Ce.setPath == null || Ce.setPath(K), ge && ge(Ce) }); let Ae = xe ? be[0] : be; if (ye === "jpg" || ye === "jpeg" || ye === "webp") { var Se; Ae = (Se = Ae.renderTarget) == null ? void 0 : Se.texture } return Ae.mapping = ve ? CubeReflectionMapping : EquirectangularReflectionMapping, Ae.colorSpace = me ?? (ve ? "srgb" : "srgb-linear"), Ae } const preloadDefaultOptions = { files: defaultFiles, path: "", preset: void 0, extensions: void 0 }; useEnvironment.preload = fe => { const K = { ...preloadDefaultOptions, ...fe }; let { files: pe, path: me = "" } = K; const { preset: ge, extensions: xe } = K; ge && (validatePreset(ge), pe = presetsObj[ge], me = CUBEMAP_ROOT); const { extension: ye } = getExtension(pe); if (ye === "webp" || ye === "jpg" || ye === "jpeg") throw new Error("useEnvironment: Preloading gainmaps is not supported"); const ve = getLoader(ye); if (!ve) throw new Error("useEnvironment: Unrecognized file extension: " + pe); useLoader.preload(ve, isArray$1(pe) ? [pe] : pe, _e => { _e.setPath == null || _e.setPath(me), xe && xe(_e) }) }; const clearDefaultOptins = { files: defaultFiles, preset: void 0 }; useEnvironment.clear = fe => { const K = { ...clearDefaultOptins, ...fe }; let { files: pe } = K; const { preset: me } = K; me && (validatePreset(me), pe = presetsObj[me]); const { extension: ge } = getExtension(pe), xe = getLoader(ge); if (!xe) throw new Error("useEnvironment: Unrecognized file extension: " + pe); useLoader.clear(xe, isArray$1(pe) ? [pe] : pe) }; function validatePreset(fe) { if (!(fe in presetsObj)) throw new Error("Preset must be one of: " + Object.keys(presetsObj).join(", ")) } function getExtension(fe) { var K; const pe = isArray$1(fe) && fe.length === 6, me = isArray$1(fe) && fe.length === 3 && fe.some(ye => ye.endsWith("json")), ge = isArray$1(fe) ? fe[0] : fe; return { extension: pe ? "cube" : me ? "webp" : ge.startsWith("data:application/exr") ? "exr" : ge.startsWith("data:application/hdr") ? "hdr" : ge.startsWith("data:image/jpeg") ? "jpg" : (K = ge.split(".").pop()) == null || (K = K.split("?")) == null || (K = K.shift()) == null ? void 0 : K.toLowerCase(), isCubemap: pe, isGainmap: me } } function getLoader(fe) { return fe === "cube" ? CubeTextureLoader : fe === "hdr" ? RGBELoader : fe === "exr" ? EXRLoader : fe === "jpg" || fe === "jpeg" ? HDRJPGLoader : fe === "webp" ? GainMapLoader : null } const isRef = fe => fe.current && fe.current.isScene, resolveScene = fe => isRef(fe) ? fe.current : fe; function setEnvProps(fe, K, pe, me, ge = {}) { var xe, ye, ve, _e; ge = { backgroundBlurriness: 0, backgroundIntensity: 1, backgroundRotation: [0, 0, 0], environmentIntensity: 1, environmentRotation: [0, 0, 0], ...ge }; const Ee = resolveScene(K || pe), be = Ee.background, Ae = Ee.environment, Se = { backgroundBlurriness: Ee.backgroundBlurriness, backgroundIntensity: Ee.backgroundIntensity, backgroundRotation: (xe = (ye = Ee.backgroundRotation) == null || ye.clone == null ? void 0 : ye.clone()) !== null && xe !== void 0 ? xe : [0, 0, 0], environmentIntensity: Ee.environmentIntensity, environmentRotation: (ve = (_e = Ee.environmentRotation) == null || _e.clone == null ? void 0 : _e.clone()) !== null && ve !== void 0 ? ve : [0, 0, 0] }; return fe !== "only" && (Ee.environment = me), fe && (Ee.background = me), applyProps(Ee, ge), () => { fe !== "only" && (Ee.environment = Ae), fe && (Ee.background = be), applyProps(Ee, Se) } } function EnvironmentMap({ scene: fe, background: K = !1, map: pe, ...me }) { const ge = useThree(xe => xe.scene); return reactExports.useLayoutEffect(() => { if (pe) return setEnvProps(K, fe, ge, pe, me) }), null } function EnvironmentCube({ background: fe = !1, scene: K, blur: pe, backgroundBlurriness: me, backgroundIntensity: ge, backgroundRotation: xe, environmentIntensity: ye, environmentRotation: ve, ..._e }) { const Ee = useEnvironment(_e), be = useThree(Ae => Ae.scene); return reactExports.useLayoutEffect(() => setEnvProps(fe, K, be, Ee, { backgroundBlurriness: pe ?? me, backgroundIntensity: ge, backgroundRotation: xe, environmentIntensity: ye, environmentRotation: ve })), reactExports.useEffect(() => () => { Ee.dispose() }, [Ee]), null } function EnvironmentPortal({ children: fe, near: K = .1, far: pe = 1e3, resolution: me = 256, frames: ge = 1, map: xe, background: ye = !1, blur: ve, backgroundBlurriness: _e, backgroundIntensity: Ee, backgroundRotation: be, environmentIntensity: Ae, environmentRotation: Se, scene: Ce, files: we, path: Be, preset: De = void 0, extensions: Re }) { const Ie = useThree(He => He.gl), Pe = useThree(He => He.scene), Ne = reactExports.useRef(null), [ke] = reactExports.useState(() => new Scene), Oe = reactExports.useMemo(() => { const He = new WebGLCubeRenderTarget(me); return He.texture.type = HalfFloatType, He }, [me]); reactExports.useEffect(() => () => { Oe.dispose() }, [Oe]), reactExports.useLayoutEffect(() => { if (ge === 1) { const He = Ie.autoClear; Ie.autoClear = !0, Ne.current.update(Ie, ke), Ie.autoClear = He } return setEnvProps(ye, Ce, Pe, Oe.texture, { backgroundBlurriness: ve ?? _e, backgroundIntensity: Ee, backgroundRotation: be, environmentIntensity: Ae, environmentRotation: Se }) }, [fe, ke, Oe.texture, Ce, Pe, ye, ge, Ie]); let Ue = 1; return useFrame(() => { if (ge === 1 / 0 || Ue < ge) { const He = Ie.autoClear; Ie.autoClear = !0, Ne.current.update(Ie, ke), Ie.autoClear = He, Ue++ } }), reactExports.createElement(reactExports.Fragment, null, createPortal(reactExports.createElement(reactExports.Fragment, null, fe, reactExports.createElement("cubeCamera", { ref: Ne, args: [K, pe, Oe] }), we || De ? reactExports.createElement(EnvironmentCube, { background: !0, files: we, preset: De, path: Be, extensions: Re }) : xe ? reactExports.createElement(EnvironmentMap, { background: !0, map: xe, extensions: Re }) : null), ke)) } function EnvironmentGround(fe) { var K, pe, me, ge; const xe = useEnvironment(fe), ye = fe.map || xe; reactExports.useMemo(() => extend$3({ GroundProjectedEnvImpl: GroundProjectedEnv }), []), reactExports.useEffect(() => () => { xe.dispose() }, [xe]); const ve = reactExports.useMemo(() => [ye], [ye]), _e = (K = fe.ground) == null ? void 0 : K.height, Ee = (pe = fe.ground) == null ? void 0 : pe.radius, be = (me = (ge = fe.ground) == null ? void 0 : ge.scale) !== null && me !== void 0 ? me : 1e3; return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(EnvironmentMap, _extends$2({}, fe, { map: ye })), reactExports.createElement("groundProjectedEnvImpl", { args: ve, scale: be, height: _e, radius: Ee })) } function Environment(fe) { return fe.ground ? reactExports.createElement(EnvironmentGround, fe) : fe.map ? reactExports.createElement(EnvironmentMap, fe) : fe.children ? reactExports.createElement(EnvironmentPortal, fe) : reactExports.createElement(EnvironmentCube, fe) } const context$1 = reactExports.createContext(null); function PerformanceMonitor({ iterations: fe = 10, ms: K = 250, threshold: pe = .75, step: me = .1, factor: ge = .5, flipflops: xe = 1 / 0, bounds: ye = Se => Se > 100 ? [60, 100] : [40, 60], onIncline: ve, onDecline: _e, onChange: Ee, onFallback: be, children: Ae }) { const Se = Math.pow(10, 0), [Ce, we] = reactExports.useState(() => ({ fps: 0, index: 0, factor: ge, flipped: 0, refreshrate: 0, fallback: !1, frames: [], averages: [], subscriptions: new Map, subscribe: De => { const Re = Symbol(); return Ce.subscriptions.set(Re, De.current), () => void Ce.subscriptions.delete(Re) } })); let Be = 0; return useFrame(() => { const { frames: De, averages: Re } = Ce; if (!Ce.fallback && Re.length < fe) { De.push(performance.now()); const Ie = De[De.length - 1] - De[0]; if (Ie >= K) { if (Ce.fps = Math.round(De.length / Ie * 1e3 * Se) / Se, Ce.refreshrate = Math.max(Ce.refreshrate, Ce.fps), Re[Ce.index++ % fe] = Ce.fps, Re.length === fe) { const [Pe, Ne] = ye(Ce.refreshrate), ke = Re.filter(Ue => Ue >= Ne), Oe = Re.filter(Ue => Ue < Pe); ke.length > fe * pe && (Ce.factor = Math.min(1, Ce.factor + me), Ce.flipped++, ve && ve(Ce), Ce.subscriptions.forEach(Ue => Ue.onIncline && Ue.onIncline(Ce))), Oe.length > fe * pe && (Ce.factor = Math.max(0, Ce.factor - me), Ce.flipped++, _e && _e(Ce), Ce.subscriptions.forEach(Ue => Ue.onDecline && Ue.onDecline(Ce))), Be !== Ce.factor && (Be = Ce.factor, Ee && Ee(Ce), Ce.subscriptions.forEach(Ue => Ue.onChange && Ue.onChange(Ce))), Ce.flipped > xe && !Ce.fallback && (Ce.fallback = !0, be && be(Ce), Ce.subscriptions.forEach(Ue => Ue.onFallback && Ue.onFallback(Ce))), Ce.averages = [] } Ce.frames = [] } } }), reactExports.createElement(context$1.Provider, { value: Ce }, Ae) } const __vite_import_meta_env__$1 = {}, createStoreImpl = fe => { let K; const pe = new Set, me = (be, Ae) => { const Se = typeof be == "function" ? be(K) : be; if (!Object.is(Se, K)) { const Ce = K; K = Ae ?? (typeof Se != "object" || Se === null) ? Se : Object.assign({}, K, Se), pe.forEach(we => we(K, Ce)) } }, ge = () => K, _e = { setState: me, getState: ge, getInitialState: () => Ee, subscribe: be => (pe.add(be), () => pe.delete(be)), destroy: () => { (__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), pe.clear() } }, Ee = K = fe(me, ge, _e); return _e }, createStore = fe => fe ? createStoreImpl(fe) : createStoreImpl, __vite_import_meta_env__ = {}, { useDebugValue } = React$4, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports; let didWarnAboutEqualityFn = !1; const identity = fe => fe; function useStore(fe, K = identity, pe) { (__vite_import_meta_env__ ? "production" : void 0) !== "production" && pe && !didWarnAboutEqualityFn && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), didWarnAboutEqualityFn = !0); const me = useSyncExternalStoreWithSelector(fe.subscribe, fe.getState, fe.getServerState || fe.getInitialState, K, pe); return useDebugValue(me), me } const createImpl = fe => { (__vite_import_meta_env__ ? "production" : void 0) !== "production" && typeof fe != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."); const K = typeof fe == "function" ? createStore(fe) : fe, pe = (me, ge) => useStore(K, me, ge); return Object.assign(pe, K), pe }, create$3 = fe => fe ? createImpl(fe) : createImpl, context = reactExports.createContext(null), vec1$1 = new Vector3, vec2$1 = new Vector3, calculateOffset$1 = (fe, K, pe, me) => { const ge = K.dot(K), xe = K.dot(fe) - K.dot(pe), ye = K.dot(me); return ye === 0 ? -xe / ge : (vec1$1.copy(me).multiplyScalar(ge / ye).sub(K), vec2$1.copy(me).multiplyScalar(xe / ye).add(pe).sub(fe), -vec1$1.dot(vec2$1) / vec1$1.dot(vec1$1)) }, upV$1 = new Vector3(0, 1, 0), offsetMatrix$1 = new Matrix4, AxisArrow = ({ direction: fe, axis: K }) => { const { translation: pe, translationLimits: me, annotations: ge, annotationsClass: xe, depthTest: ye, scale: ve, lineWidth: _e, fixed: Ee, axisColors: be, hoveredColor: Ae, opacity: Se, onDragStart: Ce, onDrag: we, onDragEnd: Be, userData: De } = reactExports.useContext(context), Re = useThree(Qe => Qe.controls), Ie = reactExports.useRef(null), Pe = reactExports.useRef(null), Ne = reactExports.useRef(null), ke = reactExports.useRef(0), [Oe, Ue] = reactExports.useState(!1), He = reactExports.useCallback(Qe => { ge && (Ie.current.innerText = `${pe.current[K].toFixed(2)}`, Ie.current.style.display = "block"), Qe.stopPropagation(); const st = new Matrix4().extractRotation(Pe.current.matrixWorld), Nt = Qe.point.clone(), Je = new Vector3().setFromMatrixPosition(Pe.current.matrixWorld), jt = fe.clone().applyMatrix4(st).normalize(); Ne.current = { clickPoint: Nt, dir: jt }, ke.current = pe.current[K], Ce({ component: "Arrow", axis: K, origin: Je, directions: [jt] }), Re && (Re.enabled = !1), Qe.target.setPointerCapture(Qe.pointerId) }, [ge, fe, Re, Ce, pe, K]), Ge = reactExports.useCallback(Qe => { if (Qe.stopPropagation(), Oe || Ue(!0), Ne.current) { const { clickPoint: st, dir: Nt } = Ne.current, [Je, jt] = me?.[K] || [void 0, void 0]; let Xt = calculateOffset$1(st, Nt, Qe.ray.origin, Qe.ray.direction); Je !== void 0 && (Xt = Math.max(Xt, Je - ke.current)), jt !== void 0 && (Xt = Math.min(Xt, jt - ke.current)), pe.current[K] = ke.current + Xt, ge && (Ie.current.innerText = `${pe.current[K].toFixed(2)}`), offsetMatrix$1.makeTranslation(Nt.x * Xt, Nt.y * Xt, Nt.z * Xt), we(offsetMatrix$1) } }, [ge, we, Oe, pe, me, K]), ze = reactExports.useCallback(Qe => { ge && (Ie.current.style.display = "none"), Qe.stopPropagation(), Ne.current = null, Be(), Re && (Re.enabled = !0), Qe.target.releasePointerCapture(Qe.pointerId) }, [ge, Re, Be]), We = reactExports.useCallback(Qe => { Qe.stopPropagation(), Ue(!1) }, []), { cylinderLength: Xe, coneWidth: Ye, coneLength: Ze, matrixL: ot } = reactExports.useMemo(() => { const Qe = Ee ? _e / ve * 1.6 : ve / 20, st = Ee ? .2 : ve / 5, Nt = Ee ? 1 - st : ve - st, Je = new Quaternion().setFromUnitVectors(upV$1, fe.clone().normalize()), jt = new Matrix4().makeRotationFromQuaternion(Je); return { cylinderLength: Nt, coneWidth: Qe, coneLength: st, matrixL: jt } }, [fe, ve, _e, Ee]), qe = Oe ? Ae : be[K]; return reactExports.createElement("group", { ref: Pe }, reactExports.createElement("group", { matrix: ot, matrixAutoUpdate: !1, onPointerDown: He, onPointerMove: Ge, onPointerUp: ze, onPointerOut: We }, ge && reactExports.createElement(Html, { position: [0, -Ze, 0] }, reactExports.createElement("div", { style: { display: "none", background: "#151520", color: "white", padding: "6px 8px", borderRadius: 7, whiteSpace: "nowrap" }, className: xe, ref: Ie })), reactExports.createElement("mesh", { visible: !1, position: [0, (Xe + Ze) / 2, 0], userData: De }, reactExports.createElement("cylinderGeometry", { args: [Ye * 1.4, Ye * 1.4, Xe + Ze, 8, 1] })), reactExports.createElement(Line$1, { transparent: !0, raycast: () => null, depthTest: ye, points: [0, 0, 0, 0, Xe, 0], lineWidth: _e, side: DoubleSide, color: qe, opacity: Se, polygonOffset: !0, renderOrder: 1, polygonOffsetFactor: -10, fog: !1 }), reactExports.createElement("mesh", { raycast: () => null, position: [0, Xe + Ze / 2, 0], renderOrder: 500 }, reactExports.createElement("coneGeometry", { args: [Ye, Ze, 24, 1] }), reactExports.createElement("meshBasicMaterial", { transparent: !0, depthTest: ye, color: qe, opacity: Se, polygonOffset: !0, polygonOffsetFactor: -10, fog: !1 })))) }, clickDir = new Vector3, intersectionDir = new Vector3, toDegrees = fe => fe * 180 / Math.PI, toRadians = fe => fe * Math.PI / 180, calculateAngle = (fe, K, pe, me, ge) => { clickDir.copy(fe).sub(pe), intersectionDir.copy(K).sub(pe); const xe = me.dot(me), ye = ge.dot(ge), ve = clickDir.dot(me) / xe, _e = clickDir.dot(ge) / ye, Ee = intersectionDir.dot(me) / xe, be = intersectionDir.dot(ge) / ye, Ae = Math.atan2(_e, ve); return Math.atan2(be, Ee) - Ae }, fmod = (fe, K) => { let pe = Math.floor(fe / K); return pe = pe < 0 ? pe + 1 : pe, fe - pe * K }, minimizeAngle = fe => { let K = fmod(fe, 2 * Math.PI); return Math.abs(K) < 1e-6 ? 0 : (K < 0 && (K += 2 * Math.PI), K) }, rotMatrix = new Matrix4, posNew = new Vector3, ray$1 = new Ray, intersection$1 = new Vector3, AxisRotator = ({ dir1: fe, dir2: K, axis: pe }) => { const { rotationLimits: me, annotations: ge, annotationsClass: xe, depthTest: ye, scale: ve, lineWidth: _e, fixed: Ee, axisColors: be, hoveredColor: Ae, opacity: Se, onDragStart: Ce, onDrag: we, onDragEnd: Be, userData: De } = reactExports.useContext(context), Re = useThree(qe => qe.controls), Ie = reactExports.useRef(null), Pe = reactExports.useRef(null), Ne = reactExports.useRef(0), ke = reactExports.useRef(0), Oe = reactExports.useRef(null), [Ue, He] = reactExports.useState(!1), Ge = reactExports.useCallback(qe => { ge && (Ie.current.innerText = `${toDegrees(ke.current).toFixed(0)}`, Ie.current.style.display = "block"), qe.stopPropagation(); const Qe = qe.point.clone(), st = new Vector3().setFromMatrixPosition(Pe.current.matrixWorld), Nt = new Vector3().setFromMatrixColumn(Pe.current.matrixWorld, 0).normalize(), Je = new Vector3().setFromMatrixColumn(Pe.current.matrixWorld, 1).normalize(), jt = new Vector3().setFromMatrixColumn(Pe.current.matrixWorld, 2).normalize(), Xt = new Plane().setFromNormalAndCoplanarPoint(jt, st); Oe.current = { clickPoint: Qe, origin: st, e1: Nt, e2: Je, normal: jt, plane: Xt }, Ce({ component: "Rotator", axis: pe, origin: st, directions: [Nt, Je, jt] }), Re && (Re.enabled = !1), qe.target.setPointerCapture(qe.pointerId) }, [ge, Re, Ce, pe]), ze = reactExports.useCallback(qe => { if (qe.stopPropagation(), Ue || He(!0), Oe.current) { const { clickPoint: Qe, origin: st, e1: Nt, e2: Je, normal: jt, plane: Xt } = Oe.current, [ct, nn] = me?.[pe] || [void 0, void 0]; ray$1.copy(qe.ray), ray$1.intersectPlane(Xt, intersection$1), ray$1.direction.negate(), ray$1.intersectPlane(Xt, intersection$1); let $t = calculateAngle(Qe, intersection$1, st, Nt, Je), an = toDegrees($t); qe.shiftKey && (an = Math.round(an / 10) * 10, $t = toRadians(an)), ct !== void 0 && nn !== void 0 && nn - ct < 2 * Math.PI ? ($t = minimizeAngle($t), $t = $t > Math.PI ? $t - 2 * Math.PI : $t, $t = MathUtils.clamp($t, ct - Ne.current, nn - Ne.current), ke.current = Ne.current + $t) : (ke.current = minimizeAngle(Ne.current + $t), ke.current = ke.current > Math.PI ? ke.current - 2 * Math.PI : ke.current), ge && (an = toDegrees(ke.current), Ie.current.innerText = `${an.toFixed(0)}`), rotMatrix.makeRotationAxis(jt, $t), posNew.copy(st).applyMatrix4(rotMatrix).sub(st).negate(), rotMatrix.setPosition(posNew), we(rotMatrix) } }, [ge, we, Ue, me, pe]), We = reactExports.useCallback(qe => { ge && (Ie.current.style.display = "none"), qe.stopPropagation(), Ne.current = ke.current, Oe.current = null, Be(), Re && (Re.enabled = !0), qe.target.releasePointerCapture(qe.pointerId) }, [ge, Re, Be]), Xe = reactExports.useCallback(qe => { qe.stopPropagation(), He(!1) }, []), Ye = reactExports.useMemo(() => { const qe = fe.clone().normalize(), Qe = K.clone().normalize(); return new Matrix4().makeBasis(qe, Qe, qe.clone().cross(Qe)) }, [fe, K]), Ze = Ee ? .65 : ve * .65, ot = reactExports.useMemo(() => { const Qe = []; for (let st = 0; st <= 32; st++) { const Nt = st * (Math.PI / 2) / 32; Qe.push(new Vector3(Math.cos(Nt) * Ze, Math.sin(Nt) * Ze, 0)) } return Qe }, [Ze]); return reactExports.createElement("group", { ref: Pe, onPointerDown: Ge, onPointerMove: ze, onPointerUp: We, onPointerOut: Xe, matrix: Ye, matrixAutoUpdate: !1 }, ge && reactExports.createElement(Html, { position: [Ze, Ze, 0] }, reactExports.createElement("div", { style: { display: "none", background: "#151520", color: "white", padding: "6px 8px", borderRadius: 7, whiteSpace: "nowrap" }, className: xe, ref: Ie })), reactExports.createElement(Line$1, { points: ot, lineWidth: _e * 4, visible: !1, userData: De }), reactExports.createElement(Line$1, { transparent: !0, raycast: () => null, depthTest: ye, points: ot, lineWidth: _e, side: DoubleSide, color: Ue ? Ae : be[pe], opacity: Se, polygonOffset: !0, polygonOffsetFactor: -10, fog: !1 })) }, decomposeIntoBasis = (fe, K, pe) => { const me = Math.abs(fe.x) >= Math.abs(fe.y) && Math.abs(fe.x) >= Math.abs(fe.z) ? 0 : Math.abs(fe.y) >= Math.abs(fe.x) && Math.abs(fe.y) >= Math.abs(fe.z) ? 1 : 2, ge = [0, 1, 2].sort((we, Be) => Math.abs(K.getComponent(Be)) - Math.abs(K.getComponent(we))), xe = me === ge[0] ? ge[1] : ge[0], ye = fe.getComponent(me), ve = fe.getComponent(xe), _e = K.getComponent(me), Ee = K.getComponent(xe), be = pe.getComponent(me), Se = (pe.getComponent(xe) - be * (ve / ye)) / (Ee - _e * (ve / ye)); return [(be - Se * _e) / ye, Se] }, ray = new Ray, intersection = new Vector3, offsetMatrix = new Matrix4, PlaneSlider = ({ dir1: fe, dir2: K, axis: pe }) => { const { translation: me, translationLimits: ge, annotations: xe, annotationsClass: ye, depthTest: ve, scale: _e, lineWidth: Ee, fixed: be, axisColors: Ae, hoveredColor: Se, opacity: Ce, onDragStart: we, onDrag: Be, onDragEnd: De, userData: Re } = reactExports.useContext(context), Ie = useThree(Nt => Nt.controls), Pe = reactExports.useRef(null), Ne = reactExports.useRef(null), ke = reactExports.useRef(null), Oe = reactExports.useRef(0), Ue = reactExports.useRef(0), [He, Ge] = reactExports.useState(!1), ze = reactExports.useCallback(Nt => { xe && (Pe.current.innerText = `${me.current[(pe + 1) % 3].toFixed(2)}, ${me.current[(pe + 2) % 3].toFixed(2)}`, Pe.current.style.display = "block"), Nt.stopPropagation(); const Je = Nt.point.clone(), jt = new Vector3().setFromMatrixPosition(Ne.current.matrixWorld), Xt = new Vector3().setFromMatrixColumn(Ne.current.matrixWorld, 0).normalize(), ct = new Vector3().setFromMatrixColumn(Ne.current.matrixWorld, 1).normalize(), nn = new Vector3().setFromMatrixColumn(Ne.current.matrixWorld, 2).normalize(), $t = new Plane().setFromNormalAndCoplanarPoint(nn, jt); ke.current = { clickPoint: Je, e1: Xt, e2: ct, plane: $t }, Oe.current = me.current[(pe + 1) % 3], Ue.current = me.current[(pe + 2) % 3], we({ component: "Slider", axis: pe, origin: jt, directions: [Xt, ct, nn] }), Ie && (Ie.enabled = !1), Nt.target.setPointerCapture(Nt.pointerId) }, [xe, Ie, we, pe]), We = reactExports.useCallback(Nt => { if (Nt.stopPropagation(), He || Ge(!0), ke.current) { const { clickPoint: Je, e1: jt, e2: Xt, plane: ct } = ke.current, [nn, $t] = ge?.[(pe + 1) % 3] || [void 0, void 0], [an, gn] = ge?.[(pe + 2) % 3] || [void 0, void 0]; ray.copy(Nt.ray), ray.intersectPlane(ct, intersection), ray.direction.negate(), ray.intersectPlane(ct, intersection), intersection.sub(Je); let [Mn, Xn] = decomposeIntoBasis(jt, Xt, intersection); nn !== void 0 && (Mn = Math.max(Mn, nn - Oe.current)), $t !== void 0 && (Mn = Math.min(Mn, $t - Oe.current)), an !== void 0 && (Xn = Math.max(Xn, an - Ue.current)), gn !== void 0 && (Xn = Math.min(Xn, gn - Ue.current)), me.current[(pe + 1) % 3] = Oe.current + Mn, me.current[(pe + 2) % 3] = Ue.current + Xn, xe && (Pe.current.innerText = `${me.current[(pe + 1) % 3].toFixed(2)}, ${me.current[(pe + 2) % 3].toFixed(2)}`), offsetMatrix.makeTranslation(Mn * jt.x + Xn * Xt.x, Mn * jt.y + Xn * Xt.y, Mn * jt.z + Xn * Xt.z), Be(offsetMatrix) } }, [xe, Be, He, me, ge, pe]), Xe = reactExports.useCallback(Nt => { xe && (Pe.current.style.display = "none"), Nt.stopPropagation(), ke.current = null, De(), Ie && (Ie.enabled = !0), Nt.target.releasePointerCapture(Nt.pointerId) }, [xe, Ie, De]), Ye = reactExports.useCallback(Nt => { Nt.stopPropagation(), Ge(!1) }, []), Ze = reactExports.useMemo(() => { const Nt = fe.clone().normalize(), Je = K.clone().normalize(); return new Matrix4().makeBasis(Nt, Je, Nt.clone().cross(Je)) }, [fe, K]), ot = be ? 1 / 7 : _e / 7, qe = be ? .225 : _e * .225, Qe = He ? Se : Ae[pe], st = reactExports.useMemo(() => [new Vector3(0, 0, 0), new Vector3(0, qe, 0), new Vector3(qe, qe, 0), new Vector3(qe, 0, 0), new Vector3(0, 0, 0)], [qe]); return reactExports.createElement("group", { ref: Ne, matrix: Ze, matrixAutoUpdate: !1 }, xe && reactExports.createElement(Html, { position: [0, 0, 0] }, reactExports.createElement("div", { style: { display: "none", background: "#151520", color: "white", padding: "6px 8px", borderRadius: 7, whiteSpace: "nowrap" }, className: ye, ref: Pe })), reactExports.createElement("group", { position: [ot * 1.7, ot * 1.7, 0] }, reactExports.createElement("mesh", { visible: !0, onPointerDown: ze, onPointerMove: We, onPointerUp: Xe, onPointerOut: Ye, scale: qe, userData: Re }, reactExports.createElement("planeGeometry", null), reactExports.createElement("meshBasicMaterial", { transparent: !0, depthTest: ve, color: Qe, polygonOffset: !0, polygonOffsetFactor: -10, side: DoubleSide, fog: !1 })), reactExports.createElement(Line$1, { position: [-qe / 2, -qe / 2, 0], transparent: !0, depthTest: ve, points: st, lineWidth: Ee, color: Qe, opacity: Ce, polygonOffset: !0, polygonOffsetFactor: -10, userData: Re, fog: !1 }))) }, vec1 = new Vector3, vec2 = new Vector3, calculateOffset = (fe, K, pe, me) => { const ge = K.dot(K), xe = K.dot(fe) - K.dot(pe), ye = K.dot(me); return ye === 0 ? -xe / ge : (vec1.copy(me).multiplyScalar(ge / ye).sub(K), vec2.copy(me).multiplyScalar(xe / ye).add(pe).sub(fe), -vec1.dot(vec2) / vec1.dot(vec1)) }, upV = new Vector3(0, 1, 0), scaleV = new Vector3, scaleMatrix = new Matrix4, ScalingSphere = ({ direction: fe, axis: K }) => { const { scaleLimits: pe, annotations: me, annotationsClass: ge, depthTest: xe, scale: ye, lineWidth: ve, fixed: _e, axisColors: Ee, hoveredColor: be, opacity: Ae, onDragStart: Se, onDrag: Ce, onDragEnd: we, userData: Be } = reactExports.useContext(context), De = useThree(st => st.size), Re = useThree(st => st.controls), Ie = reactExports.useRef(null), Pe = reactExports.useRef(null), Ne = reactExports.useRef(null), ke = reactExports.useRef(1), Oe = reactExports.useRef(1), Ue = reactExports.useRef(null), [He, Ge] = reactExports.useState(!1), ze = _e ? 1.2 : 1.2 * ye, We = reactExports.useCallback(st => { me && (Ie.current.innerText = `${Oe.current.toFixed(2)}`, Ie.current.style.display = "block"), st.stopPropagation(); const Nt = new Matrix4().extractRotation(Pe.current.matrixWorld), Je = st.point.clone(), jt = new Vector3().setFromMatrixPosition(Pe.current.matrixWorld), Xt = fe.clone().applyMatrix4(Nt).normalize(), ct = Pe.current.matrixWorld.clone(), nn = ct.clone().invert(), $t = _e ? 1 / calculateScaleFactor(Pe.current.getWorldPosition(vec1), ye, st.camera, De) : 1; Ue.current = { clickPoint: Je, dir: Xt, mPLG: ct, mPLGInv: nn, offsetMultiplier: $t }, Se({ component: "Sphere", axis: K, origin: jt, directions: [Xt] }), Re && (Re.enabled = !1), st.target.setPointerCapture(st.pointerId) }, [me, Re, fe, Se, K, _e, ye, De]), Xe = reactExports.useCallback(st => { if (st.stopPropagation(), He || Ge(!0), Ue.current) { const { clickPoint: Nt, dir: Je, mPLG: jt, mPLGInv: Xt, offsetMultiplier: ct } = Ue.current, [nn, $t] = pe?.[K] || [1e-5, void 0], gn = calculateOffset(Nt, Je, st.ray.origin, st.ray.direction) * ct, Mn = _e ? gn : gn / ye; let Xn = Math.pow(2, Mn * .2); st.shiftKey && (Xn = Math.round(Xn * 10) / 10), Xn = Math.max(Xn, nn / ke.current), $t !== void 0 && (Xn = Math.min(Xn, $t / ke.current)), Oe.current = ke.current * Xn, Ne.current.position.set(0, ze + gn, 0), me && (Ie.current.innerText = `${Oe.current.toFixed(2)}`), scaleV.set(1, 1, 1), scaleV.setComponent(K, Xn), scaleMatrix.makeScale(scaleV.x, scaleV.y, scaleV.z).premultiply(jt).multiply(Xt), Ce(scaleMatrix) } }, [me, ze, Ce, He, pe, K]), Ye = reactExports.useCallback(st => { me && (Ie.current.style.display = "none"), st.stopPropagation(), ke.current = Oe.current, Ue.current = null, Ne.current.position.set(0, ze, 0), we(), Re && (Re.enabled = !0), st.target.releasePointerCapture(st.pointerId) }, [me, Re, we, ze]), Ze = reactExports.useCallback(st => { st.stopPropagation(), Ge(!1) }, []), { radius: ot, matrixL: qe } = reactExports.useMemo(() => { const st = _e ? ve / ye * 1.8 : ye / 22.5, Nt = new Quaternion().setFromUnitVectors(upV, fe.clone().normalize()), Je = new Matrix4().makeRotationFromQuaternion(Nt); return { radius: st, matrixL: Je } }, [fe, ye, ve, _e]), Qe = He ? be : Ee[K]; return reactExports.createElement("group", { ref: Pe }, reactExports.createElement("group", { matrix: qe, matrixAutoUpdate: !1, onPointerDown: We, onPointerMove: Xe, onPointerUp: Ye, onPointerOut: Ze }, me && reactExports.createElement(Html, { position: [0, ze / 2, 0] }, reactExports.createElement("div", { style: { display: "none", background: "#151520", color: "white", padding: "6px 8px", borderRadius: 7, whiteSpace: "nowrap" }, className: ge, ref: Ie })), reactExports.createElement("mesh", { ref: Ne, position: [0, ze, 0], renderOrder: 500, userData: Be }, reactExports.createElement("sphereGeometry", { args: [ot, 12, 12] }), reactExports.createElement("meshBasicMaterial", { transparent: !0, depthTest: xe, color: Qe, opacity: Ae, polygonOffset: !0, polygonOffsetFactor: -10 })))) }, mL0 = new Matrix4, mW0 = new Matrix4, mP = new Matrix4, mPInv = new Matrix4, mW = new Matrix4, mL = new Matrix4, mL0Inv = new Matrix4, mdL = new Matrix4, mG = new Matrix4, bb = new Box3, bbObj = new Box3, vCenter = new Vector3, vSize = new Vector3, vAnchorOffset = new Vector3, vPosition = new Vector3, vScale = new Vector3, xDir = new Vector3(1, 0, 0), yDir = new Vector3(0, 1, 0), zDir = new Vector3(0, 0, 1), PivotControls = reactExports.forwardRef(({ enabled: fe = !0, matrix: K, onDragStart: pe, onDrag: me, onDragEnd: ge, autoTransform: xe = !0, anchor: ye, disableAxes: ve = !1, disableSliders: _e = !1, disableRotations: Ee = !1, disableScaling: be = !1, activeAxes: Ae = [!0, !0, !0], offset: Se = [0, 0, 0], rotation: Ce = [0, 0, 0], scale: we = 1, lineWidth: Be = 4, fixed: De = !1, translationLimits: Re, rotationLimits: Ie, scaleLimits: Pe, depthTest: Ne = !0, axisColors: ke = ["#ff2060", "#20df80", "#2080ff"], hoveredColor: Oe = "#ffff40", annotations: Ue = !1, annotationsClass: He, opacity: Ge = 1, visible: ze = !0, userData: We, children: Xe, ...Ye }, Ze) => { const ot = useThree($t => $t.invalidate), qe = reactExports.useRef(null), Qe = reactExports.useRef(null), st = reactExports.useRef(null), Nt = reactExports.useRef(null), Je = reactExports.useRef([0, 0, 0]), jt = reactExports.useRef(new Vector3(1, 1, 1)), Xt = reactExports.useRef(new Vector3(1, 1, 1)); reactExports.useLayoutEffect(() => { ye && (Nt.current.updateWorldMatrix(!0, !0), mPInv.copy(Nt.current.matrixWorld).invert(), bb.makeEmpty(), Nt.current.traverse($t => { $t.geometry && ($t.geometry.boundingBox || $t.geometry.computeBoundingBox(), mL.copy($t.matrixWorld).premultiply(mPInv), bbObj.copy($t.geometry.boundingBox), bbObj.applyMatrix4(mL), bb.union(bbObj)) }), vCenter.copy(bb.max).add(bb.min).multiplyScalar(.5), vSize.copy(bb.max).sub(bb.min).multiplyScalar(.5), vAnchorOffset.copy(vSize).multiply(new Vector3(...ye)).add(vCenter), vPosition.set(...Se).add(vAnchorOffset), st.current.position.copy(vPosition), ot()) }); const ct = reactExports.useMemo(() => ({ onDragStart: $t => { mL0.copy(Qe.current.matrix), mW0.copy(Qe.current.matrixWorld), pe && pe($t), ot() }, onDrag: $t => { mP.copy(qe.current.matrixWorld), mPInv.copy(mP).invert(), mW.copy(mW0).premultiply($t), mL.copy(mW).premultiply(mPInv), mL0Inv.copy(mL0).invert(), mdL.copy(mL).multiply(mL0Inv), xe && Qe.current.matrix.copy(mL), me && me(mL, mdL, mW, $t), ot() }, onDragEnd: () => { ge && ge(), ot() }, translation: Je, translationLimits: Re, rotationLimits: Ie, axisColors: ke, hoveredColor: Oe, opacity: Ge, scale: we, lineWidth: Be, fixed: De, depthTest: Ne, userData: We, annotations: Ue, annotationsClass: He }), [pe, me, ge, Je, Re, Ie, Pe, Ne, we, Be, De, ...ke, Oe, Ge, We, xe, Ue, He]), nn = new Vector3; return useFrame($t => { if (De) { const an = calculateScaleFactor(st.current.getWorldPosition(nn), we, $t.camera, $t.size); jt.current.setScalar(an) } K && K instanceof Matrix4 && (Qe.current.matrix = K), Qe.current.updateWorldMatrix(!0, !0), mG.makeRotationFromEuler(st.current.rotation).setPosition(st.current.position).premultiply(Qe.current.matrixWorld), Xt.current.setFromMatrixScale(mG), vScale.copy(jt.current).divide(Xt.current), (Math.abs(st.current.scale.x - vScale.x) > 1e-4 || Math.abs(st.current.scale.y - vScale.y) > 1e-4 || Math.abs(st.current.scale.z - vScale.z) > 1e-4) && (st.current.scale.copy(vScale), $t.invalidate()) }), reactExports.useImperativeHandle(Ze, () => Qe.current, []), reactExports.createElement(context.Provider, { value: ct }, reactExports.createElement("group", { ref: qe }, reactExports.createElement("group", _extends$2({ ref: Qe, matrix: K, matrixAutoUpdate: !1 }, Ye), reactExports.createElement("group", { visible: ze, ref: st, position: Se, rotation: Ce }, fe && reactExports.createElement(reactExports.Fragment, null, !ve && Ae[0] && reactExports.createElement(AxisArrow, { axis: 0, direction: xDir }), !ve && Ae[1] && reactExports.createElement(AxisArrow, { axis: 1, direction: yDir }), !ve && Ae[2] && reactExports.createElement(AxisArrow, { axis: 2, direction: zDir }), !_e && Ae[0] && Ae[1] && reactExports.createElement(PlaneSlider, { axis: 2, dir1: xDir, dir2: yDir }), !_e && Ae[0] && Ae[2] && reactExports.createElement(PlaneSlider, { axis: 1, dir1: zDir, dir2: xDir }), !_e && Ae[2] && Ae[1] && reactExports.createElement(PlaneSlider, { axis: 0, dir1: yDir, dir2: zDir }), !Ee && Ae[0] && Ae[1] && reactExports.createElement(AxisRotator, { axis: 2, dir1: xDir, dir2: yDir }), !Ee && Ae[0] && Ae[2] && reactExports.createElement(AxisRotator, { axis: 1, dir1: zDir, dir2: xDir }), !Ee && Ae[2] && Ae[1] && reactExports.createElement(AxisRotator, { axis: 0, dir1: yDir, dir2: zDir }), !be && Ae[0] && reactExports.createElement(ScalingSphere, { axis: 0, direction: xDir }), !be && Ae[1] && reactExports.createElement(ScalingSphere, { axis: 1, direction: yDir }), !be && Ae[2] && reactExports.createElement(ScalingSphere, { axis: 2, direction: zDir }))), reactExports.createElement("group", { ref: Nt }, Xe)))) }), ViewerContext = React$4.createContext(null);/*!
 * hold-event
 * https://github.com/yomotsu/hold-event
 * (c) 2020 @yomotsu
 * Released under the MIT License.
 */var HOLD_EVENT_TYPE; (function (fe) { fe.HOLD_START = "holdStart", fe.HOLD_END = "holdEnd", fe.HOLDING = "holding" })(HOLD_EVENT_TYPE || (HOLD_EVENT_TYPE = {})); class EventDispatcher { constructor() { this._listeners = {} } addEventListener(K, pe) { const me = this._listeners; me[K] === void 0 && (me[K] = []), me[K].indexOf(pe) === -1 && me[K].push(pe) } removeEventListener(K, pe) { const ge = this._listeners[K]; if (ge !== void 0) { const xe = ge.indexOf(pe); xe !== -1 && ge.splice(xe, 1) } } dispatchEvent(K) { const me = this._listeners[K.type]; if (me !== void 0) { K.target = this; const ge = me.slice(0); for (let xe = 0, ye = ge.length; xe < ye; xe++)ge[xe].call(this, K) } } } class Hold extends EventDispatcher { constructor(K) { super(), this._enabled = !0, this._holding = !1, this._intervalId = -1, this._deltaTime = 0, this._elapsedTime = 0, this._lastTime = 0, this._holdStart = pe => { if (!this._enabled || this._holding) return; this._deltaTime = 0, this._elapsedTime = 0, this._lastTime = performance.now(), this.dispatchEvent({ type: HOLD_EVENT_TYPE.HOLD_START, deltaTime: this._deltaTime, elapsedTime: this._elapsedTime, originalEvent: pe }), this._holding = !0; const me = () => { this._intervalId = this.holdIntervalDelay ? window.setTimeout(me, this.holdIntervalDelay) : window.requestAnimationFrame(me); const ge = performance.now(); this._deltaTime = ge - this._lastTime, this._elapsedTime += this._deltaTime, this._lastTime = performance.now(), this.dispatchEvent({ type: HOLD_EVENT_TYPE.HOLDING, deltaTime: this._deltaTime, elapsedTime: this._elapsedTime, originalEvent: pe }) }; this._intervalId = this.holdIntervalDelay ? window.setTimeout(me, this.holdIntervalDelay) : window.requestAnimationFrame(me) }, this._holdEnd = pe => { if (!this._enabled || !this._holding) return; const me = performance.now(); this._deltaTime = me - this._lastTime, this._elapsedTime += this._deltaTime, this._lastTime = performance.now(), this.dispatchEvent({ type: HOLD_EVENT_TYPE.HOLD_END, deltaTime: this._deltaTime, elapsedTime: this._elapsedTime, originalEvent: pe }), window.clearTimeout(this._intervalId), window.cancelAnimationFrame(this._intervalId), this._holding = !1 }, this.holdIntervalDelay = K } get enabled() { return this._enabled } set enabled(K) { this._enabled !== K && (this._enabled = K, this._enabled || this._holdEnd()) } get holding() { return this._holding } } class KeyboardKeyHold extends Hold { constructor(K, pe) { if (typeof K != "string") { console.error("KeyboardKeyHold: the first argument has to be a KeyboardEvent.code string."); return } super(pe), this._holdStart = this._holdStart.bind(this), this._holdEnd = this._holdEnd.bind(this); const me = xe => { isInputEvent(xe) || xe.code === K && this._holdStart(xe) }, ge = xe => { xe.code === K && this._holdEnd(xe) }; document.addEventListener("keydown", me), document.addEventListener("keyup", ge), window.addEventListener("blur", this._holdEnd) } } function isInputEvent(fe) { const K = fe.target; return K.tagName === "INPUT" || K.tagName === "SELECT" || K.tagName === "TEXTAREA" || K.isContentEditable } function computeT_threeworld_world(fe) { const K = fe.useSceneTree.getState().nodeAttributesFromName[""], pe = K?.wxyz ?? [1, 0, 0, 0], me = K?.position ?? [0, 0, 0]; return new Matrix4().makeRotationFromQuaternion(new Quaternion(pe[1], pe[2], pe[3], pe[0])).setPosition(me[0], me[1], me[2]) } function rayToViserCoords(fe, K) { const pe = computeT_threeworld_world(fe).invert(), me = K.origin.clone().applyMatrix4(pe), ge = pe.setPosition(0, 0, 0), xe = K.direction.clone().applyMatrix4(ge); return new Ray(me, xe) } function useThrottledMessageSender(fe) { const K = React$4.useContext(ViewerContext); return makeThrottledMessageSender(K, fe) } function makeThrottledMessageSender(fe, K) { let pe = !0, me = !1, ge = null; function xe(ve) { const _e = fe.mutable.current; _e.sendMessage !== null && (ge = ve, pe ? (_e.sendMessage(ve), me = !1, pe = !1, setTimeout(() => { pe = !0, me && ge && xe(ge) }, K)) : me = !0) } function ye() { fe.mutable.current.sendMessage !== null && ge !== null && (fe.mutable.current.sendMessage(ge), ge = null, me = !1) } return { send: xe, flush: ye } } function isTexture(fe) { return fe != null && fe.isTexture !== void 0 } function OrbitOriginTool({ forceShow: fe, pivotRef: K, onPivotChange: pe, update: me }) {
	const xe = reactExports.useContext(ViewerContext).useGui(ye => ye.showOrbitOriginTool); return React$4.useEffect(me, [xe]), !xe && !fe ? null : jsxRuntimeExports.jsxs(PivotControls, {
		ref: K, scale: 200, lineWidth: 4, fixed: !0, axisColors: ["#ffaaff", "#ff33ff", "#ffaaff"], disableScaling: !0, onDragEnd: () => { pe(K.current.matrix) }, children: [jsxRuntimeExports.jsxs("mesh", {
			children: [jsxRuntimeExports.jsx("sphereGeometry", { args: [.1, 32, 32] }), jsxRuntimeExports.jsx("shaderMaterial", {
				transparent: !0, uniforms: { color: { value: new Color$1("#ff33ff") }, size: { value: 200 } }, vertexShader: `
            // Custom shader for defining sphere size in screen space.
            uniform float size;
            void main() {
              vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
              vec4 clipPosOffset = projectionMatrix * modelViewMatrix * vec4(position * size / 1000.0, 1.0);
              gl_Position = clipPos + (clipPosOffset - clipPos) * clipPos.w;
            }
          `, fragmentShader: `
            uniform vec3 color;
            void main() {
              gl_FragColor = vec4(color, 0.8);
            }
          `})]
		}), jsxRuntimeExports.jsx(Grid, { args: [10, 10, 10, 10], infiniteGrid: !0, fadeStrength: 0, fadeFrom: 0, fadeDistance: 1e3, sectionColor: "#ffaaff", cellColor: "#ffccff", side: DoubleSide })]
	})
} function SynchronizedCameraControls() { const fe = reactExports.useContext(ViewerContext), K = useThree(Xe => Xe.camera), pe = useThrottledMessageSender(20).send, me = reactExports.useRef(null), ge = reactExports.useRef(null), xe = fe.mutable.current, [ye, ve] = reactExports.useState(null), _e = .5; useFrame(Xe => { if (ye && xe.cameraControl) { const Ye = xe.cameraControl, Ze = Ye.camera, ot = Xe.clock.getElapsedTime() - ye.startTime, qe = Math.min(ot / ye.duration, 1), Qe = qe * qe * (3 - 2 * qe), st = new Vector3().copy(ye.startUp).lerp(ye.targetUp, Qe).normalize(), Nt = new Vector3().copy(ye.startLookAt).lerp(ye.targetLookAt, Qe); Ze.up.copy(st); const Je = new Vector3; Ye.getPosition(Je), Ye.updateCameraUp(), Ye.setPosition(Je.x, Je.y, Je.z, !1), Ye.setLookAt(Je.x, Je.y, Je.z, Nt.x, Nt.y, Nt.z, !1), qe >= 1 && ve(null) } }); const { clock: Ee } = useThree(), be = Xe => { if (!xe.cameraControl) return; const Ye = new Vector3; Ye.setFromMatrixPosition(Xe); const Ze = xe.cameraControl, ot = xe.cameraControl.camera, qe = new Vector3().setFromMatrixColumn(Xe, 1), Qe = Ze.getTarget(new Vector3); ve({ startUp: ot.up.clone(), targetUp: qe, startLookAt: Qe, targetLookAt: Ye, startTime: Ee.getElapsedTime(), duration: _e }) }, Ae = () => { if (ye !== null || !xe.cameraControl || !ge.current) return; const Ye = xe.cameraControl.getTarget(new Vector3), Ze = new Matrix4().extractRotation(ge.current.matrix), ot = K.up.clone().normalize(), qe = new Vector3(0, 1, 0).applyMatrix4(Ze).normalize(), Qe = new Vector3().crossVectors(qe, ot).normalize(), st = Math.acos(Math.min(1, Math.max(-1, ot.dot(qe)))), Nt = new Matrix4; Qe.lengthSq() > 1e-4 && Nt.makeRotationAxis(Qe, st); const Je = new Matrix4; Je.multiply(Nt), Je.multiply(Ze), Je.setPosition(Ye), ge.current.matrix.copy(Je), ge.current.updateMatrixWorld(!0) }; xe.resetCameraView = () => { K.up.set(me.current.camera.up.x, me.current.camera.up.y, me.current.camera.up.z), xe.cameraControl.updateCameraUp(), xe.cameraControl.setLookAt(me.current.camera.position.x, me.current.camera.position.y, me.current.camera.position.z, me.current.lookAt.x, me.current.lookAt.y, me.current.lookAt.z, !0) }; const Se = new Quaternion().setFromEuler(new Euler(Math.PI, 0, 0)), Ce = new Quaternion, we = new Matrix4, Be = new Vector3, De = new Quaternion, Re = new Vector3, Ie = new Vector3, Pe = React$4.useCallback(() => { Ae(); const Xe = K, Ye = xe.cameraControl, Ze = xe.canvas; if (Ye === null) { setTimeout(Pe, 10); return } const ot = computeT_threeworld_world(fe).invert(), qe = ot.clone().multiply(we.makeRotationFromQuaternion(Xe.quaternion).setPosition(Xe.position)).multiply(we.makeRotationFromQuaternion(Se)); Ce.setFromRotationMatrix(ot), Ye.getTarget(Be).applyQuaternion(Ce); const Qe = Xe.up.clone().applyQuaternion(Ce); me.current === null && (me.current = { camera: Xe.clone(), lookAt: Ye.getTarget(new Vector3) }), qe.decompose(Re, De, Ie), pe({ type: "ViewerCameraMessage", wxyz: [De.w, De.x, De.y, De.z], position: Re.toArray(), image_height: Ze.height, image_width: Ze.width, fov: Xe.fov * Math.PI / 180, near: Xe.near, far: Xe.far, look_at: [Be.x, Be.y, Be.z], up_direction: [Qe.x, Qe.y, Qe.z] }), He != null && console.log(`&initialCameraPosition=${Re.x.toFixed(3)},${Re.y.toFixed(3)},${Re.z.toFixed(3)}&initialCameraLookAt=${Be.x.toFixed(3)},${Be.y.toFixed(3)},${Be.z.toFixed(3)}&initialCameraUp=${Qe.x.toFixed(3)},${Qe.y.toFixed(3)},${Qe.z.toFixed(3)}`) }, [K, pe]), Ne = new URLSearchParams(window.location.search), ke = Ne.get("initialCameraPosition"), Oe = Ne.get("initialCameraLookAt"), Ue = Ne.get("initialCameraUp"), He = Ne.get("logCamera"), Ge = fe.useGui(Xe => Xe.websocketConnected), ze = React$4.useRef(!1); React$4.useEffect(() => { if (!ze.current) { const Xe = new Vector3(...ke ? ke.split(",").map(Number) : [3, 3, 3]); Xe.applyMatrix4(computeT_threeworld_world(fe)); const Ye = new Vector3(...Oe ? Oe.split(",").map(Number) : [0, 0, 0]); Ye.applyMatrix4(computeT_threeworld_world(fe)); const Ze = new Vector3(...Ue ? Ue.split(",").map(Number) : [0, 0, 1]); Ze.applyMatrix4(computeT_threeworld_world(fe)), Ze.normalize(), K.up.set(Ze.x, Ze.y, Ze.z), xe.cameraControl.updateCameraUp(), xe.cameraControl.setLookAt(Xe.x, Xe.y, Xe.z, Ye.x, Ye.y, Ye.z, !1), ze.current = !0 } xe.sendCamera = Pe, Ge && setTimeout(() => Pe(), 50) }, [Ge, Pe]); const We = xe.canvas; return React$4.useEffect(() => { const Xe = new ResizeObserver(() => { Pe() }); return Xe.observe(We), () => Xe.disconnect() }, [We]), React$4.useEffect(() => { const Xe = xe.cameraControl, Ye = new KeyboardKeyHold("KeyW", 20), Ze = new KeyboardKeyHold("KeyA", 20), ot = new KeyboardKeyHold("KeyS", 20), qe = new KeyboardKeyHold("KeyD", 20), Qe = new KeyboardKeyHold("KeyQ", 20), st = new KeyboardKeyHold("KeyE", 20); Ze.addEventListener("holding", ct => { Xe.truck(-.002 * ct?.deltaTime, 0, !0) }), qe.addEventListener("holding", ct => { Xe.truck(.002 * ct?.deltaTime, 0, !0) }), Ye.addEventListener("holding", ct => { Xe.forward(.002 * ct?.deltaTime, !0) }), ot.addEventListener("holding", ct => { Xe.forward(-.002 * ct?.deltaTime, !0) }), Qe.addEventListener("holding", ct => { Xe.elevate(-.002 * ct?.deltaTime, !0) }), st.addEventListener("holding", ct => { Xe.elevate(.002 * ct?.deltaTime, !0) }); const Nt = new KeyboardKeyHold("ArrowLeft", 20), Je = new KeyboardKeyHold("ArrowRight", 20), jt = new KeyboardKeyHold("ArrowUp", 20), Xt = new KeyboardKeyHold("ArrowDown", 20); return Nt.addEventListener("holding", ct => { Xe.rotate(-.05 * MathUtils.DEG2RAD * ct?.deltaTime, 0, !0) }), Je.addEventListener("holding", ct => { Xe.rotate(.05 * MathUtils.DEG2RAD * ct?.deltaTime, 0, !0) }), jt.addEventListener("holding", ct => { Xe.rotate(0, -.05 * MathUtils.DEG2RAD * ct?.deltaTime, !0) }), Xt.addEventListener("holding", ct => { Xe.rotate(0, .05 * MathUtils.DEG2RAD * ct?.deltaTime, !0) }), () => { } }, [CameraControls]), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CameraControls, { ref: Xe => xe.cameraControl = Xe, minDistance: .01, dollySpeed: .3, smoothTime: .05, draggingSmoothTime: 0, onChange: Pe, makeDefault: !0 }), jsxRuntimeExports.jsx(OrbitOriginTool, { forceShow: He !== null, pivotRef: ge, onPivotChange: Xe => { be(Xe) }, update: Ae })] }) } const HoverableContext = React$4.createContext(null), OutlinesMaterial = shaderMaterial({ screenspace: !1, color: new Color$1("black"), opacity: 1, thickness: .05, size: new Vector2 }, `#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform float screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
	     #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
	   #include <morphtarget_vertex>
	   #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace == 0.0) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`, `uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
   }`), Outlines = reactExports.forwardRef(function ({ color: K = "black", opacity: pe = 1, transparent: me = !1, screenspace: ge = !1, toneMapped: xe = !0, polygonOffset: ye = !1, polygonOffsetFactor: ve = 0, renderOrder: _e = 0, thickness: Ee = .05, angle: be = Math.PI, ...Ae }, Se) { const Ce = reactExports.useRef(null), [we] = reactExports.useState(() => new OutlinesMaterial({ side: BackSide })), De = useThree(Pe => Pe.gl).getDrawingBufferSize(new Vector2), Re = reactExports.useRef(0), Ie = reactExports.useRef(); return reactExports.useLayoutEffect(() => { const Pe = Ce.current; if (!Pe) return; const Ne = Pe.parent; if (Ne && Ne.geometry && (Re.current !== be || Ie.current !== Ne.geometry)) { Re.current = be, Ie.current = Ne.geometry; let ke = Pe.children[0]; ke && (be && ke.geometry.dispose(), Pe.remove(ke)), Ne.skeleton ? (ke = new SkinnedMesh$1, ke.material = we, ke.bind(Ne.skeleton, Ne.bindMatrix), Pe.add(ke)) : Ne.isInstancedMesh ? (ke = new InstancedMesh(Ne.geometry, we, Ne.count), ke.instanceMatrix = Ne.instanceMatrix, Pe.add(ke)) : (ke = new Mesh, ke.material = we, Pe.add(ke)), ke.geometry = be ? toCreasedNormals(Ne.geometry, be) : Ne.geometry } }), reactExports.useLayoutEffect(() => { const Pe = Ce.current; if (!Pe) return; const Ne = Pe.children[0]; Ne && (Ne.renderOrder = _e, applyProps(Ne.material, { transparent: me, thickness: Ee, color: K, opacity: pe, size: De, screenspace: ge, toneMapped: xe, polygonOffset: ye, polygonOffsetFactor: ve })) }), reactExports.useEffect(() => () => { const Pe = Ce.current; if (!Pe) return; const Ne = Pe.children[0]; Ne && (be && Ne.geometry.dispose(), Pe.remove(Ne)) }, []), jsxRuntimeExports.jsx("group", { ref: Pe => { Ce.current = Pe, typeof Se == "function" ? Se(Pe) : Se && (Se.current = Pe) }, ...Ae }) }); function OutlinesIfHovered(fe = { alwaysMounted: !1, creaseAngle: Math.PI }) { const K = React$4.useRef(null), pe = React$4.useContext(HoverableContext), [me, ge] = React$4.useState(!0); return useFrame(() => { if (pe !== null) if (fe.alwaysMounted) { if (K.current === null) return; K.current.visible = pe.current.isHovered } else pe.current.isHovered != me && ge(pe.current.isHovered) }), pe === null || !me ? null : jsxRuntimeExports.jsx(Outlines, { ref: K, thickness: 10, screenspace: !0, color: 16514816, opacity: .8, transparent: !0, angle: fe.creaseAngle }) } const _tempObjects = { instanceMatrix: new Matrix4, transformMatrix: new Matrix4, finalMatrix: new Matrix4, position: new Vector3, quaternion: new Quaternion, scale: new Vector3, oneVector: new Vector3(1, 1, 1) }, BatchedMeshHoverOutlines = ({ geometry: fe, batched_positions: K, batched_wxyzs: pe, batched_scales: me, meshTransform: ge, computeBatchIndexFromInstanceIndex: xe }) => { const ye = React$4.useContext(HoverableContext), ve = React$4.useRef(null), _e = useThree(Se => Se.gl), Ee = React$4.useMemo(() => _e.getDrawingBufferSize(new Vector2), [_e]), be = React$4.useMemo(() => fe ? fe.clone() : null, [fe]), Ae = React$4.useMemo(() => { const Se = new OutlinesMaterial({ side: BackSide }); return Se.thickness = 10, Se.color = new Color$1(16514816), Se.opacity = .8, Se.size = Ee, Se.transparent = !0, Se.screenspace = !0, Se.toneMapped = !0, Se }, [Ee]); return React$4.useEffect(() => () => { be && be.dispose() }, [be]), React$4.useEffect(() => () => { Ae && Ae.dispose() }, [Ae]), useFrame(() => { if (!(!ve.current || !be || !ye) && (ve.current.visible = !1, ye.current.isHovered && ye.current.instanceId !== null)) { const Se = ye.current.instanceId, Ce = xe ? xe(Se) : Se, we = new DataView(K.buffer, K.byteOffset, K.byteLength), Be = new DataView(pe.buffer, pe.byteOffset, pe.byteLength), De = me ? new DataView(me.buffer, me.byteOffset, me.byteLength) : null; if (Ce >= 0 && Ce * 12 < K.byteLength) { const Re = Ce * 3 * 4, Ie = Ce * 4 * 4; if (ve.current.position.set(we.getFloat32(Re, !0), we.getFloat32(Re + 4, !0), we.getFloat32(Re + 8, !0)), ve.current.quaternion.set(Be.getFloat32(Ie + 4, !0), Be.getFloat32(Ie + 8, !0), Be.getFloat32(Ie + 12, !0), Be.getFloat32(Ie, !0)), De) if (me.byteLength === pe.byteLength / 4 * 3) { const Pe = Ce * 3 * 4; ve.current.scale.set(De.getFloat32(Pe, !0), De.getFloat32(Pe + 4, !0), De.getFloat32(Pe + 8, !0)) } else { const Pe = Ce * 4, Ne = De.getFloat32(Pe, !0); ve.current.scale.setScalar(Ne) } else ve.current.scale.set(1, 1, 1); ge && (_tempObjects.instanceMatrix.compose(ve.current.position, ve.current.quaternion, ve.current.scale), _tempObjects.transformMatrix.compose(ge.position, ge.rotation, ge.scale), _tempObjects.finalMatrix.copy(_tempObjects.instanceMatrix).multiply(_tempObjects.transformMatrix), _tempObjects.finalMatrix.decompose(_tempObjects.position, _tempObjects.quaternion, _tempObjects.scale), ve.current.position.copy(_tempObjects.position), ve.current.quaternion.copy(_tempObjects.quaternion), ve.current.scale.copy(_tempObjects.scale)), ve.current.visible = !0 } } }), !ye || !be ? null : jsxRuntimeExports.jsx("mesh", { ref: ve, geometry: be, material: Ae, visible: !1 }) }, originGeom = new SphereGeometry(1), PointCloudMaterial = shaderMaterial({ scale: 1, point_ball_norm: 0, uniformColor: new Color$1(1, 1, 1) }, `
  precision mediump float;

  varying vec3 vPosition;
  varying vec3 vColor; // in the vertex shader
  uniform float scale;
  uniform vec3 uniformColor;

  void main() {
      vPosition = position;
      #ifdef USE_COLOR
      vColor = color;
      #else
      vColor = uniformColor;
      #endif
      vec4 world_pos = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * world_pos;
      gl_PointSize = (scale / -world_pos.z);
  }
   `, `varying vec3 vPosition;
  varying vec3 vColor;
  uniform float point_ball_norm;

  void main() {
      if (point_ball_norm < 1000.0) {
          float r = pow(
              pow(abs(gl_PointCoord.x - 0.5), point_ball_norm)
              + pow(abs(gl_PointCoord.y - 0.5), point_ball_norm),
              1.0 / point_ball_norm);
          if (r > 0.5) discard;
      }
      gl_FragColor = vec4(vColor, 1.0);
  }
   `), PointCloud = React$4.forwardRef(function ({ children: K, ...pe }, me) { const ge = useThree(Ee => Ee.get), xe = pe.props, ye = React$4.useMemo(() => { const Ee = new BufferGeometry; return pe.props.precision === "float16" ? Ee.setAttribute("position", new Float16BufferAttribute(new Uint16Array(xe.points.buffer.slice(xe.points.byteOffset, xe.points.byteOffset + xe.points.byteLength)), 3)) : Ee.setAttribute("position", new Float32BufferAttribute(new Float32Array(xe.points.buffer.slice(xe.points.byteOffset, xe.points.byteOffset + xe.points.byteLength)), 3)), xe.colors.length > 3 ? Ee.setAttribute("color", new BufferAttribute(new Uint8Array(xe.colors), 3, !0)) : xe.colors.length < 3 && console.error(`Invalid color buffer length, got ${xe.colors.length}`), Ee }, [xe.points, xe.colors]), ve = React$4.useMemo(() => { const Ee = new PointCloudMaterial; return xe.colors.length > 3 ? Ee.vertexColors = !0 : (Ee.vertexColors = !1, Ee.uniforms.uniformColor.value = new Color$1(xe.colors[0] / 255, xe.colors[1] / 255, xe.colors[2] / 255)), Ee }, [xe.colors]); React$4.useEffect(() => () => { ye.dispose(), ve.dispose() }, [ye, ve]), React$4.useEffect(() => { ve.uniforms.scale.value = 10, ve.uniforms.point_ball_norm.value = { square: 1 / 0, diamond: 1, circle: 2, rounded: 3, sparkle: .6 }[xe.point_shape] }, [xe.point_shape, ve]); const _e = new Vector2; return useFrame(() => { ve.uniforms.scale.value = xe.point_size / Math.tan(ge().camera.fov / 180 * Math.PI / 2) * ge().gl.getSize(_e).height * ge().gl.getPixelRatio() }), jsxRuntimeExports.jsx("points", { frustumCulled: !1, ref: me, geometry: ye, material: ve, children: K }) }), CoordinateFrame = React$4.forwardRef(function ({ showAxes: K = !0, axesLength: pe = .5, axesRadius: me = .0125, originRadius: ge = void 0, originColor: xe = 15526912, children: ye }, ve) { return ge = ge ?? me * 2, jsxRuntimeExports.jsxs("group", { ref: ve, children: [K && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("mesh", { geometry: originGeom, scale: new Vector3(ge, ge, ge), children: [jsxRuntimeExports.jsx("meshBasicMaterial", { color: xe }), jsxRuntimeExports.jsx(OutlinesIfHovered, {})] }), jsxRuntimeExports.jsxs(Instances, { limit: 3, children: [jsxRuntimeExports.jsx("meshBasicMaterial", {}), jsxRuntimeExports.jsx("cylinderGeometry", { args: [me, me, pe, 16] }), jsxRuntimeExports.jsx(Instance, { rotation: new Euler(0, 0, 3 * Math.PI / 2), position: [.5 * pe, 0, 0], color: 13369344, children: jsxRuntimeExports.jsx(OutlinesIfHovered, {}) }), jsxRuntimeExports.jsx(Instance, { position: [0, .5 * pe, 0], color: 52224, children: jsxRuntimeExports.jsx(OutlinesIfHovered, {}) }), jsxRuntimeExports.jsx(Instance, { rotation: new Euler(Math.PI / 2, 0, 0), position: [0, 0, .5 * pe], color: 204, children: jsxRuntimeExports.jsx(OutlinesIfHovered, {}) })] })] }), ye] }) }), InstancedAxes = React$4.forwardRef(function ({ batched_wxyzs: K, batched_positions: pe, batched_scales: me, axes_length: ge = .5, axes_radius: xe = .0125, children: ye }, ve) { const _e = React$4.useRef(null), Ee = React$4.useMemo(() => new CylinderGeometry(xe, xe, ge, 16), [xe, ge]), be = React$4.useMemo(() => new MeshBasicMaterial, []); React$4.useEffect(() => () => { Ee.dispose(), be.dispose() }, [Ee, be]); const Ae = React$4.useMemo(() => ({ T_frame_framex: new Matrix4().makeRotationFromEuler(new Euler(0, 0, 3 * Math.PI / 2)).setPosition(.5 * ge, 0, 0), T_frame_framey: new Matrix4().makeRotationFromEuler(new Euler(0, 0, 0)).setPosition(0, .5 * ge, 0), T_frame_framez: new Matrix4().makeRotationFromEuler(new Euler(Math.PI / 2, 0, 0)).setPosition(0, 0, .5 * ge), red: new Color$1(13369344), green: new Color$1(52224), blue: new Color$1(204) }), [ge]); React$4.useEffect(() => { if (!_e.current) return; const Re = new Matrix4, Ie = new Matrix4, Pe = new Matrix4, Ne = new Matrix4, ke = new Quaternion, Oe = new Vector3, { T_frame_framex: Ue, T_frame_framey: He, T_frame_framez: Ge, red: ze, green: We, blue: Xe } = Ae, Ye = new DataView(pe.buffer, pe.byteOffset, pe.byteLength), Ze = new DataView(K.buffer, K.byteOffset, K.byteLength), ot = me ? new DataView(me.buffer, me.byteOffset, me.byteLength) : null, qe = K.byteLength / (4 * 4); for (let Qe = 0; Qe < qe; Qe++) { const st = Qe * 3 * 4, Nt = Qe * 4 * 4, Je = me && me.byteLength === K.byteLength / 4 * 3 ? Qe * 3 * 4 : Qe * 4; if (ot) if (me.byteLength === K.byteLength / 4 * 3) Oe.set(ot.getFloat32(Je, !0), ot.getFloat32(Je + 4, !0), ot.getFloat32(Je + 8, !0)); else { const jt = ot.getFloat32(Je, !0); Oe.set(jt, jt, jt) } else Oe.set(1, 1, 1); Re.makeRotationFromQuaternion(ke.set(Ze.getFloat32(Nt + 4, !0), Ze.getFloat32(Nt + 8, !0), Ze.getFloat32(Nt + 12, !0), Ze.getFloat32(Nt, !0))).scale(Oe).setPosition(Ye.getFloat32(st, !0), Ye.getFloat32(st + 4, !0), Ye.getFloat32(st + 8, !0)), Ie.copy(Re).multiply(Ue), Pe.copy(Re).multiply(He), Ne.copy(Re).multiply(Ge), _e.current.setMatrixAt(Qe * 3 + 0, Ie), _e.current.setMatrixAt(Qe * 3 + 1, Pe), _e.current.setMatrixAt(Qe * 3 + 2, Ne), _e.current.setColorAt(Qe * 3 + 0, ze), _e.current.setColorAt(Qe * 3 + 1, We), _e.current.setColorAt(Qe * 3 + 2, Xe) } _e.current.instanceMatrix.needsUpdate = !0, _e.current.instanceColor.needsUpdate = !0 }, [K, pe, me, Ae]); const Se = React$4.useMemo(() => new CylinderGeometry(xe, xe, ge, 16), [xe, ge]), Ce = React$4.useMemo(() => ({ position: new Vector3(.5 * ge, 0, 0), rotation: new Quaternion().setFromEuler(new Euler(0, 0, 3 * Math.PI / 2)), scale: new Vector3(1, 1, 1) }), [ge]), we = React$4.useMemo(() => ({ position: new Vector3(0, .5 * ge, 0), rotation: new Quaternion().setFromEuler(new Euler(0, 0, 0)), scale: new Vector3(1, 1, 1) }), [ge]), Be = React$4.useMemo(() => ({ position: new Vector3(0, 0, .5 * ge), rotation: new Quaternion().setFromEuler(new Euler(Math.PI / 2, 0, 0)), scale: new Vector3(1, 1, 1) }), [ge]), De = K.byteLength / (4 * 4) * 3; return jsxRuntimeExports.jsxs("group", { ref: ve, children: [jsxRuntimeExports.jsx("instancedMesh", { ref: _e, args: [Ee, be, De] }), jsxRuntimeExports.jsx(BatchedMeshHoverOutlines, { geometry: Se, batched_positions: pe, batched_wxyzs: K, batched_scales: me, meshTransform: Ce, computeBatchIndexFromInstanceIndex: Re => Math.floor(Re / 3) }), jsxRuntimeExports.jsx(BatchedMeshHoverOutlines, { geometry: Se, batched_positions: pe, batched_wxyzs: K, batched_scales: me, meshTransform: we, computeBatchIndexFromInstanceIndex: Re => Math.floor(Re / 3) }), jsxRuntimeExports.jsx(BatchedMeshHoverOutlines, { geometry: Se, batched_positions: pe, batched_wxyzs: K, batched_scales: me, meshTransform: Be, computeBatchIndexFromInstanceIndex: Re => Math.floor(Re / 3) }), ye] }) }), ViserImage = React$4.forwardRef(function ({ children: K, ...pe }, me) { const [ge, xe] = React$4.useState(); return React$4.useEffect(() => { if (pe.props._format !== null && pe.props._data !== null) { const ye = URL.createObjectURL(new Blob([pe.props._data], { type: "image/" + pe.props._format })); new TextureLoader().load(ye, ve => { xe(ve), URL.revokeObjectURL(ye) }) } }, [pe.props._format, pe.props._data]), jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsxs("mesh", { rotation: new Euler(Math.PI, 0, 0), castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, children: [jsxRuntimeExports.jsx(OutlinesIfHovered, {}), jsxRuntimeExports.jsx("planeGeometry", { attach: "geometry", args: [pe.props.render_width, pe.props.render_height] }), jsxRuntimeExports.jsx("meshBasicMaterial", { attach: "material", transparent: !0, side: DoubleSide, map: ge, toneMapped: !1 })] }), K] }) }); function rgbToInt$1(fe) { return fe[0] << 16 | fe[1] << 8 | fe[2] } function generateGradientMap(fe) { const K = new DataTexture(Uint8Array.from(fe === 3 ? [0, 128, 255] : [0, 64, 128, 192, 255]), fe, 1, RedFormat); return K.needsUpdate = !0, K } function assertUnreachable$1(fe) { throw new Error(`Should never get here! ${fe}`) } function disposeMaterial(fe) { "map" in fe && fe.map?.dispose(), "lightMap" in fe && fe.lightMap?.dispose(), "bumpMap" in fe && fe.bumpMap?.dispose(), "normalMap" in fe && fe.normalMap?.dispose(), "specularMap" in fe && fe.specularMap?.dispose(), "envMap" in fe && fe.envMap?.dispose(), "alphaMap" in fe && fe.alphaMap?.dispose(), "aoMap" in fe && fe.aoMap?.dispose(), "displacementMap" in fe && fe.displacementMap?.dispose(), "emissiveMap" in fe && fe.emissiveMap?.dispose(), "gradientMap" in fe && fe.gradientMap?.dispose(), "metalnessMap" in fe && fe.metalnessMap?.dispose(), "roughnessMap" in fe && fe.roughnessMap?.dispose(), fe.dispose() } function createStandardMaterial(fe) { const K = { color: fe.color === void 0 ? 16777215 : rgbToInt$1(fe.color), wireframe: fe.wireframe, transparent: fe.opacity !== null, opacity: fe.opacity ?? 1, side: { front: FrontSide, back: BackSide, double: DoubleSide }[fe.side] }; return fe.material == "standard" || fe.wireframe ? new MeshStandardMaterial({ flatShading: fe.flat_shading && !fe.wireframe, ...K }) : fe.material == "toon3" ? new MeshToonMaterial({ gradientMap: generateGradientMap(3), ...K }) : fe.material == "toon5" ? new MeshToonMaterial({ gradientMap: generateGradientMap(5), ...K }) : assertUnreachable$1(fe.material) } const CameraFrustumComponent = React$4.forwardRef(function ({ children: K, ...pe }, me) { const [ge, xe] = React$4.useState(); React$4.useEffect(() => { if (pe.props._format !== null && pe.props._image_data !== null) { const De = URL.createObjectURL(new Blob([pe.props._image_data], { type: "image/" + pe.props._format })); new TextureLoader().load(De, Re => { xe(Re), URL.revokeObjectURL(De) }) } else xe(void 0) }, [pe.props._format, pe.props._image_data]); let ye = Math.tan(pe.props.fov / 2), ve = ye * pe.props.aspect, _e = 1; const Ee = Math.cbrt(ve * ye * _e / 3); ve /= Ee, ye /= Ee, _e /= Ee, ve *= pe.props.scale, ye *= pe.props.scale, _e *= pe.props.scale; const be = React$4.useContext(HoverableContext), [Ae, Se] = React$4.useState(!1); useFrame(() => { be !== null && be.current.isHovered !== Ae && Se(be.current.isHovered) }); const Ce = [[-1, -1, 1], [1, -1, 1], [1, -1, 1], [1, 1, 1], [1, 1, 1], [-1, 1, 1], [-1, 1, 1], [-1, -1, 1], [-1, -1, 1], [0, 0, 0], [0, 0, 0], [1, -1, 1], [-1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [0, -1.2, 1], ge === void 0 ? [0, -.9, 1] : [0, -1, 1]].map(De => [De[0] * ve, De[1] * ye, De[2] * _e]), we = React$4.useMemo(() => { if (pe.props.variant !== "filled") return null; const De = new BufferGeometry, Re = new Float32Array([0, 0, 0, -ve, -ye, _e, ve, -ye, _e, ve, ye, _e, -ve, ye, _e]), Ie = new Uint16Array([0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1, 1, 4, 3, 1, 3, 2]); return De.setAttribute("position", new BufferAttribute(Re, 3)), De.setIndex(new BufferAttribute(Ie, 1)), De.computeVertexNormals(), De }, [ve, ye, _e, pe.props.variant]), Be = new Color$1().setRGB(pe.props.color[0] / 255, pe.props.color[1] / 255, pe.props.color[2] / 255); return jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(Line$1, { points: Ce, color: Ae ? 16514816 : rgbToInt$1(pe.props.color), lineWidth: Ae ? 1.5 * pe.props.line_width : pe.props.line_width, segments: !0 }), pe.props.variant === "filled" && we && jsxRuntimeExports.jsx("mesh", { geometry: we, children: jsxRuntimeExports.jsx("meshBasicMaterial", { color: Ae ? 16514816 : Be, transparent: !0, opacity: .3, side: DoubleSide, depthWrite: !1 }) }), ge && jsxRuntimeExports.jsxs("mesh", { position: [0, 0, _e * .999999], rotation: new Euler(Math.PI, 0, 0), castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, children: [jsxRuntimeExports.jsx("planeGeometry", { attach: "geometry", args: [pe.props.aspect * ye * 2, ye * 2] }), jsxRuntimeExports.jsx("meshBasicMaterial", { attach: "material", transparent: !0, side: DoubleSide, map: ge, toneMapped: !1 })] }), K] }) }); var Module = (() => {
	var fe = import.meta.url; return async function (K = {}) {
		var pe, me = K, ge, xe, ye = new Promise((Et, wt) => { ge = Et, xe = wt }), ve = typeof window == "object", _e = typeof importScripts == "function", Ee = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string"; if (Ee) { const { createRequire: Et } = await __vitePreload(() => import("./__vite-browser-external-BIHI7g3E.js"), [], import.meta.url); var be = Et(import.meta.url) } var Ae = Object.assign({}, me), Se = ""; function Ce(Et) { return me.locateFile ? me.locateFile(Et, Se) : Se + Et } var we, Be, De; if (Ee) { var Re = be("fs"), Ie = be("path"); Se = be("url").fileURLToPath(new URL("./", import.meta.url)), we = (Et, wt) => (Et = wn(Et) ? new URL(Et) : Ie.normalize(Et), Re.readFileSync(Et, wt ? void 0 : "utf8")), De = Et => { var wt = we(Et, !0); return wt.buffer || (wt = new Uint8Array(wt)), wt }, Be = (Et, wt, rn, _n = !0) => { Et = wn(Et) ? new URL(Et) : Ie.normalize(Et), Re.readFile(Et, _n ? void 0 : "utf8", (Wn, or) => { Wn ? rn(Wn) : wt(_n ? or.buffer : or) }) }, !me.thisProgram && process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2) } else (ve || _e) && (_e ? Se = self.location.href : typeof document < "u" && document.currentScript && (Se = document.currentScript.src), fe && (Se = fe), Se.startsWith("blob:") ? Se = "" : Se = Se.substr(0, Se.replace(/[?#].*/, "").lastIndexOf("/") + 1), we = Et => { var wt = new XMLHttpRequest; return wt.open("GET", Et, !1), wt.send(null), wt.responseText }, _e && (De = Et => { var wt = new XMLHttpRequest; return wt.open("GET", Et, !1), wt.responseType = "arraybuffer", wt.send(null), new Uint8Array(wt.response) }), Be = (Et, wt, rn) => { if (wn(Et)) { var _n = new XMLHttpRequest; _n.open("GET", Et, !0), _n.responseType = "arraybuffer", _n.onload = () => { if (_n.status == 200 || _n.status == 0 && _n.response) { wt(_n.response); return } rn() }, _n.onerror = rn, _n.send(null); return } fetch(Et, { credentials: "same-origin" }).then(Wn => Wn.ok ? Wn.arrayBuffer() : Promise.reject(new Error(Wn.status + " : " + Wn.url))).then(wt, rn) }); me.print || console.log.bind(console); var Pe = me.printErr || console.error.bind(console); Object.assign(me, Ae), Ae = null, me.arguments && me.arguments, me.thisProgram && me.thisProgram, me.quit && me.quit; var Ne; me.wasmBinary && (Ne = me.wasmBinary); var ke, Oe = !1, Ue, He, Ge, ze, We, Xe, Ye, Ze; function ot() { var Et = ke.buffer; me.HEAP8 = Ue = new Int8Array(Et), me.HEAP16 = Ge = new Int16Array(Et), me.HEAPU8 = He = new Uint8Array(Et), me.HEAPU16 = ze = new Uint16Array(Et), me.HEAP32 = We = new Int32Array(Et), me.HEAPU32 = Xe = new Uint32Array(Et), me.HEAPF32 = Ye = new Float32Array(Et), me.HEAPF64 = Ze = new Float64Array(Et) } var qe = [], Qe = [], st = []; function Nt() { if (me.preRun) for (typeof me.preRun == "function" && (me.preRun = [me.preRun]); me.preRun.length;)Xt(me.preRun.shift()); Ht(qe) } function Je() { Ht(Qe) } function jt() { if (me.postRun) for (typeof me.postRun == "function" && (me.postRun = [me.postRun]); me.postRun.length;)nn(me.postRun.shift()); Ht(st) } function Xt(Et) { qe.unshift(Et) } function ct(Et) { Qe.unshift(Et) } function nn(Et) { st.unshift(Et) } var $t = 0, an = null; function gn(Et) { $t++, me.monitorRunDependencies?.($t) } function Mn(Et) { if ($t--, me.monitorRunDependencies?.($t), $t == 0 && an) { var wt = an; an = null, wt() } } function Xn(Et) { me.onAbort?.(Et), Et = "Aborted(" + Et + ")", Pe(Et), Oe = !0, Et += ". Build with -sASSERTIONS for more info."; var wt = new WebAssembly.RuntimeError(Et); throw xe(wt), wt } var Ln = "data:application/octet-stream;base64,", Gn = Et => Et.startsWith(Ln), wn = Et => Et.startsWith("file://"); function Bn() { if (me.locateFile) { var Et = "Sorter.wasm"; return Gn(Et) ? Et : Ce(Et) } return new URL("" + new URL("Sorter-Df0J3ZWJ.wasm", import.meta.url).href, import.meta.url).href } var Gt; function nr(Et) { if (Et == Gt && Ne) return new Uint8Array(Ne); if (De) return De(Et); throw "both async and sync fetching of the wasm failed" } function Kn(Et) { return Ne ? Promise.resolve().then(() => nr(Et)) : new Promise((wt, rn) => { Be(Et, _n => wt(new Uint8Array(_n)), _n => { try { wt(nr(Et)) } catch (Wn) { rn(Wn) } }) }) } function vn(Et, wt, rn) { return Kn(Et).then(_n => WebAssembly.instantiate(_n, wt)).then(rn, _n => { Pe(`failed to asynchronously prepare wasm: ${_n}`), Xn(_n) }) } function yn(Et, wt, rn, _n) { return !Et && typeof WebAssembly.instantiateStreaming == "function" && !Gn(wt) && !wn(wt) && !Ee && typeof fetch == "function" ? fetch(wt, { credentials: "same-origin" }).then(Wn => { var or = WebAssembly.instantiateStreaming(Wn, rn); return or.then(_n, function (gr) { return Pe(`wasm streaming compile failed: ${gr}`), Pe("falling back to ArrayBuffer instantiation"), vn(wt, rn, _n) }) }) : vn(wt, rn, _n) } function Hn() { return { a: Oa } } function kn() { var Et = Hn(); function wt(_n, Wn) { return Ps = _n.exports, ke = Ps.z, ot(), ni = Ps.C, ct(Ps.A), Mn(), Ps } gn(); function rn(_n) { wt(_n.instance) } if (me.instantiateWasm) try { return me.instantiateWasm(Et, wt) } catch (_n) { Pe(`Module.instantiateWasm callback failed with error: ${_n}`), xe(_n) } return Gt || (Gt = Bn()), yn(Ne, Gt, Et, rn).catch(xe), {} } var Ht = Et => { for (; Et.length > 0;)Et.shift()(me) }; me.noExitRuntime; class Dt { constructor(wt) { this.excPtr = wt, this.ptr = wt - 24 } set_type(wt) { Xe[this.ptr + 4 >> 2] = wt } get_type() { return Xe[this.ptr + 4 >> 2] } set_destructor(wt) { Xe[this.ptr + 8 >> 2] = wt } get_destructor() { return Xe[this.ptr + 8 >> 2] } set_caught(wt) { wt = wt ? 1 : 0, Ue[this.ptr + 12] = wt } get_caught() { return Ue[this.ptr + 12] != 0 } set_rethrown(wt) { wt = wt ? 1 : 0, Ue[this.ptr + 13] = wt } get_rethrown() { return Ue[this.ptr + 13] != 0 } init(wt, rn) { this.set_adjusted_ptr(0), this.set_type(wt), this.set_destructor(rn) } set_adjusted_ptr(wt) { Xe[this.ptr + 16 >> 2] = wt } get_adjusted_ptr() { return Xe[this.ptr + 16 >> 2] } get_exception_ptr() { var wt = Ls(this.get_type()); if (wt) return Xe[this.excPtr >> 2]; var rn = this.get_adjusted_ptr(); return rn !== 0 ? rn : this.excPtr } } var fn = 0, en = (Et, wt, rn) => { var _n = new Dt(Et); throw _n.init(wt, rn), fn = Et, fn }, cn = () => { Xn("") }, Wt = (Et, wt, rn, _n, Wn) => { }, un = () => { for (var Et = new Array(256), wt = 0; wt < 256; ++wt)Et[wt] = String.fromCharCode(wt); Ft = Et }, Ft, Sn = Et => { for (var wt = "", rn = Et; He[rn];)wt += Ft[He[rn++]]; return wt }, lr = {}, jn = {}, Pn = {}, fr, Yn = Et => { throw new fr(Et) }, sr, Ar = Et => { throw new sr(Et) }, Er = (Et, wt, rn) => { Et.forEach(function (Qn) { Pn[Qn] = wt }); function _n(Qn) { var ur = rn(Qn); ur.length !== Et.length && Ar("Mismatched type converter count"); for (var Tr = 0; Tr < Et.length; ++Tr)mn(Et[Tr], ur[Tr]) } var Wn = new Array(wt.length), or = [], gr = 0; wt.forEach((Qn, ur) => { jn.hasOwnProperty(Qn) ? Wn[ur] = jn[Qn] : (or.push(Qn), lr.hasOwnProperty(Qn) || (lr[Qn] = []), lr[Qn].push(() => { Wn[ur] = jn[Qn], ++gr, gr === or.length && _n(Wn) })) }), or.length === 0 && _n(Wn) }; function Rr(Et, wt, rn = {}) { var _n = wt.name; if (Et || Yn(`type "${_n}" must have a positive integer typeid pointer`), jn.hasOwnProperty(Et)) { if (rn.ignoreDuplicateRegistrations) return; Yn(`Cannot register type '${_n}' twice`) } if (jn[Et] = wt, delete Pn[Et], lr.hasOwnProperty(Et)) { var Wn = lr[Et]; delete lr[Et], Wn.forEach(or => or()) } } function mn(Et, wt, rn = {}) { if (!("argPackAdvance" in wt)) throw new TypeError("registerType registeredInstance requires argPackAdvance"); return Rr(Et, wt, rn) } var Dn = 8, Rn = (Et, wt, rn, _n) => { wt = Sn(wt), mn(Et, { name: wt, fromWireType: function (Wn) { return !!Wn }, toWireType: function (Wn, or) { return or ? rn : _n }, argPackAdvance: Dn, readValueFromPointer: function (Wn) { return this.fromWireType(He[Wn]) }, destructorFunction: null }) }, qn = Et => ({ count: Et.count, deleteScheduled: Et.deleteScheduled, preservePointerOnDelete: Et.preservePointerOnDelete, ptr: Et.ptr, ptrType: Et.ptrType, smartPtr: Et.smartPtr, smartPtrType: Et.smartPtrType }), ar = Et => { function wt(rn) { return rn.$$.ptrType.registeredClass.name } Yn(wt(Et) + " instance already deleted") }, yr = !1, dr = Et => { }, mi = Et => { Et.smartPtr ? Et.smartPtrType.rawDestructor(Et.smartPtr) : Et.ptrType.registeredClass.rawDestructor(Et.ptr) }, bi = Et => { Et.count.value -= 1; var wt = Et.count.value === 0; wt && mi(Et) }, ti = (Et, wt, rn) => { if (wt === rn) return Et; if (rn.baseClass === void 0) return null; var _n = ti(Et, wt, rn.baseClass); return _n === null ? null : rn.downcast(_n) }, Si = {}, ri = () => Object.keys(Nr).length, es = () => { var Et = []; for (var wt in Nr) Nr.hasOwnProperty(wt) && Et.push(Nr[wt]); return Et }, Hi = [], Ai = () => { for (; Hi.length;) { var Et = Hi.pop(); Et.$$.deleteScheduled = !1, Et.delete() } }, gi, ts = Et => { gi = Et, Hi.length && gi && gi(Ai) }, Ii = () => { me.getInheritedInstanceCount = ri, me.getLiveInheritedInstances = es, me.flushPendingDeletes = Ai, me.setDelayFunction = ts }, Nr = {}, hs = (Et, wt) => { for (wt === void 0 && Yn("ptr should not be undefined"); Et.baseClass;)wt = Et.upcast(wt), Et = Et.baseClass; return wt }, xi = (Et, wt) => (wt = hs(Et, wt), Nr[wt]), Rt = (Et, wt) => { (!wt.ptrType || !wt.ptr) && Ar("makeClassHandle requires ptr and ptrType"); var rn = !!wt.smartPtrType, _n = !!wt.smartPtr; return rn !== _n && Ar("Both smartPtrType and smartPtr must be specified"), wt.count = { value: 1 }, dn(Object.create(Et, { $$: { value: wt, writable: !0 } })) }; function Vt(Et) { var wt = this.getPointee(Et); if (!wt) return this.destructor(Et), null; var rn = xi(this.registeredClass, wt); if (rn !== void 0) { if (rn.$$.count.value === 0) return rn.$$.ptr = wt, rn.$$.smartPtr = Et, rn.clone(); var _n = rn.clone(); return this.destructor(Et), _n } function Wn() { return this.isSmartPointer ? Rt(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: wt, smartPtrType: this, smartPtr: Et }) : Rt(this.registeredClass.instancePrototype, { ptrType: this, ptr: Et }) } var or = this.registeredClass.getActualType(wt), gr = Si[or]; if (!gr) return Wn.call(this); var Qn; this.isConst ? Qn = gr.constPointerType : Qn = gr.pointerType; var ur = ti(wt, this.registeredClass, Qn.registeredClass); return ur === null ? Wn.call(this) : this.isSmartPointer ? Rt(Qn.registeredClass.instancePrototype, { ptrType: Qn, ptr: ur, smartPtrType: this, smartPtr: Et }) : Rt(Qn.registeredClass.instancePrototype, { ptrType: Qn, ptr: ur }) } var dn = Et => typeof FinalizationRegistry > "u" ? (dn = wt => wt, Et) : (yr = new FinalizationRegistry(wt => { bi(wt.$$) }), dn = wt => { var rn = wt.$$, _n = !!rn.smartPtr; if (_n) { var Wn = { $$: rn }; yr.register(wt, Wn, wt) } return wt }, dr = wt => yr.unregister(wt), dn(Et)), In = () => { Object.assign(Vn.prototype, { isAliasOf(Et) { if (!(this instanceof Vn) || !(Et instanceof Vn)) return !1; var wt = this.$$.ptrType.registeredClass, rn = this.$$.ptr; Et.$$ = Et.$$; for (var _n = Et.$$.ptrType.registeredClass, Wn = Et.$$.ptr; wt.baseClass;)rn = wt.upcast(rn), wt = wt.baseClass; for (; _n.baseClass;)Wn = _n.upcast(Wn), _n = _n.baseClass; return wt === _n && rn === Wn }, clone() { if (this.$$.ptr || ar(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this; var Et = dn(Object.create(Object.getPrototypeOf(this), { $$: { value: qn(this.$$) } })); return Et.$$.count.value += 1, Et.$$.deleteScheduled = !1, Et }, delete() { this.$$.ptr || ar(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Yn("Object already scheduled for deletion"), dr(this), bi(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0) }, isDeleted() { return !this.$$.ptr }, deleteLater() { return this.$$.ptr || ar(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Yn("Object already scheduled for deletion"), Hi.push(this), Hi.length === 1 && gi && gi(Ai), this.$$.deleteScheduled = !0, this } }) }; function Vn() { } var Nn = (Et, wt) => Object.defineProperty(wt, "name", { value: Et }), ir = (Et, wt, rn) => { if (Et[wt].overloadTable === void 0) { var _n = Et[wt]; Et[wt] = function (...Wn) { return Et[wt].overloadTable.hasOwnProperty(Wn.length) || Yn(`Function '${rn}' called with an invalid number of arguments (${Wn.length}) - expects one of (${Et[wt].overloadTable})!`), Et[wt].overloadTable[Wn.length].apply(this, Wn) }, Et[wt].overloadTable = [], Et[wt].overloadTable[_n.argCount] = _n } }, Jn = (Et, wt, rn) => { me.hasOwnProperty(Et) ? (Yn(`Cannot register public name '${Et}' twice`), ir(me, Et, Et), me.hasOwnProperty(rn) && Yn(`Cannot register multiple overloads of a function with the same number of arguments (${rn})!`), me[Et].overloadTable[rn] = wt) : me[Et] = wt }, ft = 48, qt = 57, sn = Et => { if (Et === void 0) return "_unknown"; Et = Et.replace(/[^a-zA-Z0-9_]/g, "$"); var wt = Et.charCodeAt(0); return wt >= ft && wt <= qt ? `_${Et}` : Et }; function ln(Et, wt, rn, _n, Wn, or, gr, Qn) { this.name = Et, this.constructor = wt, this.instancePrototype = rn, this.rawDestructor = _n, this.baseClass = Wn, this.getActualType = or, this.upcast = gr, this.downcast = Qn, this.pureVirtualFunctions = [] } var pn = (Et, wt, rn) => { for (; wt !== rn;)wt.upcast || Yn(`Expected null or instance of ${rn.name}, got an instance of ${wt.name}`), Et = wt.upcast(Et), wt = wt.baseClass; return Et }; function Tn(Et, wt) { if (wt === null) return this.isReference && Yn(`null is not a valid ${this.name}`), 0; wt.$$ || Yn(`Cannot pass "${wa(wt)}" as a ${this.name}`), wt.$$.ptr || Yn(`Cannot pass deleted object as a pointer of type ${this.name}`); var rn = wt.$$.ptrType.registeredClass, _n = pn(wt.$$.ptr, rn, this.registeredClass); return _n } function $n(Et, wt) { var rn; if (wt === null) return this.isReference && Yn(`null is not a valid ${this.name}`), this.isSmartPointer ? (rn = this.rawConstructor(), Et !== null && Et.push(this.rawDestructor, rn), rn) : 0; (!wt || !wt.$$) && Yn(`Cannot pass "${wa(wt)}" as a ${this.name}`), wt.$$.ptr || Yn(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && wt.$$.ptrType.isConst && Yn(`Cannot convert argument of type ${wt.$$.smartPtrType ? wt.$$.smartPtrType.name : wt.$$.ptrType.name} to parameter type ${this.name}`); var _n = wt.$$.ptrType.registeredClass; if (rn = pn(wt.$$.ptr, _n, this.registeredClass), this.isSmartPointer) switch (wt.$$.smartPtr === void 0 && Yn("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) { case 0: wt.$$.smartPtrType === this ? rn = wt.$$.smartPtr : Yn(`Cannot convert argument of type ${wt.$$.smartPtrType ? wt.$$.smartPtrType.name : wt.$$.ptrType.name} to parameter type ${this.name}`); break; case 1: rn = wt.$$.smartPtr; break; case 2: if (wt.$$.smartPtrType === this) rn = wt.$$.smartPtr; else { var Wn = wt.clone(); rn = this.rawShare(rn, Ki.toHandle(() => Wn.delete())), Et !== null && Et.push(this.rawDestructor, rn) } break; default: Yn("Unsupporting sharing policy") }return rn } function Zn(Et, wt) { if (wt === null) return this.isReference && Yn(`null is not a valid ${this.name}`), 0; wt.$$ || Yn(`Cannot pass "${wa(wt)}" as a ${this.name}`), wt.$$.ptr || Yn(`Cannot pass deleted object as a pointer of type ${this.name}`), wt.$$.ptrType.isConst && Yn(`Cannot convert argument of type ${wt.$$.ptrType.name} to parameter type ${this.name}`); var rn = wt.$$.ptrType.registeredClass, _n = pn(wt.$$.ptr, rn, this.registeredClass); return _n } function rr(Et) { return this.fromWireType(Xe[Et >> 2]) } var br = () => { Object.assign(Un.prototype, { getPointee(Et) { return this.rawGetPointee && (Et = this.rawGetPointee(Et)), Et }, destructor(Et) { this.rawDestructor?.(Et) }, argPackAdvance: Dn, readValueFromPointer: rr, fromWireType: Vt }) }; function Un(Et, wt, rn, _n, Wn, or, gr, Qn, ur, Tr, Ir) { this.name = Et, this.registeredClass = wt, this.isReference = rn, this.isConst = _n, this.isSmartPointer = Wn, this.pointeeType = or, this.sharingPolicy = gr, this.rawGetPointee = Qn, this.rawConstructor = ur, this.rawShare = Tr, this.rawDestructor = Ir, !Wn && wt.baseClass === void 0 ? _n ? (this.toWireType = Tn, this.destructorFunction = null) : (this.toWireType = Zn, this.destructorFunction = null) : this.toWireType = $n } var _r = (Et, wt, rn) => { me.hasOwnProperty(Et) || Ar("Replacing nonexistent public symbol"), me[Et].overloadTable !== void 0 && rn !== void 0 || (me[Et] = wt, me[Et].argCount = rn) }, Lr = (Et, wt, rn) => { Et = Et.replace(/p/g, "i"); var _n = me["dynCall_" + Et]; return _n(wt, ...rn) }, Br = [], ni, wr = Et => { var wt = Br[Et]; return wt || (Et >= Br.length && (Br.length = Et + 1), Br[Et] = wt = ni.get(Et)), wt }, Fr = (Et, wt, rn = []) => { if (Et.includes("j")) return Lr(Et, wt, rn); var _n = wr(wt)(...rn); return _n }, Dr = (Et, wt) => (...rn) => Fr(Et, wt, rn), li = (Et, wt) => { Et = Sn(Et); function rn() { return Et.includes("j") ? Dr(Et, wt) : wr(wt) } var _n = rn(); return typeof _n != "function" && Yn(`unknown function pointer with signature ${Et}: ${wt}`), _n }, Gr = (Et, wt) => {
			var rn = Nn(wt, function (_n) {
				this.name = wt, this.message = _n; var Wn = new Error(_n).stack; Wn !== void 0 && (this.stack = this.toString() + `
`+ Wn.replace(/^Error(:[^\n]*)?\n/, ""))
			}); return rn.prototype = Object.create(Et.prototype), rn.prototype.constructor = rn, rn.prototype.toString = function () { return this.message === void 0 ? this.name : `${this.name}: ${this.message}` }, rn
		}, Wr, ii = Et => { var wt = qs(Et), rn = Sn(wt); return ps(wt), rn }, kr = (Et, wt) => { var rn = [], _n = {}; function Wn(or) { if (!_n[or] && !jn[or]) { if (Pn[or]) { Pn[or].forEach(Wn); return } rn.push(or), _n[or] = !0 } } throw wt.forEach(Wn), new Wr(`${Et}: ` + rn.map(ii).join([", "])) }, Zr = (Et, wt, rn, _n, Wn, or, gr, Qn, ur, Tr, Ir, ei, Kr) => { Ir = Sn(Ir), or = li(Wn, or), Qn &&= li(gr, Qn), Tr &&= li(ur, Tr), Kr = li(ei, Kr); var Zi = sn(Ir); Jn(Zi, function () { kr(`Cannot construct ${Ir} due to unbound types`, [_n]) }), Er([Et, wt, rn], _n ? [_n] : [], oi => { oi = oi[0]; var ba, Wi; _n ? (ba = oi.registeredClass, Wi = ba.instancePrototype) : Wi = Vn.prototype; var Ys = Nn(Ir, function (...Kt) { if (Object.getPrototypeOf(this) !== Na) throw new fr("Use 'new' to construct " + Ir); if (Os.constructor_body === void 0) throw new fr(Ir + " has no accessible constructor"); var tn = Os.constructor_body[Kt.length]; if (tn === void 0) throw new fr(`Tried to invoke ctor of ${Ir} with invalid number of parameters (${Kt.length}) - expected (${Object.keys(Os.constructor_body).toString()}) parameters instead!`); return tn.apply(this, Kt) }), Na = Object.create(Wi, { constructor: { value: Ys } }); Ys.prototype = Na; var Os = new ln(Ir, Ys, Na, Kr, ba, or, Qn, Tr); Os.baseClass && (Os.baseClass.__derivedClasses ??= [], Os.baseClass.__derivedClasses.push(Os)); var Ka = new Un(Ir, Os, !0, !1, !1), at = new Un(Ir + "*", Os, !1, !1, !1), kt = new Un(Ir + " const*", Os, !1, !0, !1); return Si[Et] = { pointerType: at, constPointerType: kt }, _r(Zi, Ys), [Ka, at, kt] }) }, Xr = (Et, wt) => { for (var rn = [], _n = 0; _n < Et; _n++)rn.push(Xe[wt + _n * 4 >> 2]); return rn }, Ri = Et => { for (; Et.length;) { var wt = Et.pop(), rn = Et.pop(); rn(wt) } }; function di(Et) { for (var wt = 1; wt < Et.length; ++wt)if (Et[wt] !== null && Et[wt].destructorFunction === void 0) return !0; return !1 } function yi(Et, wt) { if (!(Et instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof Et} which is not a function`); var rn = Nn(Et.name || "unknownFunctionName", function () { }); rn.prototype = Et.prototype; var _n = new rn, Wn = Et.apply(_n, wt); return Wn instanceof Object ? Wn : _n } function Vi(Et, wt, rn, _n) {
			for (var Wn = di(Et), or = Et.length, gr = "", Qn = "", ur = 0; ur < or - 2; ++ur)gr += (ur !== 0 ? ", " : "") + "arg" + ur, Qn += (ur !== 0 ? ", " : "") + "arg" + ur + "Wired"; var Tr = `
        return function (${gr}) {
        if (arguments.length !== ${or - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${or - 2}');
        }`; Wn && (Tr += `var destructors = [];
`); var Ir = Wn ? "destructors" : "null", ei = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"]; wt && (Tr += "var thisWired = classParam['toWireType'](" + Ir + `, this);
`); for (var ur = 0; ur < or - 2; ++ur)Tr += "var arg" + ur + "Wired = argType" + ur + "['toWireType'](" + Ir + ", arg" + ur + `);
`, ei.push("argType" + ur); if (wt && (Qn = "thisWired" + (Qn.length > 0 ? ", " : "") + Qn), Tr += (rn || _n ? "var rv = " : "") + "invoker(fn" + (Qn.length > 0 ? ", " : "") + Qn + `);
`, Wn) Tr += `runDestructors(destructors);
`; else for (var ur = wt ? 1 : 2; ur < Et.length; ++ur) {
				var Kr = ur === 1 ? "thisWired" : "arg" + (ur - 2) + "Wired"; Et[ur].destructorFunction !== null && (Tr += `${Kr}_dtor(${Kr});
`, ei.push(`${Kr}_dtor`))
			} return rn && (Tr += `var ret = retType['fromWireType'](rv);
return ret;
`), Tr += `}
`, [ei, Tr]
		} function Ji(Et, wt, rn, _n, Wn, or) { var gr = wt.length; gr < 2 && Yn("argTypes array size mismatch! Must at least get return value and 'this' types!"); for (var Qn = wt[1] !== null && rn !== null, ur = di(wt), Tr = wt[0].name !== "void", Ir = [Et, Yn, _n, Wn, Ri, wt[0], wt[1]], ei = 0; ei < gr - 2; ++ei)Ir.push(wt[ei + 2]); if (!ur) for (var ei = Qn ? 1 : 2; ei < wt.length; ++ei)wt[ei].destructorFunction !== null && Ir.push(wt[ei].destructorFunction); let [Kr, Zi] = Vi(wt, Qn, Tr, or); Kr.push(Zi); var oi = yi(Function, Kr)(...Ir); return Nn(Et, oi) } var vs = (Et, wt, rn, _n, Wn, or) => { var gr = Xr(wt, rn); Wn = li(_n, Wn), Er([], [Et], Qn => { Qn = Qn[0]; var ur = `constructor ${Qn.name}`; if (Qn.registeredClass.constructor_body === void 0 && (Qn.registeredClass.constructor_body = []), Qn.registeredClass.constructor_body[wt - 1] !== void 0) throw new fr(`Cannot register multiple constructors with identical number of parameters (${wt - 1}) for class '${Qn.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`); return Qn.registeredClass.constructor_body[wt - 1] = () => { kr(`Cannot construct ${Qn.name} due to unbound types`, gr) }, Er([], gr, Tr => (Tr.splice(1, 0, null), Qn.registeredClass.constructor_body[wt - 1] = Ji(ur, Tr, null, Wn, or), [])), [] }) }, Gs = Et => { Et = Et.trim(); const wt = Et.indexOf("("); return wt !== -1 ? Et.substr(0, wt) : Et }, ya = (Et, wt, rn, _n, Wn, or, gr, Qn, ur) => { var Tr = Xr(rn, _n); wt = Sn(wt), wt = Gs(wt), or = li(Wn, or), Er([], [Et], Ir => { Ir = Ir[0]; var ei = `${Ir.name}.${wt}`; wt.startsWith("@@") && (wt = Symbol[wt.substring(2)]), Qn && Ir.registeredClass.pureVirtualFunctions.push(wt); function Kr() { kr(`Cannot call ${ei} due to unbound types`, Tr) } var Zi = Ir.registeredClass.instancePrototype, oi = Zi[wt]; return oi === void 0 || oi.overloadTable === void 0 && oi.className !== Ir.name && oi.argCount === rn - 2 ? (Kr.argCount = rn - 2, Kr.className = Ir.name, Zi[wt] = Kr) : (ir(Zi, wt, ei), Zi[wt].overloadTable[rn - 2] = Kr), Er([], Tr, ba => { var Wi = Ji(ei, ba, Ir, or, gr, ur); return Zi[wt].overloadTable === void 0 ? (Wi.argCount = rn - 2, Zi[wt] = Wi) : Zi[wt].overloadTable[rn - 2] = Wi, [] }), [] }) }, $s = [], $r = [], Bs = Et => { Et > 9 && --$r[Et + 1] === 0 && ($r[Et] = void 0, $s.push(Et)) }, oa = () => $r.length / 2 - 5 - $s.length, va = () => { $r.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), me.count_emval_handles = oa }, Ki = { toValue: Et => (Et || Yn("Cannot use deleted val. handle = " + Et), $r[Et]), toHandle: Et => { switch (Et) { case void 0: return 2; case null: return 4; case !0: return 6; case !1: return 8; default: { const wt = $s.pop() || $r.length; return $r[wt] = Et, $r[wt + 1] = 1, wt } } } }, Pa = { name: "emscripten::val", fromWireType: Et => { var wt = Ki.toValue(Et); return Bs(Et), wt }, toWireType: (Et, wt) => Ki.toHandle(wt), argPackAdvance: Dn, readValueFromPointer: rr, destructorFunction: null }, Ws = Et => mn(Et, Pa), wa = Et => { if (Et === null) return "null"; var wt = typeof Et; return wt === "object" || wt === "array" || wt === "function" ? Et.toString() : "" + Et }, Le = (Et, wt) => { switch (wt) { case 4: return function (rn) { return this.fromWireType(Ye[rn >> 2]) }; case 8: return function (rn) { return this.fromWireType(Ze[rn >> 3]) }; default: throw new TypeError(`invalid float width (${wt}): ${Et}`) } }, $e = (Et, wt, rn) => { wt = Sn(wt), mn(Et, { name: wt, fromWireType: _n => _n, toWireType: (_n, Wn) => Wn, argPackAdvance: Dn, readValueFromPointer: Le(wt, rn), destructorFunction: null }) }, rt = (Et, wt, rn) => { switch (wt) { case 1: return rn ? _n => Ue[_n] : _n => He[_n]; case 2: return rn ? _n => Ge[_n >> 1] : _n => ze[_n >> 1]; case 4: return rn ? _n => We[_n >> 2] : _n => Xe[_n >> 2]; default: throw new TypeError(`invalid integer width (${wt}): ${Et}`) } }, Pt = (Et, wt, rn, _n, Wn) => { wt = Sn(wt); var or = Ir => Ir; if (_n === 0) { var gr = 32 - 8 * rn; or = Ir => Ir << gr >>> gr } var Qn = wt.includes("unsigned"), ur = (Ir, ei) => { }, Tr; Qn ? Tr = function (Ir, ei) { return ur(ei, this.name), ei >>> 0 } : Tr = function (Ir, ei) { return ur(ei, this.name), ei }, mn(Et, { name: wt, fromWireType: or, toWireType: Tr, argPackAdvance: Dn, readValueFromPointer: rt(wt, rn, _n !== 0), destructorFunction: null }) }, Yt = (Et, wt, rn) => { var _n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Wn = _n[wt]; function or(gr) { var Qn = Xe[gr >> 2], ur = Xe[gr + 4 >> 2]; return new Wn(Ue.buffer, ur, Qn) } rn = Sn(rn), mn(Et, { name: rn, fromWireType: or, argPackAdvance: Dn, readValueFromPointer: or }, { ignoreDuplicateRegistrations: !0 }) }, bn = (Et, wt, rn, _n) => { if (!(_n > 0)) return 0; for (var Wn = rn, or = rn + _n - 1, gr = 0; gr < Et.length; ++gr) { var Qn = Et.charCodeAt(gr); if (Qn >= 55296 && Qn <= 57343) { var ur = Et.charCodeAt(++gr); Qn = 65536 + ((Qn & 1023) << 10) | ur & 1023 } if (Qn <= 127) { if (rn >= or) break; wt[rn++] = Qn } else if (Qn <= 2047) { if (rn + 1 >= or) break; wt[rn++] = 192 | Qn >> 6, wt[rn++] = 128 | Qn & 63 } else if (Qn <= 65535) { if (rn + 2 >= or) break; wt[rn++] = 224 | Qn >> 12, wt[rn++] = 128 | Qn >> 6 & 63, wt[rn++] = 128 | Qn & 63 } else { if (rn + 3 >= or) break; wt[rn++] = 240 | Qn >> 18, wt[rn++] = 128 | Qn >> 12 & 63, wt[rn++] = 128 | Qn >> 6 & 63, wt[rn++] = 128 | Qn & 63 } } return wt[rn] = 0, rn - Wn }, On = (Et, wt, rn) => bn(Et, He, wt, rn), hr = Et => { for (var wt = 0, rn = 0; rn < Et.length; ++rn) { var _n = Et.charCodeAt(rn); _n <= 127 ? wt++ : _n <= 2047 ? wt += 2 : _n >= 55296 && _n <= 57343 ? (wt += 4, ++rn) : wt += 3 } return wt }, pr = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, zr = (Et, wt, rn) => { for (var _n = wt + rn, Wn = wt; Et[Wn] && !(Wn >= _n);)++Wn; if (Wn - wt > 16 && Et.buffer && pr) return pr.decode(Et.subarray(wt, Wn)); for (var or = ""; wt < Wn;) { var gr = Et[wt++]; if (!(gr & 128)) { or += String.fromCharCode(gr); continue } var Qn = Et[wt++] & 63; if ((gr & 224) == 192) { or += String.fromCharCode((gr & 31) << 6 | Qn); continue } var ur = Et[wt++] & 63; if ((gr & 240) == 224 ? gr = (gr & 15) << 12 | Qn << 6 | ur : gr = (gr & 7) << 18 | Qn << 12 | ur << 6 | Et[wt++] & 63, gr < 65536) or += String.fromCharCode(gr); else { var Tr = gr - 65536; or += String.fromCharCode(55296 | Tr >> 10, 56320 | Tr & 1023) } } return or }, Hr = (Et, wt) => Et ? zr(He, Et, wt) : "", Ni = (Et, wt) => { wt = Sn(wt); var rn = wt === "std::string"; mn(Et, { name: wt, fromWireType(_n) { var Wn = Xe[_n >> 2], or = _n + 4, gr; if (rn) for (var Qn = or, ur = 0; ur <= Wn; ++ur) { var Tr = or + ur; if (ur == Wn || He[Tr] == 0) { var Ir = Tr - Qn, ei = Hr(Qn, Ir); gr === void 0 ? gr = ei : (gr += "\0", gr += ei), Qn = Tr + 1 } } else { for (var Kr = new Array(Wn), ur = 0; ur < Wn; ++ur)Kr[ur] = String.fromCharCode(He[or + ur]); gr = Kr.join("") } return ps(_n), gr }, toWireType(_n, Wn) { Wn instanceof ArrayBuffer && (Wn = new Uint8Array(Wn)); var or, gr = typeof Wn == "string"; gr || Wn instanceof Uint8Array || Wn instanceof Uint8ClampedArray || Wn instanceof Int8Array || Yn("Cannot pass non-string to std::string"), rn && gr ? or = hr(Wn) : or = Wn.length; var Qn = As(4 + or + 1), ur = Qn + 4; if (Xe[Qn >> 2] = or, rn && gr) On(Wn, ur, or + 1); else if (gr) for (var Tr = 0; Tr < or; ++Tr) { var Ir = Wn.charCodeAt(Tr); Ir > 255 && (ps(ur), Yn("String has UTF-16 code units that do not fit in 8 bits")), He[ur + Tr] = Ir } else for (var Tr = 0; Tr < or; ++Tr)He[ur + Tr] = Wn[Tr]; return _n !== null && _n.push(ps, Qn), Qn }, argPackAdvance: Dn, readValueFromPointer: rr, destructorFunction(_n) { ps(_n) } }) }, ai = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, vi = (Et, wt) => { for (var rn = Et, _n = rn >> 1, Wn = _n + wt / 2; !(_n >= Wn) && ze[_n];)++_n; if (rn = _n << 1, rn - Et > 32 && ai) return ai.decode(He.subarray(Et, rn)); for (var or = "", gr = 0; !(gr >= wt / 2); ++gr) { var Qn = Ge[Et + gr * 2 >> 1]; if (Qn == 0) break; or += String.fromCharCode(Qn) } return or }, cs = (Et, wt, rn) => { if (rn ??= 2147483647, rn < 2) return 0; rn -= 2; for (var _n = wt, Wn = rn < Et.length * 2 ? rn / 2 : Et.length, or = 0; or < Wn; ++or) { var gr = Et.charCodeAt(or); Ge[wt >> 1] = gr, wt += 2 } return Ge[wt >> 1] = 0, wt - _n }, Fi = Et => Et.length * 2, Bi = (Et, wt) => { for (var rn = 0, _n = ""; !(rn >= wt / 4);) { var Wn = We[Et + rn * 4 >> 2]; if (Wn == 0) break; if (++rn, Wn >= 65536) { var or = Wn - 65536; _n += String.fromCharCode(55296 | or >> 10, 56320 | or & 1023) } else _n += String.fromCharCode(Wn) } return _n }, Di = (Et, wt, rn) => { if (rn ??= 2147483647, rn < 4) return 0; for (var _n = wt, Wn = _n + rn - 4, or = 0; or < Et.length; ++or) { var gr = Et.charCodeAt(or); if (gr >= 55296 && gr <= 57343) { var Qn = Et.charCodeAt(++or); gr = 65536 + ((gr & 1023) << 10) | Qn & 1023 } if (We[wt >> 2] = gr, wt += 4, wt + 4 > Wn) break } return We[wt >> 2] = 0, wt - _n }, _i = Et => { for (var wt = 0, rn = 0; rn < Et.length; ++rn) { var _n = Et.charCodeAt(rn); _n >= 55296 && _n <= 57343 && ++rn, wt += 4 } return wt }, Xs = (Et, wt, rn) => { rn = Sn(rn); var _n, Wn, or, gr; wt === 2 ? (_n = vi, Wn = cs, gr = Fi, or = Qn => ze[Qn >> 1]) : wt === 4 && (_n = Bi, Wn = Di, gr = _i, or = Qn => Xe[Qn >> 2]), mn(Et, { name: rn, fromWireType: Qn => { for (var ur = Xe[Qn >> 2], Tr, Ir = Qn + 4, ei = 0; ei <= ur; ++ei) { var Kr = Qn + 4 + ei * wt; if (ei == ur || or(Kr) == 0) { var Zi = Kr - Ir, oi = _n(Ir, Zi); Tr === void 0 ? Tr = oi : (Tr += "\0", Tr += oi), Ir = Kr + wt } } return ps(Qn), Tr }, toWireType: (Qn, ur) => { typeof ur != "string" && Yn(`Cannot pass non-string to C++ string type ${rn}`); var Tr = gr(ur), Ir = As(4 + Tr + wt); return Xe[Ir >> 2] = Tr / wt, Wn(ur, Ir + 4, Tr + wt), Qn !== null && Qn.push(ps, Ir), Ir }, argPackAdvance: Dn, readValueFromPointer: rr, destructorFunction(Qn) { ps(Qn) } }) }, La = (Et, wt) => { wt = Sn(wt), mn(Et, { isVoid: !0, name: wt, argPackAdvance: 0, fromWireType: () => { }, toWireType: (rn, _n) => { } }) }, oo = (Et, wt, rn) => He.copyWithin(Et, wt, wt + rn), Ds = (Et, wt) => { var rn = jn[Et]; return rn === void 0 && Yn(`${wt} has unknown type ${ii(Et)}`), rn }, bs = (Et, wt, rn) => { var _n = [], Wn = Et.toWireType(_n, rn); return _n.length && (Xe[wt >> 2] = Ki.toHandle(_n)), Wn }, Zo = (Et, wt, rn) => (Et = Ki.toValue(Et), wt = Ds(wt, "emval::as"), bs(wt, rn, Et)), ls = {}, lo = Et => { var wt = ls[Et]; return wt === void 0 ? Sn(Et) : wt }, ja = [], Hs = (Et, wt, rn, _n, Wn) => (Et = ja[Et], wt = Ki.toValue(wt), rn = lo(rn), Et(wt, wt[rn], _n, Wn)), Ks = Et => { var wt = ja.length; return ja.push(Et), wt }, la = (Et, wt) => { for (var rn = new Array(Et), _n = 0; _n < Et; ++_n)rn[_n] = Ds(Xe[wt + _n * 4 >> 2], "parameter " + _n); return rn }, Vs = (Et, wt, rn) => {
			var _n = la(Et, wt), Wn = _n.shift(); Et--; var or = `return function (obj, func, destructorsRef, args) {
`, gr = 0, Qn = []; rn === 0 && Qn.push("obj"); for (var ur = ["retType"], Tr = [Wn], Ir = 0; Ir < Et; ++Ir)Qn.push("arg" + Ir), ur.push("argType" + Ir), Tr.push(_n[Ir]), or += `  var arg${Ir} = argType${Ir}.readValueFromPointer(args${gr ? "+" + gr : ""});
`, gr += _n[Ir].argPackAdvance; var ei = rn === 1 ? "new func" : "func.call"; or += `  var rv = ${ei}(${Qn.join(", ")});
`, Wn.isVoid || (ur.push("emval_returnValue"), Tr.push(bs), or += `  return emval_returnValue(retType, destructorsRef, rv);
`), or += `};
`, ur.push(or); var Kr = yi(Function, ur)(...Tr), Zi = `methodCaller<(${_n.map(oi => oi.name).join(", ")}) => ${Wn.name}>`; return Ks(Nn(Zi, Kr))
		}, co = (Et, wt) => (Et = Ki.toValue(Et), wt = Ki.toValue(wt), Ki.toHandle(Et[wt])), Is = Et => { Et > 9 && ($r[Et + 1] += 1) }, Mo = Et => Ki.toHandle(lo(Et)), uo = Et => { var wt = Ki.toValue(Et); Ri(wt), Bs(Et) }, Wa = (Et, wt) => { Et = Ds(Et, "_emval_take_value"); var rn = Et.readValueFromPointer(wt); return Ki.toHandle(rn) }, Ea = () => 1073741824, Ma = Et => { var wt = ke.buffer, rn = (Et - wt.byteLength + 65535) / 65536; try { return ke.grow(rn), ot(), 1 } catch { } }, fo = Et => { var wt = He.length; Et >>>= 0; var rn = Ea(); if (Et > rn) return !1; for (var _n = (ur, Tr) => ur + (Tr - ur % Tr) % Tr, Wn = 1; Wn <= 4; Wn *= 2) { var or = wt * (1 + .2 / Wn); or = Math.min(or, Et + 100663296); var gr = Math.min(rn, _n(Math.max(Et, or), 65536)), Qn = Ma(gr); if (Qn) return !0 } return !1 }; un(), fr = me.BindingError = class extends Error { constructor(wt) { super(wt), this.name = "BindingError" } }, sr = me.InternalError = class extends Error { constructor(wt) { super(wt), this.name = "InternalError" } }, In(), Ii(), br(), Wr = me.UnboundTypeError = Gr(Error, "UnboundTypeError"), va(); var Oa = { n: en, t: cn, s: Wt, x: Rn, r: Zr, q: vs, k: ya, w: Ws, m: $e, c: Pt, a: Yt, l: Ni, f: Xs, y: La, v: oo, h: Zo, o: Hs, b: Bs, p: Vs, i: co, g: Is, j: Mo, d: uo, e: Wa, u: fo }, Ps = kn(), qs = Et => (qs = Ps.B)(Et), As = Et => (As = Ps.D)(Et), ps = Et => (ps = Ps.E)(Et), Ls = Et => (Ls = Ps.F)(Et); me.addOnPostRun = nn; var ca; an = function Et() { ca || Xa(), ca || (an = Et) }; function Xa() { if ($t > 0 || (Nt(), $t > 0)) return; function Et() { ca || (ca = !0, me.calledRun = !0, !Oe && (Je(), ge(me), me.onRuntimeInitialized && me.onRuntimeInitialized(), jt())) } me.setStatus ? (me.setStatus("Running..."), setTimeout(function () { setTimeout(function () { me.setStatus("") }, 1), Et() }, 1)) : Et() } if (me.preInit) for (typeof me.preInit == "function" && (me.preInit = [me.preInit]); me.preInit.length > 0;)me.preInit.pop()(); return Xa(), pe = ye, pe
	}
})(); function WorkerWrapper$1(fe) { return new Worker("" + new URL("SplatSortWorker-DiSpcAPr.js", import.meta.url).href, { type: "module", name: fe?.name }) } const byteToHex = []; for (let fe = 0; fe < 256; ++fe)byteToHex.push((fe + 256).toString(16).slice(1)); function unsafeStringify(fe, K = 0) { return (byteToHex[fe[K + 0]] + byteToHex[fe[K + 1]] + byteToHex[fe[K + 2]] + byteToHex[fe[K + 3]] + "-" + byteToHex[fe[K + 4]] + byteToHex[fe[K + 5]] + "-" + byteToHex[fe[K + 6]] + byteToHex[fe[K + 7]] + "-" + byteToHex[fe[K + 8]] + byteToHex[fe[K + 9]] + "-" + byteToHex[fe[K + 10]] + byteToHex[fe[K + 11]] + byteToHex[fe[K + 12]] + byteToHex[fe[K + 13]] + byteToHex[fe[K + 14]] + byteToHex[fe[K + 15]]).toLowerCase() } let getRandomValues; const rnds8 = new Uint8Array(16); function rng() { if (!getRandomValues) { if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); getRandomValues = crypto.getRandomValues.bind(crypto) } return getRandomValues(rnds8) } const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = { randomUUID }; function v4(fe, K, pe) { if (native.randomUUID && !fe) return native.randomUUID(); fe = fe || {}; const me = fe.random ?? fe.rng?.() ?? rng(); if (me.length < 16) throw new Error("Random bytes length must be >= 16"); return me[6] = me[6] & 15 | 64, me[8] = me[8] & 63 | 128, unsafeStringify(me) } const GaussianSplatMaterial = shaderMaterial({ numGaussians: 0, focal: [1, 1], viewport: [640, 480], near: 1, far: 100, depthTest: !0, depthWrite: !1, transparent: !0, textureBuffer: null, textureT_camera_groups: null, transitionInState: 0 }, `precision highp usampler2D; // Most important: ints must be 32-bit.
  precision mediump float;

  // Index from the splat sorter.
  attribute uint sortedIndex;

  // Buffers for splat data; each Gaussian gets 4 floats and 4 int32s. We just
  // copy quadjr for this.
  uniform usampler2D textureBuffer;

  // We could also use a uniform to store transforms, but this would be more
  // limiting in terms of the # of groups we can have.
  uniform sampler2D textureT_camera_groups;

  // Various other uniforms...
  uniform uint numGaussians;
  uniform vec2 focal;
  uniform vec2 viewport;
  uniform float near;
  uniform float far;

  // Fade in state between [0, 1].
  uniform float transitionInState;

  out vec4 vRgba;
  out vec2 vPosition;

  // Function to fetch and construct the i-th transform matrix using texelFetch
  mat4 getGroupTransform(uint i) {
    // Calculate the base index for the i-th transform.
    uint baseIndex = i * 3u;

    // Fetch the texels that represent the first 3 rows of the transform. We
    // choose to use row-major here, since it lets us exclude the fourth row of
    // the matrix.
    vec4 row0 = texelFetch(textureT_camera_groups, ivec2(baseIndex + 0u, 0), 0);
    vec4 row1 = texelFetch(textureT_camera_groups, ivec2(baseIndex + 1u, 0), 0);
    vec4 row2 = texelFetch(textureT_camera_groups, ivec2(baseIndex + 2u, 0), 0);

    // Construct the mat4 with the fetched rows.
    mat4 transform = mat4(row0, row1, row2, vec4(0.0, 0.0, 0.0, 1.0));
    return transpose(transform);
  }

  void main () {
    // Get position + scale from float buffer.
    ivec2 texSize = textureSize(textureBuffer, 0);
    uint texStart = sortedIndex << 1u;
    ivec2 texPos0 = ivec2(texStart % uint(texSize.x), texStart / uint(texSize.x));


    // Fetch from textures.
    uvec4 floatBufferData = texelFetch(textureBuffer, texPos0, 0);
    mat4 T_camera_group = getGroupTransform(floatBufferData.w);

    // Any early return will discard the fragment.
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    // Get center wrt camera. modelViewMatrix is T_cam_world.
    vec3 center = uintBitsToFloat(floatBufferData.xyz);
    vec4 c_cam = T_camera_group * vec4(center, 1);
    if (-c_cam.z < near || -c_cam.z > far)
      return;
    vec4 pos2d = projectionMatrix * c_cam;
    float clip = 1.1 * pos2d.w;
    if (pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip)
      return;

    // Read covariance terms.
    ivec2 texPos1 = ivec2((texStart + 1u) % uint(texSize.x), (texStart + 1u) / uint(texSize.x));
    uvec4 intBufferData = texelFetch(textureBuffer, texPos1, 0);

    // Get covariance terms from int buffer.
    uint rgbaUint32 = intBufferData.w;
    vec2 triu01 = unpackHalf2x16(intBufferData.x);
    vec2 triu23 = unpackHalf2x16(intBufferData.y);
    vec2 triu45 = unpackHalf2x16(intBufferData.z);

    // Transition in.
    float startTime = 0.8 * float(sortedIndex) / float(numGaussians);
    float cov_scale = smoothstep(startTime, startTime + 0.2, transitionInState);

    // Do the actual splatting.
    mat3 cov3d = mat3(
        triu01.x, triu01.y, triu23.x,
        triu01.y, triu23.y, triu45.x,
        triu23.x, triu45.x, triu45.y
    );
    mat3 J = mat3(
        // Matrices are column-major.
        focal.x / c_cam.z, 0., 0.0,
        0., focal.y / c_cam.z, 0.0,
        -(focal.x * c_cam.x) / (c_cam.z * c_cam.z), -(focal.y * c_cam.y) / (c_cam.z * c_cam.z), 0.
    );
    mat3 A = J * mat3(T_camera_group);
    mat3 cov_proj = A * cov3d * transpose(A);
    float diag1 = cov_proj[0][0] + 0.3;
    float offDiag = cov_proj[0][1];
    float diag2 = cov_proj[1][1] + 0.3;

    // Eigendecomposition.
    float mid = 0.5 * (diag1 + diag2);
    float radius = length(vec2((diag1 - diag2) / 2.0, offDiag));
    float lambda1 = mid + radius;
    float lambda2 = mid - radius;
    if (lambda2 < 0.0)
      return;
    vec2 diagonalVector = normalize(vec2(offDiag, lambda1 - diag1));
    vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    vRgba = vec4(
      float(rgbaUint32 & uint(0xFF)) / 255.0,
      float((rgbaUint32 >> uint(8)) & uint(0xFF)) / 255.0,
      float((rgbaUint32 >> uint(16)) & uint(0xFF)) / 255.0,
      float(rgbaUint32 >> uint(24)) / 255.0
    );

    // Throw the Gaussian off the screen if it's too close, too far, or too small.
    float weightedDeterminant = vRgba.a * (diag1 * diag2 - offDiag * offDiag);
    if (weightedDeterminant < 0.25)
      return;
    vPosition = position.xy;

    gl_Position = vec4(
        vec2(pos2d) / pos2d.w
            + position.x * v1 / viewport * 2.0
            + position.y * v2 / viewport * 2.0, pos2d.z / pos2d.w, 1.);
  }
`, `precision mediump float;

  uniform vec2 viewport;
  uniform vec2 focal;

  in vec4 vRgba;
  in vec2 vPosition;

  void main () {
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    float B = exp(A) * vRgba.a;
    if (B < 0.01) discard;  // alphaTest.
    gl_FragColor = vec4(vRgba.rgb, B);
  }`); function useGaussianMeshProps(fe, K) { const pe = fe.length / 8, me = useThree(Ce => Ce.gl).capabilities.maxTextureSize, ge = new InstancedBufferGeometry; ge.instanceCount = pe, ge.setIndex(new BufferAttribute(new Uint32Array([0, 2, 1, 0, 3, 2]), 1)), ge.setAttribute("position", new BufferAttribute(new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]), 2)); const xe = new InstancedBufferAttribute(new Uint32Array(pe), 1); xe.setUsage(DynamicDrawUsage), ge.setAttribute("sortedIndex", xe); const ye = Math.min(pe * 2, me), ve = Math.ceil(pe * 2 / ye), _e = new Uint32Array(ye * ve * 4); _e.set(fe); const Ee = new DataTexture(_e, ye, ve, RGBAIntegerFormat, UnsignedIntType); Ee.internalFormat = "RGBA32UI", Ee.needsUpdate = !0; const be = new Float32Array(K * 12), Ae = new DataTexture(be, K * 12 / 4, 1, RGBAFormat, FloatType); Ae.internalFormat = "RGBA32F", Ae.needsUpdate = !0; const Se = new GaussianSplatMaterial; return Se.textureBuffer = Ee, Se.textureT_camera_groups = Ae, Se.numGaussians = pe, Se.focal = [640, 480], { geometry: ge, material: Se, textureBuffer: Ee, sortedIndexAttribute: xe, textureT_camera_groups: Ae, rowMajorT_camera_groups: be } } function useGaussianSplatStore() { const fe = React$4.useRef({}); return React$4.useState(() => create$3(K => ({ groupBufferFromId: {}, nodeRefFromId: fe, setBuffer: (pe, me) => K(ge => ({ groupBufferFromId: { ...ge.groupBufferFromId, [pe]: me } })), removeBuffer: pe => K(me => { const { [pe]: ge, ...xe } = me.groupBufferFromId; return { groupBufferFromId: xe } }) })))[0] } const GaussianSplatsContext = React$4.createContext(null); function SplatRenderContext({ children: fe }) { const K = useGaussianSplatStore(); return jsxRuntimeExports.jsxs(GaussianSplatsContext.Provider, { value: { useGaussianSplatStore: K, updateCamera: React$4.useRef(null), meshPropsRef: React$4.useRef(null) }, children: [jsxRuntimeExports.jsx(SplatRenderer, {}), fe] }) } const SplatObject = React$4.forwardRef(function ({ buffer: K, children: pe }, me) { const ge = React$4.useContext(GaussianSplatsContext), xe = ge.useGaussianSplatStore(Ee => Ee.setBuffer), ye = ge.useGaussianSplatStore(Ee => Ee.removeBuffer), ve = ge.useGaussianSplatStore(Ee => Ee.nodeRefFromId), _e = React$4.useMemo(() => v4(), [K]); return React$4.useEffect(() => (xe(_e, K), () => { ye(_e), delete ve.current[_e] }), [K]), jsxRuntimeExports.jsx("group", { ref: Ee => { Ee !== null && (me !== null && ("current" in me ? me.current = Ee : me(Ee)), ve.current[_e] = Ee) }, children: pe }) }); function SplatRenderer() { const K = React$4.useContext(GaussianSplatsContext).useGaussianSplatStore(pe => pe.groupBufferFromId); return Object.keys(K).length > 0 ? jsxRuntimeExports.jsx(SplatRendererImpl, {}) : null } function SplatRendererImpl() { const fe = React$4.useContext(GaussianSplatsContext), K = fe.useGaussianSplatStore(Be => Be.groupBufferFromId), pe = fe.useGaussianSplatStore(Be => Be.nodeRefFromId), me = mergeGaussianGroups(K), ge = useGaussianMeshProps(me.gaussianBuffer, me.numGroups); fe.meshPropsRef.current = ge; const xe = new WorkerWrapper$1; let ye = !1; xe.onmessage = Be => { const De = Be.data.sortedIndices; ge.sortedIndexAttribute.set(De), ge.sortedIndexAttribute.needsUpdate = !0, ye || (ge.material.uniforms.numGaussians.value = me.numGaussians, ge.textureBuffer.needsUpdate = !0, ye = !0) }; function ve(Be) { xe.postMessage(Be) } ve({ setBuffer: me.gaussianBuffer, setGroupIndices: me.groupIndices }), React$4.useEffect(() => () => { ge.textureBuffer.dispose(), ge.geometry.dispose(), ge.material.dispose(), ve({ close: !0 }) }); const _e = React$4.useRef(null), Ee = new Matrix4, be = new Float32Array(me.numGroups * 4), Ae = ge.rowMajorT_camera_groups.slice().fill(0), Se = [], Ce = React$4.useRef(null); React$4.useEffect(() => { (async () => Ce.current = new (await Module()).Sorter(me.gaussianBuffer, me.groupIndices))() }, [me.gaussianBuffer, me.groupIndices]); const we = React$4.useCallback(function (De, Re, Ie, Pe) { const Ne = De.fov * Math.PI / 180, ke = Re / Ie, Oe = 2 * Math.atan(Math.tan(Ne / 2) * ke), Ue = Ie / (2 * Math.tan(Ne / 2)), He = Re / (2 * Math.tan(Oe / 2)); if (ge.material === void 0) return; const Ge = ge.material.uniforms; Ge.focal.value = [He, Ue], Ge.near.value = De.near, Ge.far.value = De.far, Ge.viewport.value = [Re, Ie], De.updateMatrixWorld(); const ze = De.matrixWorldInverse, We = []; let Xe = !1; for (const [Ze, ot] of Object.keys(K).entries()) { const qe = pe.current[ot]; if (qe === void 0) continue; Ee.copy(ze).multiply(qe.matrixWorld); const Qe = Ee.elements; be.set([Qe[2], Qe[6], Qe[10], Qe[14]], Ze * 4); const st = Ee.transpose().elements; ge.rowMajorT_camera_groups.set(st.slice(0, 12), Ze * 12); let Nt = qe.visible && qe.parent !== null; Nt && qe.traverseAncestors(Je => { Nt = Nt && Je.visible }), We.push(Nt && Se[Ze] === !0), Se[Ze] !== Nt && (Se[Ze] = Nt, Xe = !0) } const Ye = !ge.rowMajorT_camera_groups.every((Ze, ot) => Ze === Ae[ot]); if (Ye) if (Pe && Ce.current !== null) { const Ze = Ce.current.sort(be); ge.sortedIndexAttribute.set(Ze), ge.sortedIndexAttribute.needsUpdate = !0 } else ve({ setTz_camera_groups: be }); if (Ye || Xe) { for (const [Ze, ot] of We.entries()) ot || (ge.rowMajorT_camera_groups[Ze * 12 + 3] = 1e10, ge.rowMajorT_camera_groups[Ze * 12 + 7] = 1e10, ge.rowMajorT_camera_groups[Ze * 12 + 11] = 1e10); Ae.set(ge.rowMajorT_camera_groups), ge.textureT_camera_groups.needsUpdate = !0 } }, [ge]); return fe.updateCamera.current = we, useFrame((Be, De) => { if (_e.current === null || xe === null || ge.rowMajorT_camera_groups.length === 0) return; const Ie = ge.material.uniforms; Ie.transitionInState.value = Math.min(Ie.transitionInState.value + De * 2, 1), we(Be.camera, Be.viewport.dpr * Be.size.width, Be.viewport.dpr * Be.size.height, !1) }, -100), jsxRuntimeExports.jsx("mesh", { ref: _e, geometry: ge.geometry, material: ge.material, renderOrder: 1e4 }) } function mergeGaussianGroups(fe) { let K = 0; for (const ve of Object.values(fe)) K += ve.length; const pe = K / 8, me = new Uint32Array(K), ge = new Uint32Array(pe); let xe = 0; for (const [ve, _e] of Object.values(fe).entries()) { ge.fill(ve, xe / 8, (xe + _e.length) / 8), me.set(_e, xe); for (let Ee = 0; Ee < _e.length; Ee += 8)me[xe + Ee + 3] = ve; xe += _e.length } const ye = Object.keys(fe).length; return { numGaussians: pe, gaussianBuffer: me, numGroups: ye, groupIndices: ge } } const GuiComponentContext = reactExports.createContext({ folderDepth: 0, setValue: () => { }, messageSender: () => { }, GuiContainer: () => { throw new Error("GuiComponentContext not initialized") } }); var htmlIconWrapper = "_11mcxao0", sliderDefaultMarks = "_11mcxao1"; function toMantineColor(fe) { if (fe !== null) { if (Array.isArray(fe)) { const [K, pe, me] = fe; return `#${K.toString(16).padStart(2, "0")}${pe.toString(16).padStart(2, "0")}${me.toString(16).padStart(2, "0")}` } return fe } } function rgbToString(fe) { return `rgb(${Math.round(fe[0])}, ${Math.round(fe[1])}, ${Math.round(fe[2])})` } function rgbaToString(fe) { return `rgba(${Math.round(fe[0])}, ${Math.round(fe[1])}, ${Math.round(fe[2])}, ${fe[3].toFixed(2)})` } function parseToRgb(fe) { const K = fe.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/); if (K) return [parseInt(K[1]), parseInt(K[2]), parseInt(K[3])]; const pe = fe.match(/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/); if (pe) { const me = pe[1]; let ge, xe, ye; return me.length === 3 ? (ge = parseInt(me[0] + me[0], 16), xe = parseInt(me[1] + me[1], 16), ye = parseInt(me[2] + me[2], 16)) : (ge = parseInt(me.substring(0, 2), 16), xe = parseInt(me.substring(2, 4), 16), ye = parseInt(me.substring(4, 6), 16)), [ge, xe, ye] } return null } function parseToRgba(fe) { const K = fe.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/); if (K) return [parseInt(K[1]), parseInt(K[2]), parseInt(K[3]), parseFloat(K[4])]; const pe = fe.match(/^#([0-9A-Fa-f]{3,8})$/); if (pe) { const ge = pe[1]; let xe, ye, ve, _e = 1; if (ge.length === 3) xe = parseInt(ge[0] + ge[0], 16), ye = parseInt(ge[1] + ge[1], 16), ve = parseInt(ge[2] + ge[2], 16); else if (ge.length === 4) xe = parseInt(ge[0] + ge[0], 16), ye = parseInt(ge[1] + ge[1], 16), ve = parseInt(ge[2] + ge[2], 16), _e = parseInt(ge[3] + ge[3], 16) / 255; else if (ge.length === 6) xe = parseInt(ge.substring(0, 2), 16), ye = parseInt(ge.substring(2, 4), 16), ve = parseInt(ge.substring(4, 6), 16); else if (ge.length === 8) xe = parseInt(ge.substring(0, 2), 16), ye = parseInt(ge.substring(2, 4), 16), ve = parseInt(ge.substring(4, 6), 16), _e = parseInt(ge.substring(6, 8), 16) / 255; else return null; return [xe, ye, ve, _e] } const me = parseToRgb(fe); return me ? [...me, 1] : null } function rgbEqual(fe, K) { return fe[0] === K[0] && fe[1] === K[1] && fe[2] === K[2] } function rgbaEqual(fe, K) { return fe[0] === K[0] && fe[1] === K[1] && fe[2] === K[2] && Math.abs(fe[3] - K[3]) < .001 } function ButtonComponent({ uuid: fe, props: { visible: K, disabled: pe, label: me, color: ge, _icon_html: xe } }) { const { messageSender: ye } = React$4.useContext(GuiComponentContext); return K ?? !0 ? jsxRuntimeExports.jsx(Box, { mx: "xs", pb: "0.5em", children: jsxRuntimeExports.jsx(Button, { id: fe, fullWidth: !0, color: toMantineColor(ge), onClick: () => ye({ type: "GuiUpdateMessage", uuid: fe, updates: { value: !0 } }), style: { height: "2em" }, disabled: pe ?? !1, size: "sm", leftSection: xe === null ? void 0 : jsxRuntimeExports.jsx("div", { className: htmlIconWrapper, dangerouslySetInnerHTML: { __html: xe } }), children: me }) }) : null } function ViserInputComponent({ uuid: fe, label: K, hint: pe, children: me }) { const { folderDepth: ge } = reactExports.useContext(GuiComponentContext); return pe != null && (me = jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: pe, multiline: !0, style: { width: "15rem" }, withArrow: !0, openDelay: 500, withinPortal: !0, children: jsxRuntimeExports.jsx(Box, { children: me }) })), K !== void 0 && (me = jsxRuntimeExports.jsx(LabeledInput, { uuid: fe, label: K, input: me, folderDepth: ge })), jsxRuntimeExports.jsx(Box, { pb: "0.5em", px: "xs", children: me }) } function LabeledInput(fe) { return jsxRuntimeExports.jsxs(Flex, { align: "center", children: [jsxRuntimeExports.jsx(Box, { pr: "xs", style: { width: `${7.25 - fe.folderDepth * .6375}em`, flexShrink: 0, position: "relative" }, children: jsxRuntimeExports.jsx(Text, { c: "dimmed", style: { fontSize: "0.875em", fontWeight: "450", lineHeight: "1.375em", letterSpacing: "-0.75px", width: "100%", boxSizing: "content-box" }, unselectable: "off", children: jsxRuntimeExports.jsx("label", { htmlFor: fe.uuid, children: fe.label }) }) }), jsxRuntimeExports.jsx(Box, { style: { flexGrow: 1 }, children: fe.input })] }) } function VectorInput(fe) { return jsxRuntimeExports.jsx(Flex, { justify: "space-between", columnGap: "0.5em", children: [...Array(fe.n).keys()].map(K => jsxRuntimeExports.jsx(NumberInput, { id: K === 0 ? fe.uuid : void 0, value: fe.value[K], onChange: pe => { const me = [...fe.value]; me[K] = pe === "" ? 0 : Number(pe), fe.onChange(me) }, size: "xs", styles: { root: { flexGrow: 1, width: 0 }, input: { paddingLeft: "0.5em", paddingRight: "1.75em", textAlign: "right", height: "1.875em", minHeight: "1.875em" }, controls: { height: "1.25em", width: "0.825em" } }, rightSectionWidth: "1em", decimalScale: fe.precision, step: fe.step, min: fe.min === null ? void 0 : fe.min[K], max: fe.max === null ? void 0 : fe.max[K], stepHoldDelay: 500, stepHoldInterval: pe => Math.max(1e3 / pe ** 2, 25), disabled: fe.disabled }, K)) }) } function SliderComponent({ uuid: fe, value: K, props: { label: pe, hint: me, visible: ge, disabled: xe, min: ye, max: ve, precision: _e, step: Ee, _marks: be } }) { const { setValue: Ae } = React$4.useContext(GuiComponentContext); if (!ge) return null; const Se = we => Ae(fe, we), Ce = jsxRuntimeExports.jsxs(Flex, { justify: "space-between", children: [jsxRuntimeExports.jsx(Slider, { id: fe, className: be === null ? sliderDefaultMarks : void 0, size: "xs", thumbSize: 0, radius: "xs", style: { flexGrow: 1 }, styles: we => ({ thumb: { height: "0.75rem", width: "0.5rem", background: we.colors[we.primaryColor][6] }, trackContainer: { zIndex: 3, position: "relative" }, markLabel: { transform: "translate(-50%, 0.05rem)", fontSize: "0.6rem", textAlign: "center" }, mark: { transform: "scale(2)" } }), pt: "0.3em", pb: "0.2em", showLabelOnHover: !1, min: ye, max: ve, step: Ee ?? void 0, precision: _e, value: K, onChange: Se, marks: be === null ? [{ value: ye, label: `${ye.toFixed(6).replace(/\.?0+$/, "")}` }, { value: ve, label: `${ve.toFixed(6).replace(/\.?0+$/, "")}` }] : be, disabled: xe }), jsxRuntimeExports.jsx(NumberInput, { value: K, onChange: we => { we !== "" && Se(Number(we)) }, size: "xs", min: ye, max: ve, hideControls: !0, step: Ee ?? void 0, style: { width: "3rem" }, styles: { input: { padding: "0.375em", letterSpacing: "-0.5px", minHeight: "1.875em", height: "1.875em" } }, ml: "xs" })] }); return jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: me, label: pe, children: Ce }) } function NumberInputComponent({ uuid: fe, value: K, props: { visible: pe, label: me, hint: ge, disabled: xe, precision: ye, min: ve, max: _e, step: Ee } }) { const { setValue: be } = reactExports.useContext(GuiComponentContext); return pe ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: ge, label: me, children: jsxRuntimeExports.jsx(NumberInput, { id: fe, value: K, decimalScale: ye, min: ve ?? void 0, max: _e ?? void 0, step: Ee, size: "xs", onChange: Ae => { Ae !== "" && be(fe, Ae) }, styles: { input: { minHeight: "1.625rem", height: "1.625rem" }, controls: { height: "1.625em", width: "0.825em" } }, disabled: xe, stepHoldDelay: 500, stepHoldInterval: Ae => Math.max(1e3 / Ae ** 2, 25) }) }) : null } function TextInputComponent({ uuid: fe, value: K, props: { hint: pe, label: me, disabled: ge, visible: xe, multiline: ye } }) { const { setValue: ve } = reactExports.useContext(GuiComponentContext); return xe ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: pe, label: me, children: ye ? jsxRuntimeExports.jsx(Textarea, { value: K, size: "xs", onChange: _e => { ve(fe, _e.target.value) }, styles: { input: { padding: "0 0.5em" } }, disabled: ge, minRows: 2, maxRows: 6, autosize: !0, resize: "vertical" }) : jsxRuntimeExports.jsx(TextInput, { value: K, size: "xs", onChange: _e => { ve(fe, _e.target.value) }, styles: { input: { minHeight: "1.625rem", height: "1.625rem", padding: "0 0.5em" } }, disabled: ge }) }) : null } function CheckboxComponent({ uuid: fe, value: K, props: { disabled: pe, visible: me, hint: ge, label: xe } }) { const { setValue: ye } = reactExports.useContext(GuiComponentContext); if (!me) return null; let ve = jsxRuntimeExports.jsx(Checkbox, { id: fe, checked: K, size: "xs", onChange: _e => { ye(fe, _e.target.checked) }, disabled: pe }); return ge != null && (ve = jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: ge, multiline: !0, style: { width: "15rem" }, withArrow: !0, openDelay: 500, withinPortal: !0, children: jsxRuntimeExports.jsx(Box, { style: { display: "inline-block" }, children: ve }) })), jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, label: xe, children: ve }) } function Vector2Component({ uuid: fe, value: K, props: { hint: pe, label: me, visible: ge, disabled: xe, min: ye, max: ve, step: _e, precision: Ee } }) { const { setValue: be } = reactExports.useContext(GuiComponentContext); return ge ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: pe, label: me, children: jsxRuntimeExports.jsx(VectorInput, { uuid: fe, n: 2, value: K, onChange: Ae => be(fe, Ae), min: ye, max: ve, step: _e, precision: Ee, disabled: xe }) }) : null } function Vector3Component({ uuid: fe, value: K, props: { hint: pe, label: me, visible: ge, disabled: xe, min: ye, max: ve, step: _e, precision: Ee } }) { const { setValue: be } = reactExports.useContext(GuiComponentContext); return ge ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: pe, label: me, children: jsxRuntimeExports.jsx(VectorInput, { uuid: fe, n: 3, value: K, onChange: Ae => be(fe, Ae), min: ye, max: ve, step: _e, precision: Ee, disabled: xe }) }) : null } function DropdownComponent({ uuid: fe, value: K, props: { hint: pe, label: me, disabled: ge, visible: xe, options: ye } }) { const { setValue: ve } = reactExports.useContext(GuiComponentContext); return xe ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: pe, label: me, children: jsxRuntimeExports.jsx(Select, { id: fe, radius: "xs", value: K, data: ye, onChange: _e => _e !== null && ve(fe, _e), disabled: ge, searchable: !0, maxDropdownHeight: 400, size: "xs", rightSectionWidth: "1.2em", styles: { input: { padding: "0.5em", letterSpacing: "-0.5px", minHeight: "1.625rem", height: "1.625rem" } }, comboboxProps: { zIndex: 1e3 } }) }) : null }/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var defaultAttributes = { outline: { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, filled: { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "currentColor", stroke: "none" } };/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */const createReactComponent = (fe, K, pe, me) => { const ge = reactExports.forwardRef(({ color: xe = "currentColor", size: ye = 24, stroke: ve = 2, title: _e, className: Ee, children: be, ...Ae }, Se) => reactExports.createElement("svg", { ref: Se, ...defaultAttributes[fe], width: ye, height: ye, className: ["tabler-icon", `tabler-icon-${K}`, Ee].join(" "), ...fe === "filled" ? { fill: xe } : { strokeWidth: ve, stroke: xe }, ...Ae }, [_e && reactExports.createElement("title", { key: "svg-title" }, _e), ...me.map(([Ce, we]) => reactExports.createElement(Ce, we)), ...Array.isArray(be) ? be : [be]])); return ge.displayName = `${pe}`, ge };/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconAdjustments = createReactComponent("outline", "adjustments", "IconAdjustments", [["path", { d: "M4 10a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }], ["path", { d: "M6 4v4", key: "svg-1" }], ["path", { d: "M6 12v8", key: "svg-2" }], ["path", { d: "M10 16a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-3" }], ["path", { d: "M12 4v10", key: "svg-4" }], ["path", { d: "M12 18v2", key: "svg-5" }], ["path", { d: "M16 7a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-6" }], ["path", { d: "M18 4v1", key: "svg-7" }], ["path", { d: "M18 9v11", key: "svg-8" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconArrowBack = createReactComponent("outline", "arrow-back", "IconArrowBack", [["path", { d: "M9 11l-4 4l4 4m-4 -4h11a4 4 0 0 0 0 -8h-1", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconBrandGithub = createReactComponent("outline", "brand-github", "IconBrandGithub", [["path", { d: "M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconCaretDown = createReactComponent("outline", "caret-down", "IconCaretDown", [["path", { d: "M6 10l6 6l6 -6h-12", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconCaretRight = createReactComponent("outline", "caret-right", "IconCaretRight", [["path", { d: "M10 18l6 -6l-6 -6v12", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconCheck = createReactComponent("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconChevronDown = createReactComponent("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconChevronUp = createReactComponent("outline", "chevron-up", "IconChevronUp", [["path", { d: "M6 15l6 -6l6 6", key: "svg-0" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconCloudCheck = createReactComponent("outline", "cloud-check", "IconCloudCheck", [["path", { d: "M11 18.004h-4.343c-2.572 -.004 -4.657 -2.011 -4.657 -4.487c0 -2.475 2.085 -4.482 4.657 -4.482c.393 -1.762 1.794 -3.2 3.675 -3.773c1.88 -.572 3.956 -.193 5.444 1c1.488 1.19 2.162 3.007 1.77 4.769h.99c1.388 0 2.585 .82 3.138 2.007", key: "svg-0" }], ["path", { d: "M15 19l2 2l4 -4", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconColorPicker = createReactComponent("outline", "color-picker", "IconColorPicker", [["path", { d: "M11 7l6 6", key: "svg-0" }], ["path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconCopy = createReactComponent("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconDeviceFloppy = createReactComponent("outline", "device-floppy", "IconDeviceFloppy", [["path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2", key: "svg-0" }], ["path", { d: "M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M14 4l0 4l-6 0l0 -4", key: "svg-2" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconDownload = createReactComponent("outline", "download", "IconDownload", [["path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2", key: "svg-0" }], ["path", { d: "M7 11l5 5l5 -5", key: "svg-1" }], ["path", { d: "M12 4l0 12", key: "svg-2" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconEyeOff = createReactComponent("outline", "eye-off", "IconEyeOff", [["path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828", key: "svg-0" }], ["path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87", key: "svg-1" }], ["path", { d: "M3 3l18 18", key: "svg-2" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconEyeX = createReactComponent("outline", "eye-x", "IconEyeX", [["path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }], ["path", { d: "M13.048 17.942a9.298 9.298 0 0 1 -1.048 .058c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6a17.986 17.986 0 0 1 -1.362 1.975", key: "svg-1" }], ["path", { d: "M22 22l-5 -5", key: "svg-2" }], ["path", { d: "M17 22l5 -5", key: "svg-3" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconEye = createReactComponent("outline", "eye", "IconEye", [["path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }], ["path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconFileDescription = createReactComponent("outline", "file-description", "IconFileDescription", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M9 17h6", key: "svg-2" }], ["path", { d: "M9 13h6", key: "svg-3" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconHomeMove = createReactComponent("outline", "home-move", "IconHomeMove", [["path", { d: "M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2", key: "svg-0" }], ["path", { d: "M19 12h2l-9 -9l-9 9h2v7a2 2 0 0 0 2 2h5.5", key: "svg-1" }], ["path", { d: "M16 19h6", key: "svg-2" }], ["path", { d: "M19 16l3 3l-3 3", key: "svg-3" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconKeyboard = createReactComponent("outline", "keyboard", "IconKeyboard", [["path", { d: "M2 6m0 2a2 2 0 0 1 2 -2h16a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-16a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M6 10l0 .01", key: "svg-1" }], ["path", { d: "M10 10l0 .01", key: "svg-2" }], ["path", { d: "M14 10l0 .01", key: "svg-3" }], ["path", { d: "M18 10l0 .01", key: "svg-4" }], ["path", { d: "M6 14l0 .01", key: "svg-5" }], ["path", { d: "M18 14l0 .01", key: "svg-6" }], ["path", { d: "M10 14l4 .01", key: "svg-7" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconMaximize = createReactComponent("outline", "maximize", "IconMaximize", [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconPencil = createReactComponent("outline", "pencil", "IconPencil", [["path", { d: "M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4", key: "svg-0" }], ["path", { d: "M13.5 6.5l4 4", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconPhoto = createReactComponent("outline", "photo", "IconPhoto", [["path", { d: "M15 8h.01", key: "svg-0" }], ["path", { d: "M3 6a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3v-12z", key: "svg-1" }], ["path", { d: "M3 16l5 -5c.928 -.893 2.072 -.893 3 0l5 5", key: "svg-2" }], ["path", { d: "M14 14l1 -1c.928 -.893 2.072 -.893 3 0l3 3", key: "svg-3" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconPlugConnectedX = createReactComponent("outline", "plug-connected-x", "IconPlugConnectedX", [["path", { d: "M20 16l-4 4", key: "svg-0" }], ["path", { d: "M7 12l5 5l-1.5 1.5a3.536 3.536 0 1 1 -5 -5l1.5 -1.5z", key: "svg-1" }], ["path", { d: "M17 12l-5 -5l1.5 -1.5a3.536 3.536 0 1 1 5 5l-1.5 1.5z", key: "svg-2" }], ["path", { d: "M3 21l2.5 -2.5", key: "svg-3" }], ["path", { d: "M18.5 5.5l2.5 -2.5", key: "svg-4" }], ["path", { d: "M10 11l-2 2", key: "svg-5" }], ["path", { d: "M13 14l-2 2", key: "svg-6" }], ["path", { d: "M16 16l4 4", key: "svg-7" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconQrcodeOff = createReactComponent("outline", "qrcode-off", "IconQrcodeOff", [["path", { d: "M8 4h1a1 1 0 0 1 1 1v1m-.297 3.711a1 1 0 0 1 -.703 .289h-4a1 1 0 0 1 -1 -1v-4c0 -.275 .11 -.524 .29 -.705", key: "svg-0" }], ["path", { d: "M7 17v.01", key: "svg-1" }], ["path", { d: "M14 4m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M7 7v.01", key: "svg-3" }], ["path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-4" }], ["path", { d: "M17 7v.01", key: "svg-5" }], ["path", { d: "M20 14v.01", key: "svg-6" }], ["path", { d: "M14 14v3", key: "svg-7" }], ["path", { d: "M14 20h3", key: "svg-8" }], ["path", { d: "M3 3l18 18", key: "svg-9" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconQrcode = createReactComponent("outline", "qrcode", "IconQrcode", [["path", { d: "M4 4m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M7 17l0 .01", key: "svg-1" }], ["path", { d: "M14 4m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M7 7l0 .01", key: "svg-3" }], ["path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-4" }], ["path", { d: "M17 7l0 .01", key: "svg-5" }], ["path", { d: "M14 14l3 0", key: "svg-6" }], ["path", { d: "M20 14l0 .01", key: "svg-7" }], ["path", { d: "M14 14l0 3", key: "svg-8" }], ["path", { d: "M14 20l3 0", key: "svg-9" }], ["path", { d: "M17 17l3 0", key: "svg-10" }], ["path", { d: "M20 17l0 3", key: "svg-11" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconShare = createReactComponent("outline", "share", "IconShare", [["path", { d: "M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-0" }], ["path", { d: "M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M8.7 10.7l6.6 -3.4", key: "svg-3" }], ["path", { d: "M8.7 13.3l6.6 3.4", key: "svg-4" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconPlayerPauseFilled = createReactComponent("filled", "player-pause-filled", "IconPlayerPauseFilled", [["path", { d: "M9 4h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h2a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2z", key: "svg-0" }], ["path", { d: "M17 4h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h2a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2z", key: "svg-1" }]]);/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */var IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "IconPlayerPlayFilled", [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]]); function RgbComponent({ uuid: fe, value: K, props: { label: pe, hint: me, disabled: ge, visible: xe } }) { const { setValue: ye } = reactExports.useContext(GuiComponentContext), [ve, _e] = reactExports.useState(rgbToString(K)); return reactExports.useEffect(() => { const Ee = parseToRgb(ve); (!Ee || !rgbEqual(Ee, K)) && _e(rgbToString(K)) }, [K]), xe ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: me, label: pe, children: jsxRuntimeExports.jsx(ColorInput, { disabled: ge, size: "xs", value: ve, format: "rgb", eyeDropperIcon: jsxRuntimeExports.jsx(IconColorPicker, { size: 18, stroke: 1.5 }), popoverProps: { zIndex: 1e3 }, styles: { input: { height: "1.625rem", minHeight: "1.625rem" } }, onChange: Ee => { if (_e(Ee), Ee.startsWith("rgb(")) { const be = parseToRgb(Ee); be && !rgbEqual(be, K) && ye(fe, be) } }, onKeyDown: Ee => { if (Ee.key === "Enter") { const be = parseToRgb(ve); be && ye(fe, be) } }, onBlur: () => { const Ee = parseToRgb(ve); Ee && !rgbEqual(Ee, K) && ye(fe, Ee) } }) }) : null } function RgbaComponent({ uuid: fe, value: K, props: { label: pe, hint: me, disabled: ge, visible: xe } }) { const { setValue: ye } = reactExports.useContext(GuiComponentContext), [ve, _e] = reactExports.useState(rgbaToString(K)); return reactExports.useEffect(() => { const Ee = parseToRgba(ve); (!Ee || !rgbaEqual(Ee, K)) && _e(rgbaToString(K)) }, [K, ve]), xe ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: me, label: pe, children: jsxRuntimeExports.jsx(ColorInput, { disabled: ge, size: "xs", value: ve, format: "rgba", eyeDropperIcon: jsxRuntimeExports.jsx(IconColorPicker, { size: 18, stroke: 1.5 }), popoverProps: { zIndex: 1e3 }, styles: { input: { height: "1.625rem", minHeight: "1.625rem" } }, onChange: Ee => { if (_e(Ee), Ee.startsWith("rgba(")) { const be = parseToRgba(Ee); be && !rgbaEqual(be, K) && ye(fe, be) } }, onKeyDown: Ee => { if (Ee.key === "Enter") { const be = parseToRgba(ve); be && ye(fe, be) } }, onBlur: () => { const Ee = parseToRgba(ve); Ee && !rgbaEqual(Ee, K) && ye(fe, Ee) } }) }) : null } function ButtonGroupComponent({ uuid: fe, props: { hint: K, label: pe, visible: me, disabled: ge, options: xe } }) { const { messageSender: ye } = reactExports.useContext(GuiComponentContext); return me ? jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: K, label: pe, children: jsxRuntimeExports.jsx(Flex, { justify: "space-between", columnGap: "xs", children: xe.map((ve, _e) => jsxRuntimeExports.jsx(Button, { onClick: () => ye({ type: "GuiUpdateMessage", uuid: fe, updates: { value: ve } }), style: { flexGrow: 1, wuuidth: 0 }, disabled: ge, size: "compact-xs", variant: "outline", children: ve }, _e)) }) }) : null } const emptyComponents = {}, MDXContext = React$4.createContext(emptyComponents); function useMDXComponents(fe) { const K = React$4.useContext(MDXContext); return React$4.useMemo(function () { return typeof fe == "function" ? fe(K) : { ...K, ...fe } }, [K, fe]) } function MDXProvider(fe) { let K; return fe.disableParentContext ? K = typeof fe.components == "function" ? fe.components(emptyComponents) : fe.components || emptyComponents : K = useMDXComponents(fe.components), React$4.createElement(MDXContext.Provider, { value: K }, fe.children) } const provider = Object.freeze(Object.defineProperty({ __proto__: null, MDXProvider, useMDXComponents }, Symbol.toStringTag, { value: "Module" })); function stringifyPosition(fe) { return !fe || typeof fe != "object" ? "" : "position" in fe || "type" in fe ? position$1(fe.position) : "start" in fe || "end" in fe ? position$1(fe) : "line" in fe || "column" in fe ? point$2(fe) : "" } function point$2(fe) { return index(fe && fe.line) + ":" + index(fe && fe.column) } function position$1(fe) { return point$2(fe && fe.start) + "-" + point$2(fe && fe.end) } function index(fe) { return fe && typeof fe == "number" ? fe : 1 } class VFileMessage extends Error { constructor(K, pe, me) { super(), typeof pe == "string" && (me = pe, pe = void 0); let ge = "", xe = {}, ye = !1; if (pe && ("line" in pe && "column" in pe ? xe = { place: pe } : "start" in pe && "end" in pe ? xe = { place: pe } : "type" in pe ? xe = { ancestors: [pe], place: pe.position } : xe = { ...pe }), typeof K == "string" ? ge = K : !xe.cause && K && (ye = !0, ge = K.message, xe.cause = K), !xe.ruleId && !xe.source && typeof me == "string") { const _e = me.indexOf(":"); _e === -1 ? xe.ruleId = me : (xe.source = me.slice(0, _e), xe.ruleId = me.slice(_e + 1)) } if (!xe.place && xe.ancestors && xe.ancestors) { const _e = xe.ancestors[xe.ancestors.length - 1]; _e && (xe.place = _e.position) } const ve = xe.place && "start" in xe.place ? xe.place.start : xe.place; this.ancestors = xe.ancestors || void 0, this.cause = xe.cause || void 0, this.column = ve ? ve.column : void 0, this.fatal = void 0, this.file, this.message = ge, this.line = ve ? ve.line : void 0, this.name = stringifyPosition(xe.place) || "1:1", this.place = xe.place || void 0, this.reason = this.message, this.ruleId = xe.ruleId || void 0, this.source = xe.source || void 0, this.stack = ye && xe.cause && typeof xe.cause.stack == "string" ? xe.cause.stack : "", this.actual, this.expected, this.note, this.url } } VFileMessage.prototype.file = ""; VFileMessage.prototype.name = ""; VFileMessage.prototype.reason = ""; VFileMessage.prototype.message = ""; VFileMessage.prototype.stack = ""; VFileMessage.prototype.column = void 0; VFileMessage.prototype.line = void 0; VFileMessage.prototype.ancestors = void 0; VFileMessage.prototype.cause = void 0; VFileMessage.prototype.fatal = void 0; VFileMessage.prototype.place = void 0; VFileMessage.prototype.ruleId = void 0; VFileMessage.prototype.source = void 0; const minpath = { basename, dirname, extname, join: join$1, sep: "/" }; function basename(fe, K) { if (K !== void 0 && typeof K != "string") throw new TypeError('"ext" argument must be a string'); assertPath$1(fe); let pe = 0, me = -1, ge = fe.length, xe; if (K === void 0 || K.length === 0 || K.length > fe.length) { for (; ge--;)if (fe.codePointAt(ge) === 47) { if (xe) { pe = ge + 1; break } } else me < 0 && (xe = !0, me = ge + 1); return me < 0 ? "" : fe.slice(pe, me) } if (K === fe) return ""; let ye = -1, ve = K.length - 1; for (; ge--;)if (fe.codePointAt(ge) === 47) { if (xe) { pe = ge + 1; break } } else ye < 0 && (xe = !0, ye = ge + 1), ve > -1 && (fe.codePointAt(ge) === K.codePointAt(ve--) ? ve < 0 && (me = ge) : (ve = -1, me = ye)); return pe === me ? me = ye : me < 0 && (me = fe.length), fe.slice(pe, me) } function dirname(fe) { if (assertPath$1(fe), fe.length === 0) return "."; let K = -1, pe = fe.length, me; for (; --pe;)if (fe.codePointAt(pe) === 47) { if (me) { K = pe; break } } else me || (me = !0); return K < 0 ? fe.codePointAt(0) === 47 ? "/" : "." : K === 1 && fe.codePointAt(0) === 47 ? "//" : fe.slice(0, K) } function extname(fe) { assertPath$1(fe); let K = fe.length, pe = -1, me = 0, ge = -1, xe = 0, ye; for (; K--;) { const ve = fe.codePointAt(K); if (ve === 47) { if (ye) { me = K + 1; break } continue } pe < 0 && (ye = !0, pe = K + 1), ve === 46 ? ge < 0 ? ge = K : xe !== 1 && (xe = 1) : ge > -1 && (xe = -1) } return ge < 0 || pe < 0 || xe === 0 || xe === 1 && ge === pe - 1 && ge === me + 1 ? "" : fe.slice(ge, pe) } function join$1(...fe) { let K = -1, pe; for (; ++K < fe.length;)assertPath$1(fe[K]), fe[K] && (pe = pe === void 0 ? fe[K] : pe + "/" + fe[K]); return pe === void 0 ? "." : normalize$1(pe) } function normalize$1(fe) { assertPath$1(fe); const K = fe.codePointAt(0) === 47; let pe = normalizeString(fe, !K); return pe.length === 0 && !K && (pe = "."), pe.length > 0 && fe.codePointAt(fe.length - 1) === 47 && (pe += "/"), K ? "/" + pe : pe } function normalizeString(fe, K) { let pe = "", me = 0, ge = -1, xe = 0, ye = -1, ve, _e; for (; ++ye <= fe.length;) { if (ye < fe.length) ve = fe.codePointAt(ye); else { if (ve === 47) break; ve = 47 } if (ve === 47) { if (!(ge === ye - 1 || xe === 1)) if (ge !== ye - 1 && xe === 2) { if (pe.length < 2 || me !== 2 || pe.codePointAt(pe.length - 1) !== 46 || pe.codePointAt(pe.length - 2) !== 46) { if (pe.length > 2) { if (_e = pe.lastIndexOf("/"), _e !== pe.length - 1) { _e < 0 ? (pe = "", me = 0) : (pe = pe.slice(0, _e), me = pe.length - 1 - pe.lastIndexOf("/")), ge = ye, xe = 0; continue } } else if (pe.length > 0) { pe = "", me = 0, ge = ye, xe = 0; continue } } K && (pe = pe.length > 0 ? pe + "/.." : "..", me = 2) } else pe.length > 0 ? pe += "/" + fe.slice(ge + 1, ye) : pe = fe.slice(ge + 1, ye), me = ye - ge - 1; ge = ye, xe = 0 } else ve === 46 && xe > -1 ? xe++ : xe = -1 } return pe } function assertPath$1(fe) { if (typeof fe != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(fe)) } const minproc = { cwd }; function cwd() { return "/" } function isUrl(fe) { return !!(fe !== null && typeof fe == "object" && "href" in fe && fe.href && "protocol" in fe && fe.protocol && fe.auth === void 0) } function urlToPath(fe) { if (typeof fe == "string") fe = new URL(fe); else if (!isUrl(fe)) { const K = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + fe + "`"); throw K.code = "ERR_INVALID_ARG_TYPE", K } if (fe.protocol !== "file:") { const K = new TypeError("The URL must be of scheme file"); throw K.code = "ERR_INVALID_URL_SCHEME", K } return getPathFromURLPosix(fe) } function getPathFromURLPosix(fe) { if (fe.hostname !== "") { const me = new TypeError('File URL host must be "localhost" or empty on darwin'); throw me.code = "ERR_INVALID_FILE_URL_HOST", me } const K = fe.pathname; let pe = -1; for (; ++pe < K.length;)if (K.codePointAt(pe) === 37 && K.codePointAt(pe + 1) === 50) { const me = K.codePointAt(pe + 2); if (me === 70 || me === 102) { const ge = new TypeError("File URL path must not include encoded / characters"); throw ge.code = "ERR_INVALID_FILE_URL_PATH", ge } } return decodeURIComponent(K) } const order = ["history", "path", "basename", "stem", "extname", "dirname"]; class VFile { constructor(K) { let pe; K ? isUrl(K) ? pe = { path: K } : typeof K == "string" || isUint8Array$1(K) ? pe = { value: K } : pe = K : pe = {}, this.cwd = "cwd" in pe ? "" : minproc.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let me = -1; for (; ++me < order.length;) { const xe = order[me]; xe in pe && pe[xe] !== void 0 && pe[xe] !== null && (this[xe] = xe === "history" ? [...pe[xe]] : pe[xe]) } let ge; for (ge in pe) order.includes(ge) || (this[ge] = pe[ge]) } get basename() { return typeof this.path == "string" ? minpath.basename(this.path) : void 0 } set basename(K) { assertNonEmpty(K, "basename"), assertPart(K, "basename"), this.path = minpath.join(this.dirname || "", K) } get dirname() { return typeof this.path == "string" ? minpath.dirname(this.path) : void 0 } set dirname(K) { assertPath(this.basename, "dirname"), this.path = minpath.join(K || "", this.basename) } get extname() { return typeof this.path == "string" ? minpath.extname(this.path) : void 0 } set extname(K) { if (assertPart(K, "extname"), assertPath(this.dirname, "extname"), K) { if (K.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (K.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = minpath.join(this.dirname, this.stem + (K || "")) } get path() { return this.history[this.history.length - 1] } set path(K) { isUrl(K) && (K = urlToPath(K)), assertNonEmpty(K, "path"), this.path !== K && this.history.push(K) } get stem() { return typeof this.path == "string" ? minpath.basename(this.path, this.extname) : void 0 } set stem(K) { assertNonEmpty(K, "stem"), assertPart(K, "stem"), this.path = minpath.join(this.dirname || "", K + (this.extname || "")) } fail(K, pe, me) { const ge = this.message(K, pe, me); throw ge.fatal = !0, ge } info(K, pe, me) { const ge = this.message(K, pe, me); return ge.fatal = void 0, ge } message(K, pe, me) { const ge = new VFileMessage(K, pe, me); return this.path && (ge.name = this.path + ":" + ge.name, ge.file = this.path), ge.fatal = !1, this.messages.push(ge), ge } toString(K) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(K || void 0).decode(this.value) } } function assertPart(fe, K) { if (fe && fe.includes(minpath.sep)) throw new Error("`" + K + "` cannot be a path: did not expect `" + minpath.sep + "`") } function assertNonEmpty(fe, K) { if (!fe) throw new Error("`" + K + "` cannot be empty") } function assertPath(fe, K) { if (!fe) throw new Error("Setting `" + K + "` requires `path` to be set too") } function isUint8Array$1(fe) { return !!(fe && typeof fe == "object" && "byteLength" in fe && "byteOffset" in fe) } const markdownExtension = ["md", "markdown", "mdown", "mkdn", "mkd", "mdwn", "mkdown", "ron"], md$1 = markdownExtension.map(function (fe) { return "." + fe }); function resolveFileAndOptions(fe, K) { const pe = looksLikeAVFile$1(fe) ? fe : new VFile(fe), { format: me, ...ge } = K || {}; return { file: pe, options: { format: me === "md" || me === "mdx" ? me : pe.extname && (ge.mdExtensions || md$1).includes(pe.extname) ? "md" : "mdx", ...ge } } } function looksLikeAVFile$1(fe) { return !!(fe && typeof fe == "object" && "message" in fe && "messages" in fe) } function ok$1() { } const startRe = /[$_\p{ID_Start}]/u, contRe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, contReJsx = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, emptyOptions$5 = {}; function start(fe) { return fe ? startRe.test(String.fromCodePoint(fe)) : !1 } function cont(fe, K) { const me = (K || emptyOptions$5).jsx ? contReJsx : contRe; return fe ? me.test(String.fromCodePoint(fe)) : !1 } function name(fe, K) { return ((K || emptyOptions$5).jsx ? nameReJsx : nameRe).test(fe) } let WalkerBase$1 = class { constructor() { this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: K => this.replacement = K } } replace(K, pe, me, ge) { K && pe && (me != null ? K[pe][me] = ge : K[pe] = ge) } remove(K, pe, me) { K && pe && (me != null ? K[pe].splice(me, 1) : delete K[pe]) } }, SyncWalker$1 = class extends WalkerBase$1 { constructor(K, pe) { super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: me => this.replacement = me }, this.enter = K, this.leave = pe } visit(K, pe, me, ge) { if (K) { if (this.enter) { const ye = this.should_skip, ve = this.should_remove, _e = this.replacement; this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, K, pe, me, ge), this.replacement && (K = this.replacement, this.replace(pe, me, ge, K)), this.should_remove && this.remove(pe, me, ge); const Ee = this.should_skip, be = this.should_remove; if (this.should_skip = ye, this.should_remove = ve, this.replacement = _e, Ee) return K; if (be) return null } let xe; for (xe in K) { const ye = K[xe]; if (ye && typeof ye == "object") if (Array.isArray(ye)) { const ve = ye; for (let _e = 0; _e < ve.length; _e += 1) { const Ee = ve[_e]; isNode$1(Ee) && (this.visit(Ee, K, xe, _e) || _e--) } } else isNode$1(ye) && this.visit(ye, K, xe, null) } if (this.leave) { const ye = this.replacement, ve = this.should_remove; this.replacement = null, this.should_remove = !1, this.leave.call(this.context, K, pe, me, ge), this.replacement && (K = this.replacement, this.replace(pe, me, ge, K)), this.should_remove && this.remove(pe, me, ge); const _e = this.should_remove; if (this.replacement = ye, this.should_remove = ve, _e) return null } } return K } }; function isNode$1(fe) { return fe !== null && typeof fe == "object" && "type" in fe && typeof fe.type == "string" } function walk$2(fe, { enter: K, leave: pe }) { return new SyncWalker$1(K, pe).visit(fe, null) } const regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g; function buildJsx(fe, K) {
	const pe = K || {}; let me = pe.runtime === "automatic"; const ge = {}, xe = {}; walk$2(fe, {
		enter(ye) { if (ye.type === "Program") { const ve = ye.comments || []; let _e = -1; for (; ++_e < ve.length;) { regex.lastIndex = 0; let Ee = regex.exec(ve[_e].value); for (; Ee;)ge[Ee[1]] = Ee[2], Ee = regex.exec(ve[_e].value) } if (ge.jsxRuntime) if (ge.jsxRuntime === "automatic") { if (me = !0, ge.jsx) throw new Error("Unexpected `@jsx` pragma w/ automatic runtime"); if (ge.jsxFrag) throw new Error("Unexpected `@jsxFrag` pragma w/ automatic runtime") } else if (ge.jsxRuntime === "classic") { if (me = !1, ge.jsxImportSource) throw new Error("Unexpected `@jsxImportSource` w/ classic runtime") } else throw new Error("Unexpected `jsxRuntime` `" + ge.jsxRuntime + "`, expected `automatic` or `classic`") } }, leave(ye) {
			if (ye.type === "Program") { const Be = []; if (xe.fragment && Be.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "Fragment" }, local: { type: "Identifier", name: "_Fragment" } }), xe.jsx && Be.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsx" }, local: { type: "Identifier", name: "_jsx" } }), xe.jsxs && Be.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsxs" }, local: { type: "Identifier", name: "_jsxs" } }), xe.jsxDEV && Be.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsxDEV" }, local: { type: "Identifier", name: "_jsxDEV" } }), Be.length > 0) { let De = 0; for (; De < ye.body.length;) { const Re = ye.body[De]; if ("directive" in Re && Re.directive) De++; else break } ye.body.splice(De, 0, { type: "ImportDeclaration", specifiers: Be, source: { type: "Literal", value: (ge.jsxImportSource || pe.importSource || "react") + (pe.development ? "/jsx-dev-runtime" : "/jsx-runtime") } }) } } if (ye.type !== "JSXElement" && ye.type !== "JSXFragment") return; const ve = []; let _e = -1; for (; ++_e < ye.children.length;) {
				const Be = ye.children[_e]; if (Be.type === "JSXExpressionContainer") Be.expression.type !== "JSXEmptyExpression" && ve.push(Be.expression); else if (Be.type === "JSXText") {
					const De = Be.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " "); if (De) { const Re = { type: "Literal", value: De }; create$2(Be, Re), ve.push(Re) }
				} else Be.type !== "JSXElement" && Be.type !== "JSXFragment" && Be.type, ve.push(Be)
			} let Ee; const be = []; let Ae = [], Se; if (ye.type === "JSXElement") { if (Ee = toIdentifier(ye.openingElement.name), Ee.type === "Identifier" && /^[a-z]/.test(Ee.name)) { const Ie = { type: "Literal", value: Ee.name }; create$2(Ee, Ie), Ee = Ie } let Be; const De = ye.openingElement.attributes; let Re = -1; for (; ++Re < De.length;) { const Ie = De[Re]; if (Ie.type === "JSXSpreadAttribute") Ie.argument.type === "ObjectExpression" ? be.push(...Ie.argument.properties) : be.push({ type: "SpreadElement", argument: Ie.argument }), Be = !0; else { const Pe = toProperty(Ie); if (me && Pe.key.type === "Identifier" && Pe.key.name === "key") { if (Be) throw new Error("Expected `key` to come before any spread expressions"); const Ne = Pe.value; Ne.type !== "AssignmentPattern" && Ne.type !== "ArrayPattern" && Ne.type !== "ObjectPattern" && Ne.type, Se = Ne } else be.push(Pe) } } } else me ? (xe.fragment = !0, Ee = { type: "Identifier", name: "_Fragment" }) : Ee = toMemberExpression(ge.jsxFrag || pe.pragmaFrag || "React.Fragment"); me ? ve.length > 0 && be.push({ type: "Property", key: { type: "Identifier", name: "children" }, value: ve.length > 1 ? { type: "ArrayExpression", elements: ve } : ve[0], kind: "init", method: !1, shorthand: !1, computed: !1 }) : Ae = ve; let Ce; if (me) { Ae.push({ type: "ObjectExpression", properties: be }), Se ? Ae.push(Se) : pe.development && Ae.push({ type: "Identifier", name: "undefined" }); const Be = ve.length > 1; if (pe.development) { xe.jsxDEV = !0, Ce = { type: "Identifier", name: "_jsxDEV" }, Ae.push({ type: "Literal", value: Be }); const De = { type: "ObjectExpression", properties: [{ type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "fileName" }, value: { type: "Literal", value: pe.filePath || "<source.js>" } }] }; ye.loc && De.properties.push({ type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "lineNumber" }, value: { type: "Literal", value: ye.loc.start.line } }, { type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "columnNumber" }, value: { type: "Literal", value: ye.loc.start.column + 1 } }), Ae.push(De, { type: "ThisExpression" }) } else Be ? (xe.jsxs = !0, Ce = { type: "Identifier", name: "_jsxs" }) : (xe.jsx = !0, Ce = { type: "Identifier", name: "_jsx" }) } else be.length > 0 ? Ae.unshift({ type: "ObjectExpression", properties: be }) : Ae.length > 0 && Ae.unshift({ type: "Literal", value: null }), Ce = toMemberExpression(ge.jsx || pe.pragma || "React.createElement"); Ae.unshift(Ee); const we = { type: "CallExpression", callee: Ce, arguments: Ae, optional: !1 }; create$2(ye, we), this.replace(we)
		}
	})
} function toProperty(fe) { let K; if (fe.value) if (fe.value.type === "JSXExpressionContainer") { const me = fe.value.expression; me.type, K = me } else { const me = fe.value; me.type !== "JSXElement" && me.type, K = me, delete K.raw } else K = { type: "Literal", value: !0 }; const pe = { type: "Property", key: toIdentifier(fe.name), value: K, kind: "init", method: !1, shorthand: !1, computed: !1 }; return create$2(fe, pe), pe } function toIdentifier(fe) { let K; if (fe.type === "JSXMemberExpression") { const pe = toIdentifier(fe.property); K = { type: "MemberExpression", object: toIdentifier(fe.object), property: pe, computed: pe.type === "Literal", optional: !1 } } else fe.type === "JSXNamespacedName" ? K = { type: "Literal", value: fe.namespace.name + ":" + fe.name.name } : K = name(fe.name) ? { type: "Identifier", name: fe.name } : { type: "Literal", value: fe.name }; return create$2(fe, K), K } function toMemberExpression(fe) { const K = fe.split("."); let pe = -1, me; for (; ++pe < K.length;) { const ge = name(K[pe]) ? { type: "Identifier", name: K[pe] } : { type: "Literal", value: K[pe] }; me = me ? { type: "MemberExpression", object: me, property: ge, computed: !!(pe && ge.type === "Literal"), optional: !1 } : ge } return me } function create$2(fe, K) { const pe = ["start", "end", "loc", "range", "comments"]; let me = -1; for (; ++me < pe.length;) { const ge = pe[me]; ge in fe && (K[ge] = fe[ge]) } } function recmaJsx$1(fe) { return function (K, pe) { buildJsx(K, { filePath: pe.history[0], ...fe }) } } var acornJsx$1 = { exports: {} }, xhtml = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, acorn = { exports: {} }, hasRequiredAcorn; function requireAcorn() {
	return hasRequiredAcorn || (hasRequiredAcorn = 1, function (fe, K) {
		(function (pe, me) { me(K) })(commonjsGlobal, function (pe) {
			var me = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], ge = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], xe = "-----------------------------------------------------------------------------------------------------------------------------------------------------", ye = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", ve = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, _e = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", Ee = { 5: _e, "5module": _e + " export import", 6: _e + " const class extends export import super" }, be = /^in(stanceof)?$/, Ae = new RegExp("[" + ye + "]"), Se = new RegExp("[" + ye + xe + "]"); function Ce(Le, $e) { for (var rt = 65536, Pt = 0; Pt < $e.length; Pt += 2) { if (rt += $e[Pt], rt > Le) return !1; if (rt += $e[Pt + 1], rt >= Le) return !0 } return !1 } function we(Le, $e) { return Le < 65 ? Le === 36 : Le < 91 ? !0 : Le < 97 ? Le === 95 : Le < 123 ? !0 : Le <= 65535 ? Le >= 170 && Ae.test(String.fromCharCode(Le)) : $e === !1 ? !1 : Ce(Le, ge) } function Be(Le, $e) { return Le < 48 ? Le === 36 : Le < 58 ? !0 : Le < 65 ? !1 : Le < 91 ? !0 : Le < 97 ? Le === 95 : Le < 123 ? !0 : Le <= 65535 ? Le >= 170 && Se.test(String.fromCharCode(Le)) : $e === !1 ? !1 : Ce(Le, ge) || Ce(Le, me) } var De = function ($e, rt) { rt === void 0 && (rt = {}), this.label = $e, this.keyword = rt.keyword, this.beforeExpr = !!rt.beforeExpr, this.startsExpr = !!rt.startsExpr, this.isLoop = !!rt.isLoop, this.isAssign = !!rt.isAssign, this.prefix = !!rt.prefix, this.postfix = !!rt.postfix, this.binop = rt.binop || null, this.updateContext = null }; function Re(Le, $e) { return new De(Le, { beforeExpr: !0, binop: $e }) } var Ie = { beforeExpr: !0 }, Pe = { startsExpr: !0 }, Ne = {}; function ke(Le, $e) { return $e === void 0 && ($e = {}), $e.keyword = Le, Ne[Le] = new De(Le, $e) } var Oe = { num: new De("num", Pe), regexp: new De("regexp", Pe), string: new De("string", Pe), name: new De("name", Pe), privateId: new De("privateId", Pe), eof: new De("eof"), bracketL: new De("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new De("]"), braceL: new De("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new De("}"), parenL: new De("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new De(")"), comma: new De(",", Ie), semi: new De(";", Ie), colon: new De(":", Ie), dot: new De("."), question: new De("?", Ie), questionDot: new De("?."), arrow: new De("=>", Ie), template: new De("template"), invalidTemplate: new De("invalidTemplate"), ellipsis: new De("...", Ie), backQuote: new De("`", Pe), dollarBraceL: new De("${", { beforeExpr: !0, startsExpr: !0 }), eq: new De("=", { beforeExpr: !0, isAssign: !0 }), assign: new De("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new De("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new De("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: Re("||", 1), logicalAND: Re("&&", 2), bitwiseOR: Re("|", 3), bitwiseXOR: Re("^", 4), bitwiseAND: Re("&", 5), equality: Re("==/!=/===/!==", 6), relational: Re("</>/<=/>=", 7), bitShift: Re("<</>>/>>>", 8), plusMin: new De("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: Re("%", 10), star: Re("*", 10), slash: Re("/", 10), starstar: new De("**", { beforeExpr: !0 }), coalesce: Re("??", 1), _break: ke("break"), _case: ke("case", Ie), _catch: ke("catch"), _continue: ke("continue"), _debugger: ke("debugger"), _default: ke("default", Ie), _do: ke("do", { isLoop: !0, beforeExpr: !0 }), _else: ke("else", Ie), _finally: ke("finally"), _for: ke("for", { isLoop: !0 }), _function: ke("function", Pe), _if: ke("if"), _return: ke("return", Ie), _switch: ke("switch"), _throw: ke("throw", Ie), _try: ke("try"), _var: ke("var"), _const: ke("const"), _while: ke("while", { isLoop: !0 }), _with: ke("with"), _new: ke("new", { beforeExpr: !0, startsExpr: !0 }), _this: ke("this", Pe), _super: ke("super", Pe), _class: ke("class", Pe), _extends: ke("extends", Ie), _export: ke("export"), _import: ke("import", Pe), _null: ke("null", Pe), _true: ke("true", Pe), _false: ke("false", Pe), _in: ke("in", { beforeExpr: !0, binop: 7 }), _instanceof: ke("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: ke("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: ke("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: ke("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, Ue = /\r\n?|\n|\u2028|\u2029/, He = new RegExp(Ue.source, "g"); function Ge(Le) { return Le === 10 || Le === 13 || Le === 8232 || Le === 8233 } function ze(Le, $e, rt) { rt === void 0 && (rt = Le.length); for (var Pt = $e; Pt < rt; Pt++) { var Yt = Le.charCodeAt(Pt); if (Ge(Yt)) return Pt < rt - 1 && Yt === 13 && Le.charCodeAt(Pt + 1) === 10 ? Pt + 2 : Pt + 1 } return -1 } var We = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Xe = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ye = Object.prototype, Ze = Ye.hasOwnProperty, ot = Ye.toString, qe = Object.hasOwn || function (Le, $e) { return Ze.call(Le, $e) }, Qe = Array.isArray || function (Le) { return ot.call(Le) === "[object Array]" }, st = Object.create(null); function Nt(Le) { return st[Le] || (st[Le] = new RegExp("^(?:" + Le.replace(/ /g, "|") + ")$")) } function Je(Le) { return Le <= 65535 ? String.fromCharCode(Le) : (Le -= 65536, String.fromCharCode((Le >> 10) + 55296, (Le & 1023) + 56320)) } var jt = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Xt = function ($e, rt) { this.line = $e, this.column = rt }; Xt.prototype.offset = function ($e) { return new Xt(this.line, this.column + $e) }; var ct = function ($e, rt, Pt) { this.start = rt, this.end = Pt, $e.sourceFile !== null && (this.source = $e.sourceFile) }; function nn(Le, $e) { for (var rt = 1, Pt = 0; ;) { var Yt = ze(Le, Pt, $e); if (Yt < 0) return new Xt(rt, $e - Pt); ++rt, Pt = Yt } } var $t = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, checkPrivateFields: !0, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, an = !1; function gn(Le) {
				var $e = {}; for (var rt in $t) $e[rt] = Le && qe(Le, rt) ? Le[rt] : $t[rt]; if ($e.ecmaVersion === "latest" ? $e.ecmaVersion = 1e8 : $e.ecmaVersion == null ? (!an && typeof console == "object" && console.warn && (an = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), $e.ecmaVersion = 11) : $e.ecmaVersion >= 2015 && ($e.ecmaVersion -= 2009), $e.allowReserved == null && ($e.allowReserved = $e.ecmaVersion < 5), (!Le || Le.allowHashBang == null) && ($e.allowHashBang = $e.ecmaVersion >= 14), Qe($e.onToken)) { var Pt = $e.onToken; $e.onToken = function (Yt) { return Pt.push(Yt) } } return Qe($e.onComment) && ($e.onComment = Mn($e, $e.onComment)), $e
			} function Mn(Le, $e) { return function (rt, Pt, Yt, bn, On, hr) { var pr = { type: rt ? "Block" : "Line", value: Pt, start: Yt, end: bn }; Le.locations && (pr.loc = new ct(this, On, hr)), Le.ranges && (pr.range = [Yt, bn]), $e.push(pr) } } var Xn = 1, Ln = 2, Gn = 4, wn = 8, Bn = 16, Gt = 32, nr = 64, Kn = 128, vn = 256, yn = 512, Hn = Xn | Ln | vn; function kn(Le, $e) { return Ln | (Le ? Gn : 0) | ($e ? wn : 0) } var Ht = 0, Dt = 1, fn = 2, en = 3, cn = 4, Wt = 5, un = function ($e, rt, Pt) {
				this.options = $e = gn($e), this.sourceFile = $e.sourceFile, this.keywords = Nt(Ee[$e.ecmaVersion >= 6 ? 6 : $e.sourceType === "module" ? "5module" : 5]); var Yt = ""; $e.allowReserved !== !0 && (Yt = ve[$e.ecmaVersion >= 6 ? 6 : $e.ecmaVersion === 5 ? 5 : 3], $e.sourceType === "module" && (Yt += " await")), this.reservedWords = Nt(Yt); var bn = (Yt ? Yt + " " : "") + ve.strict; this.reservedWordsStrict = Nt(bn), this.reservedWordsStrictBind = Nt(bn + " " + ve.strictBind), this.input = String(rt), this.containsEsc = !1, Pt ? (this.pos = Pt, this.lineStart = this.input.lastIndexOf(`
`, Pt - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Ue).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = Oe.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = $e.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), this.pos === 0 && $e.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Xn), this.regexpState = null, this.privateNameStack = []
			}, Ft = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } }; un.prototype.parse = function () { var $e = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel($e) }, Ft.inFunction.get = function () { return (this.currentVarScope().flags & Ln) > 0 }, Ft.inGenerator.get = function () { return (this.currentVarScope().flags & wn) > 0 }, Ft.inAsync.get = function () { return (this.currentVarScope().flags & Gn) > 0 }, Ft.canAwait.get = function () { for (var Le = this.scopeStack.length - 1; Le >= 0; Le--) { var $e = this.scopeStack[Le], rt = $e.flags; if (rt & (vn | yn)) return !1; if (rt & Ln) return (rt & Gn) > 0 } return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction }, Ft.allowSuper.get = function () { var Le = this.currentThisScope(), $e = Le.flags; return ($e & nr) > 0 || this.options.allowSuperOutsideMethod }, Ft.allowDirectSuper.get = function () { return (this.currentThisScope().flags & Kn) > 0 }, Ft.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) }, Ft.allowNewDotTarget.get = function () { for (var Le = this.scopeStack.length - 1; Le >= 0; Le--) { var $e = this.scopeStack[Le], rt = $e.flags; if (rt & (vn | yn) || rt & Ln && !(rt & Bn)) return !0 } return !1 }, Ft.inClassStaticBlock.get = function () { return (this.currentVarScope().flags & vn) > 0 }, un.extend = function () { for (var $e = [], rt = arguments.length; rt--;)$e[rt] = arguments[rt]; for (var Pt = this, Yt = 0; Yt < $e.length; Yt++)Pt = $e[Yt](Pt); return Pt }, un.parse = function ($e, rt) { return new this(rt, $e).parse() }, un.parseExpressionAt = function ($e, rt, Pt) { var Yt = new this(Pt, $e, rt); return Yt.nextToken(), Yt.parseExpression() }, un.tokenizer = function ($e, rt) { return new this(rt, $e) }, Object.defineProperties(un.prototype, Ft); var Sn = un.prototype, lr = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/; Sn.strictDirective = function (Le) { if (this.options.ecmaVersion < 5) return !1; for (; ;) { Xe.lastIndex = Le, Le += Xe.exec(this.input)[0].length; var $e = lr.exec(this.input.slice(Le)); if (!$e) return !1; if (($e[1] || $e[2]) === "use strict") { Xe.lastIndex = Le + $e[0].length; var rt = Xe.exec(this.input), Pt = rt.index + rt[0].length, Yt = this.input.charAt(Pt); return Yt === ";" || Yt === "}" || Ue.test(rt[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(Yt) || Yt === "!" && this.input.charAt(Pt + 1) === "=") } Le += $e[0].length, Xe.lastIndex = Le, Le += Xe.exec(this.input)[0].length, this.input[Le] === ";" && Le++ } }, Sn.eat = function (Le) { return this.type === Le ? (this.next(), !0) : !1 }, Sn.isContextual = function (Le) { return this.type === Oe.name && this.value === Le && !this.containsEsc }, Sn.eatContextual = function (Le) { return this.isContextual(Le) ? (this.next(), !0) : !1 }, Sn.expectContextual = function (Le) { this.eatContextual(Le) || this.unexpected() }, Sn.canInsertSemicolon = function () { return this.type === Oe.eof || this.type === Oe.braceR || Ue.test(this.input.slice(this.lastTokEnd, this.start)) }, Sn.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }, Sn.semicolon = function () { !this.eat(Oe.semi) && !this.insertSemicolon() && this.unexpected() }, Sn.afterTrailingComma = function (Le, $e) { if (this.type === Le) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), $e || this.next(), !0 }, Sn.expect = function (Le) { this.eat(Le) || this.unexpected() }, Sn.unexpected = function (Le) { this.raise(Le ?? this.start, "Unexpected token") }; var jn = function () { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 }; Sn.checkPatternErrors = function (Le, $e) { if (Le) { Le.trailingComma > -1 && this.raiseRecoverable(Le.trailingComma, "Comma is not permitted after the rest element"); var rt = $e ? Le.parenthesizedAssign : Le.parenthesizedBind; rt > -1 && this.raiseRecoverable(rt, $e ? "Assigning to rvalue" : "Parenthesized pattern") } }, Sn.checkExpressionErrors = function (Le, $e) { if (!Le) return !1; var rt = Le.shorthandAssign, Pt = Le.doubleProto; if (!$e) return rt >= 0 || Pt >= 0; rt >= 0 && this.raise(rt, "Shorthand property assignments are valid only in destructuring patterns"), Pt >= 0 && this.raiseRecoverable(Pt, "Redefinition of __proto__ property") }, Sn.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }, Sn.isSimpleAssignTarget = function (Le) { return Le.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(Le.expression) : Le.type === "Identifier" || Le.type === "MemberExpression" }; var Pn = un.prototype; Pn.parseTopLevel = function (Le) { var $e = Object.create(null); for (Le.body || (Le.body = []); this.type !== Oe.eof;) { var rt = this.parseStatement(null, !0, $e); Le.body.push(rt) } if (this.inModule) for (var Pt = 0, Yt = Object.keys(this.undefinedExports); Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; this.raiseRecoverable(this.undefinedExports[bn].start, "Export '" + bn + "' is not defined") } return this.adaptDirectivePrologue(Le.body), this.next(), Le.sourceType = this.options.sourceType, this.finishNode(Le, "Program") }; var fr = { kind: "loop" }, Yn = { kind: "switch" }; Pn.isLet = function (Le) { if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1; Xe.lastIndex = this.pos; var $e = Xe.exec(this.input), rt = this.pos + $e[0].length, Pt = this.input.charCodeAt(rt); if (Pt === 91 || Pt === 92) return !0; if (Le) return !1; if (Pt === 123 || Pt > 55295 && Pt < 56320) return !0; if (we(Pt, !0)) { for (var Yt = rt + 1; Be(Pt = this.input.charCodeAt(Yt), !0);)++Yt; if (Pt === 92 || Pt > 55295 && Pt < 56320) return !0; var bn = this.input.slice(rt, Yt); if (!be.test(bn)) return !0 } return !1 }, Pn.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1; Xe.lastIndex = this.pos; var Le = Xe.exec(this.input), $e = this.pos + Le[0].length, rt; return !Ue.test(this.input.slice(this.pos, $e)) && this.input.slice($e, $e + 8) === "function" && ($e + 8 === this.input.length || !(Be(rt = this.input.charCodeAt($e + 8)) || rt > 55295 && rt < 56320)) }, Pn.parseStatement = function (Le, $e, rt) { var Pt = this.type, Yt = this.startNode(), bn; switch (this.isLet(Le) && (Pt = Oe._var, bn = "let"), Pt) { case Oe._break: case Oe._continue: return this.parseBreakContinueStatement(Yt, Pt.keyword); case Oe._debugger: return this.parseDebuggerStatement(Yt); case Oe._do: return this.parseDoStatement(Yt); case Oe._for: return this.parseForStatement(Yt); case Oe._function: return Le && (this.strict || Le !== "if" && Le !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Yt, !1, !Le); case Oe._class: return Le && this.unexpected(), this.parseClass(Yt, !0); case Oe._if: return this.parseIfStatement(Yt); case Oe._return: return this.parseReturnStatement(Yt); case Oe._switch: return this.parseSwitchStatement(Yt); case Oe._throw: return this.parseThrowStatement(Yt); case Oe._try: return this.parseTryStatement(Yt); case Oe._const: case Oe._var: return bn = bn || this.value, Le && bn !== "var" && this.unexpected(), this.parseVarStatement(Yt, bn); case Oe._while: return this.parseWhileStatement(Yt); case Oe._with: return this.parseWithStatement(Yt); case Oe.braceL: return this.parseBlock(!0, Yt); case Oe.semi: return this.parseEmptyStatement(Yt); case Oe._export: case Oe._import: if (this.options.ecmaVersion > 10 && Pt === Oe._import) { Xe.lastIndex = this.pos; var On = Xe.exec(this.input), hr = this.pos + On[0].length, pr = this.input.charCodeAt(hr); if (pr === 40 || pr === 46) return this.parseExpressionStatement(Yt, this.parseExpression()) } return this.options.allowImportExportEverywhere || ($e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), Pt === Oe._import ? this.parseImport(Yt) : this.parseExport(Yt, rt); default: if (this.isAsyncFunction()) return Le && this.unexpected(), this.next(), this.parseFunctionStatement(Yt, !0, !Le); var zr = this.value, Hr = this.parseExpression(); return Pt === Oe.name && Hr.type === "Identifier" && this.eat(Oe.colon) ? this.parseLabeledStatement(Yt, zr, Hr, Le) : this.parseExpressionStatement(Yt, Hr) } }, Pn.parseBreakContinueStatement = function (Le, $e) { var rt = $e === "break"; this.next(), this.eat(Oe.semi) || this.insertSemicolon() ? Le.label = null : this.type !== Oe.name ? this.unexpected() : (Le.label = this.parseIdent(), this.semicolon()); for (var Pt = 0; Pt < this.labels.length; ++Pt) { var Yt = this.labels[Pt]; if ((Le.label == null || Yt.name === Le.label.name) && (Yt.kind != null && (rt || Yt.kind === "loop") || Le.label && rt)) break } return Pt === this.labels.length && this.raise(Le.start, "Unsyntactic " + $e), this.finishNode(Le, rt ? "BreakStatement" : "ContinueStatement") }, Pn.parseDebuggerStatement = function (Le) { return this.next(), this.semicolon(), this.finishNode(Le, "DebuggerStatement") }, Pn.parseDoStatement = function (Le) { return this.next(), this.labels.push(fr), Le.body = this.parseStatement("do"), this.labels.pop(), this.expect(Oe._while), Le.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(Oe.semi) : this.semicolon(), this.finishNode(Le, "DoWhileStatement") }, Pn.parseForStatement = function (Le) { this.next(); var $e = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1; if (this.labels.push(fr), this.enterScope(0), this.expect(Oe.parenL), this.type === Oe.semi) return $e > -1 && this.unexpected($e), this.parseFor(Le, null); var rt = this.isLet(); if (this.type === Oe._var || this.type === Oe._const || rt) { var Pt = this.startNode(), Yt = rt ? "let" : this.value; return this.next(), this.parseVar(Pt, !0, Yt), this.finishNode(Pt, "VariableDeclaration"), (this.type === Oe._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && Pt.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === Oe._in ? $e > -1 && this.unexpected($e) : Le.await = $e > -1), this.parseForIn(Le, Pt)) : ($e > -1 && this.unexpected($e), this.parseFor(Le, Pt)) } var bn = this.isContextual("let"), On = !1, hr = this.containsEsc, pr = new jn, zr = this.start, Hr = $e > -1 ? this.parseExprSubscripts(pr, "await") : this.parseExpression(!0, pr); return this.type === Oe._in || (On = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? ($e > -1 ? (this.type === Oe._in && this.unexpected($e), Le.await = !0) : On && this.options.ecmaVersion >= 8 && (Hr.start === zr && !hr && Hr.type === "Identifier" && Hr.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (Le.await = !1)), bn && On && this.raise(Hr.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Hr, !1, pr), this.checkLValPattern(Hr), this.parseForIn(Le, Hr)) : (this.checkExpressionErrors(pr, !0), $e > -1 && this.unexpected($e), this.parseFor(Le, Hr)) }, Pn.parseFunctionStatement = function (Le, $e, rt) { return this.next(), this.parseFunction(Le, Ar | (rt ? 0 : Er), !1, $e) }, Pn.parseIfStatement = function (Le) { return this.next(), Le.test = this.parseParenExpression(), Le.consequent = this.parseStatement("if"), Le.alternate = this.eat(Oe._else) ? this.parseStatement("if") : null, this.finishNode(Le, "IfStatement") }, Pn.parseReturnStatement = function (Le) { return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(Oe.semi) || this.insertSemicolon() ? Le.argument = null : (Le.argument = this.parseExpression(), this.semicolon()), this.finishNode(Le, "ReturnStatement") }, Pn.parseSwitchStatement = function (Le) { this.next(), Le.discriminant = this.parseParenExpression(), Le.cases = [], this.expect(Oe.braceL), this.labels.push(Yn), this.enterScope(0); for (var $e, rt = !1; this.type !== Oe.braceR;)if (this.type === Oe._case || this.type === Oe._default) { var Pt = this.type === Oe._case; $e && this.finishNode($e, "SwitchCase"), Le.cases.push($e = this.startNode()), $e.consequent = [], this.next(), Pt ? $e.test = this.parseExpression() : (rt && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), rt = !0, $e.test = null), this.expect(Oe.colon) } else $e || this.unexpected(), $e.consequent.push(this.parseStatement(null)); return this.exitScope(), $e && this.finishNode($e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(Le, "SwitchStatement") }, Pn.parseThrowStatement = function (Le) { return this.next(), Ue.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), Le.argument = this.parseExpression(), this.semicolon(), this.finishNode(Le, "ThrowStatement") }; var sr = []; Pn.parseCatchClauseParam = function () { var Le = this.parseBindingAtom(), $e = Le.type === "Identifier"; return this.enterScope($e ? Gt : 0), this.checkLValPattern(Le, $e ? cn : fn), this.expect(Oe.parenR), Le }, Pn.parseTryStatement = function (Le) { if (this.next(), Le.block = this.parseBlock(), Le.handler = null, this.type === Oe._catch) { var $e = this.startNode(); this.next(), this.eat(Oe.parenL) ? $e.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), $e.param = null, this.enterScope(0)), $e.body = this.parseBlock(!1), this.exitScope(), Le.handler = this.finishNode($e, "CatchClause") } return Le.finalizer = this.eat(Oe._finally) ? this.parseBlock() : null, !Le.handler && !Le.finalizer && this.raise(Le.start, "Missing catch or finally clause"), this.finishNode(Le, "TryStatement") }, Pn.parseVarStatement = function (Le, $e, rt) { return this.next(), this.parseVar(Le, !1, $e, rt), this.semicolon(), this.finishNode(Le, "VariableDeclaration") }, Pn.parseWhileStatement = function (Le) { return this.next(), Le.test = this.parseParenExpression(), this.labels.push(fr), Le.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(Le, "WhileStatement") }, Pn.parseWithStatement = function (Le) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), Le.object = this.parseParenExpression(), Le.body = this.parseStatement("with"), this.finishNode(Le, "WithStatement") }, Pn.parseEmptyStatement = function (Le) { return this.next(), this.finishNode(Le, "EmptyStatement") }, Pn.parseLabeledStatement = function (Le, $e, rt, Pt) { for (var Yt = 0, bn = this.labels; Yt < bn.length; Yt += 1) { var On = bn[Yt]; On.name === $e && this.raise(rt.start, "Label '" + $e + "' is already declared") } for (var hr = this.type.isLoop ? "loop" : this.type === Oe._switch ? "switch" : null, pr = this.labels.length - 1; pr >= 0; pr--) { var zr = this.labels[pr]; if (zr.statementStart === Le.start) zr.statementStart = this.start, zr.kind = hr; else break } return this.labels.push({ name: $e, kind: hr, statementStart: this.start }), Le.body = this.parseStatement(Pt ? Pt.indexOf("label") === -1 ? Pt + "label" : Pt : "label"), this.labels.pop(), Le.label = rt, this.finishNode(Le, "LabeledStatement") }, Pn.parseExpressionStatement = function (Le, $e) { return Le.expression = $e, this.semicolon(), this.finishNode(Le, "ExpressionStatement") }, Pn.parseBlock = function (Le, $e, rt) { for (Le === void 0 && (Le = !0), $e === void 0 && ($e = this.startNode()), $e.body = [], this.expect(Oe.braceL), Le && this.enterScope(0); this.type !== Oe.braceR;) { var Pt = this.parseStatement(null); $e.body.push(Pt) } return rt && (this.strict = !1), this.next(), Le && this.exitScope(), this.finishNode($e, "BlockStatement") }, Pn.parseFor = function (Le, $e) { return Le.init = $e, this.expect(Oe.semi), Le.test = this.type === Oe.semi ? null : this.parseExpression(), this.expect(Oe.semi), Le.update = this.type === Oe.parenR ? null : this.parseExpression(), this.expect(Oe.parenR), Le.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(Le, "ForStatement") }, Pn.parseForIn = function (Le, $e) { var rt = this.type === Oe._in; return this.next(), $e.type === "VariableDeclaration" && $e.declarations[0].init != null && (!rt || this.options.ecmaVersion < 8 || this.strict || $e.kind !== "var" || $e.declarations[0].id.type !== "Identifier") && this.raise($e.start, (rt ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), Le.left = $e, Le.right = rt ? this.parseExpression() : this.parseMaybeAssign(), this.expect(Oe.parenR), Le.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(Le, rt ? "ForInStatement" : "ForOfStatement") }, Pn.parseVar = function (Le, $e, rt, Pt) { for (Le.declarations = [], Le.kind = rt; ;) { var Yt = this.startNode(); if (this.parseVarId(Yt, rt), this.eat(Oe.eq) ? Yt.init = this.parseMaybeAssign($e) : !Pt && rt === "const" && !(this.type === Oe._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !Pt && Yt.id.type !== "Identifier" && !($e && (this.type === Oe._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : Yt.init = null, Le.declarations.push(this.finishNode(Yt, "VariableDeclarator")), !this.eat(Oe.comma)) break } return Le }, Pn.parseVarId = function (Le, $e) { Le.id = this.parseBindingAtom(), this.checkLValPattern(Le.id, $e === "var" ? Dt : fn, !1) }; var Ar = 1, Er = 2, Rr = 4; Pn.parseFunction = function (Le, $e, rt, Pt, Yt) { this.initFunction(Le), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !Pt) && (this.type === Oe.star && $e & Er && this.unexpected(), Le.generator = this.eat(Oe.star)), this.options.ecmaVersion >= 8 && (Le.async = !!Pt), $e & Ar && (Le.id = $e & Rr && this.type !== Oe.name ? null : this.parseIdent(), Le.id && !($e & Er) && this.checkLValSimple(Le.id, this.strict || Le.generator || Le.async ? this.treatFunctionsAsVar ? Dt : fn : en)); var bn = this.yieldPos, On = this.awaitPos, hr = this.awaitIdentPos; return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(kn(Le.async, Le.generator)), $e & Ar || (Le.id = this.type === Oe.name ? this.parseIdent() : null), this.parseFunctionParams(Le), this.parseFunctionBody(Le, rt, !1, Yt), this.yieldPos = bn, this.awaitPos = On, this.awaitIdentPos = hr, this.finishNode(Le, $e & Ar ? "FunctionDeclaration" : "FunctionExpression") }, Pn.parseFunctionParams = function (Le) { this.expect(Oe.parenL), Le.params = this.parseBindingList(Oe.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, Pn.parseClass = function (Le, $e) { this.next(); var rt = this.strict; this.strict = !0, this.parseClassId(Le, $e), this.parseClassSuper(Le); var Pt = this.enterClassBody(), Yt = this.startNode(), bn = !1; for (Yt.body = [], this.expect(Oe.braceL); this.type !== Oe.braceR;) { var On = this.parseClassElement(Le.superClass !== null); On && (Yt.body.push(On), On.type === "MethodDefinition" && On.kind === "constructor" ? (bn && this.raiseRecoverable(On.start, "Duplicate constructor in the same class"), bn = !0) : On.key && On.key.type === "PrivateIdentifier" && mn(Pt, On) && this.raiseRecoverable(On.key.start, "Identifier '#" + On.key.name + "' has already been declared")) } return this.strict = rt, this.next(), Le.body = this.finishNode(Yt, "ClassBody"), this.exitClassBody(), this.finishNode(Le, $e ? "ClassDeclaration" : "ClassExpression") }, Pn.parseClassElement = function (Le) { if (this.eat(Oe.semi)) return null; var $e = this.options.ecmaVersion, rt = this.startNode(), Pt = "", Yt = !1, bn = !1, On = "method", hr = !1; if (this.eatContextual("static")) { if ($e >= 13 && this.eat(Oe.braceL)) return this.parseClassStaticBlock(rt), rt; this.isClassElementNameStart() || this.type === Oe.star ? hr = !0 : Pt = "static" } if (rt.static = hr, !Pt && $e >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === Oe.star) && !this.canInsertSemicolon() ? bn = !0 : Pt = "async"), !Pt && ($e >= 9 || !bn) && this.eat(Oe.star) && (Yt = !0), !Pt && !bn && !Yt) { var pr = this.value; (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? On = pr : Pt = pr) } if (Pt ? (rt.computed = !1, rt.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), rt.key.name = Pt, this.finishNode(rt.key, "Identifier")) : this.parseClassElementName(rt), $e < 13 || this.type === Oe.parenL || On !== "method" || Yt || bn) { var zr = !rt.static && Dn(rt, "constructor"), Hr = zr && Le; zr && On !== "method" && this.raise(rt.key.start, "Constructor can't have get/set modifier"), rt.kind = zr ? "constructor" : On, this.parseClassMethod(rt, Yt, bn, Hr) } else this.parseClassField(rt); return rt }, Pn.isClassElementNameStart = function () { return this.type === Oe.name || this.type === Oe.privateId || this.type === Oe.num || this.type === Oe.string || this.type === Oe.bracketL || this.type.keyword }, Pn.parseClassElementName = function (Le) { this.type === Oe.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), Le.computed = !1, Le.key = this.parsePrivateIdent()) : this.parsePropertyName(Le) }, Pn.parseClassMethod = function (Le, $e, rt, Pt) { var Yt = Le.key; Le.kind === "constructor" ? ($e && this.raise(Yt.start, "Constructor can't be a generator"), rt && this.raise(Yt.start, "Constructor can't be an async method")) : Le.static && Dn(Le, "prototype") && this.raise(Yt.start, "Classes may not have a static property named prototype"); var bn = Le.value = this.parseMethod($e, rt, Pt); return Le.kind === "get" && bn.params.length !== 0 && this.raiseRecoverable(bn.start, "getter should have no params"), Le.kind === "set" && bn.params.length !== 1 && this.raiseRecoverable(bn.start, "setter should have exactly one param"), Le.kind === "set" && bn.params[0].type === "RestElement" && this.raiseRecoverable(bn.params[0].start, "Setter cannot use rest params"), this.finishNode(Le, "MethodDefinition") }, Pn.parseClassField = function (Le) { return Dn(Le, "constructor") ? this.raise(Le.key.start, "Classes can't have a field named 'constructor'") : Le.static && Dn(Le, "prototype") && this.raise(Le.key.start, "Classes can't have a static field named 'prototype'"), this.eat(Oe.eq) ? (this.enterScope(yn | nr), Le.value = this.parseMaybeAssign(), this.exitScope()) : Le.value = null, this.semicolon(), this.finishNode(Le, "PropertyDefinition") }, Pn.parseClassStaticBlock = function (Le) { Le.body = []; var $e = this.labels; for (this.labels = [], this.enterScope(vn | nr); this.type !== Oe.braceR;) { var rt = this.parseStatement(null); Le.body.push(rt) } return this.next(), this.exitScope(), this.labels = $e, this.finishNode(Le, "StaticBlock") }, Pn.parseClassId = function (Le, $e) { this.type === Oe.name ? (Le.id = this.parseIdent(), $e && this.checkLValSimple(Le.id, fn, !1)) : ($e === !0 && this.unexpected(), Le.id = null) }, Pn.parseClassSuper = function (Le) { Le.superClass = this.eat(Oe._extends) ? this.parseExprSubscripts(null, !1) : null }, Pn.enterClassBody = function () { var Le = { declared: Object.create(null), used: [] }; return this.privateNameStack.push(Le), Le.declared }, Pn.exitClassBody = function () { var Le = this.privateNameStack.pop(), $e = Le.declared, rt = Le.used; if (this.options.checkPrivateFields) for (var Pt = this.privateNameStack.length, Yt = Pt === 0 ? null : this.privateNameStack[Pt - 1], bn = 0; bn < rt.length; ++bn) { var On = rt[bn]; qe($e, On.name) || (Yt ? Yt.used.push(On) : this.raiseRecoverable(On.start, "Private field '#" + On.name + "' must be declared in an enclosing class")) } }; function mn(Le, $e) { var rt = $e.key.name, Pt = Le[rt], Yt = "true"; return $e.type === "MethodDefinition" && ($e.kind === "get" || $e.kind === "set") && (Yt = ($e.static ? "s" : "i") + $e.kind), Pt === "iget" && Yt === "iset" || Pt === "iset" && Yt === "iget" || Pt === "sget" && Yt === "sset" || Pt === "sset" && Yt === "sget" ? (Le[rt] = "true", !1) : Pt ? !0 : (Le[rt] = Yt, !1) } function Dn(Le, $e) { var rt = Le.computed, Pt = Le.key; return !rt && (Pt.type === "Identifier" && Pt.name === $e || Pt.type === "Literal" && Pt.value === $e) } Pn.parseExportAllDeclaration = function (Le, $e) { return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (Le.exported = this.parseModuleExportName(), this.checkExport($e, Le.exported, this.lastTokStart)) : Le.exported = null), this.expectContextual("from"), this.type !== Oe.string && this.unexpected(), Le.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (Le.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(Le, "ExportAllDeclaration") }, Pn.parseExport = function (Le, $e) { if (this.next(), this.eat(Oe.star)) return this.parseExportAllDeclaration(Le, $e); if (this.eat(Oe._default)) return this.checkExport($e, "default", this.lastTokStart), Le.declaration = this.parseExportDefaultDeclaration(), this.finishNode(Le, "ExportDefaultDeclaration"); if (this.shouldParseExportStatement()) Le.declaration = this.parseExportDeclaration(Le), Le.declaration.type === "VariableDeclaration" ? this.checkVariableExport($e, Le.declaration.declarations) : this.checkExport($e, Le.declaration.id, Le.declaration.id.start), Le.specifiers = [], Le.source = null, this.options.ecmaVersion >= 16 && (Le.attributes = []); else { if (Le.declaration = null, Le.specifiers = this.parseExportSpecifiers($e), this.eatContextual("from")) this.type !== Oe.string && this.unexpected(), Le.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (Le.attributes = this.parseWithClause()); else { for (var rt = 0, Pt = Le.specifiers; rt < Pt.length; rt += 1) { var Yt = Pt[rt]; this.checkUnreserved(Yt.local), this.checkLocalExport(Yt.local), Yt.local.type === "Literal" && this.raise(Yt.local.start, "A string literal cannot be used as an exported binding without `from`.") } Le.source = null, this.options.ecmaVersion >= 16 && (Le.attributes = []) } this.semicolon() } return this.finishNode(Le, "ExportNamedDeclaration") }, Pn.parseExportDeclaration = function (Le) { return this.parseStatement(null) }, Pn.parseExportDefaultDeclaration = function () { var Le; if (this.type === Oe._function || (Le = this.isAsyncFunction())) { var $e = this.startNode(); return this.next(), Le && this.next(), this.parseFunction($e, Ar | Rr, !1, Le) } else if (this.type === Oe._class) { var rt = this.startNode(); return this.parseClass(rt, "nullableID") } else { var Pt = this.parseMaybeAssign(); return this.semicolon(), Pt } }, Pn.checkExport = function (Le, $e, rt) { Le && (typeof $e != "string" && ($e = $e.type === "Identifier" ? $e.name : $e.value), qe(Le, $e) && this.raiseRecoverable(rt, "Duplicate export '" + $e + "'"), Le[$e] = !0) }, Pn.checkPatternExport = function (Le, $e) { var rt = $e.type; if (rt === "Identifier") this.checkExport(Le, $e, $e.start); else if (rt === "ObjectPattern") for (var Pt = 0, Yt = $e.properties; Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; this.checkPatternExport(Le, bn) } else if (rt === "ArrayPattern") for (var On = 0, hr = $e.elements; On < hr.length; On += 1) { var pr = hr[On]; pr && this.checkPatternExport(Le, pr) } else rt === "Property" ? this.checkPatternExport(Le, $e.value) : rt === "AssignmentPattern" ? this.checkPatternExport(Le, $e.left) : rt === "RestElement" && this.checkPatternExport(Le, $e.argument) }, Pn.checkVariableExport = function (Le, $e) { if (Le) for (var rt = 0, Pt = $e; rt < Pt.length; rt += 1) { var Yt = Pt[rt]; this.checkPatternExport(Le, Yt.id) } }, Pn.shouldParseExportStatement = function () { return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction() }, Pn.parseExportSpecifier = function (Le) { var $e = this.startNode(); return $e.local = this.parseModuleExportName(), $e.exported = this.eatContextual("as") ? this.parseModuleExportName() : $e.local, this.checkExport(Le, $e.exported, $e.exported.start), this.finishNode($e, "ExportSpecifier") }, Pn.parseExportSpecifiers = function (Le) { var $e = [], rt = !0; for (this.expect(Oe.braceL); !this.eat(Oe.braceR);) { if (rt) rt = !1; else if (this.expect(Oe.comma), this.afterTrailingComma(Oe.braceR)) break; $e.push(this.parseExportSpecifier(Le)) } return $e }, Pn.parseImport = function (Le) { return this.next(), this.type === Oe.string ? (Le.specifiers = sr, Le.source = this.parseExprAtom()) : (Le.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), Le.source = this.type === Oe.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (Le.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(Le, "ImportDeclaration") }, Pn.parseImportSpecifier = function () { var Le = this.startNode(); return Le.imported = this.parseModuleExportName(), this.eatContextual("as") ? Le.local = this.parseIdent() : (this.checkUnreserved(Le.imported), Le.local = Le.imported), this.checkLValSimple(Le.local, fn), this.finishNode(Le, "ImportSpecifier") }, Pn.parseImportDefaultSpecifier = function () { var Le = this.startNode(); return Le.local = this.parseIdent(), this.checkLValSimple(Le.local, fn), this.finishNode(Le, "ImportDefaultSpecifier") }, Pn.parseImportNamespaceSpecifier = function () { var Le = this.startNode(); return this.next(), this.expectContextual("as"), Le.local = this.parseIdent(), this.checkLValSimple(Le.local, fn), this.finishNode(Le, "ImportNamespaceSpecifier") }, Pn.parseImportSpecifiers = function () { var Le = [], $e = !0; if (this.type === Oe.name && (Le.push(this.parseImportDefaultSpecifier()), !this.eat(Oe.comma))) return Le; if (this.type === Oe.star) return Le.push(this.parseImportNamespaceSpecifier()), Le; for (this.expect(Oe.braceL); !this.eat(Oe.braceR);) { if ($e) $e = !1; else if (this.expect(Oe.comma), this.afterTrailingComma(Oe.braceR)) break; Le.push(this.parseImportSpecifier()) } return Le }, Pn.parseWithClause = function () { var Le = []; if (!this.eat(Oe._with)) return Le; this.expect(Oe.braceL); for (var $e = {}, rt = !0; !this.eat(Oe.braceR);) { if (rt) rt = !1; else if (this.expect(Oe.comma), this.afterTrailingComma(Oe.braceR)) break; var Pt = this.parseImportAttribute(), Yt = Pt.key.type === "Identifier" ? Pt.key.name : Pt.key.value; qe($e, Yt) && this.raiseRecoverable(Pt.key.start, "Duplicate attribute key '" + Yt + "'"), $e[Yt] = !0, Le.push(Pt) } return Le }, Pn.parseImportAttribute = function () { var Le = this.startNode(); return Le.key = this.type === Oe.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(Oe.colon), this.type !== Oe.string && this.unexpected(), Le.value = this.parseExprAtom(), this.finishNode(Le, "ImportAttribute") }, Pn.parseModuleExportName = function () { if (this.options.ecmaVersion >= 13 && this.type === Oe.string) { var Le = this.parseLiteral(this.value); return jt.test(Le.value) && this.raise(Le.start, "An export name cannot include a lone surrogate."), Le } return this.parseIdent(!0) }, Pn.adaptDirectivePrologue = function (Le) { for (var $e = 0; $e < Le.length && this.isDirectiveCandidate(Le[$e]); ++$e)Le[$e].directive = Le[$e].expression.raw.slice(1, -1) }, Pn.isDirectiveCandidate = function (Le) { return this.options.ecmaVersion >= 5 && Le.type === "ExpressionStatement" && Le.expression.type === "Literal" && typeof Le.expression.value == "string" && (this.input[Le.start] === '"' || this.input[Le.start] === "'") }; var Rn = un.prototype; Rn.toAssignable = function (Le, $e, rt) { if (this.options.ecmaVersion >= 6 && Le) switch (Le.type) { case "Identifier": this.inAsync && Le.name === "await" && this.raise(Le.start, "Cannot use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": case "RestElement": break; case "ObjectExpression": Le.type = "ObjectPattern", rt && this.checkPatternErrors(rt, !0); for (var Pt = 0, Yt = Le.properties; Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; this.toAssignable(bn, $e), bn.type === "RestElement" && (bn.argument.type === "ArrayPattern" || bn.argument.type === "ObjectPattern") && this.raise(bn.argument.start, "Unexpected token") } break; case "Property": Le.kind !== "init" && this.raise(Le.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(Le.value, $e); break; case "ArrayExpression": Le.type = "ArrayPattern", rt && this.checkPatternErrors(rt, !0), this.toAssignableList(Le.elements, $e); break; case "SpreadElement": Le.type = "RestElement", this.toAssignable(Le.argument, $e), Le.argument.type === "AssignmentPattern" && this.raise(Le.argument.start, "Rest elements cannot have a default value"); break; case "AssignmentExpression": Le.operator !== "=" && this.raise(Le.left.end, "Only '=' operator can be used for specifying default value."), Le.type = "AssignmentPattern", delete Le.operator, this.toAssignable(Le.left, $e); break; case "ParenthesizedExpression": this.toAssignable(Le.expression, $e, rt); break; case "ChainExpression": this.raiseRecoverable(Le.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": if (!$e) break; default: this.raise(Le.start, "Assigning to rvalue") } else rt && this.checkPatternErrors(rt, !0); return Le }, Rn.toAssignableList = function (Le, $e) { for (var rt = Le.length, Pt = 0; Pt < rt; Pt++) { var Yt = Le[Pt]; Yt && this.toAssignable(Yt, $e) } if (rt) { var bn = Le[rt - 1]; this.options.ecmaVersion === 6 && $e && bn && bn.type === "RestElement" && bn.argument.type !== "Identifier" && this.unexpected(bn.argument.start) } return Le }, Rn.parseSpread = function (Le) { var $e = this.startNode(); return this.next(), $e.argument = this.parseMaybeAssign(!1, Le), this.finishNode($e, "SpreadElement") }, Rn.parseRestBinding = function () { var Le = this.startNode(); return this.next(), this.options.ecmaVersion === 6 && this.type !== Oe.name && this.unexpected(), Le.argument = this.parseBindingAtom(), this.finishNode(Le, "RestElement") }, Rn.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case Oe.bracketL: var Le = this.startNode(); return this.next(), Le.elements = this.parseBindingList(Oe.bracketR, !0, !0), this.finishNode(Le, "ArrayPattern"); case Oe.braceL: return this.parseObj(!0) }return this.parseIdent() }, Rn.parseBindingList = function (Le, $e, rt, Pt) { for (var Yt = [], bn = !0; !this.eat(Le);)if (bn ? bn = !1 : this.expect(Oe.comma), $e && this.type === Oe.comma) Yt.push(null); else { if (rt && this.afterTrailingComma(Le)) break; if (this.type === Oe.ellipsis) { var On = this.parseRestBinding(); this.parseBindingListItem(On), Yt.push(On), this.type === Oe.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(Le); break } else Yt.push(this.parseAssignableListItem(Pt)) } return Yt }, Rn.parseAssignableListItem = function (Le) { var $e = this.parseMaybeDefault(this.start, this.startLoc); return this.parseBindingListItem($e), $e }, Rn.parseBindingListItem = function (Le) { return Le }, Rn.parseMaybeDefault = function (Le, $e, rt) { if (rt = rt || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(Oe.eq)) return rt; var Pt = this.startNodeAt(Le, $e); return Pt.left = rt, Pt.right = this.parseMaybeAssign(), this.finishNode(Pt, "AssignmentPattern") }, Rn.checkLValSimple = function (Le, $e, rt) { $e === void 0 && ($e = Ht); var Pt = $e !== Ht; switch (Le.type) { case "Identifier": this.strict && this.reservedWordsStrictBind.test(Le.name) && this.raiseRecoverable(Le.start, (Pt ? "Binding " : "Assigning to ") + Le.name + " in strict mode"), Pt && ($e === fn && Le.name === "let" && this.raiseRecoverable(Le.start, "let is disallowed as a lexically bound name"), rt && (qe(rt, Le.name) && this.raiseRecoverable(Le.start, "Argument name clash"), rt[Le.name] = !0), $e !== Wt && this.declareName(Le.name, $e, Le.start)); break; case "ChainExpression": this.raiseRecoverable(Le.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": Pt && this.raiseRecoverable(Le.start, "Binding member expression"); break; case "ParenthesizedExpression": return Pt && this.raiseRecoverable(Le.start, "Binding parenthesized expression"), this.checkLValSimple(Le.expression, $e, rt); default: this.raise(Le.start, (Pt ? "Binding" : "Assigning to") + " rvalue") } }, Rn.checkLValPattern = function (Le, $e, rt) { switch ($e === void 0 && ($e = Ht), Le.type) { case "ObjectPattern": for (var Pt = 0, Yt = Le.properties; Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; this.checkLValInnerPattern(bn, $e, rt) } break; case "ArrayPattern": for (var On = 0, hr = Le.elements; On < hr.length; On += 1) { var pr = hr[On]; pr && this.checkLValInnerPattern(pr, $e, rt) } break; default: this.checkLValSimple(Le, $e, rt) } }, Rn.checkLValInnerPattern = function (Le, $e, rt) { switch ($e === void 0 && ($e = Ht), Le.type) { case "Property": this.checkLValInnerPattern(Le.value, $e, rt); break; case "AssignmentPattern": this.checkLValPattern(Le.left, $e, rt); break; case "RestElement": this.checkLValPattern(Le.argument, $e, rt); break; default: this.checkLValPattern(Le, $e, rt) } }; var qn = function ($e, rt, Pt, Yt, bn) { this.token = $e, this.isExpr = !!rt, this.preserveSpace = !!Pt, this.override = Yt, this.generator = !!bn }, ar = { b_stat: new qn("{", !1), b_expr: new qn("{", !0), b_tmpl: new qn("${", !1), p_stat: new qn("(", !1), p_expr: new qn("(", !0), q_tmpl: new qn("`", !0, !0, function (Le) { return Le.tryReadTemplateToken() }), f_stat: new qn("function", !1), f_expr: new qn("function", !0), f_expr_gen: new qn("function", !0, !1, null, !0), f_gen: new qn("function", !1, !1, null, !0) }, yr = un.prototype; yr.initialContext = function () { return [ar.b_stat] }, yr.curContext = function () { return this.context[this.context.length - 1] }, yr.braceIsBlock = function (Le) { var $e = this.curContext(); return $e === ar.f_expr || $e === ar.f_stat ? !0 : Le === Oe.colon && ($e === ar.b_stat || $e === ar.b_expr) ? !$e.isExpr : Le === Oe._return || Le === Oe.name && this.exprAllowed ? Ue.test(this.input.slice(this.lastTokEnd, this.start)) : Le === Oe._else || Le === Oe.semi || Le === Oe.eof || Le === Oe.parenR || Le === Oe.arrow ? !0 : Le === Oe.braceL ? $e === ar.b_stat : Le === Oe._var || Le === Oe._const || Le === Oe.name ? !1 : !this.exprAllowed }, yr.inGeneratorContext = function () { for (var Le = this.context.length - 1; Le >= 1; Le--) { var $e = this.context[Le]; if ($e.token === "function") return $e.generator } return !1 }, yr.updateContext = function (Le) { var $e, rt = this.type; rt.keyword && Le === Oe.dot ? this.exprAllowed = !1 : ($e = rt.updateContext) ? $e.call(this, Le) : this.exprAllowed = rt.beforeExpr }, yr.overrideContext = function (Le) { this.curContext() !== Le && (this.context[this.context.length - 1] = Le) }, Oe.parenR.updateContext = Oe.braceR.updateContext = function () { if (this.context.length === 1) { this.exprAllowed = !0; return } var Le = this.context.pop(); Le === ar.b_stat && this.curContext().token === "function" && (Le = this.context.pop()), this.exprAllowed = !Le.isExpr }, Oe.braceL.updateContext = function (Le) { this.context.push(this.braceIsBlock(Le) ? ar.b_stat : ar.b_expr), this.exprAllowed = !0 }, Oe.dollarBraceL.updateContext = function () { this.context.push(ar.b_tmpl), this.exprAllowed = !0 }, Oe.parenL.updateContext = function (Le) { var $e = Le === Oe._if || Le === Oe._for || Le === Oe._with || Le === Oe._while; this.context.push($e ? ar.p_stat : ar.p_expr), this.exprAllowed = !0 }, Oe.incDec.updateContext = function () { }, Oe._function.updateContext = Oe._class.updateContext = function (Le) { Le.beforeExpr && Le !== Oe._else && !(Le === Oe.semi && this.curContext() !== ar.p_stat) && !(Le === Oe._return && Ue.test(this.input.slice(this.lastTokEnd, this.start))) && !((Le === Oe.colon || Le === Oe.braceL) && this.curContext() === ar.b_stat) ? this.context.push(ar.f_expr) : this.context.push(ar.f_stat), this.exprAllowed = !1 }, Oe.colon.updateContext = function () { this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0 }, Oe.backQuote.updateContext = function () { this.curContext() === ar.q_tmpl ? this.context.pop() : this.context.push(ar.q_tmpl), this.exprAllowed = !1 }, Oe.star.updateContext = function (Le) { if (Le === Oe._function) { var $e = this.context.length - 1; this.context[$e] === ar.f_expr ? this.context[$e] = ar.f_expr_gen : this.context[$e] = ar.f_gen } this.exprAllowed = !0 }, Oe.name.updateContext = function (Le) { var $e = !1; this.options.ecmaVersion >= 6 && Le !== Oe.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && ($e = !0), this.exprAllowed = $e }; var dr = un.prototype; dr.checkPropClash = function (Le, $e, rt) { if (!(this.options.ecmaVersion >= 9 && Le.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (Le.computed || Le.method || Le.shorthand))) { var Pt = Le.key, Yt; switch (Pt.type) { case "Identifier": Yt = Pt.name; break; case "Literal": Yt = String(Pt.value); break; default: return }var bn = Le.kind; if (this.options.ecmaVersion >= 6) { Yt === "__proto__" && bn === "init" && ($e.proto && (rt ? rt.doubleProto < 0 && (rt.doubleProto = Pt.start) : this.raiseRecoverable(Pt.start, "Redefinition of __proto__ property")), $e.proto = !0); return } Yt = "$" + Yt; var On = $e[Yt]; if (On) { var hr; bn === "init" ? hr = this.strict && On.init || On.get || On.set : hr = On.init || On[bn], hr && this.raiseRecoverable(Pt.start, "Redefinition of property") } else On = $e[Yt] = { init: !1, get: !1, set: !1 }; On[bn] = !0 } }, dr.parseExpression = function (Le, $e) { var rt = this.start, Pt = this.startLoc, Yt = this.parseMaybeAssign(Le, $e); if (this.type === Oe.comma) { var bn = this.startNodeAt(rt, Pt); for (bn.expressions = [Yt]; this.eat(Oe.comma);)bn.expressions.push(this.parseMaybeAssign(Le, $e)); return this.finishNode(bn, "SequenceExpression") } return Yt }, dr.parseMaybeAssign = function (Le, $e, rt) { if (this.isContextual("yield")) { if (this.inGenerator) return this.parseYield(Le); this.exprAllowed = !1 } var Pt = !1, Yt = -1, bn = -1, On = -1; $e ? (Yt = $e.parenthesizedAssign, bn = $e.trailingComma, On = $e.doubleProto, $e.parenthesizedAssign = $e.trailingComma = -1) : ($e = new jn, Pt = !0); var hr = this.start, pr = this.startLoc; (this.type === Oe.parenL || this.type === Oe.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = Le === "await"); var zr = this.parseMaybeConditional(Le, $e); if (rt && (zr = rt.call(this, zr, hr, pr)), this.type.isAssign) { var Hr = this.startNodeAt(hr, pr); return Hr.operator = this.value, this.type === Oe.eq && (zr = this.toAssignable(zr, !1, $e)), Pt || ($e.parenthesizedAssign = $e.trailingComma = $e.doubleProto = -1), $e.shorthandAssign >= zr.start && ($e.shorthandAssign = -1), this.type === Oe.eq ? this.checkLValPattern(zr) : this.checkLValSimple(zr), Hr.left = zr, this.next(), Hr.right = this.parseMaybeAssign(Le), On > -1 && ($e.doubleProto = On), this.finishNode(Hr, "AssignmentExpression") } else Pt && this.checkExpressionErrors($e, !0); return Yt > -1 && ($e.parenthesizedAssign = Yt), bn > -1 && ($e.trailingComma = bn), zr }, dr.parseMaybeConditional = function (Le, $e) { var rt = this.start, Pt = this.startLoc, Yt = this.parseExprOps(Le, $e); if (this.checkExpressionErrors($e)) return Yt; if (this.eat(Oe.question)) { var bn = this.startNodeAt(rt, Pt); return bn.test = Yt, bn.consequent = this.parseMaybeAssign(), this.expect(Oe.colon), bn.alternate = this.parseMaybeAssign(Le), this.finishNode(bn, "ConditionalExpression") } return Yt }, dr.parseExprOps = function (Le, $e) { var rt = this.start, Pt = this.startLoc, Yt = this.parseMaybeUnary($e, !1, !1, Le); return this.checkExpressionErrors($e) || Yt.start === rt && Yt.type === "ArrowFunctionExpression" ? Yt : this.parseExprOp(Yt, rt, Pt, -1, Le) }, dr.parseExprOp = function (Le, $e, rt, Pt, Yt) { var bn = this.type.binop; if (bn != null && (!Yt || this.type !== Oe._in) && bn > Pt) { var On = this.type === Oe.logicalOR || this.type === Oe.logicalAND, hr = this.type === Oe.coalesce; hr && (bn = Oe.logicalAND.binop); var pr = this.value; this.next(); var zr = this.start, Hr = this.startLoc, Ni = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, Yt), zr, Hr, bn, Yt), ai = this.buildBinary($e, rt, Le, Ni, pr, On || hr); return (On && this.type === Oe.coalesce || hr && (this.type === Oe.logicalOR || this.type === Oe.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(ai, $e, rt, Pt, Yt) } return Le }, dr.buildBinary = function (Le, $e, rt, Pt, Yt, bn) { Pt.type === "PrivateIdentifier" && this.raise(Pt.start, "Private identifier can only be left side of binary expression"); var On = this.startNodeAt(Le, $e); return On.left = rt, On.operator = Yt, On.right = Pt, this.finishNode(On, bn ? "LogicalExpression" : "BinaryExpression") }, dr.parseMaybeUnary = function (Le, $e, rt, Pt) { var Yt = this.start, bn = this.startLoc, On; if (this.isContextual("await") && this.canAwait) On = this.parseAwait(Pt), $e = !0; else if (this.type.prefix) { var hr = this.startNode(), pr = this.type === Oe.incDec; hr.operator = this.value, hr.prefix = !0, this.next(), hr.argument = this.parseMaybeUnary(null, !0, pr, Pt), this.checkExpressionErrors(Le, !0), pr ? this.checkLValSimple(hr.argument) : this.strict && hr.operator === "delete" && mi(hr.argument) ? this.raiseRecoverable(hr.start, "Deleting local variable in strict mode") : hr.operator === "delete" && bi(hr.argument) ? this.raiseRecoverable(hr.start, "Private fields can not be deleted") : $e = !0, On = this.finishNode(hr, pr ? "UpdateExpression" : "UnaryExpression") } else if (!$e && this.type === Oe.privateId) (Pt || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), On = this.parsePrivateIdent(), this.type !== Oe._in && this.unexpected(); else { if (On = this.parseExprSubscripts(Le, Pt), this.checkExpressionErrors(Le)) return On; for (; this.type.postfix && !this.canInsertSemicolon();) { var zr = this.startNodeAt(Yt, bn); zr.operator = this.value, zr.prefix = !1, zr.argument = On, this.checkLValSimple(On), this.next(), On = this.finishNode(zr, "UpdateExpression") } } if (!rt && this.eat(Oe.starstar)) if ($e) this.unexpected(this.lastTokStart); else return this.buildBinary(Yt, bn, On, this.parseMaybeUnary(null, !1, !1, Pt), "**", !1); else return On }; function mi(Le) { return Le.type === "Identifier" || Le.type === "ParenthesizedExpression" && mi(Le.expression) } function bi(Le) { return Le.type === "MemberExpression" && Le.property.type === "PrivateIdentifier" || Le.type === "ChainExpression" && bi(Le.expression) || Le.type === "ParenthesizedExpression" && bi(Le.expression) } dr.parseExprSubscripts = function (Le, $e) { var rt = this.start, Pt = this.startLoc, Yt = this.parseExprAtom(Le, $e); if (Yt.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return Yt; var bn = this.parseSubscripts(Yt, rt, Pt, !1, $e); return Le && bn.type === "MemberExpression" && (Le.parenthesizedAssign >= bn.start && (Le.parenthesizedAssign = -1), Le.parenthesizedBind >= bn.start && (Le.parenthesizedBind = -1), Le.trailingComma >= bn.start && (Le.trailingComma = -1)), bn }, dr.parseSubscripts = function (Le, $e, rt, Pt, Yt) { for (var bn = this.options.ecmaVersion >= 8 && Le.type === "Identifier" && Le.name === "async" && this.lastTokEnd === Le.end && !this.canInsertSemicolon() && Le.end - Le.start === 5 && this.potentialArrowAt === Le.start, On = !1; ;) { var hr = this.parseSubscript(Le, $e, rt, Pt, bn, On, Yt); if (hr.optional && (On = !0), hr === Le || hr.type === "ArrowFunctionExpression") { if (On) { var pr = this.startNodeAt($e, rt); pr.expression = hr, hr = this.finishNode(pr, "ChainExpression") } return hr } Le = hr } }, dr.shouldParseAsyncArrow = function () { return !this.canInsertSemicolon() && this.eat(Oe.arrow) }, dr.parseSubscriptAsyncArrow = function (Le, $e, rt, Pt) { return this.parseArrowExpression(this.startNodeAt(Le, $e), rt, !0, Pt) }, dr.parseSubscript = function (Le, $e, rt, Pt, Yt, bn, On) { var hr = this.options.ecmaVersion >= 11, pr = hr && this.eat(Oe.questionDot); Pt && pr && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); var zr = this.eat(Oe.bracketL); if (zr || pr && this.type !== Oe.parenL && this.type !== Oe.backQuote || this.eat(Oe.dot)) { var Hr = this.startNodeAt($e, rt); Hr.object = Le, zr ? (Hr.property = this.parseExpression(), this.expect(Oe.bracketR)) : this.type === Oe.privateId && Le.type !== "Super" ? Hr.property = this.parsePrivateIdent() : Hr.property = this.parseIdent(this.options.allowReserved !== "never"), Hr.computed = !!zr, hr && (Hr.optional = pr), Le = this.finishNode(Hr, "MemberExpression") } else if (!Pt && this.eat(Oe.parenL)) { var Ni = new jn, ai = this.yieldPos, vi = this.awaitPos, cs = this.awaitIdentPos; this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0; var Fi = this.parseExprList(Oe.parenR, this.options.ecmaVersion >= 8, !1, Ni); if (Yt && !pr && this.shouldParseAsyncArrow()) return this.checkPatternErrors(Ni, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = ai, this.awaitPos = vi, this.awaitIdentPos = cs, this.parseSubscriptAsyncArrow($e, rt, Fi, On); this.checkExpressionErrors(Ni, !0), this.yieldPos = ai || this.yieldPos, this.awaitPos = vi || this.awaitPos, this.awaitIdentPos = cs || this.awaitIdentPos; var Bi = this.startNodeAt($e, rt); Bi.callee = Le, Bi.arguments = Fi, hr && (Bi.optional = pr), Le = this.finishNode(Bi, "CallExpression") } else if (this.type === Oe.backQuote) { (pr || bn) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions"); var Di = this.startNodeAt($e, rt); Di.tag = Le, Di.quasi = this.parseTemplate({ isTagged: !0 }), Le = this.finishNode(Di, "TaggedTemplateExpression") } return Le }, dr.parseExprAtom = function (Le, $e, rt) { this.type === Oe.slash && this.readRegexp(); var Pt, Yt = this.potentialArrowAt === this.start; switch (this.type) { case Oe._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), Pt = this.startNode(), this.next(), this.type === Oe.parenL && !this.allowDirectSuper && this.raise(Pt.start, "super() call outside constructor of a subclass"), this.type !== Oe.dot && this.type !== Oe.bracketL && this.type !== Oe.parenL && this.unexpected(), this.finishNode(Pt, "Super"); case Oe._this: return Pt = this.startNode(), this.next(), this.finishNode(Pt, "ThisExpression"); case Oe.name: var bn = this.start, On = this.startLoc, hr = this.containsEsc, pr = this.parseIdent(!1); if (this.options.ecmaVersion >= 8 && !hr && pr.name === "async" && !this.canInsertSemicolon() && this.eat(Oe._function)) return this.overrideContext(ar.f_expr), this.parseFunction(this.startNodeAt(bn, On), 0, !1, !0, $e); if (Yt && !this.canInsertSemicolon()) { if (this.eat(Oe.arrow)) return this.parseArrowExpression(this.startNodeAt(bn, On), [pr], !1, $e); if (this.options.ecmaVersion >= 8 && pr.name === "async" && this.type === Oe.name && !hr && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return pr = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(Oe.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(bn, On), [pr], !0, $e) } return pr; case Oe.regexp: var zr = this.value; return Pt = this.parseLiteral(zr.value), Pt.regex = { pattern: zr.pattern, flags: zr.flags }, Pt; case Oe.num: case Oe.string: return this.parseLiteral(this.value); case Oe._null: case Oe._true: case Oe._false: return Pt = this.startNode(), Pt.value = this.type === Oe._null ? null : this.type === Oe._true, Pt.raw = this.type.keyword, this.next(), this.finishNode(Pt, "Literal"); case Oe.parenL: var Hr = this.start, Ni = this.parseParenAndDistinguishExpression(Yt, $e); return Le && (Le.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Ni) && (Le.parenthesizedAssign = Hr), Le.parenthesizedBind < 0 && (Le.parenthesizedBind = Hr)), Ni; case Oe.bracketL: return Pt = this.startNode(), this.next(), Pt.elements = this.parseExprList(Oe.bracketR, !0, !0, Le), this.finishNode(Pt, "ArrayExpression"); case Oe.braceL: return this.overrideContext(ar.b_expr), this.parseObj(!1, Le); case Oe._function: return Pt = this.startNode(), this.next(), this.parseFunction(Pt, 0); case Oe._class: return this.parseClass(this.startNode(), !1); case Oe._new: return this.parseNew(); case Oe.backQuote: return this.parseTemplate(); case Oe._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport(rt) : this.unexpected(); default: return this.parseExprAtomDefault() } }, dr.parseExprAtomDefault = function () { this.unexpected() }, dr.parseExprImport = function (Le) { var $e = this.startNode(); if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === Oe.parenL && !Le) return this.parseDynamicImport($e); if (this.type === Oe.dot) { var rt = this.startNodeAt($e.start, $e.loc && $e.loc.start); return rt.name = "import", $e.meta = this.finishNode(rt, "Identifier"), this.parseImportMeta($e) } else this.unexpected() }, dr.parseDynamicImport = function (Le) { if (this.next(), Le.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(Oe.parenR) ? Le.options = null : (this.expect(Oe.comma), this.afterTrailingComma(Oe.parenR) ? Le.options = null : (Le.options = this.parseMaybeAssign(), this.eat(Oe.parenR) || (this.expect(Oe.comma), this.afterTrailingComma(Oe.parenR) || this.unexpected()))); else if (!this.eat(Oe.parenR)) { var $e = this.start; this.eat(Oe.comma) && this.eat(Oe.parenR) ? this.raiseRecoverable($e, "Trailing comma is not allowed in import()") : this.unexpected($e) } return this.finishNode(Le, "ImportExpression") }, dr.parseImportMeta = function (Le) { this.next(); var $e = this.containsEsc; return Le.property = this.parseIdent(!0), Le.property.name !== "meta" && this.raiseRecoverable(Le.property.start, "The only valid meta property for import is 'import.meta'"), $e && this.raiseRecoverable(Le.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(Le.start, "Cannot use 'import.meta' outside a module"), this.finishNode(Le, "MetaProperty") }, dr.parseLiteral = function (Le) { var $e = this.startNode(); return $e.value = Le, $e.raw = this.input.slice(this.start, this.end), $e.raw.charCodeAt($e.raw.length - 1) === 110 && ($e.bigint = $e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode($e, "Literal") }, dr.parseParenExpression = function () { this.expect(Oe.parenL); var Le = this.parseExpression(); return this.expect(Oe.parenR), Le }, dr.shouldParseArrow = function (Le) { return !this.canInsertSemicolon() }, dr.parseParenAndDistinguishExpression = function (Le, $e) { var rt = this.start, Pt = this.startLoc, Yt, bn = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var On = this.start, hr = this.startLoc, pr = [], zr = !0, Hr = !1, Ni = new jn, ai = this.yieldPos, vi = this.awaitPos, cs; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== Oe.parenR;)if (zr ? zr = !1 : this.expect(Oe.comma), bn && this.afterTrailingComma(Oe.parenR, !0)) { Hr = !0; break } else if (this.type === Oe.ellipsis) { cs = this.start, pr.push(this.parseParenItem(this.parseRestBinding())), this.type === Oe.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); break } else pr.push(this.parseMaybeAssign(!1, Ni, this.parseParenItem)); var Fi = this.lastTokEnd, Bi = this.lastTokEndLoc; if (this.expect(Oe.parenR), Le && this.shouldParseArrow(pr) && this.eat(Oe.arrow)) return this.checkPatternErrors(Ni, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = ai, this.awaitPos = vi, this.parseParenArrowList(rt, Pt, pr, $e); (!pr.length || Hr) && this.unexpected(this.lastTokStart), cs && this.unexpected(cs), this.checkExpressionErrors(Ni, !0), this.yieldPos = ai || this.yieldPos, this.awaitPos = vi || this.awaitPos, pr.length > 1 ? (Yt = this.startNodeAt(On, hr), Yt.expressions = pr, this.finishNodeAt(Yt, "SequenceExpression", Fi, Bi)) : Yt = pr[0] } else Yt = this.parseParenExpression(); if (this.options.preserveParens) { var Di = this.startNodeAt(rt, Pt); return Di.expression = Yt, this.finishNode(Di, "ParenthesizedExpression") } else return Yt }, dr.parseParenItem = function (Le) { return Le }, dr.parseParenArrowList = function (Le, $e, rt, Pt) { return this.parseArrowExpression(this.startNodeAt(Le, $e), rt, !1, Pt) }; var ti = []; dr.parseNew = function () { this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new"); var Le = this.startNode(); if (this.next(), this.options.ecmaVersion >= 6 && this.type === Oe.dot) { var $e = this.startNodeAt(Le.start, Le.loc && Le.loc.start); $e.name = "new", Le.meta = this.finishNode($e, "Identifier"), this.next(); var rt = this.containsEsc; return Le.property = this.parseIdent(!0), Le.property.name !== "target" && this.raiseRecoverable(Le.property.start, "The only valid meta property for new is 'new.target'"), rt && this.raiseRecoverable(Le.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(Le.start, "'new.target' can only be used in functions and class static block"), this.finishNode(Le, "MetaProperty") } var Pt = this.start, Yt = this.startLoc; return Le.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), Pt, Yt, !0, !1), this.eat(Oe.parenL) ? Le.arguments = this.parseExprList(Oe.parenR, this.options.ecmaVersion >= 8, !1) : Le.arguments = ti, this.finishNode(Le, "NewExpression") }, dr.parseTemplateElement = function (Le) {
				var $e = Le.isTagged, rt = this.startNode(); return this.type === Oe.invalidTemplate ? ($e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), rt.value = {
					raw: this.value.replace(/\r\n?/g, `
`), cooked: null
				}) : rt.value = {
					raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value
				}, this.next(), rt.tail = this.type === Oe.backQuote, this.finishNode(rt, "TemplateElement")
			}, dr.parseTemplate = function (Le) { Le === void 0 && (Le = {}); var $e = Le.isTagged; $e === void 0 && ($e = !1); var rt = this.startNode(); this.next(), rt.expressions = []; var Pt = this.parseTemplateElement({ isTagged: $e }); for (rt.quasis = [Pt]; !Pt.tail;)this.type === Oe.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(Oe.dollarBraceL), rt.expressions.push(this.parseExpression()), this.expect(Oe.braceR), rt.quasis.push(Pt = this.parseTemplateElement({ isTagged: $e })); return this.next(), this.finishNode(rt, "TemplateLiteral") }, dr.isAsyncProp = function (Le) { return !Le.computed && Le.key.type === "Identifier" && Le.key.name === "async" && (this.type === Oe.name || this.type === Oe.num || this.type === Oe.string || this.type === Oe.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === Oe.star) && !Ue.test(this.input.slice(this.lastTokEnd, this.start)) }, dr.parseObj = function (Le, $e) { var rt = this.startNode(), Pt = !0, Yt = {}; for (rt.properties = [], this.next(); !this.eat(Oe.braceR);) { if (Pt) Pt = !1; else if (this.expect(Oe.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(Oe.braceR)) break; var bn = this.parseProperty(Le, $e); Le || this.checkPropClash(bn, Yt, $e), rt.properties.push(bn) } return this.finishNode(rt, Le ? "ObjectPattern" : "ObjectExpression") }, dr.parseProperty = function (Le, $e) { var rt = this.startNode(), Pt, Yt, bn, On; if (this.options.ecmaVersion >= 9 && this.eat(Oe.ellipsis)) return Le ? (rt.argument = this.parseIdent(!1), this.type === Oe.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(rt, "RestElement")) : (rt.argument = this.parseMaybeAssign(!1, $e), this.type === Oe.comma && $e && $e.trailingComma < 0 && ($e.trailingComma = this.start), this.finishNode(rt, "SpreadElement")); this.options.ecmaVersion >= 6 && (rt.method = !1, rt.shorthand = !1, (Le || $e) && (bn = this.start, On = this.startLoc), Le || (Pt = this.eat(Oe.star))); var hr = this.containsEsc; return this.parsePropertyName(rt), !Le && !hr && this.options.ecmaVersion >= 8 && !Pt && this.isAsyncProp(rt) ? (Yt = !0, Pt = this.options.ecmaVersion >= 9 && this.eat(Oe.star), this.parsePropertyName(rt)) : Yt = !1, this.parsePropertyValue(rt, Le, Pt, Yt, bn, On, $e, hr), this.finishNode(rt, "Property") }, dr.parseGetterSetter = function (Le) { var $e = Le.key.name; this.parsePropertyName(Le), Le.value = this.parseMethod(!1), Le.kind = $e; var rt = Le.kind === "get" ? 0 : 1; if (Le.value.params.length !== rt) { var Pt = Le.value.start; Le.kind === "get" ? this.raiseRecoverable(Pt, "getter should have no params") : this.raiseRecoverable(Pt, "setter should have exactly one param") } else Le.kind === "set" && Le.value.params[0].type === "RestElement" && this.raiseRecoverable(Le.value.params[0].start, "Setter cannot use rest params") }, dr.parsePropertyValue = function (Le, $e, rt, Pt, Yt, bn, On, hr) { (rt || Pt) && this.type === Oe.colon && this.unexpected(), this.eat(Oe.colon) ? (Le.value = $e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, On), Le.kind = "init") : this.options.ecmaVersion >= 6 && this.type === Oe.parenL ? ($e && this.unexpected(), Le.method = !0, Le.value = this.parseMethod(rt, Pt), Le.kind = "init") : !$e && !hr && this.options.ecmaVersion >= 5 && !Le.computed && Le.key.type === "Identifier" && (Le.key.name === "get" || Le.key.name === "set") && this.type !== Oe.comma && this.type !== Oe.braceR && this.type !== Oe.eq ? ((rt || Pt) && this.unexpected(), this.parseGetterSetter(Le)) : this.options.ecmaVersion >= 6 && !Le.computed && Le.key.type === "Identifier" ? ((rt || Pt) && this.unexpected(), this.checkUnreserved(Le.key), Le.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = Yt), $e ? Le.value = this.parseMaybeDefault(Yt, bn, this.copyNode(Le.key)) : this.type === Oe.eq && On ? (On.shorthandAssign < 0 && (On.shorthandAssign = this.start), Le.value = this.parseMaybeDefault(Yt, bn, this.copyNode(Le.key))) : Le.value = this.copyNode(Le.key), Le.kind = "init", Le.shorthand = !0) : this.unexpected() }, dr.parsePropertyName = function (Le) { if (this.options.ecmaVersion >= 6) { if (this.eat(Oe.bracketL)) return Le.computed = !0, Le.key = this.parseMaybeAssign(), this.expect(Oe.bracketR), Le.key; Le.computed = !1 } return Le.key = this.type === Oe.num || this.type === Oe.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never") }, dr.initFunction = function (Le) { Le.id = null, this.options.ecmaVersion >= 6 && (Le.generator = Le.expression = !1), this.options.ecmaVersion >= 8 && (Le.async = !1) }, dr.parseMethod = function (Le, $e, rt) { var Pt = this.startNode(), Yt = this.yieldPos, bn = this.awaitPos, On = this.awaitIdentPos; return this.initFunction(Pt), this.options.ecmaVersion >= 6 && (Pt.generator = Le), this.options.ecmaVersion >= 8 && (Pt.async = !!$e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(kn($e, Pt.generator) | nr | (rt ? Kn : 0)), this.expect(Oe.parenL), Pt.params = this.parseBindingList(Oe.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(Pt, !1, !0, !1), this.yieldPos = Yt, this.awaitPos = bn, this.awaitIdentPos = On, this.finishNode(Pt, "FunctionExpression") }, dr.parseArrowExpression = function (Le, $e, rt, Pt) { var Yt = this.yieldPos, bn = this.awaitPos, On = this.awaitIdentPos; return this.enterScope(kn(rt, !1) | Bn), this.initFunction(Le), this.options.ecmaVersion >= 8 && (Le.async = !!rt), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, Le.params = this.toAssignableList($e, !0), this.parseFunctionBody(Le, !0, !1, Pt), this.yieldPos = Yt, this.awaitPos = bn, this.awaitIdentPos = On, this.finishNode(Le, "ArrowFunctionExpression") }, dr.parseFunctionBody = function (Le, $e, rt, Pt) { var Yt = $e && this.type !== Oe.braceL, bn = this.strict, On = !1; if (Yt) Le.body = this.parseMaybeAssign(Pt), Le.expression = !0, this.checkParams(Le, !1); else { var hr = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(Le.params); (!bn || hr) && (On = this.strictDirective(this.end), On && hr && this.raiseRecoverable(Le.start, "Illegal 'use strict' directive in function with non-simple parameter list")); var pr = this.labels; this.labels = [], On && (this.strict = !0), this.checkParams(Le, !bn && !On && !$e && !rt && this.isSimpleParamList(Le.params)), this.strict && Le.id && this.checkLValSimple(Le.id, Wt), Le.body = this.parseBlock(!1, void 0, On && !bn), Le.expression = !1, this.adaptDirectivePrologue(Le.body.body), this.labels = pr } this.exitScope() }, dr.isSimpleParamList = function (Le) { for (var $e = 0, rt = Le; $e < rt.length; $e += 1) { var Pt = rt[$e]; if (Pt.type !== "Identifier") return !1 } return !0 }, dr.checkParams = function (Le, $e) { for (var rt = Object.create(null), Pt = 0, Yt = Le.params; Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; this.checkLValInnerPattern(bn, Dt, $e ? null : rt) } }, dr.parseExprList = function (Le, $e, rt, Pt) { for (var Yt = [], bn = !0; !this.eat(Le);) { if (bn) bn = !1; else if (this.expect(Oe.comma), $e && this.afterTrailingComma(Le)) break; var On = void 0; rt && this.type === Oe.comma ? On = null : this.type === Oe.ellipsis ? (On = this.parseSpread(Pt), Pt && this.type === Oe.comma && Pt.trailingComma < 0 && (Pt.trailingComma = this.start)) : On = this.parseMaybeAssign(!1, Pt), Yt.push(On) } return Yt }, dr.checkUnreserved = function (Le) { var $e = Le.start, rt = Le.end, Pt = Le.name; if (this.inGenerator && Pt === "yield" && this.raiseRecoverable($e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && Pt === "await" && this.raiseRecoverable($e, "Cannot use 'await' as identifier inside an async function"), !(this.currentThisScope().flags & Hn) && Pt === "arguments" && this.raiseRecoverable($e, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (Pt === "arguments" || Pt === "await") && this.raise($e, "Cannot use " + Pt + " in class static initialization block"), this.keywords.test(Pt) && this.raise($e, "Unexpected keyword '" + Pt + "'"), !(this.options.ecmaVersion < 6 && this.input.slice($e, rt).indexOf("\\") !== -1)) { var Yt = this.strict ? this.reservedWordsStrict : this.reservedWords; Yt.test(Pt) && (!this.inAsync && Pt === "await" && this.raiseRecoverable($e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable($e, "The keyword '" + Pt + "' is reserved")) } }, dr.parseIdent = function (Le) { var $e = this.parseIdentNode(); return this.next(!!Le), this.finishNode($e, "Identifier"), Le || (this.checkUnreserved($e), $e.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = $e.start)), $e }, dr.parseIdentNode = function () { var Le = this.startNode(); return this.type === Oe.name ? Le.name = this.value : this.type.keyword ? (Le.name = this.type.keyword, (Le.name === "class" || Le.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = Oe.name) : this.unexpected(), Le }, dr.parsePrivateIdent = function () { var Le = this.startNode(); return this.type === Oe.privateId ? Le.name = this.value : this.unexpected(), this.next(), this.finishNode(Le, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(Le.start, "Private field '#" + Le.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(Le)), Le }, dr.parseYield = function (Le) { this.yieldPos || (this.yieldPos = this.start); var $e = this.startNode(); return this.next(), this.type === Oe.semi || this.canInsertSemicolon() || this.type !== Oe.star && !this.type.startsExpr ? ($e.delegate = !1, $e.argument = null) : ($e.delegate = this.eat(Oe.star), $e.argument = this.parseMaybeAssign(Le)), this.finishNode($e, "YieldExpression") }, dr.parseAwait = function (Le) { this.awaitPos || (this.awaitPos = this.start); var $e = this.startNode(); return this.next(), $e.argument = this.parseMaybeUnary(null, !0, !1, Le), this.finishNode($e, "AwaitExpression") }; var Si = un.prototype; Si.raise = function (Le, $e) { var rt = nn(this.input, Le); $e += " (" + rt.line + ":" + rt.column + ")", this.sourceFile && ($e += " in " + this.sourceFile); var Pt = new SyntaxError($e); throw Pt.pos = Le, Pt.loc = rt, Pt.raisedAt = this.pos, Pt }, Si.raiseRecoverable = Si.raise, Si.curPosition = function () { if (this.options.locations) return new Xt(this.curLine, this.pos - this.lineStart) }; var ri = un.prototype, es = function ($e) { this.flags = $e, this.var = [], this.lexical = [], this.functions = [] }; ri.enterScope = function (Le) { this.scopeStack.push(new es(Le)) }, ri.exitScope = function () { this.scopeStack.pop() }, ri.treatFunctionsAsVarInScope = function (Le) { return Le.flags & Ln || !this.inModule && Le.flags & Xn }, ri.declareName = function (Le, $e, rt) { var Pt = !1; if ($e === fn) { var Yt = this.currentScope(); Pt = Yt.lexical.indexOf(Le) > -1 || Yt.functions.indexOf(Le) > -1 || Yt.var.indexOf(Le) > -1, Yt.lexical.push(Le), this.inModule && Yt.flags & Xn && delete this.undefinedExports[Le] } else if ($e === cn) { var bn = this.currentScope(); bn.lexical.push(Le) } else if ($e === en) { var On = this.currentScope(); this.treatFunctionsAsVar ? Pt = On.lexical.indexOf(Le) > -1 : Pt = On.lexical.indexOf(Le) > -1 || On.var.indexOf(Le) > -1, On.functions.push(Le) } else for (var hr = this.scopeStack.length - 1; hr >= 0; --hr) { var pr = this.scopeStack[hr]; if (pr.lexical.indexOf(Le) > -1 && !(pr.flags & Gt && pr.lexical[0] === Le) || !this.treatFunctionsAsVarInScope(pr) && pr.functions.indexOf(Le) > -1) { Pt = !0; break } if (pr.var.push(Le), this.inModule && pr.flags & Xn && delete this.undefinedExports[Le], pr.flags & Hn) break } Pt && this.raiseRecoverable(rt, "Identifier '" + Le + "' has already been declared") }, ri.checkLocalExport = function (Le) { this.scopeStack[0].lexical.indexOf(Le.name) === -1 && this.scopeStack[0].var.indexOf(Le.name) === -1 && (this.undefinedExports[Le.name] = Le) }, ri.currentScope = function () { return this.scopeStack[this.scopeStack.length - 1] }, ri.currentVarScope = function () { for (var Le = this.scopeStack.length - 1; ; Le--) { var $e = this.scopeStack[Le]; if ($e.flags & (Hn | yn | vn)) return $e } }, ri.currentThisScope = function () { for (var Le = this.scopeStack.length - 1; ; Le--) { var $e = this.scopeStack[Le]; if ($e.flags & (Hn | yn | vn) && !($e.flags & Bn)) return $e } }; var Hi = function ($e, rt, Pt) { this.type = "", this.start = rt, this.end = 0, $e.options.locations && (this.loc = new ct($e, Pt)), $e.options.directSourceFile && (this.sourceFile = $e.options.directSourceFile), $e.options.ranges && (this.range = [rt, 0]) }, Ai = un.prototype; Ai.startNode = function () { return new Hi(this, this.start, this.startLoc) }, Ai.startNodeAt = function (Le, $e) { return new Hi(this, Le, $e) }; function gi(Le, $e, rt, Pt) { return Le.type = $e, Le.end = rt, this.options.locations && (Le.loc.end = Pt), this.options.ranges && (Le.range[1] = rt), Le } Ai.finishNode = function (Le, $e) { return gi.call(this, Le, $e, this.lastTokEnd, this.lastTokEndLoc) }, Ai.finishNodeAt = function (Le, $e, rt, Pt) { return gi.call(this, Le, $e, rt, Pt) }, Ai.copyNode = function (Le) { var $e = new Hi(this, Le.start, this.startLoc); for (var rt in Le) $e[rt] = Le[rt]; return $e }; var ts = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", Ii = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Nr = Ii + " Extended_Pictographic", hs = Nr, xi = hs + " EBase EComp EMod EPres ExtPict", Rt = xi, Vt = Rt, dn = { 9: Ii, 10: Nr, 11: hs, 12: xi, 13: Rt, 14: Vt }, In = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", Vn = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: In }, Nn = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ir = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Jn = ir + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ft = Jn + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", qt = ft + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", sn = qt + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", ln = sn + " " + ts, pn = { 9: ir, 10: Jn, 11: ft, 12: qt, 13: sn, 14: ln }, Tn = {}; function $n(Le) { var $e = Tn[Le] = { binary: Nt(dn[Le] + " " + Nn), binaryOfStrings: Nt(Vn[Le]), nonBinary: { General_Category: Nt(Nn), Script: Nt(pn[Le]) } }; $e.nonBinary.Script_Extensions = $e.nonBinary.Script, $e.nonBinary.gc = $e.nonBinary.General_Category, $e.nonBinary.sc = $e.nonBinary.Script, $e.nonBinary.scx = $e.nonBinary.Script_Extensions } for (var Zn = 0, rr = [9, 10, 11, 12, 13, 14]; Zn < rr.length; Zn += 1) { var br = rr[Zn]; $n(br) } var Un = un.prototype, _r = function ($e, rt) { this.parent = $e, this.base = rt || this }; _r.prototype.separatedFrom = function ($e) { for (var rt = this; rt; rt = rt.parent)for (var Pt = $e; Pt; Pt = Pt.parent)if (rt.base === Pt.base && rt !== Pt) return !0; return !1 }, _r.prototype.sibling = function () { return new _r(this.parent, this.base) }; var Lr = function ($e) { this.parser = $e, this.validFlags = "gim" + ($e.options.ecmaVersion >= 6 ? "uy" : "") + ($e.options.ecmaVersion >= 9 ? "s" : "") + ($e.options.ecmaVersion >= 13 ? "d" : "") + ($e.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Tn[$e.options.ecmaVersion >= 14 ? 14 : $e.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = Object.create(null), this.backReferenceNames = [], this.branchID = null }; Lr.prototype.reset = function ($e, rt, Pt) { var Yt = Pt.indexOf("v") !== -1, bn = Pt.indexOf("u") !== -1; this.start = $e | 0, this.source = rt + "", this.flags = Pt, Yt && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = bn && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = bn && this.parser.options.ecmaVersion >= 9) }, Lr.prototype.raise = function ($e) { this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + $e) }, Lr.prototype.at = function ($e, rt) { rt === void 0 && (rt = !1); var Pt = this.source, Yt = Pt.length; if ($e >= Yt) return -1; var bn = Pt.charCodeAt($e); if (!(rt || this.switchU) || bn <= 55295 || bn >= 57344 || $e + 1 >= Yt) return bn; var On = Pt.charCodeAt($e + 1); return On >= 56320 && On <= 57343 ? (bn << 10) + On - 56613888 : bn }, Lr.prototype.nextIndex = function ($e, rt) { rt === void 0 && (rt = !1); var Pt = this.source, Yt = Pt.length; if ($e >= Yt) return Yt; var bn = Pt.charCodeAt($e), On; return !(rt || this.switchU) || bn <= 55295 || bn >= 57344 || $e + 1 >= Yt || (On = Pt.charCodeAt($e + 1)) < 56320 || On > 57343 ? $e + 1 : $e + 2 }, Lr.prototype.current = function ($e) { return $e === void 0 && ($e = !1), this.at(this.pos, $e) }, Lr.prototype.lookahead = function ($e) { return $e === void 0 && ($e = !1), this.at(this.nextIndex(this.pos, $e), $e) }, Lr.prototype.advance = function ($e) { $e === void 0 && ($e = !1), this.pos = this.nextIndex(this.pos, $e) }, Lr.prototype.eat = function ($e, rt) { return rt === void 0 && (rt = !1), this.current(rt) === $e ? (this.advance(rt), !0) : !1 }, Lr.prototype.eatChars = function ($e, rt) { rt === void 0 && (rt = !1); for (var Pt = this.pos, Yt = 0, bn = $e; Yt < bn.length; Yt += 1) { var On = bn[Yt], hr = this.at(Pt, rt); if (hr === -1 || hr !== On) return !1; Pt = this.nextIndex(Pt, rt) } return this.pos = Pt, !0 }, Un.validateRegExpFlags = function (Le) { for (var $e = Le.validFlags, rt = Le.flags, Pt = !1, Yt = !1, bn = 0; bn < rt.length; bn++) { var On = rt.charAt(bn); $e.indexOf(On) === -1 && this.raise(Le.start, "Invalid regular expression flag"), rt.indexOf(On, bn + 1) > -1 && this.raise(Le.start, "Duplicate regular expression flag"), On === "u" && (Pt = !0), On === "v" && (Yt = !0) } this.options.ecmaVersion >= 15 && Pt && Yt && this.raise(Le.start, "Invalid regular expression flag") }; function Br(Le) { for (var $e in Le) return !0; return !1 } Un.validateRegExpPattern = function (Le) { this.regexp_pattern(Le), !Le.switchN && this.options.ecmaVersion >= 9 && Br(Le.groupNames) && (Le.switchN = !0, this.regexp_pattern(Le)) }, Un.regexp_pattern = function (Le) { Le.pos = 0, Le.lastIntValue = 0, Le.lastStringValue = "", Le.lastAssertionIsQuantifiable = !1, Le.numCapturingParens = 0, Le.maxBackReference = 0, Le.groupNames = Object.create(null), Le.backReferenceNames.length = 0, Le.branchID = null, this.regexp_disjunction(Le), Le.pos !== Le.source.length && (Le.eat(41) && Le.raise("Unmatched ')'"), (Le.eat(93) || Le.eat(125)) && Le.raise("Lone quantifier brackets")), Le.maxBackReference > Le.numCapturingParens && Le.raise("Invalid escape"); for (var $e = 0, rt = Le.backReferenceNames; $e < rt.length; $e += 1) { var Pt = rt[$e]; Le.groupNames[Pt] || Le.raise("Invalid named capture referenced") } }, Un.regexp_disjunction = function (Le) { var $e = this.options.ecmaVersion >= 16; for ($e && (Le.branchID = new _r(Le.branchID, null)), this.regexp_alternative(Le); Le.eat(124);)$e && (Le.branchID = Le.branchID.sibling()), this.regexp_alternative(Le); $e && (Le.branchID = Le.branchID.parent), this.regexp_eatQuantifier(Le, !0) && Le.raise("Nothing to repeat"), Le.eat(123) && Le.raise("Lone quantifier brackets") }, Un.regexp_alternative = function (Le) { for (; Le.pos < Le.source.length && this.regexp_eatTerm(Le);); }, Un.regexp_eatTerm = function (Le) { return this.regexp_eatAssertion(Le) ? (Le.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(Le) && Le.switchU && Le.raise("Invalid quantifier"), !0) : (Le.switchU ? this.regexp_eatAtom(Le) : this.regexp_eatExtendedAtom(Le)) ? (this.regexp_eatQuantifier(Le), !0) : !1 }, Un.regexp_eatAssertion = function (Le) { var $e = Le.pos; if (Le.lastAssertionIsQuantifiable = !1, Le.eat(94) || Le.eat(36)) return !0; if (Le.eat(92)) { if (Le.eat(66) || Le.eat(98)) return !0; Le.pos = $e } if (Le.eat(40) && Le.eat(63)) { var rt = !1; if (this.options.ecmaVersion >= 9 && (rt = Le.eat(60)), Le.eat(61) || Le.eat(33)) return this.regexp_disjunction(Le), Le.eat(41) || Le.raise("Unterminated group"), Le.lastAssertionIsQuantifiable = !rt, !0 } return Le.pos = $e, !1 }, Un.regexp_eatQuantifier = function (Le, $e) { return $e === void 0 && ($e = !1), this.regexp_eatQuantifierPrefix(Le, $e) ? (Le.eat(63), !0) : !1 }, Un.regexp_eatQuantifierPrefix = function (Le, $e) { return Le.eat(42) || Le.eat(43) || Le.eat(63) || this.regexp_eatBracedQuantifier(Le, $e) }, Un.regexp_eatBracedQuantifier = function (Le, $e) { var rt = Le.pos; if (Le.eat(123)) { var Pt = 0, Yt = -1; if (this.regexp_eatDecimalDigits(Le) && (Pt = Le.lastIntValue, Le.eat(44) && this.regexp_eatDecimalDigits(Le) && (Yt = Le.lastIntValue), Le.eat(125))) return Yt !== -1 && Yt < Pt && !$e && Le.raise("numbers out of order in {} quantifier"), !0; Le.switchU && !$e && Le.raise("Incomplete quantifier"), Le.pos = rt } return !1 }, Un.regexp_eatAtom = function (Le) { return this.regexp_eatPatternCharacters(Le) || Le.eat(46) || this.regexp_eatReverseSolidusAtomEscape(Le) || this.regexp_eatCharacterClass(Le) || this.regexp_eatUncapturingGroup(Le) || this.regexp_eatCapturingGroup(Le) }, Un.regexp_eatReverseSolidusAtomEscape = function (Le) { var $e = Le.pos; if (Le.eat(92)) { if (this.regexp_eatAtomEscape(Le)) return !0; Le.pos = $e } return !1 }, Un.regexp_eatUncapturingGroup = function (Le) { var $e = Le.pos; if (Le.eat(40)) { if (Le.eat(63)) { if (this.options.ecmaVersion >= 16) { var rt = this.regexp_eatModifiers(Le), Pt = Le.eat(45); if (rt || Pt) { for (var Yt = 0; Yt < rt.length; Yt++) { var bn = rt.charAt(Yt); rt.indexOf(bn, Yt + 1) > -1 && Le.raise("Duplicate regular expression modifiers") } if (Pt) { var On = this.regexp_eatModifiers(Le); !rt && !On && Le.current() === 58 && Le.raise("Invalid regular expression modifiers"); for (var hr = 0; hr < On.length; hr++) { var pr = On.charAt(hr); (On.indexOf(pr, hr + 1) > -1 || rt.indexOf(pr) > -1) && Le.raise("Duplicate regular expression modifiers") } } } } if (Le.eat(58)) { if (this.regexp_disjunction(Le), Le.eat(41)) return !0; Le.raise("Unterminated group") } } Le.pos = $e } return !1 }, Un.regexp_eatCapturingGroup = function (Le) { if (Le.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(Le) : Le.current() === 63 && Le.raise("Invalid group"), this.regexp_disjunction(Le), Le.eat(41)) return Le.numCapturingParens += 1, !0; Le.raise("Unterminated group") } return !1 }, Un.regexp_eatModifiers = function (Le) { for (var $e = "", rt = 0; (rt = Le.current()) !== -1 && ni(rt);)$e += Je(rt), Le.advance(); return $e }; function ni(Le) { return Le === 105 || Le === 109 || Le === 115 } Un.regexp_eatExtendedAtom = function (Le) { return Le.eat(46) || this.regexp_eatReverseSolidusAtomEscape(Le) || this.regexp_eatCharacterClass(Le) || this.regexp_eatUncapturingGroup(Le) || this.regexp_eatCapturingGroup(Le) || this.regexp_eatInvalidBracedQuantifier(Le) || this.regexp_eatExtendedPatternCharacter(Le) }, Un.regexp_eatInvalidBracedQuantifier = function (Le) { return this.regexp_eatBracedQuantifier(Le, !0) && Le.raise("Nothing to repeat"), !1 }, Un.regexp_eatSyntaxCharacter = function (Le) { var $e = Le.current(); return wr($e) ? (Le.lastIntValue = $e, Le.advance(), !0) : !1 }; function wr(Le) { return Le === 36 || Le >= 40 && Le <= 43 || Le === 46 || Le === 63 || Le >= 91 && Le <= 94 || Le >= 123 && Le <= 125 } Un.regexp_eatPatternCharacters = function (Le) { for (var $e = Le.pos, rt = 0; (rt = Le.current()) !== -1 && !wr(rt);)Le.advance(); return Le.pos !== $e }, Un.regexp_eatExtendedPatternCharacter = function (Le) { var $e = Le.current(); return $e !== -1 && $e !== 36 && !($e >= 40 && $e <= 43) && $e !== 46 && $e !== 63 && $e !== 91 && $e !== 94 && $e !== 124 ? (Le.advance(), !0) : !1 }, Un.regexp_groupSpecifier = function (Le) { if (Le.eat(63)) { this.regexp_eatGroupName(Le) || Le.raise("Invalid group"); var $e = this.options.ecmaVersion >= 16, rt = Le.groupNames[Le.lastStringValue]; if (rt) if ($e) for (var Pt = 0, Yt = rt; Pt < Yt.length; Pt += 1) { var bn = Yt[Pt]; bn.separatedFrom(Le.branchID) || Le.raise("Duplicate capture group name") } else Le.raise("Duplicate capture group name"); $e ? (rt || (Le.groupNames[Le.lastStringValue] = [])).push(Le.branchID) : Le.groupNames[Le.lastStringValue] = !0 } }, Un.regexp_eatGroupName = function (Le) { if (Le.lastStringValue = "", Le.eat(60)) { if (this.regexp_eatRegExpIdentifierName(Le) && Le.eat(62)) return !0; Le.raise("Invalid capture group name") } return !1 }, Un.regexp_eatRegExpIdentifierName = function (Le) { if (Le.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(Le)) { for (Le.lastStringValue += Je(Le.lastIntValue); this.regexp_eatRegExpIdentifierPart(Le);)Le.lastStringValue += Je(Le.lastIntValue); return !0 } return !1 }, Un.regexp_eatRegExpIdentifierStart = function (Le) { var $e = Le.pos, rt = this.options.ecmaVersion >= 11, Pt = Le.current(rt); return Le.advance(rt), Pt === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(Le, rt) && (Pt = Le.lastIntValue), Fr(Pt) ? (Le.lastIntValue = Pt, !0) : (Le.pos = $e, !1) }; function Fr(Le) { return we(Le, !0) || Le === 36 || Le === 95 } Un.regexp_eatRegExpIdentifierPart = function (Le) { var $e = Le.pos, rt = this.options.ecmaVersion >= 11, Pt = Le.current(rt); return Le.advance(rt), Pt === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(Le, rt) && (Pt = Le.lastIntValue), Dr(Pt) ? (Le.lastIntValue = Pt, !0) : (Le.pos = $e, !1) }; function Dr(Le) { return Be(Le, !0) || Le === 36 || Le === 95 || Le === 8204 || Le === 8205 } Un.regexp_eatAtomEscape = function (Le) { return this.regexp_eatBackReference(Le) || this.regexp_eatCharacterClassEscape(Le) || this.regexp_eatCharacterEscape(Le) || Le.switchN && this.regexp_eatKGroupName(Le) ? !0 : (Le.switchU && (Le.current() === 99 && Le.raise("Invalid unicode escape"), Le.raise("Invalid escape")), !1) }, Un.regexp_eatBackReference = function (Le) { var $e = Le.pos; if (this.regexp_eatDecimalEscape(Le)) { var rt = Le.lastIntValue; if (Le.switchU) return rt > Le.maxBackReference && (Le.maxBackReference = rt), !0; if (rt <= Le.numCapturingParens) return !0; Le.pos = $e } return !1 }, Un.regexp_eatKGroupName = function (Le) { if (Le.eat(107)) { if (this.regexp_eatGroupName(Le)) return Le.backReferenceNames.push(Le.lastStringValue), !0; Le.raise("Invalid named reference") } return !1 }, Un.regexp_eatCharacterEscape = function (Le) { return this.regexp_eatControlEscape(Le) || this.regexp_eatCControlLetter(Le) || this.regexp_eatZero(Le) || this.regexp_eatHexEscapeSequence(Le) || this.regexp_eatRegExpUnicodeEscapeSequence(Le, !1) || !Le.switchU && this.regexp_eatLegacyOctalEscapeSequence(Le) || this.regexp_eatIdentityEscape(Le) }, Un.regexp_eatCControlLetter = function (Le) { var $e = Le.pos; if (Le.eat(99)) { if (this.regexp_eatControlLetter(Le)) return !0; Le.pos = $e } return !1 }, Un.regexp_eatZero = function (Le) { return Le.current() === 48 && !Ji(Le.lookahead()) ? (Le.lastIntValue = 0, Le.advance(), !0) : !1 }, Un.regexp_eatControlEscape = function (Le) { var $e = Le.current(); return $e === 116 ? (Le.lastIntValue = 9, Le.advance(), !0) : $e === 110 ? (Le.lastIntValue = 10, Le.advance(), !0) : $e === 118 ? (Le.lastIntValue = 11, Le.advance(), !0) : $e === 102 ? (Le.lastIntValue = 12, Le.advance(), !0) : $e === 114 ? (Le.lastIntValue = 13, Le.advance(), !0) : !1 }, Un.regexp_eatControlLetter = function (Le) { var $e = Le.current(); return li($e) ? (Le.lastIntValue = $e % 32, Le.advance(), !0) : !1 }; function li(Le) { return Le >= 65 && Le <= 90 || Le >= 97 && Le <= 122 } Un.regexp_eatRegExpUnicodeEscapeSequence = function (Le, $e) { $e === void 0 && ($e = !1); var rt = Le.pos, Pt = $e || Le.switchU; if (Le.eat(117)) { if (this.regexp_eatFixedHexDigits(Le, 4)) { var Yt = Le.lastIntValue; if (Pt && Yt >= 55296 && Yt <= 56319) { var bn = Le.pos; if (Le.eat(92) && Le.eat(117) && this.regexp_eatFixedHexDigits(Le, 4)) { var On = Le.lastIntValue; if (On >= 56320 && On <= 57343) return Le.lastIntValue = (Yt - 55296) * 1024 + (On - 56320) + 65536, !0 } Le.pos = bn, Le.lastIntValue = Yt } return !0 } if (Pt && Le.eat(123) && this.regexp_eatHexDigits(Le) && Le.eat(125) && Gr(Le.lastIntValue)) return !0; Pt && Le.raise("Invalid unicode escape"), Le.pos = rt } return !1 }; function Gr(Le) { return Le >= 0 && Le <= 1114111 } Un.regexp_eatIdentityEscape = function (Le) { if (Le.switchU) return this.regexp_eatSyntaxCharacter(Le) ? !0 : Le.eat(47) ? (Le.lastIntValue = 47, !0) : !1; var $e = Le.current(); return $e !== 99 && (!Le.switchN || $e !== 107) ? (Le.lastIntValue = $e, Le.advance(), !0) : !1 }, Un.regexp_eatDecimalEscape = function (Le) { Le.lastIntValue = 0; var $e = Le.current(); if ($e >= 49 && $e <= 57) { do Le.lastIntValue = 10 * Le.lastIntValue + ($e - 48), Le.advance(); while (($e = Le.current()) >= 48 && $e <= 57); return !0 } return !1 }; var Wr = 0, ii = 1, kr = 2; Un.regexp_eatCharacterClassEscape = function (Le) { var $e = Le.current(); if (Zr($e)) return Le.lastIntValue = -1, Le.advance(), ii; var rt = !1; if (Le.switchU && this.options.ecmaVersion >= 9 && ((rt = $e === 80) || $e === 112)) { Le.lastIntValue = -1, Le.advance(); var Pt; if (Le.eat(123) && (Pt = this.regexp_eatUnicodePropertyValueExpression(Le)) && Le.eat(125)) return rt && Pt === kr && Le.raise("Invalid property name"), Pt; Le.raise("Invalid property name") } return Wr }; function Zr(Le) { return Le === 100 || Le === 68 || Le === 115 || Le === 83 || Le === 119 || Le === 87 } Un.regexp_eatUnicodePropertyValueExpression = function (Le) { var $e = Le.pos; if (this.regexp_eatUnicodePropertyName(Le) && Le.eat(61)) { var rt = Le.lastStringValue; if (this.regexp_eatUnicodePropertyValue(Le)) { var Pt = Le.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(Le, rt, Pt), ii } } if (Le.pos = $e, this.regexp_eatLoneUnicodePropertyNameOrValue(Le)) { var Yt = Le.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(Le, Yt) } return Wr }, Un.regexp_validateUnicodePropertyNameAndValue = function (Le, $e, rt) { qe(Le.unicodeProperties.nonBinary, $e) || Le.raise("Invalid property name"), Le.unicodeProperties.nonBinary[$e].test(rt) || Le.raise("Invalid property value") }, Un.regexp_validateUnicodePropertyNameOrValue = function (Le, $e) { if (Le.unicodeProperties.binary.test($e)) return ii; if (Le.switchV && Le.unicodeProperties.binaryOfStrings.test($e)) return kr; Le.raise("Invalid property name") }, Un.regexp_eatUnicodePropertyName = function (Le) { var $e = 0; for (Le.lastStringValue = ""; Xr($e = Le.current());)Le.lastStringValue += Je($e), Le.advance(); return Le.lastStringValue !== "" }; function Xr(Le) { return li(Le) || Le === 95 } Un.regexp_eatUnicodePropertyValue = function (Le) { var $e = 0; for (Le.lastStringValue = ""; Ri($e = Le.current());)Le.lastStringValue += Je($e), Le.advance(); return Le.lastStringValue !== "" }; function Ri(Le) { return Xr(Le) || Ji(Le) } Un.regexp_eatLoneUnicodePropertyNameOrValue = function (Le) { return this.regexp_eatUnicodePropertyValue(Le) }, Un.regexp_eatCharacterClass = function (Le) { if (Le.eat(91)) { var $e = Le.eat(94), rt = this.regexp_classContents(Le); return Le.eat(93) || Le.raise("Unterminated character class"), $e && rt === kr && Le.raise("Negated character class may contain strings"), !0 } return !1 }, Un.regexp_classContents = function (Le) { return Le.current() === 93 ? ii : Le.switchV ? this.regexp_classSetExpression(Le) : (this.regexp_nonEmptyClassRanges(Le), ii) }, Un.regexp_nonEmptyClassRanges = function (Le) { for (; this.regexp_eatClassAtom(Le);) { var $e = Le.lastIntValue; if (Le.eat(45) && this.regexp_eatClassAtom(Le)) { var rt = Le.lastIntValue; Le.switchU && ($e === -1 || rt === -1) && Le.raise("Invalid character class"), $e !== -1 && rt !== -1 && $e > rt && Le.raise("Range out of order in character class") } } }, Un.regexp_eatClassAtom = function (Le) { var $e = Le.pos; if (Le.eat(92)) { if (this.regexp_eatClassEscape(Le)) return !0; if (Le.switchU) { var rt = Le.current(); (rt === 99 || ya(rt)) && Le.raise("Invalid class escape"), Le.raise("Invalid escape") } Le.pos = $e } var Pt = Le.current(); return Pt !== 93 ? (Le.lastIntValue = Pt, Le.advance(), !0) : !1 }, Un.regexp_eatClassEscape = function (Le) { var $e = Le.pos; if (Le.eat(98)) return Le.lastIntValue = 8, !0; if (Le.switchU && Le.eat(45)) return Le.lastIntValue = 45, !0; if (!Le.switchU && Le.eat(99)) { if (this.regexp_eatClassControlLetter(Le)) return !0; Le.pos = $e } return this.regexp_eatCharacterClassEscape(Le) || this.regexp_eatCharacterEscape(Le) }, Un.regexp_classSetExpression = function (Le) { var $e = ii, rt; if (!this.regexp_eatClassSetRange(Le)) if (rt = this.regexp_eatClassSetOperand(Le)) { rt === kr && ($e = kr); for (var Pt = Le.pos; Le.eatChars([38, 38]);) { if (Le.current() !== 38 && (rt = this.regexp_eatClassSetOperand(Le))) { rt !== kr && ($e = ii); continue } Le.raise("Invalid character in character class") } if (Pt !== Le.pos) return $e; for (; Le.eatChars([45, 45]);)this.regexp_eatClassSetOperand(Le) || Le.raise("Invalid character in character class"); if (Pt !== Le.pos) return $e } else Le.raise("Invalid character in character class"); for (; ;)if (!this.regexp_eatClassSetRange(Le)) { if (rt = this.regexp_eatClassSetOperand(Le), !rt) return $e; rt === kr && ($e = kr) } }, Un.regexp_eatClassSetRange = function (Le) { var $e = Le.pos; if (this.regexp_eatClassSetCharacter(Le)) { var rt = Le.lastIntValue; if (Le.eat(45) && this.regexp_eatClassSetCharacter(Le)) { var Pt = Le.lastIntValue; return rt !== -1 && Pt !== -1 && rt > Pt && Le.raise("Range out of order in character class"), !0 } Le.pos = $e } return !1 }, Un.regexp_eatClassSetOperand = function (Le) { return this.regexp_eatClassSetCharacter(Le) ? ii : this.regexp_eatClassStringDisjunction(Le) || this.regexp_eatNestedClass(Le) }, Un.regexp_eatNestedClass = function (Le) { var $e = Le.pos; if (Le.eat(91)) { var rt = Le.eat(94), Pt = this.regexp_classContents(Le); if (Le.eat(93)) return rt && Pt === kr && Le.raise("Negated character class may contain strings"), Pt; Le.pos = $e } if (Le.eat(92)) { var Yt = this.regexp_eatCharacterClassEscape(Le); if (Yt) return Yt; Le.pos = $e } return null }, Un.regexp_eatClassStringDisjunction = function (Le) { var $e = Le.pos; if (Le.eatChars([92, 113])) { if (Le.eat(123)) { var rt = this.regexp_classStringDisjunctionContents(Le); if (Le.eat(125)) return rt } else Le.raise("Invalid escape"); Le.pos = $e } return null }, Un.regexp_classStringDisjunctionContents = function (Le) { for (var $e = this.regexp_classString(Le); Le.eat(124);)this.regexp_classString(Le) === kr && ($e = kr); return $e }, Un.regexp_classString = function (Le) { for (var $e = 0; this.regexp_eatClassSetCharacter(Le);)$e++; return $e === 1 ? ii : kr }, Un.regexp_eatClassSetCharacter = function (Le) { var $e = Le.pos; if (Le.eat(92)) return this.regexp_eatCharacterEscape(Le) || this.regexp_eatClassSetReservedPunctuator(Le) ? !0 : Le.eat(98) ? (Le.lastIntValue = 8, !0) : (Le.pos = $e, !1); var rt = Le.current(); return rt < 0 || rt === Le.lookahead() && di(rt) || yi(rt) ? !1 : (Le.advance(), Le.lastIntValue = rt, !0) }; function di(Le) { return Le === 33 || Le >= 35 && Le <= 38 || Le >= 42 && Le <= 44 || Le === 46 || Le >= 58 && Le <= 64 || Le === 94 || Le === 96 || Le === 126 } function yi(Le) { return Le === 40 || Le === 41 || Le === 45 || Le === 47 || Le >= 91 && Le <= 93 || Le >= 123 && Le <= 125 } Un.regexp_eatClassSetReservedPunctuator = function (Le) { var $e = Le.current(); return Vi($e) ? (Le.lastIntValue = $e, Le.advance(), !0) : !1 }; function Vi(Le) { return Le === 33 || Le === 35 || Le === 37 || Le === 38 || Le === 44 || Le === 45 || Le >= 58 && Le <= 62 || Le === 64 || Le === 96 || Le === 126 } Un.regexp_eatClassControlLetter = function (Le) { var $e = Le.current(); return Ji($e) || $e === 95 ? (Le.lastIntValue = $e % 32, Le.advance(), !0) : !1 }, Un.regexp_eatHexEscapeSequence = function (Le) { var $e = Le.pos; if (Le.eat(120)) { if (this.regexp_eatFixedHexDigits(Le, 2)) return !0; Le.switchU && Le.raise("Invalid escape"), Le.pos = $e } return !1 }, Un.regexp_eatDecimalDigits = function (Le) { var $e = Le.pos, rt = 0; for (Le.lastIntValue = 0; Ji(rt = Le.current());)Le.lastIntValue = 10 * Le.lastIntValue + (rt - 48), Le.advance(); return Le.pos !== $e }; function Ji(Le) { return Le >= 48 && Le <= 57 } Un.regexp_eatHexDigits = function (Le) { var $e = Le.pos, rt = 0; for (Le.lastIntValue = 0; vs(rt = Le.current());)Le.lastIntValue = 16 * Le.lastIntValue + Gs(rt), Le.advance(); return Le.pos !== $e }; function vs(Le) { return Le >= 48 && Le <= 57 || Le >= 65 && Le <= 70 || Le >= 97 && Le <= 102 } function Gs(Le) { return Le >= 65 && Le <= 70 ? 10 + (Le - 65) : Le >= 97 && Le <= 102 ? 10 + (Le - 97) : Le - 48 } Un.regexp_eatLegacyOctalEscapeSequence = function (Le) { if (this.regexp_eatOctalDigit(Le)) { var $e = Le.lastIntValue; if (this.regexp_eatOctalDigit(Le)) { var rt = Le.lastIntValue; $e <= 3 && this.regexp_eatOctalDigit(Le) ? Le.lastIntValue = $e * 64 + rt * 8 + Le.lastIntValue : Le.lastIntValue = $e * 8 + rt } else Le.lastIntValue = $e; return !0 } return !1 }, Un.regexp_eatOctalDigit = function (Le) { var $e = Le.current(); return ya($e) ? (Le.lastIntValue = $e - 48, Le.advance(), !0) : (Le.lastIntValue = 0, !1) }; function ya(Le) { return Le >= 48 && Le <= 55 } Un.regexp_eatFixedHexDigits = function (Le, $e) { var rt = Le.pos; Le.lastIntValue = 0; for (var Pt = 0; Pt < $e; ++Pt) { var Yt = Le.current(); if (!vs(Yt)) return Le.pos = rt, !1; Le.lastIntValue = 16 * Le.lastIntValue + Gs(Yt), Le.advance() } return !0 }; var $s = function ($e) { this.type = $e.type, this.value = $e.value, this.start = $e.start, this.end = $e.end, $e.options.locations && (this.loc = new ct($e, $e.startLoc, $e.endLoc)), $e.options.ranges && (this.range = [$e.start, $e.end]) }, $r = un.prototype; $r.next = function (Le) { !Le && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new $s(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, $r.getToken = function () { return this.next(), new $s(this) }, typeof Symbol < "u" && ($r[Symbol.iterator] = function () { var Le = this; return { next: function () { var $e = Le.getToken(); return { done: $e.type === Oe.eof, value: $e } } } }), $r.nextToken = function () { var Le = this.curContext(); if ((!Le || !Le.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(Oe.eof); if (Le.override) return Le.override(this); this.readToken(this.fullCharCodeAtPos()) }, $r.readToken = function (Le) { return we(Le, this.options.ecmaVersion >= 6) || Le === 92 ? this.readWord() : this.getTokenFromCode(Le) }, $r.fullCharCodeAtPos = function () { var Le = this.input.charCodeAt(this.pos); if (Le <= 55295 || Le >= 56320) return Le; var $e = this.input.charCodeAt(this.pos + 1); return $e <= 56319 || $e >= 57344 ? Le : (Le << 10) + $e - 56613888 }, $r.skipBlockComment = function () { var Le = this.options.onComment && this.curPosition(), $e = this.pos, rt = this.input.indexOf("*/", this.pos += 2); if (rt === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = rt + 2, this.options.locations) for (var Pt = void 0, Yt = $e; (Pt = ze(this.input, Yt, this.pos)) > -1;)++this.curLine, Yt = this.lineStart = Pt; this.options.onComment && this.options.onComment(!0, this.input.slice($e + 2, rt), $e, this.pos, Le, this.curPosition()) }, $r.skipLineComment = function (Le) { for (var $e = this.pos, rt = this.options.onComment && this.curPosition(), Pt = this.input.charCodeAt(this.pos += Le); this.pos < this.input.length && !Ge(Pt);)Pt = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice($e + Le, this.pos), $e, this.pos, rt, this.curPosition()) }, $r.skipSpace = function () { e: for (; this.pos < this.input.length;) { var Le = this.input.charCodeAt(this.pos); switch (Le) { case 32: case 160: ++this.pos; break; case 13: this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break e }break; default: if (Le > 8 && Le < 14 || Le >= 5760 && We.test(String.fromCharCode(Le))) ++this.pos; else break e } } }, $r.finishToken = function (Le, $e) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var rt = this.type; this.type = Le, this.value = $e, this.updateContext(rt) }, $r.readToken_dot = function () { var Le = this.input.charCodeAt(this.pos + 1); if (Le >= 48 && Le <= 57) return this.readNumber(!0); var $e = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && Le === 46 && $e === 46 ? (this.pos += 3, this.finishToken(Oe.ellipsis)) : (++this.pos, this.finishToken(Oe.dot)) }, $r.readToken_slash = function () { var Le = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : Le === 61 ? this.finishOp(Oe.assign, 2) : this.finishOp(Oe.slash, 1) }, $r.readToken_mult_modulo_exp = function (Le) { var $e = this.input.charCodeAt(this.pos + 1), rt = 1, Pt = Le === 42 ? Oe.star : Oe.modulo; return this.options.ecmaVersion >= 7 && Le === 42 && $e === 42 && (++rt, Pt = Oe.starstar, $e = this.input.charCodeAt(this.pos + 2)), $e === 61 ? this.finishOp(Oe.assign, rt + 1) : this.finishOp(Pt, rt) }, $r.readToken_pipe_amp = function (Le) { var $e = this.input.charCodeAt(this.pos + 1); if ($e === Le) { if (this.options.ecmaVersion >= 12) { var rt = this.input.charCodeAt(this.pos + 2); if (rt === 61) return this.finishOp(Oe.assign, 3) } return this.finishOp(Le === 124 ? Oe.logicalOR : Oe.logicalAND, 2) } return $e === 61 ? this.finishOp(Oe.assign, 2) : this.finishOp(Le === 124 ? Oe.bitwiseOR : Oe.bitwiseAND, 1) }, $r.readToken_caret = function () { var Le = this.input.charCodeAt(this.pos + 1); return Le === 61 ? this.finishOp(Oe.assign, 2) : this.finishOp(Oe.bitwiseXOR, 1) }, $r.readToken_plus_min = function (Le) { var $e = this.input.charCodeAt(this.pos + 1); return $e === Le ? $e === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Ue.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(Oe.incDec, 2) : $e === 61 ? this.finishOp(Oe.assign, 2) : this.finishOp(Oe.plusMin, 1) }, $r.readToken_lt_gt = function (Le) { var $e = this.input.charCodeAt(this.pos + 1), rt = 1; return $e === Le ? (rt = Le === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + rt) === 61 ? this.finishOp(Oe.assign, rt + 1) : this.finishOp(Oe.bitShift, rt)) : $e === 33 && Le === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : ($e === 61 && (rt = 2), this.finishOp(Oe.relational, rt)) }, $r.readToken_eq_excl = function (Le) { var $e = this.input.charCodeAt(this.pos + 1); return $e === 61 ? this.finishOp(Oe.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : Le === 61 && $e === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(Oe.arrow)) : this.finishOp(Le === 61 ? Oe.eq : Oe.prefix, 1) }, $r.readToken_question = function () { var Le = this.options.ecmaVersion; if (Le >= 11) { var $e = this.input.charCodeAt(this.pos + 1); if ($e === 46) { var rt = this.input.charCodeAt(this.pos + 2); if (rt < 48 || rt > 57) return this.finishOp(Oe.questionDot, 2) } if ($e === 63) { if (Le >= 12) { var Pt = this.input.charCodeAt(this.pos + 2); if (Pt === 61) return this.finishOp(Oe.assign, 3) } return this.finishOp(Oe.coalesce, 2) } } return this.finishOp(Oe.question, 1) }, $r.readToken_numberSign = function () { var Le = this.options.ecmaVersion, $e = 35; if (Le >= 13 && (++this.pos, $e = this.fullCharCodeAtPos(), we($e, !0) || $e === 92)) return this.finishToken(Oe.privateId, this.readWord1()); this.raise(this.pos, "Unexpected character '" + Je($e) + "'") }, $r.getTokenFromCode = function (Le) { switch (Le) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(Oe.parenL); case 41: return ++this.pos, this.finishToken(Oe.parenR); case 59: return ++this.pos, this.finishToken(Oe.semi); case 44: return ++this.pos, this.finishToken(Oe.comma); case 91: return ++this.pos, this.finishToken(Oe.bracketL); case 93: return ++this.pos, this.finishToken(Oe.bracketR); case 123: return ++this.pos, this.finishToken(Oe.braceL); case 125: return ++this.pos, this.finishToken(Oe.braceR); case 58: return ++this.pos, this.finishToken(Oe.colon); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(Oe.backQuote); case 48: var $e = this.input.charCodeAt(this.pos + 1); if ($e === 120 || $e === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if ($e === 111 || $e === 79) return this.readRadixNumber(8); if ($e === 98 || $e === 66) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(Le); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(Le); case 124: case 38: return this.readToken_pipe_amp(Le); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(Le); case 60: case 62: return this.readToken_lt_gt(Le); case 61: case 33: return this.readToken_eq_excl(Le); case 63: return this.readToken_question(); case 126: return this.finishOp(Oe.prefix, 1); case 35: return this.readToken_numberSign() }this.raise(this.pos, "Unexpected character '" + Je(Le) + "'") }, $r.finishOp = function (Le, $e) { var rt = this.input.slice(this.pos, this.pos + $e); return this.pos += $e, this.finishToken(Le, rt) }, $r.readRegexp = function () { for (var Le, $e, rt = this.pos; ;) { this.pos >= this.input.length && this.raise(rt, "Unterminated regular expression"); var Pt = this.input.charAt(this.pos); if (Ue.test(Pt) && this.raise(rt, "Unterminated regular expression"), Le) Le = !1; else { if (Pt === "[") $e = !0; else if (Pt === "]" && $e) $e = !1; else if (Pt === "/" && !$e) break; Le = Pt === "\\" } ++this.pos } var Yt = this.input.slice(rt, this.pos); ++this.pos; var bn = this.pos, On = this.readWord1(); this.containsEsc && this.unexpected(bn); var hr = this.regexpState || (this.regexpState = new Lr(this)); hr.reset(rt, Yt, On), this.validateRegExpFlags(hr), this.validateRegExpPattern(hr); var pr = null; try { pr = new RegExp(Yt, On) } catch { } return this.finishToken(Oe.regexp, { pattern: Yt, flags: On, value: pr }) }, $r.readInt = function (Le, $e, rt) { for (var Pt = this.options.ecmaVersion >= 12 && $e === void 0, Yt = rt && this.input.charCodeAt(this.pos) === 48, bn = this.pos, On = 0, hr = 0, pr = 0, zr = $e ?? 1 / 0; pr < zr; ++pr, ++this.pos) { var Hr = this.input.charCodeAt(this.pos), Ni = void 0; if (Pt && Hr === 95) { Yt && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), hr === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), pr === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), hr = Hr; continue } if (Hr >= 97 ? Ni = Hr - 97 + 10 : Hr >= 65 ? Ni = Hr - 65 + 10 : Hr >= 48 && Hr <= 57 ? Ni = Hr - 48 : Ni = 1 / 0, Ni >= Le) break; hr = Hr, On = On * Le + Ni } return Pt && hr === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === bn || $e != null && this.pos - bn !== $e ? null : On }; function Bs(Le, $e) { return $e ? parseInt(Le, 8) : parseFloat(Le.replace(/_/g, "")) } function oa(Le) { return typeof BigInt != "function" ? null : BigInt(Le.replace(/_/g, "")) } $r.readRadixNumber = function (Le) { var $e = this.pos; this.pos += 2; var rt = this.readInt(Le); return rt == null && this.raise(this.start + 2, "Expected number in radix " + Le), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (rt = oa(this.input.slice($e, this.pos)), ++this.pos) : we(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Oe.num, rt) }, $r.readNumber = function (Le) { var $e = this.pos; !Le && this.readInt(10, void 0, !0) === null && this.raise($e, "Invalid number"); var rt = this.pos - $e >= 2 && this.input.charCodeAt($e) === 48; rt && this.strict && this.raise($e, "Invalid number"); var Pt = this.input.charCodeAt(this.pos); if (!rt && !Le && this.options.ecmaVersion >= 11 && Pt === 110) { var Yt = oa(this.input.slice($e, this.pos)); return ++this.pos, we(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Oe.num, Yt) } rt && /[89]/.test(this.input.slice($e, this.pos)) && (rt = !1), Pt === 46 && !rt && (++this.pos, this.readInt(10), Pt = this.input.charCodeAt(this.pos)), (Pt === 69 || Pt === 101) && !rt && (Pt = this.input.charCodeAt(++this.pos), (Pt === 43 || Pt === 45) && ++this.pos, this.readInt(10) === null && this.raise($e, "Invalid number")), we(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var bn = Bs(this.input.slice($e, this.pos), rt); return this.finishToken(Oe.num, bn) }, $r.readCodePoint = function () { var Le = this.input.charCodeAt(this.pos), $e; if (Le === 123) { this.options.ecmaVersion < 6 && this.unexpected(); var rt = ++this.pos; $e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, $e > 1114111 && this.invalidStringToken(rt, "Code point out of bounds") } else $e = this.readHexChar(4); return $e }, $r.readString = function (Le) { for (var $e = "", rt = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var Pt = this.input.charCodeAt(this.pos); if (Pt === Le) break; Pt === 92 ? ($e += this.input.slice(rt, this.pos), $e += this.readEscapedChar(!1), rt = this.pos) : Pt === 8232 || Pt === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Ge(Pt) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return $e += this.input.slice(rt, this.pos++), this.finishToken(Oe.string, $e) }; var va = {}; $r.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (Le) { if (Le === va) this.readInvalidTemplateToken(); else throw Le } this.inTemplateElement = !1 }, $r.invalidStringToken = function (Le, $e) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw va; this.raise(Le, $e) }, $r.readTmplToken = function () {
				for (var Le = "", $e = this.pos; ;) {
					this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var rt = this.input.charCodeAt(this.pos); if (rt === 96 || rt === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === Oe.template || this.type === Oe.invalidTemplate) ? rt === 36 ? (this.pos += 2, this.finishToken(Oe.dollarBraceL)) : (++this.pos, this.finishToken(Oe.backQuote)) : (Le += this.input.slice($e, this.pos), this.finishToken(Oe.template, Le)); if (rt === 92) Le += this.input.slice($e, this.pos), Le += this.readEscapedChar(!0), $e = this.pos; else if (Ge(rt)) {
						switch (Le += this.input.slice($e, this.pos), ++this.pos, rt) {
							case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: Le += `
`; break; default: Le += String.fromCharCode(rt); break
						}this.options.locations && (++this.curLine, this.lineStart = this.pos), $e = this.pos
					} else ++this.pos
				}
			}, $r.readInvalidTemplateToken = function () {
				for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) {
					case "\\": ++this.pos; break; case "$": if (this.input[this.pos + 1] !== "{") break; case "`": return this.finishToken(Oe.invalidTemplate, this.input.slice(this.start, this.pos)); case "\r": this.input[this.pos + 1] === `
`&& ++this.pos; case `
`: case "\u2028": case "\u2029": ++this.curLine, this.lineStart = this.pos + 1; break
				}this.raise(this.start, "Unterminated template")
			}, $r.readEscapedChar = function (Le) {
				var $e = this.input.charCodeAt(++this.pos); switch (++this.pos, $e) {
					case 110: return `
`; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return Je(this.readCodePoint()); case 116: return "	"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; case 56: case 57: if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), Le) { var rt = this.pos - 1; this.invalidStringToken(rt, "Invalid escape sequence in template string") } default: if ($e >= 48 && $e <= 55) { var Pt = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], Yt = parseInt(Pt, 8); return Yt > 255 && (Pt = Pt.slice(0, -1), Yt = parseInt(Pt, 8)), this.pos += Pt.length - 1, $e = this.input.charCodeAt(this.pos), (Pt !== "0" || $e === 56 || $e === 57) && (this.strict || Le) && this.invalidStringToken(this.pos - 1 - Pt.length, Le ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(Yt) } return Ge($e) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode($e)
				}
			}, $r.readHexChar = function (Le) { var $e = this.pos, rt = this.readInt(16, Le); return rt === null && this.invalidStringToken($e, "Bad character escape sequence"), rt }, $r.readWord1 = function () { this.containsEsc = !1; for (var Le = "", $e = !0, rt = this.pos, Pt = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var Yt = this.fullCharCodeAtPos(); if (Be(Yt, Pt)) this.pos += Yt <= 65535 ? 1 : 2; else if (Yt === 92) { this.containsEsc = !0, Le += this.input.slice(rt, this.pos); var bn = this.pos; this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var On = this.readCodePoint(); ($e ? we : Be)(On, Pt) || this.invalidStringToken(bn, "Invalid Unicode escape"), Le += Je(On), rt = this.pos } else break; $e = !1 } return Le + this.input.slice(rt, this.pos) }, $r.readWord = function () { var Le = this.readWord1(), $e = Oe.name; return this.keywords.test(Le) && ($e = Ne[Le]), this.finishToken($e, Le) }; var Ki = "8.14.1"; un.acorn = { Parser: un, version: Ki, defaultOptions: $t, Position: Xt, SourceLocation: ct, getLineInfo: nn, Node: Hi, TokenType: De, tokTypes: Oe, keywordTypes: Ne, TokContext: qn, tokContexts: ar, isIdentifierChar: Be, isIdentifierStart: we, Token: $s, isNewLine: Ge, lineBreak: Ue, lineBreakG: He, nonASCIIwhitespace: We }; function Pa(Le, $e) { return un.parse(Le, $e) } function Ws(Le, $e, rt) { return un.parseExpressionAt(Le, $e, rt) } function wa(Le, $e) { return un.tokenizer(Le, $e) } pe.Node = Hi, pe.Parser = un, pe.Position = Xt, pe.SourceLocation = ct, pe.TokContext = qn, pe.Token = $s, pe.TokenType = De, pe.defaultOptions = $t, pe.getLineInfo = nn, pe.isIdentifierChar = Be, pe.isIdentifierStart = we, pe.isNewLine = Ge, pe.keywordTypes = Ne, pe.lineBreak = Ue, pe.lineBreakG = He, pe.nonASCIIwhitespace = We, pe.parse = Pa, pe.parseExpressionAt = Ws, pe.tokContexts = ar, pe.tokTypes = Oe, pe.tokenizer = wa, pe.version = Ki
		})
	}(acorn, acorn.exports)), acorn.exports
} (function (fe) {
	const K = xhtml, pe = /^[\da-fA-F]+$/, me = /^\d+$/, ge = new WeakMap; function xe(_e) { _e = _e.Parser.acorn || _e; let Ee = ge.get(_e); if (!Ee) { const be = _e.tokTypes, Ae = _e.TokContext, Se = _e.TokenType, Ce = new Ae("<tag", !1), we = new Ae("</tag", !1), Be = new Ae("<tag>...</tag>", !0, !0), De = { tc_oTag: Ce, tc_cTag: we, tc_expr: Be }, Re = { jsxName: new Se("jsxName"), jsxText: new Se("jsxText", { beforeExpr: !0 }), jsxTagStart: new Se("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: new Se("jsxTagEnd") }; Re.jsxTagStart.updateContext = function () { this.context.push(Be), this.context.push(Ce), this.exprAllowed = !1 }, Re.jsxTagEnd.updateContext = function (Ie) { let Pe = this.context.pop(); Pe === Ce && Ie === be.slash || Pe === we ? (this.context.pop(), this.exprAllowed = this.curContext() === Be) : this.exprAllowed = !0 }, Ee = { tokContexts: De, tokTypes: Re }, ge.set(_e, Ee) } return Ee } function ye(_e) { if (!_e) return _e; if (_e.type === "JSXIdentifier") return _e.name; if (_e.type === "JSXNamespacedName") return _e.namespace.name + ":" + _e.name.name; if (_e.type === "JSXMemberExpression") return ye(_e.object) + "." + ye(_e.property) } fe.exports = function (_e) { return _e = _e || {}, function (Ee) { return ve({ allowNamespaces: _e.allowNamespaces !== !1, allowNamespacedObjects: !!_e.allowNamespacedObjects }, Ee) } }, Object.defineProperty(fe.exports, "tokTypes", { get: function () { return xe(requireAcorn()).tokTypes }, configurable: !0, enumerable: !0 }); function ve(_e, Ee) {
		const be = Ee.acorn || requireAcorn(), Ae = xe(be), Se = be.tokTypes, Ce = Ae.tokTypes, we = be.tokContexts, Be = Ae.tokContexts.tc_oTag, De = Ae.tokContexts.tc_cTag, Re = Ae.tokContexts.tc_expr, Ie = be.isNewLine, Pe = be.isIdentifierStart, Ne = be.isIdentifierChar; return class extends Ee {
			static get acornJsx() { return Ae } jsx_readToken() { let ke = "", Oe = this.pos; for (; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents"); let Ue = this.input.charCodeAt(this.pos); switch (Ue) { case 60: case 123: return this.pos === this.start ? Ue === 60 && this.exprAllowed ? (++this.pos, this.finishToken(Ce.jsxTagStart)) : this.getTokenFromCode(Ue) : (ke += this.input.slice(Oe, this.pos), this.finishToken(Ce.jsxText, ke)); case 38: ke += this.input.slice(Oe, this.pos), ke += this.jsx_readEntity(), Oe = this.pos; break; case 62: case 125: this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (Ue === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'); default: Ie(Ue) ? (ke += this.input.slice(Oe, this.pos), ke += this.jsx_readNewLine(!0), Oe = this.pos) : ++this.pos } } } jsx_readNewLine(ke) {
				let Oe = this.input.charCodeAt(this.pos), Ue; return ++this.pos, Oe === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, Ue = ke ? `
`: `\r
`) : Ue = String.fromCharCode(Oe), this.options.locations && (++this.curLine, this.lineStart = this.pos), Ue
			} jsx_readString(ke) { let Oe = "", Ue = ++this.pos; for (; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); let He = this.input.charCodeAt(this.pos); if (He === ke) break; He === 38 ? (Oe += this.input.slice(Ue, this.pos), Oe += this.jsx_readEntity(), Ue = this.pos) : Ie(He) ? (Oe += this.input.slice(Ue, this.pos), Oe += this.jsx_readNewLine(!1), Ue = this.pos) : ++this.pos } return Oe += this.input.slice(Ue, this.pos++), this.finishToken(Se.string, Oe) } jsx_readEntity() { let ke = "", Oe = 0, Ue, He = this.input[this.pos]; He !== "&" && this.raise(this.pos, "Entity must start with an ampersand"); let Ge = ++this.pos; for (; this.pos < this.input.length && Oe++ < 10;) { if (He = this.input[this.pos++], He === ";") { ke[0] === "#" ? ke[1] === "x" ? (ke = ke.substr(2), pe.test(ke) && (Ue = String.fromCharCode(parseInt(ke, 16)))) : (ke = ke.substr(1), me.test(ke) && (Ue = String.fromCharCode(parseInt(ke, 10)))) : Ue = K[ke]; break } ke += He } return Ue || (this.pos = Ge, "&") } jsx_readWord() { let ke, Oe = this.pos; do ke = this.input.charCodeAt(++this.pos); while (Ne(ke) || ke === 45); return this.finishToken(Ce.jsxName, this.input.slice(Oe, this.pos)) } jsx_parseIdentifier() { let ke = this.startNode(); return this.type === Ce.jsxName ? ke.name = this.value : this.type.keyword ? ke.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(ke, "JSXIdentifier") } jsx_parseNamespacedName() { let ke = this.start, Oe = this.startLoc, Ue = this.jsx_parseIdentifier(); if (!_e.allowNamespaces || !this.eat(Se.colon)) return Ue; var He = this.startNodeAt(ke, Oe); return He.namespace = Ue, He.name = this.jsx_parseIdentifier(), this.finishNode(He, "JSXNamespacedName") } jsx_parseElementName() { if (this.type === Ce.jsxTagEnd) return ""; let ke = this.start, Oe = this.startLoc, Ue = this.jsx_parseNamespacedName(); for (this.type === Se.dot && Ue.type === "JSXNamespacedName" && !_e.allowNamespacedObjects && this.unexpected(); this.eat(Se.dot);) { let He = this.startNodeAt(ke, Oe); He.object = Ue, He.property = this.jsx_parseIdentifier(), Ue = this.finishNode(He, "JSXMemberExpression") } return Ue } jsx_parseAttributeValue() { switch (this.type) { case Se.braceL: let ke = this.jsx_parseExpressionContainer(); return ke.expression.type === "JSXEmptyExpression" && this.raise(ke.start, "JSX attributes must only be assigned a non-empty expression"), ke; case Ce.jsxTagStart: case Se.string: return this.parseExprAtom(); default: this.raise(this.start, "JSX value should be either an expression or a quoted JSX text") } } jsx_parseEmptyExpression() { let ke = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc); return this.finishNodeAt(ke, "JSXEmptyExpression", this.start, this.startLoc) } jsx_parseExpressionContainer() { let ke = this.startNode(); return this.next(), ke.expression = this.type === Se.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(Se.braceR), this.finishNode(ke, "JSXExpressionContainer") } jsx_parseAttribute() { let ke = this.startNode(); return this.eat(Se.braceL) ? (this.expect(Se.ellipsis), ke.argument = this.parseMaybeAssign(), this.expect(Se.braceR), this.finishNode(ke, "JSXSpreadAttribute")) : (ke.name = this.jsx_parseNamespacedName(), ke.value = this.eat(Se.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(ke, "JSXAttribute")) } jsx_parseOpeningElementAt(ke, Oe) { let Ue = this.startNodeAt(ke, Oe); Ue.attributes = []; let He = this.jsx_parseElementName(); for (He && (Ue.name = He); this.type !== Se.slash && this.type !== Ce.jsxTagEnd;)Ue.attributes.push(this.jsx_parseAttribute()); return Ue.selfClosing = this.eat(Se.slash), this.expect(Ce.jsxTagEnd), this.finishNode(Ue, He ? "JSXOpeningElement" : "JSXOpeningFragment") } jsx_parseClosingElementAt(ke, Oe) { let Ue = this.startNodeAt(ke, Oe), He = this.jsx_parseElementName(); return He && (Ue.name = He), this.expect(Ce.jsxTagEnd), this.finishNode(Ue, He ? "JSXClosingElement" : "JSXClosingFragment") } jsx_parseElementAt(ke, Oe) { let Ue = this.startNodeAt(ke, Oe), He = [], Ge = this.jsx_parseOpeningElementAt(ke, Oe), ze = null; if (!Ge.selfClosing) { e: for (; ;)switch (this.type) { case Ce.jsxTagStart: if (ke = this.start, Oe = this.startLoc, this.next(), this.eat(Se.slash)) { ze = this.jsx_parseClosingElementAt(ke, Oe); break e } He.push(this.jsx_parseElementAt(ke, Oe)); break; case Ce.jsxText: He.push(this.parseExprAtom()); break; case Se.braceL: He.push(this.jsx_parseExpressionContainer()); break; default: this.unexpected() }ye(ze.name) !== ye(Ge.name) && this.raise(ze.start, "Expected corresponding JSX closing tag for <" + ye(Ge.name) + ">") } let We = Ge.name ? "Element" : "Fragment"; return Ue["opening" + We] = Ge, Ue["closing" + We] = ze, Ue.children = He, this.type === Se.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(Ue, "JSX" + We) } jsx_parseText() { let ke = this.parseLiteral(this.value); return ke.type = "JSXText", ke } jsx_parseElement() { let ke = this.start, Oe = this.startLoc; return this.next(), this.jsx_parseElementAt(ke, Oe) } parseExprAtom(ke) { return this.type === Ce.jsxText ? this.jsx_parseText() : this.type === Ce.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(ke) } readToken(ke) { let Oe = this.curContext(); if (Oe === Re) return this.jsx_readToken(); if (Oe === Be || Oe === De) { if (Pe(ke)) return this.jsx_readWord(); if (ke == 62) return ++this.pos, this.finishToken(Ce.jsxTagEnd); if ((ke === 34 || ke === 39) && Oe == Be) return this.jsx_readString(ke) } return ke === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(Ce.jsxTagStart)) : super.readToken(ke) } updateContext(ke) { if (this.type == Se.braceL) { var Oe = this.curContext(); Oe == Be ? this.context.push(we.b_expr) : Oe == Re ? this.context.push(we.b_tmpl) : super.updateContext(ke), this.exprAllowed = !0 } else if (this.type === Se.slash && ke === Ce.jsxTagStart) this.context.length -= 2, this.context.push(De), this.exprAllowed = !1; else return super.updateContext(ke) }
		}
	}
})(acornJsx$1); var acornJsxExports = acornJsx$1.exports; const acornJsx = getDefaultExportFromCjs(acornJsxExports), { stringify: stringify$2 } = JSON; if (!String.prototype.repeat) throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"); if (!String.prototype.endsWith) throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"); const OPERATOR_PRECEDENCE = { "||": 2, "??": 3, "&&": 4, "|": 5, "^": 6, "&": 7, "==": 8, "!=": 8, "===": 8, "!==": 8, "<": 9, ">": 9, "<=": 9, ">=": 9, in: 9, instanceof: 9, "<<": 10, ">>": 10, ">>>": 10, "+": 11, "-": 11, "*": 12, "%": 12, "/": 12, "**": 13 }, NEEDS_PARENTHESES = 17, EXPRESSIONS_PRECEDENCE = { ArrayExpression: 20, TaggedTemplateExpression: 20, ThisExpression: 20, Identifier: 20, PrivateIdentifier: 20, Literal: 18, TemplateLiteral: 20, Super: 20, SequenceExpression: 20, MemberExpression: 19, ChainExpression: 19, CallExpression: 19, NewExpression: 19, ArrowFunctionExpression: NEEDS_PARENTHESES, ClassExpression: NEEDS_PARENTHESES, FunctionExpression: NEEDS_PARENTHESES, ObjectExpression: NEEDS_PARENTHESES, UpdateExpression: 16, UnaryExpression: 15, AwaitExpression: 15, BinaryExpression: 14, LogicalExpression: 13, ConditionalExpression: 4, AssignmentExpression: 3, YieldExpression: 2, RestElement: 1 }; function formatSequence(fe, K) { const { generator: pe } = fe; if (fe.write("("), K != null && K.length > 0) { pe[K[0].type](K[0], fe); const { length: me } = K; for (let ge = 1; ge < me; ge++) { const xe = K[ge]; fe.write(", "), pe[xe.type](xe, fe) } } fe.write(")") } function expressionNeedsParenthesis(fe, K, pe, me) { const ge = fe.expressionsPrecedence[K.type]; if (ge === NEEDS_PARENTHESES) return !0; const xe = fe.expressionsPrecedence[pe.type]; return ge !== xe ? !me && ge === 15 && xe === 14 && pe.operator === "**" || ge < xe : ge !== 13 && ge !== 14 ? !1 : K.operator === "**" && pe.operator === "**" ? !me : ge === 13 && xe === 13 && (K.operator === "??" || pe.operator === "??") ? !0 : me ? OPERATOR_PRECEDENCE[K.operator] <= OPERATOR_PRECEDENCE[pe.operator] : OPERATOR_PRECEDENCE[K.operator] < OPERATOR_PRECEDENCE[pe.operator] } function formatExpression(fe, K, pe, me) { const { generator: ge } = fe; expressionNeedsParenthesis(fe, K, pe, me) ? (fe.write("("), ge[K.type](K, fe), fe.write(")")) : ge[K.type](K, fe) } function reindent(fe, K, pe, me) {
	const ge = K.split(`
`), xe = ge.length - 1; if (fe.write(ge[0].trim()), xe > 0) { fe.write(me); for (let ye = 1; ye < xe; ye++)fe.write(pe + ge[ye].trim() + me); fe.write(pe + ge[xe].trim()) }
} function formatComments(fe, K, pe, me) {
	const { length: ge } = K; for (let xe = 0; xe < ge; xe++) {
		const ye = K[xe]; fe.write(pe), ye.type[0] === "L" ? fe.write("// " + ye.value.trim() + `
`, ye) : (fe.write("/*"), reindent(fe, ye.value, pe, me), fe.write("*/" + me))
	}
} function hasCallExpression(fe) { let K = fe; for (; K != null;) { const { type: pe } = K; if (pe[0] === "C" && pe[1] === "a") return !0; if (pe[0] === "M" && pe[1] === "e" && pe[2] === "m") K = K.object; else return !1 } } function formatVariableDeclaration(fe, K) { const { generator: pe } = fe, { declarations: me } = K; fe.write(K.kind + " "); const { length: ge } = me; if (ge > 0) { pe.VariableDeclarator(me[0], fe); for (let xe = 1; xe < ge; xe++)fe.write(", "), pe.VariableDeclarator(me[xe], fe) } } let ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement; const GENERATOR = { Program(fe, K) { const pe = K.indent.repeat(K.indentLevel), { lineEnd: me, writeComments: ge } = K; ge && fe.comments != null && formatComments(K, fe.comments, pe, me); const xe = fe.body, { length: ye } = xe; for (let ve = 0; ve < ye; ve++) { const _e = xe[ve]; ge && _e.comments != null && formatComments(K, _e.comments, pe, me), K.write(pe), this[_e.type](_e, K), K.write(me) } ge && fe.trailingComments != null && formatComments(K, fe.trailingComments, pe, me) }, BlockStatement: BlockStatement = function (fe, K) { const pe = K.indent.repeat(K.indentLevel++), { lineEnd: me, writeComments: ge } = K, xe = pe + K.indent; K.write("{"); const ye = fe.body; if (ye != null && ye.length > 0) { K.write(me), ge && fe.comments != null && formatComments(K, fe.comments, xe, me); const { length: ve } = ye; for (let _e = 0; _e < ve; _e++) { const Ee = ye[_e]; ge && Ee.comments != null && formatComments(K, Ee.comments, xe, me), K.write(xe), this[Ee.type](Ee, K), K.write(me) } K.write(pe) } else ge && fe.comments != null && (K.write(me), formatComments(K, fe.comments, xe, me), K.write(pe)); ge && fe.trailingComments != null && formatComments(K, fe.trailingComments, xe, me), K.write("}"), K.indentLevel-- }, ClassBody: BlockStatement, StaticBlock(fe, K) { K.write("static "), this.BlockStatement(fe, K) }, EmptyStatement(fe, K) { K.write(";") }, ExpressionStatement(fe, K) { const pe = K.expressionsPrecedence[fe.expression.type]; pe === NEEDS_PARENTHESES || pe === 3 && fe.expression.left.type[0] === "O" ? (K.write("("), this[fe.expression.type](fe.expression, K), K.write(")")) : this[fe.expression.type](fe.expression, K), K.write(";") }, IfStatement(fe, K) { K.write("if ("), this[fe.test.type](fe.test, K), K.write(") "), this[fe.consequent.type](fe.consequent, K), fe.alternate != null && (K.write(" else "), this[fe.alternate.type](fe.alternate, K)) }, LabeledStatement(fe, K) { this[fe.label.type](fe.label, K), K.write(": "), this[fe.body.type](fe.body, K) }, BreakStatement(fe, K) { K.write("break"), fe.label != null && (K.write(" "), this[fe.label.type](fe.label, K)), K.write(";") }, ContinueStatement(fe, K) { K.write("continue"), fe.label != null && (K.write(" "), this[fe.label.type](fe.label, K)), K.write(";") }, WithStatement(fe, K) { K.write("with ("), this[fe.object.type](fe.object, K), K.write(") "), this[fe.body.type](fe.body, K) }, SwitchStatement(fe, K) { const pe = K.indent.repeat(K.indentLevel++), { lineEnd: me, writeComments: ge } = K; K.indentLevel++; const xe = pe + K.indent, ye = xe + K.indent; K.write("switch ("), this[fe.discriminant.type](fe.discriminant, K), K.write(") {" + me); const { cases: ve } = fe, { length: _e } = ve; for (let Ee = 0; Ee < _e; Ee++) { const be = ve[Ee]; ge && be.comments != null && formatComments(K, be.comments, xe, me), be.test ? (K.write(xe + "case "), this[be.test.type](be.test, K), K.write(":" + me)) : K.write(xe + "default:" + me); const { consequent: Ae } = be, { length: Se } = Ae; for (let Ce = 0; Ce < Se; Ce++) { const we = Ae[Ce]; ge && we.comments != null && formatComments(K, we.comments, ye, me), K.write(ye), this[we.type](we, K), K.write(me) } } K.indentLevel -= 2, K.write(pe + "}") }, ReturnStatement(fe, K) { K.write("return"), fe.argument && (K.write(" "), this[fe.argument.type](fe.argument, K)), K.write(";") }, ThrowStatement(fe, K) { K.write("throw "), this[fe.argument.type](fe.argument, K), K.write(";") }, TryStatement(fe, K) { if (K.write("try "), this[fe.block.type](fe.block, K), fe.handler) { const { handler: pe } = fe; pe.param == null ? K.write(" catch ") : (K.write(" catch ("), this[pe.param.type](pe.param, K), K.write(") ")), this[pe.body.type](pe.body, K) } fe.finalizer && (K.write(" finally "), this[fe.finalizer.type](fe.finalizer, K)) }, WhileStatement(fe, K) { K.write("while ("), this[fe.test.type](fe.test, K), K.write(") "), this[fe.body.type](fe.body, K) }, DoWhileStatement(fe, K) { K.write("do "), this[fe.body.type](fe.body, K), K.write(" while ("), this[fe.test.type](fe.test, K), K.write(");") }, ForStatement(fe, K) { if (K.write("for ("), fe.init != null) { const { init: pe } = fe; pe.type[0] === "V" ? formatVariableDeclaration(K, pe) : this[pe.type](pe, K) } K.write("; "), fe.test && this[fe.test.type](fe.test, K), K.write("; "), fe.update && this[fe.update.type](fe.update, K), K.write(") "), this[fe.body.type](fe.body, K) }, ForInStatement: ForInStatement = function (fe, K) { K.write(`for ${fe.await ? "await " : ""}(`); const { left: pe } = fe; pe.type[0] === "V" ? formatVariableDeclaration(K, pe) : this[pe.type](pe, K), K.write(fe.type[3] === "I" ? " in " : " of "), this[fe.right.type](fe.right, K), K.write(") "), this[fe.body.type](fe.body, K) }, ForOfStatement: ForInStatement, DebuggerStatement(fe, K) { K.write("debugger;", fe) }, FunctionDeclaration: FunctionDeclaration = function (fe, K) { K.write((fe.async ? "async " : "") + (fe.generator ? "function* " : "function ") + (fe.id ? fe.id.name : ""), fe), formatSequence(K, fe.params), K.write(" "), this[fe.body.type](fe.body, K) }, FunctionExpression: FunctionDeclaration, VariableDeclaration(fe, K) { formatVariableDeclaration(K, fe), K.write(";") }, VariableDeclarator(fe, K) { this[fe.id.type](fe.id, K), fe.init != null && (K.write(" = "), this[fe.init.type](fe.init, K)) }, ClassDeclaration(fe, K) { if (K.write("class " + (fe.id ? `${fe.id.name} ` : ""), fe), fe.superClass) { K.write("extends "); const { superClass: pe } = fe, { type: me } = pe, ge = K.expressionsPrecedence[me]; (me[0] !== "C" || me[1] !== "l" || me[5] !== "E") && (ge === NEEDS_PARENTHESES || ge < K.expressionsPrecedence.ClassExpression) ? (K.write("("), this[fe.superClass.type](pe, K), K.write(")")) : this[pe.type](pe, K), K.write(" ") } this.ClassBody(fe.body, K) }, ImportDeclaration(fe, K) { K.write("import "); const { specifiers: pe, attributes: me } = fe, { length: ge } = pe; let xe = 0; if (ge > 0) { for (; xe < ge;) { xe > 0 && K.write(", "); const ye = pe[xe], ve = ye.type[6]; if (ve === "D") K.write(ye.local.name, ye), xe++; else if (ve === "N") K.write("* as " + ye.local.name, ye), xe++; else break } if (xe < ge) { for (K.write("{"); ;) { const ye = pe[xe], { name: ve } = ye.imported; if (K.write(ve, ye), ve !== ye.local.name && K.write(" as " + ye.local.name), ++xe < ge) K.write(", "); else break } K.write("}") } K.write(" from ") } if (this.Literal(fe.source, K), me && me.length > 0) { K.write(" with { "); for (let ye = 0; ye < me.length; ye++)this.ImportAttribute(me[ye], K), ye < me.length - 1 && K.write(", "); K.write(" }") } K.write(";") }, ImportAttribute(fe, K) { this.Identifier(fe.key, K), K.write(": "), this.Literal(fe.value, K) }, ImportExpression(fe, K) { K.write("import("), this[fe.source.type](fe.source, K), K.write(")") }, ExportDefaultDeclaration(fe, K) { K.write("export default "), this[fe.declaration.type](fe.declaration, K), K.expressionsPrecedence[fe.declaration.type] != null && fe.declaration.type[0] !== "F" && K.write(";") }, ExportNamedDeclaration(fe, K) { if (K.write("export "), fe.declaration) this[fe.declaration.type](fe.declaration, K); else { K.write("{"); const { specifiers: pe } = fe, { length: me } = pe; if (me > 0) for (let ge = 0; ;) { const xe = pe[ge], { name: ye } = xe.local; if (K.write(ye, xe), ye !== xe.exported.name && K.write(" as " + xe.exported.name), ++ge < me) K.write(", "); else break } if (K.write("}"), fe.source && (K.write(" from "), this.Literal(fe.source, K)), fe.attributes && fe.attributes.length > 0) { K.write(" with { "); for (let ge = 0; ge < fe.attributes.length; ge++)this.ImportAttribute(fe.attributes[ge], K), ge < fe.attributes.length - 1 && K.write(", "); K.write(" }") } K.write(";") } }, ExportAllDeclaration(fe, K) { if (fe.exported != null ? K.write("export * as " + fe.exported.name + " from ") : K.write("export * from "), this.Literal(fe.source, K), fe.attributes && fe.attributes.length > 0) { K.write(" with { "); for (let pe = 0; pe < fe.attributes.length; pe++)this.ImportAttribute(fe.attributes[pe], K), pe < fe.attributes.length - 1 && K.write(", "); K.write(" }") } K.write(";") }, MethodDefinition(fe, K) { fe.static && K.write("static "); const pe = fe.kind[0]; (pe === "g" || pe === "s") && K.write(fe.kind + " "), fe.value.async && K.write("async "), fe.value.generator && K.write("*"), fe.computed ? (K.write("["), this[fe.key.type](fe.key, K), K.write("]")) : this[fe.key.type](fe.key, K), formatSequence(K, fe.value.params), K.write(" "), this[fe.value.body.type](fe.value.body, K) }, ClassExpression(fe, K) { this.ClassDeclaration(fe, K) }, ArrowFunctionExpression(fe, K) { K.write(fe.async ? "async " : "", fe); const { params: pe } = fe; pe != null && (pe.length === 1 && pe[0].type[0] === "I" ? K.write(pe[0].name, pe[0]) : formatSequence(K, fe.params)), K.write(" => "), fe.body.type[0] === "O" ? (K.write("("), this.ObjectExpression(fe.body, K), K.write(")")) : this[fe.body.type](fe.body, K) }, ThisExpression(fe, K) { K.write("this", fe) }, Super(fe, K) { K.write("super", fe) }, RestElement: RestElement = function (fe, K) { K.write("..."), this[fe.argument.type](fe.argument, K) }, SpreadElement: RestElement, YieldExpression(fe, K) { K.write(fe.delegate ? "yield*" : "yield"), fe.argument && (K.write(" "), this[fe.argument.type](fe.argument, K)) }, AwaitExpression(fe, K) { K.write("await ", fe), formatExpression(K, fe.argument, fe) }, TemplateLiteral(fe, K) { const { quasis: pe, expressions: me } = fe; K.write("`"); const { length: ge } = me; for (let ye = 0; ye < ge; ye++) { const ve = me[ye], _e = pe[ye]; K.write(_e.value.raw, _e), K.write("${"), this[ve.type](ve, K), K.write("}") } const xe = pe[pe.length - 1]; K.write(xe.value.raw, xe), K.write("`") }, TemplateElement(fe, K) { K.write(fe.value.raw, fe) }, TaggedTemplateExpression(fe, K) { formatExpression(K, fe.tag, fe), this[fe.quasi.type](fe.quasi, K) }, ArrayExpression: ArrayExpression = function (fe, K) { if (K.write("["), fe.elements.length > 0) { const { elements: pe } = fe, { length: me } = pe; for (let ge = 0; ;) { const xe = pe[ge]; if (xe != null && this[xe.type](xe, K), ++ge < me) K.write(", "); else { xe == null && K.write(", "); break } } } K.write("]") }, ArrayPattern: ArrayExpression, ObjectExpression(fe, K) { const pe = K.indent.repeat(K.indentLevel++), { lineEnd: me, writeComments: ge } = K, xe = pe + K.indent; if (K.write("{"), fe.properties.length > 0) { K.write(me), ge && fe.comments != null && formatComments(K, fe.comments, xe, me); const ye = "," + me, { properties: ve } = fe, { length: _e } = ve; for (let Ee = 0; ;) { const be = ve[Ee]; if (ge && be.comments != null && formatComments(K, be.comments, xe, me), K.write(xe), this[be.type](be, K), ++Ee < _e) K.write(ye); else break } K.write(me), ge && fe.trailingComments != null && formatComments(K, fe.trailingComments, xe, me), K.write(pe + "}") } else ge ? fe.comments != null ? (K.write(me), formatComments(K, fe.comments, xe, me), fe.trailingComments != null && formatComments(K, fe.trailingComments, xe, me), K.write(pe + "}")) : fe.trailingComments != null ? (K.write(me), formatComments(K, fe.trailingComments, xe, me), K.write(pe + "}")) : K.write("}") : K.write("}"); K.indentLevel-- }, Property(fe, K) { fe.method || fe.kind[0] !== "i" ? this.MethodDefinition(fe, K) : (fe.shorthand || (fe.computed ? (K.write("["), this[fe.key.type](fe.key, K), K.write("]")) : this[fe.key.type](fe.key, K), K.write(": ")), this[fe.value.type](fe.value, K)) }, PropertyDefinition(fe, K) { if (fe.static && K.write("static "), fe.computed && K.write("["), this[fe.key.type](fe.key, K), fe.computed && K.write("]"), fe.value == null) { fe.key.type[0] !== "F" && K.write(";"); return } K.write(" = "), this[fe.value.type](fe.value, K), K.write(";") }, ObjectPattern(fe, K) { if (K.write("{"), fe.properties.length > 0) { const { properties: pe } = fe, { length: me } = pe; for (let ge = 0; this[pe[ge].type](pe[ge], K), ++ge < me;)K.write(", ") } K.write("}") }, SequenceExpression(fe, K) { formatSequence(K, fe.expressions) }, UnaryExpression(fe, K) { if (fe.prefix) { const { operator: pe, argument: me, argument: { type: ge } } = fe; K.write(pe); const xe = expressionNeedsParenthesis(K, me, fe); !xe && (pe.length > 1 || ge[0] === "U" && (ge[1] === "n" || ge[1] === "p") && me.prefix && me.operator[0] === pe && (pe === "+" || pe === "-")) && K.write(" "), xe ? (K.write(pe.length > 1 ? " (" : "("), this[ge](me, K), K.write(")")) : this[ge](me, K) } else this[fe.argument.type](fe.argument, K), K.write(fe.operator) }, UpdateExpression(fe, K) { fe.prefix ? (K.write(fe.operator), this[fe.argument.type](fe.argument, K)) : (this[fe.argument.type](fe.argument, K), K.write(fe.operator)) }, AssignmentExpression(fe, K) { this[fe.left.type](fe.left, K), K.write(" " + fe.operator + " "), this[fe.right.type](fe.right, K) }, AssignmentPattern(fe, K) { this[fe.left.type](fe.left, K), K.write(" = "), this[fe.right.type](fe.right, K) }, BinaryExpression: BinaryExpression = function (fe, K) { const pe = fe.operator === "in"; pe && K.write("("), formatExpression(K, fe.left, fe, !1), K.write(" " + fe.operator + " "), formatExpression(K, fe.right, fe, !0), pe && K.write(")") }, LogicalExpression: BinaryExpression, ConditionalExpression(fe, K) { const { test: pe } = fe, me = K.expressionsPrecedence[pe.type]; me === NEEDS_PARENTHESES || me <= K.expressionsPrecedence.ConditionalExpression ? (K.write("("), this[pe.type](pe, K), K.write(")")) : this[pe.type](pe, K), K.write(" ? "), this[fe.consequent.type](fe.consequent, K), K.write(" : "), this[fe.alternate.type](fe.alternate, K) }, NewExpression(fe, K) { K.write("new "); const pe = K.expressionsPrecedence[fe.callee.type]; pe === NEEDS_PARENTHESES || pe < K.expressionsPrecedence.CallExpression || hasCallExpression(fe.callee) ? (K.write("("), this[fe.callee.type](fe.callee, K), K.write(")")) : this[fe.callee.type](fe.callee, K), formatSequence(K, fe.arguments) }, CallExpression(fe, K) { const pe = K.expressionsPrecedence[fe.callee.type]; pe === NEEDS_PARENTHESES || pe < K.expressionsPrecedence.CallExpression ? (K.write("("), this[fe.callee.type](fe.callee, K), K.write(")")) : this[fe.callee.type](fe.callee, K), fe.optional && K.write("?."), formatSequence(K, fe.arguments) }, ChainExpression(fe, K) { this[fe.expression.type](fe.expression, K) }, MemberExpression(fe, K) { const pe = K.expressionsPrecedence[fe.object.type]; pe === NEEDS_PARENTHESES || pe < K.expressionsPrecedence.MemberExpression ? (K.write("("), this[fe.object.type](fe.object, K), K.write(")")) : this[fe.object.type](fe.object, K), fe.computed ? (fe.optional && K.write("?."), K.write("["), this[fe.property.type](fe.property, K), K.write("]")) : (fe.optional ? K.write("?.") : K.write("."), this[fe.property.type](fe.property, K)) }, MetaProperty(fe, K) { K.write(fe.meta.name + "." + fe.property.name, fe) }, Identifier(fe, K) { K.write(fe.name, fe) }, PrivateIdentifier(fe, K) { K.write(`#${fe.name}`, fe) }, Literal(fe, K) { fe.raw != null ? K.write(fe.raw, fe) : fe.regex != null ? this.RegExpLiteral(fe, K) : fe.bigint != null ? K.write(fe.bigint + "n", fe) : K.write(stringify$2(fe.value), fe) }, RegExpLiteral(fe, K) { const { regex: pe } = fe; K.write(`/${pe.pattern}/${pe.flags}`, fe) } }, EMPTY_OBJECT = {}; class State {
	constructor(K) {
		const pe = K ?? EMPTY_OBJECT; this.output = "", pe.output != null ? (this.output = pe.output, this.write = this.writeToStream) : this.output = "", this.generator = pe.generator != null ? pe.generator : GENERATOR, this.expressionsPrecedence = pe.expressionsPrecedence != null ? pe.expressionsPrecedence : EXPRESSIONS_PRECEDENCE, this.indent = pe.indent != null ? pe.indent : "  ", this.lineEnd = pe.lineEnd != null ? pe.lineEnd : `
`, this.indentLevel = pe.startingIndentLevel != null ? pe.startingIndentLevel : 0, this.writeComments = pe.comments ? pe.comments : !1, pe.sourceMap != null && (this.write = pe.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = pe.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = { original: null, generated: this, name: void 0, source: pe.sourceMap.file || pe.sourceMap._file })
	} write(K) { this.output += K } writeToStream(K) { this.output.write(K) } writeAndMap(K, pe) { this.output += K, this.map(K, pe) } writeToStreamAndMap(K, pe) { this.output.write(K), this.map(K, pe) } map(K, pe) {
		if (pe != null) {
			const { type: xe } = pe; if (xe[0] === "L" && xe[2] === "n") { this.column = 0, this.line++; return } if (pe.loc != null) { const { mapping: ye } = this; ye.original = pe.loc.start, ye.name = pe.name, this.sourceMap.addMapping(ye) } if (xe[0] === "T" && xe[8] === "E" || xe[0] === "L" && xe[1] === "i" && typeof pe.value == "string") {
				const { length: ye } = K; let { column: ve, line: _e } = this; for (let Ee = 0; Ee < ye; Ee++)K[Ee] === `
`? (ve = 0, _e++) : ve++; this.column = ve, this.line = _e; return
			}
		} const { length: me } = K, { lineEnd: ge } = this; me > 0 && (this.lineEndSize > 0 && (ge.length === 1 ? K[me - 1] === ge : K.endsWith(ge)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += me)
	} toString() { return this.output }
} function generate(fe, K) { const pe = new State(K); return pe.generator[fe.type](fe, pe), pe.output } const emptyOptions$4 = {}; function toJs(fe, K) { const { SourceMapGenerator: pe, filePath: me, handlers: ge } = K || emptyOptions$4, xe = pe ? new pe({ file: me || "<unknown>.js" }) : void 0, ye = generate(fe, { comments: !0, generator: { ...GENERATOR, ...ge }, sourceMap: xe || void 0 }), ve = xe ? xe.toJSON() : void 0; return { value: ye, map: ve } } const jsx = { JSXAttribute: jsxAttribute, JSXClosingElement: jsxClosingElement, JSXClosingFragment: jsxClosingFragment, JSXElement: jsxElement, JSXEmptyExpression: jsxEmptyExpression, JSXExpressionContainer: jsxExpressionContainer, JSXFragment: jsxFragment, JSXIdentifier: jsxIdentifier, JSXMemberExpression: jsxMemberExpression, JSXNamespacedName: jsxNamespacedName, JSXOpeningElement: jsxOpeningElement, JSXOpeningFragment: jsxOpeningFragment, JSXSpreadAttribute: jsxSpreadAttribute, JSXText: jsxText$1 }; function jsxAttribute(fe, K) { this[fe.name.type](fe.name, K), fe.value !== null && fe.value !== void 0 && (K.write("="), fe.value.type === "Literal" ? K.write('"' + encodeJsx(String(fe.value.value)).replace(/"/g, "&quot;") + '"', fe) : this[fe.value.type](fe.value, K)) } function jsxClosingElement(fe, K) { K.write("</"), this[fe.name.type](fe.name, K), K.write(">") } function jsxClosingFragment(fe, K) { K.write("</>", fe) } function jsxElement(fe, K) { let pe = -1; if (this[fe.openingElement.type](fe.openingElement, K), fe.children) for (; ++pe < fe.children.length;) { const me = fe.children[pe]; if (me.type === "JSXSpreadChild") throw new Error("JSX spread children are not supported"); this[me.type](me, K) } fe.closingElement && this[fe.closingElement.type](fe.closingElement, K) } function jsxEmptyExpression() { } function jsxExpressionContainer(fe, K) { K.write("{"), this[fe.expression.type](fe.expression, K), K.write("}") } function jsxFragment(fe, K) { let pe = -1; if (this[fe.openingFragment.type](fe.openingFragment, K), fe.children) for (; ++pe < fe.children.length;) { const me = fe.children[pe]; if (me.type === "JSXSpreadChild") throw new Error("JSX spread children are not supported"); this[me.type](me, K) } this[fe.closingFragment.type](fe.closingFragment, K) } function jsxIdentifier(fe, K) { K.write(fe.name, fe) } function jsxMemberExpression(fe, K) { this[fe.object.type](fe.object, K), K.write("."), this[fe.property.type](fe.property, K) } function jsxNamespacedName(fe, K) { this[fe.namespace.type](fe.namespace, K), K.write(":"), this[fe.name.type](fe.name, K) } function jsxOpeningElement(fe, K) { let pe = -1; if (K.write("<"), this[fe.name.type](fe.name, K), fe.attributes) for (; ++pe < fe.attributes.length;)K.write(" "), this[fe.attributes[pe].type](fe.attributes[pe], K); K.write(fe.selfClosing ? " />" : ">") } function jsxOpeningFragment(fe, K) { K.write("<>", fe) } function jsxSpreadAttribute(fe, K) { K.write("{"), this.SpreadElement(fe, K), K.write("}") } function jsxText$1(fe, K) { K.write(encodeJsx(fe.value).replace(/[<>{}]/g, replaceJsxChar), fe) } function encodeJsx(fe) { return fe.replace(/&(?=[#a-z])/gi, "&amp;") } function replaceJsxChar(fe) { return fe === "<" ? "&lt;" : fe === ">" ? "&gt;" : fe === "{" ? "&#123;" : "&#125;" } function recmaJsx() { const fe = this.data(), K = fe.settings || (fe.settings = {}), pe = K.handlers || (K.handlers = {}); (K.plugins || (K.plugins = [])).push(acornJsx()), Object.assign(pe, jsx) } function recmaStringify(fe) { const K = this; this.compiler = pe; function pe(me, ge) { const xe = { ...K.data("settings"), ...fe }, ye = toJs(me, { SourceMapGenerator: xe.SourceMapGenerator, filePath: ge.path || "unknown.js", handlers: xe.handlers }); return ge.map = ye.map, ye.value } } function comment(fe, K) { const pe = { type: "Block", value: fe.value }; K.inherit(fe, pe), K.comments.push(pe); const me = { type: "JSXEmptyExpression", comments: [Object.assign({}, pe, { leading: !1, trailing: !0 })] }; K.patch(fe, me); const ge = { type: "JSXExpressionContainer", expression: me }; return K.patch(fe, ge), ge } function stringify$1(fe, K) { const pe = {}; return (fe[fe.length - 1] === "" ? [...fe, ""] : fe).join((pe.padRight ? " " : "") + "," + (pe.padLeft === !1 ? "" : " ")).trim() } class Schema { constructor(K, pe, me) { this.normal = pe, this.property = K, me && (this.space = me) } } Schema.prototype.normal = {}; Schema.prototype.property = {}; Schema.prototype.space = void 0; function merge(fe, K) { const pe = {}, me = {}; for (const ge of fe) Object.assign(pe, ge.property), Object.assign(me, ge.normal); return new Schema(pe, me, K) } function normalize(fe) { return fe.toLowerCase() } class Info { constructor(K, pe) { this.attribute = pe, this.property = K } } Info.prototype.attribute = ""; Info.prototype.booleanish = !1; Info.prototype.boolean = !1; Info.prototype.commaOrSpaceSeparated = !1; Info.prototype.commaSeparated = !1; Info.prototype.defined = !1; Info.prototype.mustUseProperty = !1; Info.prototype.number = !1; Info.prototype.overloadedBoolean = !1; Info.prototype.property = ""; Info.prototype.spaceSeparated = !1; Info.prototype.space = void 0; let powers = 0; const boolean = increment(), booleanish = increment(), overloadedBoolean = increment(), number = increment(), spaceSeparated = increment(), commaSeparated = increment(), commaOrSpaceSeparated = increment(); function increment() { return 2 ** ++powers } const types = Object.freeze(Object.defineProperty({ __proto__: null, boolean, booleanish, commaOrSpaceSeparated, commaSeparated, number, overloadedBoolean, spaceSeparated }, Symbol.toStringTag, { value: "Module" })), checks = Object.keys(types); class DefinedInfo extends Info { constructor(K, pe, me, ge) { let xe = -1; if (super(K, pe), mark(this, "space", ge), typeof me == "number") for (; ++xe < checks.length;) { const ye = checks[xe]; mark(this, checks[xe], (me & types[ye]) === types[ye]) } } } DefinedInfo.prototype.defined = !0; function mark(fe, K, pe) { pe && (fe[K] = pe) } function create$1(fe) { const K = {}, pe = {}; for (const [me, ge] of Object.entries(fe.properties)) { const xe = new DefinedInfo(me, fe.transform(fe.attributes || {}, me), ge, fe.space); fe.mustUseProperty && fe.mustUseProperty.includes(me) && (xe.mustUseProperty = !0), K[me] = xe, pe[normalize(me)] = me, pe[normalize(xe.attribute)] = me } return new Schema(K, pe, fe.space) } const aria = create$1({ properties: { ariaActiveDescendant: null, ariaAtomic: booleanish, ariaAutoComplete: null, ariaBusy: booleanish, ariaChecked: booleanish, ariaColCount: number, ariaColIndex: number, ariaColSpan: number, ariaControls: spaceSeparated, ariaCurrent: null, ariaDescribedBy: spaceSeparated, ariaDetails: null, ariaDisabled: booleanish, ariaDropEffect: spaceSeparated, ariaErrorMessage: null, ariaExpanded: booleanish, ariaFlowTo: spaceSeparated, ariaGrabbed: booleanish, ariaHasPopup: null, ariaHidden: booleanish, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: spaceSeparated, ariaLevel: number, ariaLive: null, ariaModal: booleanish, ariaMultiLine: booleanish, ariaMultiSelectable: booleanish, ariaOrientation: null, ariaOwns: spaceSeparated, ariaPlaceholder: null, ariaPosInSet: number, ariaPressed: booleanish, ariaReadOnly: booleanish, ariaRelevant: null, ariaRequired: booleanish, ariaRoleDescription: spaceSeparated, ariaRowCount: number, ariaRowIndex: number, ariaRowSpan: number, ariaSelected: booleanish, ariaSetSize: number, ariaSort: null, ariaValueMax: number, ariaValueMin: number, ariaValueNow: number, ariaValueText: null, role: null }, transform(fe, K) { return K === "role" ? K : "aria-" + K.slice(4).toLowerCase() } }); function caseSensitiveTransform(fe, K) { return K in fe ? fe[K] : K } function caseInsensitiveTransform(fe, K) { return caseSensitiveTransform(fe, K.toLowerCase()) } const html$4 = create$1({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: commaSeparated, acceptCharset: spaceSeparated, accessKey: spaceSeparated, action: null, allow: null, allowFullScreen: boolean, allowPaymentRequest: boolean, allowUserMedia: boolean, alt: null, as: null, async: boolean, autoCapitalize: null, autoComplete: spaceSeparated, autoFocus: boolean, autoPlay: boolean, blocking: spaceSeparated, capture: null, charSet: null, checked: boolean, cite: null, className: spaceSeparated, cols: number, colSpan: null, content: null, contentEditable: booleanish, controls: boolean, controlsList: spaceSeparated, coords: number | commaSeparated, crossOrigin: null, data: null, dateTime: null, decoding: null, default: boolean, defer: boolean, dir: null, dirName: null, disabled: boolean, download: overloadedBoolean, draggable: booleanish, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: boolean, formTarget: null, headers: spaceSeparated, height: number, hidden: boolean, high: number, href: null, hrefLang: null, htmlFor: spaceSeparated, httpEquiv: spaceSeparated, id: null, imageSizes: null, imageSrcSet: null, inert: boolean, inputMode: null, integrity: null, is: null, isMap: boolean, itemId: null, itemProp: spaceSeparated, itemRef: spaceSeparated, itemScope: boolean, itemType: spaceSeparated, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: boolean, low: number, manifest: null, max: null, maxLength: number, media: null, method: null, min: null, minLength: number, multiple: boolean, muted: boolean, name: null, nonce: null, noModule: boolean, noValidate: boolean, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: boolean, optimum: number, pattern: null, ping: spaceSeparated, placeholder: null, playsInline: boolean, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: boolean, referrerPolicy: null, rel: spaceSeparated, required: boolean, reversed: boolean, rows: number, rowSpan: number, sandbox: spaceSeparated, scope: null, scoped: boolean, seamless: boolean, selected: boolean, shadowRootClonable: boolean, shadowRootDelegatesFocus: boolean, shadowRootMode: null, shape: null, size: number, sizes: null, slot: null, span: number, spellCheck: booleanish, src: null, srcDoc: null, srcLang: null, srcSet: null, start: number, step: null, style: null, tabIndex: number, target: null, title: null, translate: null, type: null, typeMustMatch: boolean, useMap: null, value: booleanish, width: number, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: spaceSeparated, axis: null, background: null, bgColor: null, border: number, borderColor: null, bottomMargin: number, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: boolean, declare: boolean, event: null, face: null, frame: null, frameBorder: null, hSpace: number, leftMargin: number, link: null, longDesc: null, lowSrc: null, marginHeight: number, marginWidth: number, noResize: boolean, noHref: boolean, noShade: boolean, noWrap: boolean, object: null, profile: null, prompt: null, rev: null, rightMargin: number, rules: null, scheme: null, scrolling: booleanish, standby: null, summary: null, text: null, topMargin: number, valueType: null, version: null, vAlign: null, vLink: null, vSpace: number, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: boolean, disableRemotePlayback: boolean, prefix: null, property: null, results: number, security: null, unselectable: null }, space: "html", transform: caseInsensitiveTransform }), svg$1 = create$1({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: commaOrSpaceSeparated, accentHeight: number, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: number, amplitude: number, arabicForm: null, ascent: number, attributeName: null, attributeType: null, azimuth: number, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: number, by: null, calcMode: null, capHeight: number, className: spaceSeparated, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: number, diffuseConstant: number, direction: null, display: null, dur: null, divisor: number, dominantBaseline: null, download: boolean, dx: null, dy: null, edgeMode: null, editable: null, elevation: number, enableBackground: null, end: null, event: null, exponent: number, externalResourcesRequired: null, fill: null, fillOpacity: number, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: commaSeparated, g2: commaSeparated, glyphName: commaSeparated, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: number, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: number, horizOriginX: number, horizOriginY: number, id: null, ideographic: number, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: number, k: number, k1: number, k2: number, k3: number, k4: number, kernelMatrix: commaOrSpaceSeparated, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: number, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: number, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: number, overlineThickness: number, paintOrder: null, panose1: null, path: null, pathLength: number, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: spaceSeparated, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: number, pointsAtY: number, pointsAtZ: number, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: commaOrSpaceSeparated, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: commaOrSpaceSeparated, rev: commaOrSpaceSeparated, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: commaOrSpaceSeparated, requiredFeatures: commaOrSpaceSeparated, requiredFonts: commaOrSpaceSeparated, requiredFormats: commaOrSpaceSeparated, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: number, specularExponent: number, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: number, strikethroughThickness: number, string: null, stroke: null, strokeDashArray: commaOrSpaceSeparated, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: number, strokeOpacity: number, strokeWidth: null, style: null, surfaceScale: number, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: commaOrSpaceSeparated, tabIndex: number, tableValues: null, target: null, targetX: number, targetY: number, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: commaOrSpaceSeparated, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: number, underlineThickness: number, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: number, values: null, vAlphabetic: number, vMathematical: number, vectorEffect: null, vHanging: number, vIdeographic: number, version: null, vertAdvY: number, vertOriginX: number, vertOriginY: number, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: number, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: caseSensitiveTransform }), xlink = create$1({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform(fe, K) { return "xlink:" + K.slice(5).toLowerCase() } }), xmlns = create$1({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: caseInsensitiveTransform }), xml = create$1({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform(fe, K) { return "xml:" + K.slice(3).toLowerCase() } }), hastToReact = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, cap$1 = /[A-Z]/g, dash = /-[a-z]/g, valid = /^data[-\w.:]+$/i; function find(fe, K) { const pe = normalize(K); let me = K, ge = Info; if (pe in fe.normal) return fe.property[fe.normal[pe]]; if (pe.length > 4 && pe.slice(0, 4) === "data" && valid.test(K)) { if (K.charAt(4) === "-") { const xe = K.slice(5).replace(dash, camelcase); me = "data" + xe.charAt(0).toUpperCase() + xe.slice(1) } else { const xe = K.slice(4); if (!dash.test(xe)) { let ye = xe.replace(cap$1, kebab); ye.charAt(0) !== "-" && (ye = "-" + ye), K = "data" + ye } } ge = DefinedInfo } return new ge(me, K) } function kebab(fe) { return "-" + fe.toLowerCase() } function camelcase(fe) { return fe.charAt(1).toUpperCase() } const html$3 = merge([aria, html$4, xlink, xmlns, xml], "html"), svg = merge([aria, svg$1, xlink, xmlns, xml], "svg"); function stringify(fe) { return fe.join(" ").trim() } var cjs$1 = {}, COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = `
`, FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration", inlineStyleParser = function (fe, K) { if (typeof fe != "string") throw new TypeError("First argument must be a string"); if (!fe) return []; K = K || {}; var pe = 1, me = 1; function ge(we) { var Be = we.match(NEWLINE_REGEX); Be && (pe += Be.length); var De = we.lastIndexOf(NEWLINE); me = ~De ? we.length - De : me + we.length } function xe() { var we = { line: pe, column: me }; return function (Be) { return Be.position = new ye(we), Ee(), Be } } function ye(we) { this.start = we, this.end = { line: pe, column: me }, this.source = K.source } ye.prototype.content = fe; function ve(we) { var Be = new Error(K.source + ":" + pe + ":" + me + ": " + we); if (Be.reason = we, Be.filename = K.source, Be.line = pe, Be.column = me, Be.source = fe, !K.silent) throw Be } function _e(we) { var Be = we.exec(fe); if (Be) { var De = Be[0]; return ge(De), fe = fe.slice(De.length), Be } } function Ee() { _e(WHITESPACE_REGEX) } function be(we) { var Be; for (we = we || []; Be = Ae();)Be !== !1 && we.push(Be); return we } function Ae() { var we = xe(); if (!(FORWARD_SLASH != fe.charAt(0) || ASTERISK != fe.charAt(1))) { for (var Be = 2; EMPTY_STRING != fe.charAt(Be) && (ASTERISK != fe.charAt(Be) || FORWARD_SLASH != fe.charAt(Be + 1));)++Be; if (Be += 2, EMPTY_STRING === fe.charAt(Be - 1)) return ve("End of comment missing"); var De = fe.slice(2, Be - 2); return me += 2, ge(De), fe = fe.slice(Be), me += 2, we({ type: TYPE_COMMENT, comment: De }) } } function Se() { var we = xe(), Be = _e(PROPERTY_REGEX); if (Be) { if (Ae(), !_e(COLON_REGEX)) return ve("property missing ':'"); var De = _e(VALUE_REGEX), Re = we({ type: TYPE_DECLARATION, property: trim(Be[0].replace(COMMENT_REGEX, EMPTY_STRING)), value: De ? trim(De[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING }); return _e(SEMICOLON_REGEX), Re } } function Ce() { var we = []; be(we); for (var Be; Be = Se();)Be !== !1 && (we.push(Be), be(we)); return we } return Ee(), Ce() }; function trim(fe) { return fe ? fe.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING } var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (fe) { return fe && fe.__esModule ? fe : { default: fe } }; Object.defineProperty(cjs$1, "__esModule", { value: !0 }); cjs$1.default = StyleToObject; var inline_style_parser_1 = __importDefault$1(inlineStyleParser); function StyleToObject(fe, K) { var pe = null; if (!fe || typeof fe != "string") return pe; var me = (0, inline_style_parser_1.default)(fe), ge = typeof K == "function"; return me.forEach(function (xe) { if (xe.type === "declaration") { var ye = xe.property, ve = xe.value; ge ? K(ye, ve, xe) : ve && (pe = pe || {}, pe[ye] = ve) } }), pe } var utilities = {}; Object.defineProperty(utilities, "__esModule", { value: !0 }); utilities.camelCase = void 0; var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/, HYPHEN_REGEX = /-([a-z])/g, NO_HYPHEN_REGEX = /^[^-]+$/, VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/, MS_VENDOR_PREFIX_REGEX = /^-(ms)-/, skipCamelCase = function (fe) { return !fe || NO_HYPHEN_REGEX.test(fe) || CUSTOM_PROPERTY_REGEX.test(fe) }, capitalize = function (fe, K) { return K.toUpperCase() }, trimHyphen = function (fe, K) { return "".concat(K, "-") }, camelCase = function (fe, K) { return K === void 0 && (K = {}), skipCamelCase(fe) ? fe : (fe = fe.toLowerCase(), K.reactCompat ? fe = fe.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen) : fe = fe.replace(VENDOR_PREFIX_REGEX, trimHyphen), fe.replace(HYPHEN_REGEX, capitalize)) }; utilities.camelCase = camelCase; var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (fe) { return fe && fe.__esModule ? fe : { default: fe } }, style_to_object_1 = __importDefault(cjs$1), utilities_1 = utilities; function StyleToJS(fe, K) { var pe = {}; return !fe || typeof fe != "string" || (0, style_to_object_1.default)(fe, function (me, ge) { me && ge && (pe[(0, utilities_1.camelCase)(me, K)] = ge) }), pe } StyleToJS.default = StyleToJS; var cjs = StyleToJS; const styleToJs = getDefaultExportFromCjs(cjs), own$7 = {}.hasOwnProperty, cap = /[A-Z]/g, tableCellElement = new Set(["td", "th"]); function element$1(fe, K) { const pe = K.schema; let me = pe; const ge = fe.properties || {}; pe.space === "html" && fe.tagName.toLowerCase() === "svg" && (me = svg, K.schema = me); const xe = K.all(fe), ye = []; let ve, _e, Ee; for (ve in ge) if (own$7.call(ge, ve)) { let Ae = ge[ve]; const Se = find(me, ve); let Ce; if (Ae == null || Ae === !1 || typeof Ae == "number" && Number.isNaN(Ae) || !Ae && Se.boolean) continue; if (ve = K.elementAttributeNameCase === "react" && Se.space ? hastToReact[Se.property] || Se.property : Se.attribute, Array.isArray(Ae) && (Ae = Se.commaSeparated ? stringify$1(Ae) : stringify(Ae)), ve === "style") { let we = typeof Ae == "object" ? Ae : parseStyle(String(Ae), fe.tagName); K.stylePropertyNameCase === "css" && (we = transformStylesToCssCasing(we)); const Be = []; let De; for (De in we) own$7.call(we, De) && Be.push({ type: "Property", method: !1, shorthand: !1, computed: !1, key: name(De) ? { type: "Identifier", name: De } : { type: "Literal", value: De }, value: { type: "Literal", value: String(we[De]) }, kind: "init" }); Ee = Be, Ce = { type: "JSXExpressionContainer", expression: { type: "ObjectExpression", properties: Be } } } else if (Ae === !0) Ce = null; else if (K.tableCellAlignToStyle && tableCellElement.has(fe.tagName) && ve === "align") { _e = String(Ae); continue } else Ce = { type: "Literal", value: String(Ae) }; name(ve, { jsx: !0 }) ? ye.push({ type: "JSXAttribute", name: { type: "JSXIdentifier", name: ve }, value: Ce }) : ye.push({ type: "JSXSpreadAttribute", argument: { type: "ObjectExpression", properties: [{ type: "Property", method: !1, shorthand: !1, computed: !1, key: { type: "Literal", value: String(ve) }, value: Ce || { type: "Literal", value: !0 }, kind: "init" }] } }) } if (_e !== void 0) { Ee || (Ee = [], ye.push({ type: "JSXAttribute", name: { type: "JSXIdentifier", name: "style" }, value: { type: "JSXExpressionContainer", expression: { type: "ObjectExpression", properties: Ee } } })); const Ae = K.stylePropertyNameCase === "css" ? transformStyleToCssCasing("textAlign") : "textAlign"; Ee.push({ type: "Property", method: !1, shorthand: !1, computed: !1, key: name(Ae) ? { type: "Identifier", name: Ae } : { type: "Literal", value: Ae }, value: { type: "Literal", value: _e }, kind: "init" }) } K.schema = pe; const be = { type: "JSXElement", openingElement: { type: "JSXOpeningElement", attributes: ye, name: K.createJsxElementName(fe.tagName), selfClosing: xe.length === 0 }, closingElement: xe.length > 0 ? { type: "JSXClosingElement", name: K.createJsxElementName(fe.tagName) } : null, children: xe }; return K.inherit(fe, be), be } function parseStyle(fe, K) { try { return styleToJs(fe, { reactCompat: !0 }) } catch (pe) { const me = pe; throw new Error("Could not parse `style` attribute on `" + K + "`", { cause: me }) } } function transformStylesToCssCasing(fe) { const K = {}; let pe; for (pe in fe) own$7.call(fe, pe) && (K[transformStyleToCssCasing(pe)] = fe[pe]); return K } function transformStyleToCssCasing(fe) { let K = fe.replace(cap, toDash); return K.slice(0, 3) === "ms-" && (K = "-" + K), K } function toDash(fe) { return "-" + fe.toLowerCase() } const own$6 = {}.hasOwnProperty, emptyComments = []; function attachComments(fe, K) { const pe = K ? [...K].sort(compare) : emptyComments; pe.length > 0 && walk$1(fe, { comments: pe, index: 0 }) } function walk$1(fe, K) { if (K.index === K.comments.length) return; const pe = [], me = []; let ge; for (ge in fe) if (own$6.call(fe, ge)) { const ye = fe[ge]; if (ye && typeof ye == "object" && ge !== "comments") if (Array.isArray(ye)) { let ve = -1; for (; ++ve < ye.length;)ye[ve] && typeof ye[ve].type == "string" && pe.push(ye[ve]) } else typeof ye.type == "string" && pe.push(ye) } pe.sort(compare), me.push(...slice(K, fe, !1, { leading: !0, trailing: !1 })); let xe = -1; for (; ++xe < pe.length;)walk$1(pe[xe], K); me.push(...slice(K, fe, !0, { leading: !1, trailing: pe.length > 0 })), me.length > 0 && (fe.comments = me) } function slice(fe, K, pe, me) { const ge = []; for (; fe.comments[fe.index] && compare(fe.comments[fe.index], K, pe) < 1;)ge.push(Object.assign({}, fe.comments[fe.index++], me)); return ge } function compare(fe, K, pe) { const me = pe ? "end" : "start"; return fe.range && K.range ? fe.range[0] - K.range[pe ? 1 : 0] : fe.loc && fe.loc.start && K.loc && K.loc[me] ? fe.loc.start.line - K.loc[me].line || fe.loc.start.column - K.loc[me].column : "start" in fe && me in K ? fe.start - K[me] : Number.NaN } function mdxExpression$1(fe, K) { const pe = fe.data && fe.data.estree, me = pe && pe.comments || []; let ge; pe && (K.comments.push(...me), attachComments(pe, pe.comments), ge = pe.body[0] && pe.body[0].type === "ExpressionStatement" && pe.body[0].expression || void 0), ge || (ge = { type: "JSXEmptyExpression" }, K.patch(fe, ge)); const xe = { type: "JSXExpressionContainer", expression: ge }; return K.inherit(fe, xe), xe } function mdxJsxElement(fe, K) { const pe = K.schema; let me = pe; const ge = fe.attributes || []; let xe = -1; fe.name && pe.space === "html" && fe.name.toLowerCase() === "svg" && (me = svg, K.schema = me); const ye = K.all(fe), ve = []; for (; ++xe < ge.length;) { const Ee = ge[xe], be = Ee.value; let Ae; if (Ee.type === "mdxJsxAttribute") { if (be == null) Ae = null; else if (typeof be == "object") { const Ce = be.data && be.data.estree, we = Ce && Ce.comments || []; let Be; Ce && (K.comments.push(...we), attachComments(Ce, Ce.comments), Be = Ce.body[0] && Ce.body[0].type === "ExpressionStatement" && Ce.body[0].expression || void 0), Ae = { type: "JSXExpressionContainer", expression: Be || { type: "JSXEmptyExpression" } }, K.inherit(be, Ae) } else Ae = { type: "Literal", value: String(be) }; const Se = { type: "JSXAttribute", name: K.createJsxAttributeName(Ee.name), value: Ae }; K.inherit(Ee, Se), ve.push(Se) } else { const Se = Ee.data && Ee.data.estree, Ce = Se && Se.comments || []; let we; Se && (K.comments.push(...Ce), attachComments(Se, Se.comments), we = Se.body[0] && Se.body[0].type === "ExpressionStatement" && Se.body[0].expression && Se.body[0].expression.type === "ObjectExpression" && Se.body[0].expression.properties && Se.body[0].expression.properties[0] && Se.body[0].expression.properties[0].type === "SpreadElement" && Se.body[0].expression.properties[0].argument || void 0); const Be = { type: "JSXSpreadAttribute", argument: we || { type: "ObjectExpression", properties: [] } }; K.inherit(Ee, Be), ve.push(Be) } } K.schema = pe; const _e = fe.name ? { type: "JSXElement", openingElement: { type: "JSXOpeningElement", attributes: ve, name: K.createJsxElementName(fe.name), selfClosing: ye.length === 0 }, closingElement: ye.length > 0 ? { type: "JSXClosingElement", name: K.createJsxElementName(fe.name) } : null, children: ye } : { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: ye }; return K.inherit(fe, _e), _e } function mdxjsEsm$1(fe, K) { const pe = fe.data && fe.data.estree, me = pe && pe.comments || []; pe && (K.comments.push(...me), attachComments(pe, me), K.esm.push(...pe.body)) } const re$1 = /[ \t\n\f\r]/g; function whitespace(fe) { return typeof fe == "object" ? fe.type === "text" ? empty$2(fe.value) : !1 : empty$2(fe) } function empty$2(fe) { return fe.replace(re$1, "") === "" } function root$2(fe, K) { const pe = K.all(fe), me = []; let ge = -1, xe; for (; ++ge < pe.length;) { const ve = pe[ge]; ve.type === "JSXExpressionContainer" && ve.expression.type === "Literal" && whitespace(String(ve.expression.value)) ? xe && xe.push(ve) : (xe && me.push(...xe), me.push(ve), xe = []) } const ye = { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: me }; return K.inherit(fe, ye), ye } function text$5(fe, K) { const pe = String(fe.value || ""); if (pe) { const me = { type: "Literal", value: pe }; K.inherit(fe, me); const ge = { type: "JSXExpressionContainer", expression: me }; return K.patch(fe, ge), ge } } const handlers$1 = { comment, doctype: ignore$1, element: element$1, mdxFlowExpression: mdxExpression$1, mdxJsxFlowElement: mdxJsxElement, mdxJsxTextElement: mdxJsxElement, mdxTextExpression: mdxExpression$1, mdxjsEsm: mdxjsEsm$1, root: root$2, text: text$5 }; function ignore$1() { } const pointEnd = point$1("end"), pointStart = point$1("start"); function point$1(fe) { return K; function K(pe) { const me = pe && pe.position && pe.position[fe] || {}; if (typeof me.line == "number" && me.line > 0 && typeof me.column == "number" && me.column > 0) return { line: me.line, column: me.column, offset: typeof me.offset == "number" && me.offset > -1 ? me.offset : void 0 } } } function position(fe) { const K = pointStart(fe), pe = pointEnd(fe); if (K && pe) return { start: K, end: pe } } const own$5 = {}.hasOwnProperty; function zwitch(fe, K) { const pe = K || {}; function me(ge, ...xe) { let ye = me.invalid; const ve = me.handlers; if (ge && own$5.call(ge, fe)) { const _e = String(ge[fe]); ye = own$5.call(ve, _e) ? ve[_e] : me.unknown } if (ye) return ye.call(this, ge, ...xe) } return me.handlers = pe.handlers || {}, me.invalid = pe.invalid, me.unknown = pe.unknown, me } const own$4 = {}.hasOwnProperty, tableElements = new Set(["table", "tbody", "thead", "tfoot", "tr"]); function createState$1(fe) { const K = zwitch("type", { invalid, unknown, handlers: { ...handlers$1, ...fe.handlers } }); return { elementAttributeNameCase: fe.elementAttributeNameCase || "react", schema: fe.space === "svg" ? svg : html$3, stylePropertyNameCase: fe.stylePropertyNameCase || "dom", tableCellAlignToStyle: fe.tableCellAlignToStyle !== !1, comments: [], esm: [], all: all$2, createJsxAttributeName, createJsxElementName, handle: pe, inherit, patch: patch$1 }; function pe(me) { return K(me, this) } } function invalid(fe) { throw new Error("Cannot handle value `" + fe + "`, expected node") } function unknown(fe) { throw new Error("Cannot handle unknown node `" + fe.type + "`") } function all$2(fe) {
	const K = fe.children || []; let pe = -1; const me = [], ge = this.schema.space === "html" && fe.type === "element" && tableElements.has(fe.tagName.toLowerCase()); for (; ++pe < K.length;) {
		const xe = K[pe]; if (ge && xe.type === "text" && xe.value === `
`) continue; const ye = this.handle(xe); Array.isArray(ye) ? me.push(...ye) : ye && me.push(ye)
	} return me
} function inherit(fe, K) { const pe = fe.data; let me, ge; if (patch$1(fe, K), pe) { for (ge in pe) own$4.call(pe, ge) && ge !== "estree" && (me || (me = {}), me[ge] = pe[ge]); me && (K.data = me) } } function patch$1(fe, K) { const pe = position(fe); pe && pe.start.offset !== void 0 && pe.end.offset !== void 0 && (K.start = pe.start.offset, K.end = pe.end.offset, K.loc = { start: { line: pe.start.line, column: pe.start.column - 1 }, end: { line: pe.end.line, column: pe.end.column - 1 } }, K.range = [pe.start.offset, pe.end.offset]) } function createJsxAttributeName(fe) { const K = createJsxNameFromString(fe); if (K.type === "JSXMemberExpression") throw new Error("Member expressions in attribute names are not supported"); return K } function createJsxElementName(fe) { return createJsxNameFromString(fe) } function createJsxNameFromString(fe) { if (fe.includes(".")) { const K = fe.split("."); let pe = K.shift(), me = { type: "JSXIdentifier", name: pe }; for (; pe = K.shift();)me = { type: "JSXMemberExpression", object: me, property: { type: "JSXIdentifier", name: pe } }; return me } if (fe.includes(":")) { const K = fe.split(":"); return { type: "JSXNamespacedName", namespace: { type: "JSXIdentifier", name: K[0] }, name: { type: "JSXIdentifier", name: K[1] } } } return { type: "JSXIdentifier", name: fe } } function toEstree(fe, K) { const pe = createState$1(K || {}); let me = pe.handle(fe); const ge = pe.esm; if (me) { me.type !== "JSXFragment" && me.type !== "JSXElement" && (me = { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: [me] }, pe.patch(fe, me)); const ye = { type: "ExpressionStatement", expression: me }; pe.patch(fe, ye), ge.push(ye) } const xe = { type: "Program", body: ge, sourceType: "module", comments: pe.comments }; return pe.patch(fe, xe), xe } function rehypeRecma(fe) { return function (K) { return toEstree(K, fe) } } function mdxExpressionFromMarkdown() { return { enter: { mdxFlowExpression: enterMdxFlowExpression, mdxTextExpression: enterMdxTextExpression }, exit: { mdxFlowExpression: exitMdxExpression, mdxFlowExpressionChunk: exitMdxExpressionData, mdxTextExpression: exitMdxExpression, mdxTextExpressionChunk: exitMdxExpressionData } } } function mdxExpressionToMarkdown() { return { handlers: { mdxFlowExpression: handleMdxExpression, mdxTextExpression: handleMdxExpression }, unsafe: [{ character: "{", inConstruct: ["phrasing"] }, { atBreak: !0, character: "{" }] } } function enterMdxFlowExpression(fe) { this.enter({ type: "mdxFlowExpression", value: "" }, fe), this.buffer() } function enterMdxTextExpression(fe) { this.enter({ type: "mdxTextExpression", value: "" }, fe), this.buffer() } function exitMdxExpression(fe) { const K = this.resume(), pe = fe.estree, me = this.stack[this.stack.length - 1]; me.type === "mdxFlowExpression" || me.type, this.exit(fe), me.value = K, pe && (me.data = { estree: pe }) } function exitMdxExpressionData(fe) { this.config.enter.data.call(this, fe), this.config.exit.data.call(this, fe) } function handleMdxExpression(fe, K, pe) { const me = fe.value || ""; return "{" + pe.indentLines(me, function (xe, ye, ve) { return (ye === 0 || ve ? "" : "  ") + xe }) + "}" } function ccount(fe, K) { const pe = String(fe); if (typeof K != "string") throw new TypeError("Expected character"); let me = 0, ge = pe.indexOf(K); for (; ge !== -1;)me++, ge = pe.indexOf(K, ge + K.length); return me } const characterEntitiesLegacy = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"], characterReferenceInvalid = { 0: "", 128: "", 130: "", 131: "", 132: "", 133: "", 134: "", 135: "", 136: "", 137: "", 138: "", 139: "", 140: "", 142: "", 145: "", 146: "", 147: "", 148: "", 149: "", 150: "", 151: "", 152: "", 153: "", 154: "", 155: "", 156: "", 158: "", 159: "" }; function isDecimal(fe) { const K = typeof fe == "string" ? fe.charCodeAt(0) : fe; return K >= 48 && K <= 57 } function isHexadecimal(fe) { const K = typeof fe == "string" ? fe.charCodeAt(0) : fe; return K >= 97 && K <= 102 || K >= 65 && K <= 70 || K >= 48 && K <= 57 } function isAlphabetical(fe) { const K = typeof fe == "string" ? fe.charCodeAt(0) : fe; return K >= 97 && K <= 122 || K >= 65 && K <= 90 } function isAlphanumerical(fe) { return isAlphabetical(fe) || isDecimal(fe) } const element = document.createElement("i"); function decodeNamedCharacterReference(fe) { const K = "&" + fe + ";"; element.innerHTML = K; const pe = element.textContent; return pe.charCodeAt(pe.length - 1) === 59 && fe !== "semi" || pe === K ? !1 : pe } const messages = ["", "Named character references must be terminated by a semicolon", "Numeric character references must be terminated by a semicolon", "Named character references cannot be empty", "Numeric character references cannot be empty", "Named character references must be known", "Numeric character references cannot be disallowed", "Numeric character references cannot be outside the permissible Unicode range"]; function parseEntities(fe, K) { const pe = K || {}, me = typeof pe.additional == "string" ? pe.additional.charCodeAt(0) : pe.additional, ge = []; let xe = 0, ye = -1, ve = "", _e, Ee; pe.position && ("start" in pe.position || "indent" in pe.position ? (Ee = pe.position.indent, _e = pe.position.start) : _e = pe.position); let be = (_e ? _e.line : 0) || 1, Ae = (_e ? _e.column : 0) || 1, Se = we(), Ce; for (xe--; ++xe <= fe.length;)if (Ce === 10 && (Ae = (Ee ? Ee[ye] : 0) || 1), Ce = fe.charCodeAt(xe), Ce === 38) { const Re = fe.charCodeAt(xe + 1); if (Re === 9 || Re === 10 || Re === 12 || Re === 32 || Re === 38 || Re === 60 || Number.isNaN(Re) || me && Re === me) { ve += String.fromCharCode(Ce), Ae++; continue } const Ie = xe + 1; let Pe = Ie, Ne = Ie, ke; if (Re === 35) { Ne = ++Pe; const Ye = fe.charCodeAt(Ne); Ye === 88 || Ye === 120 ? (ke = "hexadecimal", Ne = ++Pe) : ke = "decimal" } else ke = "named"; let Oe = "", Ue = "", He = ""; const Ge = ke === "named" ? isAlphanumerical : ke === "decimal" ? isDecimal : isHexadecimal; for (Ne--; ++Ne <= fe.length;) { const Ye = fe.charCodeAt(Ne); if (!Ge(Ye)) break; He += String.fromCharCode(Ye), ke === "named" && characterEntitiesLegacy.includes(He) && (Oe = He, Ue = decodeNamedCharacterReference(He)) } let ze = fe.charCodeAt(Ne) === 59; if (ze) { Ne++; const Ye = ke === "named" ? decodeNamedCharacterReference(He) : !1; Ye && (Oe = He, Ue = Ye) } let We = 1 + Ne - Ie, Xe = ""; if (!(!ze && pe.nonTerminated === !1)) if (!He) ke !== "named" && Be(4, We); else if (ke === "named") { if (ze && !Ue) Be(5, 1); else if (Oe !== He && (Ne = Pe + Oe.length, We = 1 + Ne - Pe, ze = !1), !ze) { const Ye = Oe ? 1 : 3; if (pe.attribute) { const Ze = fe.charCodeAt(Ne); Ze === 61 ? (Be(Ye, We), Ue = "") : isAlphanumerical(Ze) ? Ue = "" : Be(Ye, We) } else Be(Ye, We) } Xe = Ue } else { ze || Be(2, We); let Ye = Number.parseInt(He, ke === "hexadecimal" ? 16 : 10); if (prohibited(Ye)) Be(7, We), Xe = ""; else if (Ye in characterReferenceInvalid) Be(6, We), Xe = characterReferenceInvalid[Ye]; else { let Ze = ""; disallowed(Ye) && Be(6, We), Ye > 65535 && (Ye -= 65536, Ze += String.fromCharCode(Ye >>> 10 | 55296), Ye = 56320 | Ye & 1023), Xe = Ze + String.fromCharCode(Ye) } } if (Xe) { De(), Se = we(), xe = Ne - 1, Ae += Ne - Ie + 1, ge.push(Xe); const Ye = we(); Ye.offset++, pe.reference && pe.reference.call(pe.referenceContext || void 0, Xe, { start: Se, end: Ye }, fe.slice(Ie - 1, Ne)), Se = Ye } else He = fe.slice(Ie - 1, Ne), ve += He, Ae += He.length, xe = Ne - 1 } else Ce === 10 && (be++, ye++, Ae = 0), Number.isNaN(Ce) ? De() : (ve += String.fromCharCode(Ce), Ae++); return ge.join(""); function we() { return { line: be, column: Ae, offset: xe + ((_e ? _e.offset : 0) || 0) } } function Be(Re, Ie) { let Pe; pe.warning && (Pe = we(), Pe.column += Ie, Pe.offset += Ie, pe.warning.call(pe.warningContext || void 0, messages[Re], Pe, Re)) } function De() { ve && (ge.push(ve), pe.text && pe.text.call(pe.textContext || void 0, ve, { start: Se, end: we() }), ve = "") } } function prohibited(fe) { return fe >= 55296 && fe <= 57343 || fe > 1114111 } function disallowed(fe) { return fe >= 1 && fe <= 8 || fe === 11 || fe >= 13 && fe <= 31 || fe >= 127 && fe <= 159 || fe >= 64976 && fe <= 65007 || (fe & 65535) === 65535 || (fe & 65535) === 65534 } const defaultSubsetRegex = /["&'<>`]/g, surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, controlCharactersRegex = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g, subsetToRegexCache = new WeakMap; function core(fe, K) { if (fe = fe.replace(K.subset ? charactersToExpressionCached(K.subset) : defaultSubsetRegex, me), K.subset || K.escapeOnly) return fe; return fe.replace(surrogatePairsRegex, pe).replace(controlCharactersRegex, me); function pe(ge, xe, ye) { return K.format((ge.charCodeAt(0) - 55296) * 1024 + ge.charCodeAt(1) - 56320 + 65536, ye.charCodeAt(xe + 2), K) } function me(ge, xe, ye) { return K.format(ge.charCodeAt(0), ye.charCodeAt(xe + 1), K) } } function charactersToExpressionCached(fe) { let K = subsetToRegexCache.get(fe); return K || (K = charactersToExpression(fe), subsetToRegexCache.set(fe, K)), K } function charactersToExpression(fe) { const K = []; let pe = -1; for (; ++pe < fe.length;)K.push(fe[pe].replace(regexEscapeRegex, "\\$&")); return new RegExp("(?:" + K.join("|") + ")", "g") } function formatBasic(fe) { return "&#x" + fe.toString(16).toUpperCase() + ";" } function stringifyEntitiesLight(fe, K) { return core(fe, Object.assign({ format: formatBasic }, K)) } const indent$1 = "  "; function mdxJsxFromMarkdown() { return { canContainEols: ["mdxJsxTextElement"], enter: { mdxJsxFlowTag: me, mdxJsxFlowTagClosingMarker: ge, mdxJsxFlowTagAttribute: Ae, mdxJsxFlowTagExpressionAttribute: Se, mdxJsxFlowTagAttributeValueLiteral: fe, mdxJsxFlowTagAttributeValueExpression: fe, mdxJsxFlowTagSelfClosingMarker: ye, mdxJsxTextTag: me, mdxJsxTextTagClosingMarker: ge, mdxJsxTextTagAttribute: Ae, mdxJsxTextTagExpressionAttribute: Se, mdxJsxTextTagAttributeValueLiteral: fe, mdxJsxTextTagAttributeValueExpression: fe, mdxJsxTextTagSelfClosingMarker: ye }, exit: { mdxJsxFlowTagClosingMarker: ve, mdxJsxFlowTagNamePrimary: _e, mdxJsxFlowTagNameMember: Ee, mdxJsxFlowTagNameLocal: be, mdxJsxFlowTagExpressionAttribute: Ce, mdxJsxFlowTagExpressionAttributeValue: pe, mdxJsxFlowTagAttributeNamePrimary: we, mdxJsxFlowTagAttributeNameLocal: Be, mdxJsxFlowTagAttributeValueLiteral: De, mdxJsxFlowTagAttributeValueLiteralValue: pe, mdxJsxFlowTagAttributeValueExpression: Re, mdxJsxFlowTagAttributeValueExpressionValue: pe, mdxJsxFlowTagSelfClosingMarker: Ie, mdxJsxFlowTag: Pe, mdxJsxTextTagClosingMarker: ve, mdxJsxTextTagNamePrimary: _e, mdxJsxTextTagNameMember: Ee, mdxJsxTextTagNameLocal: be, mdxJsxTextTagExpressionAttribute: Ce, mdxJsxTextTagExpressionAttributeValue: pe, mdxJsxTextTagAttributeNamePrimary: we, mdxJsxTextTagAttributeNameLocal: Be, mdxJsxTextTagAttributeValueLiteral: De, mdxJsxTextTagAttributeValueLiteralValue: pe, mdxJsxTextTagAttributeValueExpression: Re, mdxJsxTextTagAttributeValueExpressionValue: pe, mdxJsxTextTagSelfClosingMarker: Ie, mdxJsxTextTag: Pe } }; function fe() { this.buffer() } function K(Ue) { return { line: Ue.line, column: Ue.column, offset: Ue.offset } } function pe(Ue) { this.config.enter.data.call(this, Ue), this.config.exit.data.call(this, Ue) } function me(Ue) { const He = { name: void 0, attributes: [], close: !1, selfClosing: !1, start: Ue.start, end: Ue.end }; this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = He, this.buffer() } function ge(Ue) { if (this.data.mdxJsxTagStack.length === 0) throw new VFileMessage("Unexpected closing slash `/` in tag, expected an open tag first", { start: Ue.start, end: Ue.end }, "mdast-util-mdx-jsx:unexpected-closing-slash") } function xe(Ue) { if (this.data.mdxJsxTag.close) throw new VFileMessage("Unexpected attribute in closing tag, expected the end of the tag", { start: Ue.start, end: Ue.end }, "mdast-util-mdx-jsx:unexpected-attribute") } function ye(Ue) { if (this.data.mdxJsxTag.close) throw new VFileMessage("Unexpected self-closing slash `/` in closing tag, expected the end of the tag", { start: Ue.start, end: Ue.end }, "mdast-util-mdx-jsx:unexpected-self-closing-slash") } function ve() { const Ue = this.data.mdxJsxTag; Ue.close = !0 } function _e(Ue) { const He = this.data.mdxJsxTag; He.name = this.sliceSerialize(Ue) } function Ee(Ue) { const He = this.data.mdxJsxTag; He.name += "." + this.sliceSerialize(Ue) } function be(Ue) { const He = this.data.mdxJsxTag; He.name += ":" + this.sliceSerialize(Ue) } function Ae(Ue) { const He = this.data.mdxJsxTag; xe.call(this, Ue), He.attributes.push({ type: "mdxJsxAttribute", name: "", value: null, position: { start: K(Ue.start), end: void 0 } }) } function Se(Ue) { const He = this.data.mdxJsxTag; xe.call(this, Ue), He.attributes.push({ type: "mdxJsxExpressionAttribute", value: "", position: { start: K(Ue.start), end: void 0 } }), this.buffer() } function Ce(Ue) { const He = this.data.mdxJsxTag, Ge = He.attributes[He.attributes.length - 1]; Ge.type; const ze = Ue.estree; Ge.value = this.resume(), Ge.position, Ge.position.end = K(Ue.end), ze && (Ge.data = { estree: ze }) } function we(Ue) { const He = this.data.mdxJsxTag, Ge = He.attributes[He.attributes.length - 1]; Ge.type, Ge.name = this.sliceSerialize(Ue), Ge.position, Ge.position.end = K(Ue.end) } function Be(Ue) { const He = this.data.mdxJsxTag, Ge = He.attributes[He.attributes.length - 1]; Ge.type, Ge.name += ":" + this.sliceSerialize(Ue), Ge.position, Ge.position.end = K(Ue.end) } function De(Ue) { const He = this.data.mdxJsxTag, Ge = He.attributes[He.attributes.length - 1]; Ge.value = parseEntities(this.resume(), { nonTerminated: !1 }), Ge.position, Ge.position.end = K(Ue.end) } function Re(Ue) { const He = this.data.mdxJsxTag, Ge = He.attributes[He.attributes.length - 1]; Ge.type; const ze = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, We = Ue.estree; We && (ze.data = { estree: We }), Ge.value = ze, Ge.position, Ge.position.end = K(Ue.end) } function Ie() { const Ue = this.data.mdxJsxTag; Ue.selfClosing = !0 } function Pe(Ue) { const He = this.data.mdxJsxTag, Ge = this.data.mdxJsxTagStack, ze = Ge[Ge.length - 1]; if (He.close && ze.name !== He.name) throw new VFileMessage("Unexpected closing tag `" + Oe(He) + "`, expected corresponding closing tag for `" + Oe(ze) + "` (" + stringifyPosition(ze) + ")", { start: Ue.start, end: Ue.end }, "mdast-util-mdx-jsx:end-tag-mismatch"); this.resume(), He.close ? Ge.pop() : this.enter({ type: Ue.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement", name: He.name || null, attributes: He.attributes, children: [] }, Ue, Ne), He.selfClosing || He.close ? this.exit(Ue, ke) : Ge.push(He) } function Ne(Ue, He) { const Ge = this.data.mdxJsxTagStack, ze = Ge[Ge.length - 1], We = Ue ? " before the end of `" + Ue.type + "`" : "", Xe = Ue ? { start: Ue.start, end: Ue.end } : void 0; throw new VFileMessage("Expected a closing tag for `" + Oe(ze) + "` (" + stringifyPosition({ start: He.start, end: He.end }) + ")" + We, Xe, "mdast-util-mdx-jsx:end-tag-mismatch") } function ke(Ue, He) { const Ge = this.data.mdxJsxTag; throw new VFileMessage("Expected the closing tag `" + Oe(Ge) + "` either after the end of `" + He.type + "` (" + stringifyPosition(He.end) + ") or another opening tag after the start of `" + He.type + "` (" + stringifyPosition(He.start) + ")", { start: Ue.start, end: Ue.end }, "mdast-util-mdx-jsx:end-tag-mismatch") } function Oe(Ue) { return "<" + (Ue.close ? "/" : "") + (Ue.name || "") + ">" } } function mdxJsxToMarkdown(fe) {
	const K = fe || {}, pe = K.quote || '"', me = K.quoteSmart || !1, ge = K.tightSelfClosing || !1, xe = K.printWidth || Number.POSITIVE_INFINITY, ye = pe === '"' ? "'" : '"'; if (pe !== '"' && pe !== "'") throw new Error("Cannot serialize attribute values with `" + pe + "` for `options.quote`, expected `\"`, or `'`"); return ve.peek = peekElement, { handlers: { mdxJsxFlowElement: ve, mdxJsxTextElement: ve }, unsafe: [{ character: "<", inConstruct: ["phrasing"] }, { atBreak: !0, character: "<" }], fences: !0, resourceLink: !0 }; function ve(_e, Ee, be, Ae) {
		const Se = _e.type === "mdxJsxFlowElement", Ce = _e.name ? !_e.children || _e.children.length === 0 : !1, we = inferDepth(be), Be = createIndent(we), De = be.createTracker(Ae), Re = be.createTracker(Ae), Ie = [], Pe = (Se ? Be : "") + "<" + (_e.name || ""), Ne = be.enter(_e.type); if (De.move(Pe), Re.move(Pe), _e.attributes && _e.attributes.length > 0) { if (!_e.name) throw new Error("Cannot serialize fragment w/ attributes"); let Ge = -1; for (; ++Ge < _e.attributes.length;) { const ze = _e.attributes[Ge]; let We; if (ze.type === "mdxJsxExpressionAttribute") We = "{" + (ze.value || "") + "}"; else { if (!ze.name) throw new Error("Cannot serialize attribute w/o name"); const Xe = ze.value, Ye = ze.name; let Ze = ""; if (Xe != null) if (typeof Xe == "object") Ze = "{" + (Xe.value || "") + "}"; else { const ot = me && ccount(Xe, pe) > ccount(Xe, ye) ? ye : pe; Ze = ot + stringifyEntitiesLight(Xe, { subset: [ot] }) + ot } We = Ye + (Ze ? "=" : "") + Ze } Ie.push(We) } } let ke = !1; const Oe = Ie.join(" "); Se && (/\r?\n|\r/.test(Oe) || De.current().now.column + Oe.length + (Ce ? ge ? 2 : 3 : 1) > xe) && (ke = !0); let Ue = De, He = Pe; if (ke) {
			Ue = Re; let Ge = -1; for (; ++Ge < Ie.length;)Ie[Ge] = Be + indent$1 + Ie[Ge]; He += Ue.move(`
`+ Ie.join(`
`) + `
`+ Be)
		} else Oe && (He += Ue.move(" " + Oe)); return Ce && (He += Ue.move((ge || ke ? "" : " ") + "/")), He += Ue.move(">"), _e.children && _e.children.length > 0 && (_e.type === "mdxJsxTextElement" ? He += Ue.move(be.containerPhrasing(_e, { ...Ue.current(), before: ">", after: "<" })) : (Ue.shift(2), He += Ue.move(`
`), He += Ue.move(containerFlow(_e, be, Ue.current())), He += Ue.move(`
`))), Ce || (He += Ue.move((Se ? Be : "") + "</" + (_e.name || "") + ">")), Ne(), He
	}
} function containerFlow(fe, K, pe) {
	const me = K.indexStack, ge = fe.children, xe = K.createTracker(pe), ye = createIndent(inferDepth(K)), ve = []; let _e = -1; for (me.push(-1); ++_e < ge.length;) {
		const Ee = ge[_e]; me[me.length - 1] = _e; const be = {
			before: `
`, after: `
`, ...xe.current()
		}, Ae = K.handle(Ee, fe, K, be), Se = Ee.type === "mdxJsxFlowElement" ? Ae : K.indentLines(Ae, function (Ce, we, Be) { return (Be ? "" : ye) + Ce }); ve.push(xe.move(Se)), Ee.type !== "list" && (K.bulletLastUsed = void 0), _e < ge.length - 1 && ve.push(xe.move(`

`))
	} return me.pop(), ve.join("")
} function inferDepth(fe) { let K = 0, pe = fe.stack.length; for (; --pe > -1;) { const me = fe.stack[pe]; if (me === "blockquote" || me === "listItem") break; me === "mdxJsxFlowElement" && K++ } return K } function createIndent(fe) { return indent$1.repeat(fe) } function peekElement() { return "<" } function mdxjsEsmFromMarkdown() { return { enter: { mdxjsEsm: enterMdxjsEsm }, exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData } } } function mdxjsEsmToMarkdown() { return { handlers: { mdxjsEsm: handleMdxjsEsm } } } function enterMdxjsEsm(fe) { this.enter({ type: "mdxjsEsm", value: "" }, fe), this.buffer() } function exitMdxjsEsm(fe) { const K = this.resume(), pe = this.stack[this.stack.length - 1]; pe.type, this.exit(fe); const me = fe.estree; pe.value = K, me && (pe.data = { estree: me }) } function exitMdxjsEsmData(fe) { this.config.enter.data.call(this, fe), this.config.exit.data.call(this, fe) } function handleMdxjsEsm(fe) { return fe.value || "" } function mdxFromMarkdown() { return [mdxExpressionFromMarkdown(), mdxJsxFromMarkdown(), mdxjsEsmFromMarkdown()] } function mdxToMarkdown(fe) { return { extensions: [mdxExpressionToMarkdown(), mdxJsxToMarkdown(fe), mdxjsEsmToMarkdown()] } } var acornExports = requireAcorn(); const asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/); function asciiControl(fe) { return fe !== null && (fe < 32 || fe === 127) } const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/); function markdownLineEnding(fe) { return fe !== null && fe < -2 } function markdownLineEndingOrSpace(fe) { return fe !== null && (fe < 0 || fe === 32) } function markdownSpace(fe) { return fe === -2 || fe === -1 || fe === 32 } const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u")), unicodeWhitespace = regexCheck(/\s/); function regexCheck(fe) { return K; function K(pe) { return pe !== null && pe > -1 && fe.test(String.fromCharCode(pe)) } } function factorySpace(fe, K, pe, me) { const ge = me ? me - 1 : Number.POSITIVE_INFINITY; let xe = 0; return ye; function ye(_e) { return markdownSpace(_e) ? (fe.enter(pe), ve(_e)) : K(_e) } function ve(_e) { return markdownSpace(_e) && xe++ < ge ? (fe.consume(_e), ve) : (fe.exit(pe), K(_e)) } } function color$3(fe) { return fe } const own$3 = {}.hasOwnProperty, CONTINUE$2 = Symbol("continue"), EXIT$2 = Symbol("exit"), SKIP$2 = Symbol("skip"); function visit$2(fe, K) { let pe, me; typeof K == "function" ? pe = K : K && typeof K == "object" && (K.enter && (pe = K.enter), K.leave && (me = K.leave)), ge(fe, void 0, void 0, [])(); function ge(xe, ye, ve, _e) { return nodelike(xe) && (Ee.displayName = "node (" + xe.type + ")"), Ee; function Ee() { const be = pe ? toResult$2(pe(xe, ye, ve, _e)) : []; if (be[0] === EXIT$2) return be; if (be[0] !== SKIP$2) { let Ae; for (Ae in xe) if (own$3.call(xe, Ae) && xe[Ae] && typeof xe[Ae] == "object" && Ae !== "data" && Ae !== "position") { const Se = _e.concat(xe), Ce = xe[Ae]; if (Array.isArray(Ce)) { const we = Ce; let Be = 0; for (; Be > -1 && Be < we.length;) { const De = we[Be]; if (nodelike(De)) { const Re = ge(De, Ae, Be, Se)(); if (Re[0] === EXIT$2) return Re; Be = typeof Re[1] == "number" ? Re[1] : Be + 1 } else Be++ } } else if (nodelike(Ce)) { const we = ge(Ce, Ae, void 0, Se)(); if (we[0] === EXIT$2) return we } } } return me ? toResult$2(me(xe, ye, ve, _e)) : be } } } function toResult$2(fe) { return Array.isArray(fe) ? fe : typeof fe == "number" ? [CONTINUE$2, fe] : [fe] } function nodelike(fe) { return !!(fe && typeof fe == "object" && "type" in fe && typeof fe.type == "string" && fe.type.length > 0) } function eventsToAcorn(fe, K) { const pe = K.prefix || "", me = K.suffix || "", ge = Object.assign({}, K.acornOptions), xe = [], ye = [], ve = ge.onComment, _e = ge.onToken; let Ee = !1, be, Ae; const Se = Object.assign({}, ge, { onComment: xe, preserveParens: !0 }); _e && (Se.onToken = ye); const Ce = collect(fe, K.tokenTypes), we = Ce.value, Be = pe + we + me, De = K.expression && empty$1(we); if (De && !K.allowEmpty) throw new VFileMessage("Unexpected empty expression", { place: Ie(0), ruleId: "unexpected-empty-expression", source: "micromark-extension-mdx-expression" }); try { be = K.expression && !De ? K.acorn.parseExpressionAt(Be, 0, Se) : K.acorn.parse(Be, Se) } catch (Pe) { const Ne = Pe, ke = Ie(Ne.pos); Ne.message = String(Ne.message).replace(/ \(\d+:\d+\)$/, ""), Ne.pos = ke.offset, Ne.loc = { line: ke.line, column: ke.column - 1 }, Ae = Ne, Ee = Ne.raisedAt >= pe.length + we.length || Ne.message === "Unterminated comment" } if (be && K.expression && !De) if (empty$1(Be.slice(be.end, Be.length - me.length))) be = { type: "Program", start: 0, end: pe.length + we.length, body: [{ type: "ExpressionStatement", expression: be, start: 0, end: pe.length + we.length }], sourceType: "module", comments: [] }; else { const Pe = Ie(be.end), Ne = new Error("Unexpected content after expression"); Ne.pos = Pe.offset, Ne.loc = { line: Pe.line, column: Pe.column - 1 }, Ae = Ne, be = void 0 } if (be) { if (be.comments = xe, visit$2(be, function (Pe, Ne, ke, Oe) { let Ue = Oe[Oe.length - 1], He = Ne; Pe.type === "ParenthesizedExpression" && Ue && He && (typeof ke == "number" && (Ue = Ue[He], He = ke), Ue[He] = Pe.expression), Re(Pe) }), Array.isArray(ve)) ve.push(...xe); else if (typeof ve == "function") for (const Pe of xe) ve(Pe.type === "Block", Pe.value, Pe.start, Pe.end, Pe.loc.start, Pe.loc.end); for (const Pe of ye) Pe.end <= pe.length || Pe.start - pe.length >= we.length || (Re(Pe), Array.isArray(_e) ? _e.push(Pe) : _e(Pe)) } return { estree: be, error: Ae, swallow: Ee }; function Re(Pe) { const Ne = Ie(Pe.start), ke = Ie(Pe.end); Pe.start = Ne.offset, Pe.end = ke.offset, Pe.loc = { start: { line: Ne.line, column: Ne.column - 1, offset: Ne.offset }, end: { line: ke.line, column: ke.column - 1, offset: ke.offset } }, Pe.range = [Pe.start, Pe.end] } function Ie(Pe) { let Ne = Pe - pe.length; Ne < 0 ? Ne = 0 : Ne > we.length && (Ne = we.length); let ke = relativeToPoint(Ce.stops, Ne); return ke || (ke = { line: K.start.line, column: K.start.column, offset: K.start.offset }), ke } } function empty$1(fe) { return /^\s*$/.test(fe.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")) } function collect(fe, K) { const pe = { value: "", stops: [] }; let me = -1; for (; ++me < fe.length;) { const ge = fe[me]; if (ge[0] === "enter") { const xe = ge[1].type; if (xe === "lineEnding" || K.includes(xe)) { const ye = ge[2].sliceStream(ge[1]); for (; ye.length > 0 && ye[0] === -1;)ye.shift(); const ve = serializeChunks$1(ye); pe.stops.push([pe.value.length, ge[1].start]), pe.value += ve, pe.stops.push([pe.value.length, ge[1].end]) } } } return pe } function relativeToPoint(fe, K) { let pe = 0; for (; pe < fe.length && fe[pe][0] <= K;)pe += 1; if (pe === 0) return; const [me, ge] = fe[pe - 1], xe = K - me; return { line: ge.line, column: ge.column + xe, offset: ge.offset + xe } } function serializeChunks$1(fe) {
	let K = -1; const pe = []; let me; for (; ++K < fe.length;) {
		const ge = fe[K]; let xe; if (typeof ge == "string") xe = ge; else switch (ge) {
			case -5: { xe = "\r"; break } case -4: {
				xe = `
`; break
			} case -3: {
				xe = `\r
`; break
			} case -2: { xe = "	"; break } case -1: { if (me) continue; xe = " "; break } default: xe = String.fromCharCode(ge)
		}me = ge === -2, pe.push(xe)
	} return pe.join("")
} function positionFromEstree(fe) { const K = fe || {}, pe = K.loc || {}, me = K.range || [void 0, void 0], ge = pointOrUndefined(pe.start, me[0] || K.start), xe = pointOrUndefined(pe.end, me[1] || K.end); if (ge && xe) return { start: ge, end: xe } } function pointOrUndefined(fe, K) { if (fe && typeof fe == "object") { const pe = "line" in fe ? numberOrUndefined(fe.line) : void 0, me = "column" in fe ? numberOrUndefined(fe.column) : void 0; if (pe && me !== void 0) return { line: pe, column: me + 1, offset: numberOrUndefined(K) } } } function numberOrUndefined(fe) { return typeof fe == "number" && fe > -1 ? fe : void 0 } const indentSize = 2, trouble$2 = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", unexpectedEndOfFileHash = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", unexpectedLazyHash = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed", nonSpreadHash = "#unexpected-type-in-code-expected-an-object-spread-spread", spreadExtraHash = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported", acornHash = "#could-not-parse-expression-with-acorn"; function factoryMdxExpression(fe, K, pe, me, ge, xe, ye, ve, _e, Ee, be) { const Ae = this, Se = this.events.length + 3; let Ce = 0, we, Be; return De; function De(Ne) { return fe.enter(pe), fe.enter(me), fe.consume(Ne), fe.exit(me), we = Ae.now(), Re } function Re(Ne) { if (Ne === null) { if (Be) throw Be; const ke = new VFileMessage("Unexpected end of file in expression, expected a corresponding closing brace for `{`", { place: Ae.now(), ruleId: "unexpected-eof", source: "micromark-extension-mdx-expression" }); throw ke.url = trouble$2 + unexpectedEndOfFileHash, ke } if (markdownLineEnding(Ne)) return fe.enter("lineEnding"), fe.consume(Ne), fe.exit("lineEnding"), Pe; if (Ne === 125 && Ce === 0) { const ke = xe ? mdxExpressionParse.call(Ae, xe, ye, ge, Se, we, Ee || !1, _e || !1) : { type: "ok", estree: void 0 }; if (ke.type === "ok") { fe.enter(me), fe.consume(Ne), fe.exit(me); const Oe = fe.exit(pe); return ve && ke.estree && Object.assign(Oe, { estree: ke.estree }), K } return Be = ke.message, fe.enter(ge), fe.consume(Ne), Ie } return fe.enter(ge), Ie(Ne) } function Ie(Ne) { return Ne === 125 && Ce === 0 || Ne === null || markdownLineEnding(Ne) ? (fe.exit(ge), Re(Ne)) : (Ne === 123 && !xe ? Ce += 1 : Ne === 125 && (Ce -= 1), fe.consume(Ne), Ie) } function Pe(Ne) { const ke = Ae.now(); if (ke.line !== we.line && !be && Ae.parser.lazy[ke.line]) { const Oe = new VFileMessage("Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", { place: Ae.now(), ruleId: "unexpected-lazy", source: "micromark-extension-mdx-expression" }); throw Oe.url = trouble$2 + unexpectedLazyHash, Oe } return markdownSpace(Ne) ? factorySpace(fe, Re, "linePrefix", indentSize + 1)(Ne) : Re(Ne) } } function mdxExpressionParse(fe, K, pe, me, ge, xe, ye) { const ve = eventsToAcorn(this.events.slice(me), { acorn: fe, tokenTypes: [pe], acornOptions: K, start: ge, expression: !0, allowEmpty: xe, prefix: ye ? "({" : "", suffix: ye ? "})" : "" }), _e = ve.estree; if (ye && _e) { const Ee = _e.body[0]; if (Ee.type !== "ExpressionStatement" || Ee.expression.type !== "ObjectExpression") { const be = positionFromEstree(Ee), Ae = new VFileMessage("Unexpected `" + Ee.type + "` in code: expected an object spread (`{...spread}`)", { place: be.start, ruleId: "non-spread", source: "micromark-extension-mdx-expression" }); throw Ae.url = trouble$2 + nonSpreadHash, Ae } if (Ee.expression.properties[1]) { const be = positionFromEstree(Ee.expression.properties[1]), Ae = new VFileMessage("Unexpected extra content in spread: only a single spread is supported", { place: be.start, ruleId: "spread-extra", source: "micromark-extension-mdx-expression" }); throw Ae.url = trouble$2 + spreadExtraHash, Ae } if (Ee.expression.properties[0] && Ee.expression.properties[0].type !== "SpreadElement") { const be = positionFromEstree(Ee.expression.properties[0]), Ae = new VFileMessage("Unexpected `" + Ee.expression.properties[0].type + "` in code: only spread elements are supported", { place: be.start, ruleId: "non-spread", source: "micromark-extension-mdx-expression" }); throw Ae.url = trouble$2 + nonSpreadHash, Ae } } if (ve.error) { const Ee = new VFileMessage("Could not parse expression with acorn", { cause: ve.error, place: { line: ve.error.loc.line, column: ve.error.loc.column + 1, offset: ve.error.pos }, ruleId: "acorn", source: "micromark-extension-mdx-expression" }); return Ee.url = trouble$2 + acornHash, { type: "nok", message: Ee } } return { type: "ok", estree: _e } } function mdxExpression(fe) { const K = fe || {}, pe = K.addResult, me = K.acorn, ge = K.spread; let xe = K.allowEmpty, ye; if (xe == null && (xe = !0), me) { if (!me.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`"); ye = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, K.acornOptions) } else if (K.acornOptions || K.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); return { flow: { 123: { name: "mdxFlowExpression", tokenize: ve, concrete: !0 } }, text: { 123: { name: "mdxTextExpression", tokenize: _e } } }; function ve(Ee, be, Ae) { const Se = this; return Ce; function Ce(Re) { return we(Re) } function we(Re) { return factoryMdxExpression.call(Se, Ee, Be, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", me, ye, pe, ge, xe)(Re) } function Be(Re) { return markdownSpace(Re) ? factorySpace(Ee, De, "whitespace")(Re) : De(Re) } function De(Re) { const Ie = Se.parser.constructs.flow[60], Ne = (Array.isArray(Ie) ? Ie : Ie ? [Ie] : []).find(function (ke) { return ke.name === "mdxJsxFlowTag" }); return Re === 60 && Ne ? Ee.attempt(Ne, De, Ae)(Re) : Re === null || markdownLineEnding(Re) ? be(Re) : Ae(Re) } } function _e(Ee, be) { const Ae = this; return Se; function Se(Ce) { return factoryMdxExpression.call(Ae, Ee, be, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", me, ye, pe, ge, xe, !0)(Ce) } } } const trouble$1 = "https://github.com/micromark/micromark-extension-mdx-jsx"; function factoryTag(fe, K, pe, me, ge, xe, ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De, Re, Ie, Pe, Ne, ke, Oe, Ue, He, Ge, ze, We, Xe, Ye, Ze, ot) { const qe = this; let Qe, st; return Nt; function Nt(Ft) { return fe.enter(ve), fe.enter(_e), fe.consume(Ft), fe.exit(_e), Je } function Je(Ft) { return markdownLineEndingOrSpace(Ft) ? pe(Ft) : (Qe = jt, en(Ft)) } function jt(Ft) { if (Ft === 47) return fe.enter(Ee), fe.consume(Ft), fe.exit(Ee), Qe = Xt, en; if (Ft === 62) return fn(Ft); if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(Ae), fe.enter(Se), fe.consume(Ft), ct; un(Ft, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (Ft === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")) } function Xt(Ft) { if (Ft === 62) return fn(Ft); if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(Ae), fe.enter(Se), fe.consume(Ft), ct; un(Ft, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (Ft === 42 || Ft === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")) } function ct(Ft) { if (Ft !== null && Ft >= 0 && cont(Ft, { jsx: !0 })) return fe.consume(Ft), ct; if (Ft === 46 || Ft === 47 || Ft === 58 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft)) return fe.exit(Se), Qe = nn, en(Ft); un(Ft, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (Ft === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function nn(Ft) { if (Ft === 46) return fe.enter(Ce), fe.consume(Ft), fe.exit(Ce), Qe = $t, en; if (Ft === 58) return fe.enter(Be), fe.consume(Ft), fe.exit(Be), Qe = Mn, en; if (Ft === 47 || Ft === 62 || Ft === 123 || Ft !== null && Ft >= 0 && start(Ft)) return fe.exit(Ae), Gn(Ft); un(Ft, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function $t(Ft) { if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(we), fe.consume(Ft), an; un(Ft, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function an(Ft) { if (Ft !== null && Ft >= 0 && cont(Ft, { jsx: !0 })) return fe.consume(Ft), an; if (Ft === 46 || Ft === 47 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft)) return fe.exit(we), Qe = gn, en(Ft); un(Ft, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (Ft === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function gn(Ft) { if (Ft === 46) return fe.enter(Ce), fe.consume(Ft), fe.exit(Ce), Qe = $t, en; if (Ft === 47 || Ft === 62 || Ft === 123 || Ft !== null && Ft >= 0 && start(Ft)) return fe.exit(Ae), Gn(Ft); un(Ft, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function Mn(Ft) { if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(De), fe.consume(Ft), Xn; un(Ft, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (Ft === 43 || Ft !== null && Ft > 46 && Ft < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function Xn(Ft) { if (Ft !== null && Ft >= 0 && cont(Ft, { jsx: !0 })) return fe.consume(Ft), Xn; if (Ft === 47 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft)) return fe.exit(De), Qe = Ln, en(Ft); un(Ft, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag") } function Ln(Ft) { if (Ft === 47 || Ft === 62 || Ft === 123 || Ft !== null && Ft >= 0 && start(Ft)) return fe.exit(Ae), Gn(Ft); un(Ft, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function Gn(Ft) { if (Ft === 47) return fe.enter(be), fe.consume(Ft), fe.exit(be), Qe = Dt, en; if (Ft === 62) return fn(Ft); if (Ft === 123) return factoryMdxExpression.call(qe, fe, wn, Re, Ie, Pe, me, ge, xe, !0, !1, ye)(Ft); if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(Ne), fe.enter(ke), fe.enter(Oe), fe.consume(Ft), Bn; un(Ft, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function wn(Ft) { return Qe = Gn, en(Ft) } function Bn(Ft) { if (Ft !== null && Ft >= 0 && cont(Ft, { jsx: !0 })) return fe.consume(Ft), Bn; if (Ft === 47 || Ft === 58 || Ft === 61 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft)) return fe.exit(Oe), Qe = Gt, en(Ft); un(Ft, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag") } function Gt(Ft) { if (Ft === 58) return fe.enter(Ue), fe.consume(Ft), fe.exit(Ue), Qe = nr, en; if (Ft === 61) return fe.exit(ke), fe.enter(Ge), fe.consume(Ft), fe.exit(Ge), Qe = yn, en; if (Ft === 47 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft) || Ft !== null && Ft >= 0 && start(Ft)) return fe.exit(ke), fe.exit(Ne), Qe = Gn, en(Ft); un(Ft, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function nr(Ft) { if (Ft !== null && Ft >= 0 && start(Ft)) return fe.enter(He), fe.consume(Ft), Kn; un(Ft, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function Kn(Ft) { if (Ft !== null && Ft >= 0 && cont(Ft, { jsx: !0 })) return fe.consume(Ft), Kn; if (Ft === 47 || Ft === 61 || Ft === 62 || Ft === 123 || markdownLineEndingOrSpace(Ft) || unicodeWhitespace(Ft)) return fe.exit(He), fe.exit(ke), Qe = vn, en(Ft); un(Ft, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag") } function vn(Ft) { if (Ft === 61) return fe.enter(Ge), fe.consume(Ft), fe.exit(Ge), Qe = yn, en; if (Ft === 47 || Ft === 62 || Ft === 123 || Ft !== null && Ft >= 0 && start(Ft)) return fe.exit(Ne), Gn(Ft); un(Ft, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function yn(Ft) { if (Ft === 34 || Ft === 39) return fe.enter(ze), fe.enter(We), fe.consume(Ft), fe.exit(We), st = Ft, kn; if (Ft === 123) return factoryMdxExpression.call(qe, fe, Hn, Ye, Ze, ot, me, ge, xe, !1, !1, ye)(Ft); un(Ft, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (Ft === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")) } function Hn(Ft) { return fe.exit(Ne), Qe = Gn, en(Ft) } function kn(Ft) { return Ft === null && un(Ft, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(st) + "`"), Ft === st ? (fe.enter(We), fe.consume(Ft), fe.exit(We), fe.exit(ze), fe.exit(Ne), st = void 0, Qe = Gn, en) : markdownLineEnding(Ft) ? (Qe = kn, en(Ft)) : (fe.enter(Xe), Ht(Ft)) } function Ht(Ft) { return Ft === null || Ft === st || markdownLineEnding(Ft) ? (fe.exit(Xe), kn(Ft)) : (fe.consume(Ft), Ht) } function Dt(Ft) { if (Ft === 62) return fn(Ft); un(Ft, "after self-closing slash", "`>` to end the tag" + (Ft === 42 || Ft === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")) } function fn(Ft) { return fe.enter(_e), fe.consume(Ft), fe.exit(_e), fe.exit(ve), K } function en(Ft) { return markdownLineEnding(Ft) ? (fe.enter("lineEnding"), fe.consume(Ft), fe.exit("lineEnding"), Wt) : markdownSpace(Ft) || unicodeWhitespace(Ft) ? (fe.enter("esWhitespace"), cn(Ft)) : Qe(Ft) } function cn(Ft) { return markdownLineEnding(Ft) ? (fe.exit("esWhitespace"), en(Ft)) : markdownSpace(Ft) || unicodeWhitespace(Ft) ? (fe.consume(Ft), cn) : (fe.exit("esWhitespace"), Qe(Ft)) } function Wt(Ft) { if (!ye && qe.parser.lazy[qe.now().line]) { const Sn = new VFileMessage("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", qe.now(), "micromark-extension-mdx-jsx:unexpected-lazy"); throw Sn.url = trouble$1 + "#unexpected-lazy-line-in-container-expected-line-to-be", Sn } return en(Ft) } function un(Ft, Sn, lr) { const jn = new VFileMessage("Unexpected " + (Ft === null ? "end of file" : "character `" + (Ft === 96 ? "` ` `" : String.fromCodePoint(Ft)) + "` (" + serializeCharCode(Ft) + ")") + " " + Sn + ", expected " + lr, qe.now(), "micromark-extension-mdx-jsx:unexpected-" + (Ft === null ? "eof" : "character")); throw jn.url = trouble$1 + (Ft === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), jn } } function serializeCharCode(fe) { return "U+" + fe.toString(16).toUpperCase().padStart(4, "0") } function jsxText(fe, K) { return { name: "mdxJsxTextTag", tokenize: pe }; function pe(me, ge, xe) { return factoryTag.call(this, me, ge, xe, fe, K.acornOptions, K.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue") } } function jsxFlow(fe, K) { return { name: "mdxJsxFlowTag", tokenize: pe, concrete: !0 }; function pe(me, ge, xe) { const ye = this; return ve; function ve(Ae) { return _e(Ae) } function _e(Ae) { return factoryTag.call(ye, me, Ee, xe, fe, K.acornOptions, K.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(Ae) } function Ee(Ae) { return markdownSpace(Ae) ? factorySpace(me, be, "whitespace")(Ae) : be(Ae) } function be(Ae) { const Se = ye.parser.constructs.flow[123], we = (Array.isArray(Se) ? Se : Se ? [Se] : []).find(Be => Be.name === "mdxFlowExpression"); return Ae === 60 ? ve(Ae) : Ae === 123 && we ? me.attempt(we, be, xe)(Ae) : Ae === null || markdownLineEnding(Ae) ? ge(Ae) : xe(Ae) } } } function mdxJsx(fe) { const K = fe || {}, pe = K.acorn; let me; if (pe) { if (!pe.parse || !pe.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`"); me = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, K.acornOptions, { locations: !0 }) } else if (K.acornOptions || K.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); return { flow: { 60: jsxFlow(pe || void 0, { acornOptions: me, addResult: K.addResult || void 0 }) }, text: { 60: jsxText(pe || void 0, { acornOptions: me, addResult: K.addResult || void 0 }) } } } function mdxMd() { return { disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] } } } function splice(fe, K, pe, me) { const ge = fe.length; let xe = 0, ye; if (K < 0 ? K = -K > ge ? 0 : ge + K : K = K > ge ? ge : K, pe = pe > 0 ? pe : 0, me.length < 1e4) ye = Array.from(me), ye.unshift(K, pe), fe.splice(...ye); else for (pe && fe.splice(K, pe); xe < me.length;)ye = me.slice(xe, xe + 1e4), ye.unshift(K, 0), fe.splice(...ye), xe += 1e4, K += 1e4 } function push(fe, K) { return fe.length > 0 ? (splice(fe, fe.length, 0, K), fe) : K } function classifyCharacter(fe) { if (fe === null || markdownLineEndingOrSpace(fe) || unicodeWhitespace(fe)) return 1; if (unicodePunctuation(fe)) return 2 } function resolveAll(fe, K, pe) { const me = []; let ge = -1; for (; ++ge < fe.length;) { const xe = fe[ge].resolveAll; xe && !me.includes(xe) && (K = xe(K, pe), me.push(xe)) } return K } const attention = { name: "attention", resolveAll: resolveAllAttention, tokenize: tokenizeAttention }; function resolveAllAttention(fe, K) { let pe = -1, me, ge, xe, ye, ve, _e, Ee, be; for (; ++pe < fe.length;)if (fe[pe][0] === "enter" && fe[pe][1].type === "attentionSequence" && fe[pe][1]._close) { for (me = pe; me--;)if (fe[me][0] === "exit" && fe[me][1].type === "attentionSequence" && fe[me][1]._open && K.sliceSerialize(fe[me][1]).charCodeAt(0) === K.sliceSerialize(fe[pe][1]).charCodeAt(0)) { if ((fe[me][1]._close || fe[pe][1]._open) && (fe[pe][1].end.offset - fe[pe][1].start.offset) % 3 && !((fe[me][1].end.offset - fe[me][1].start.offset + fe[pe][1].end.offset - fe[pe][1].start.offset) % 3)) continue; _e = fe[me][1].end.offset - fe[me][1].start.offset > 1 && fe[pe][1].end.offset - fe[pe][1].start.offset > 1 ? 2 : 1; const Ae = { ...fe[me][1].end }, Se = { ...fe[pe][1].start }; movePoint(Ae, -_e), movePoint(Se, _e), ye = { type: _e > 1 ? "strongSequence" : "emphasisSequence", start: Ae, end: { ...fe[me][1].end } }, ve = { type: _e > 1 ? "strongSequence" : "emphasisSequence", start: { ...fe[pe][1].start }, end: Se }, xe = { type: _e > 1 ? "strongText" : "emphasisText", start: { ...fe[me][1].end }, end: { ...fe[pe][1].start } }, ge = { type: _e > 1 ? "strong" : "emphasis", start: { ...ye.start }, end: { ...ve.end } }, fe[me][1].end = { ...ye.start }, fe[pe][1].start = { ...ve.end }, Ee = [], fe[me][1].end.offset - fe[me][1].start.offset && (Ee = push(Ee, [["enter", fe[me][1], K], ["exit", fe[me][1], K]])), Ee = push(Ee, [["enter", ge, K], ["enter", ye, K], ["exit", ye, K], ["enter", xe, K]]), Ee = push(Ee, resolveAll(K.parser.constructs.insideSpan.null, fe.slice(me + 1, pe), K)), Ee = push(Ee, [["exit", xe, K], ["enter", ve, K], ["exit", ve, K], ["exit", ge, K]]), fe[pe][1].end.offset - fe[pe][1].start.offset ? (be = 2, Ee = push(Ee, [["enter", fe[pe][1], K], ["exit", fe[pe][1], K]])) : be = 0, splice(fe, me - 1, pe - me + 3, Ee), pe = me + Ee.length - be - 2; break } } for (pe = -1; ++pe < fe.length;)fe[pe][1].type === "attentionSequence" && (fe[pe][1].type = "data"); return fe } function tokenizeAttention(fe, K) { const pe = this.parser.constructs.attentionMarkers.null, me = this.previous, ge = classifyCharacter(me); let xe; return ye; function ye(_e) { return xe = _e, fe.enter("attentionSequence"), ve(_e) } function ve(_e) { if (_e === xe) return fe.consume(_e), ve; const Ee = fe.exit("attentionSequence"), be = classifyCharacter(_e), Ae = !be || be === 2 && ge || pe.includes(_e), Se = !ge || ge === 2 && be || pe.includes(me); return Ee._open = !!(xe === 42 ? Ae : Ae && (ge || !Se)), Ee._close = !!(xe === 42 ? Se : Se && (be || !Ae)), K(_e) } } function movePoint(fe, K) { fe.column += K, fe.offset += K, fe._bufferIndex += K } const autolink = { name: "autolink", tokenize: tokenizeAutolink }; function tokenizeAutolink(fe, K, pe) { let me = 0; return ge; function ge(Ce) { return fe.enter("autolink"), fe.enter("autolinkMarker"), fe.consume(Ce), fe.exit("autolinkMarker"), fe.enter("autolinkProtocol"), xe } function xe(Ce) { return asciiAlpha(Ce) ? (fe.consume(Ce), ye) : Ce === 64 ? pe(Ce) : Ee(Ce) } function ye(Ce) { return Ce === 43 || Ce === 45 || Ce === 46 || asciiAlphanumeric(Ce) ? (me = 1, ve(Ce)) : Ee(Ce) } function ve(Ce) { return Ce === 58 ? (fe.consume(Ce), me = 0, _e) : (Ce === 43 || Ce === 45 || Ce === 46 || asciiAlphanumeric(Ce)) && me++ < 32 ? (fe.consume(Ce), ve) : (me = 0, Ee(Ce)) } function _e(Ce) { return Ce === 62 ? (fe.exit("autolinkProtocol"), fe.enter("autolinkMarker"), fe.consume(Ce), fe.exit("autolinkMarker"), fe.exit("autolink"), K) : Ce === null || Ce === 32 || Ce === 60 || asciiControl(Ce) ? pe(Ce) : (fe.consume(Ce), _e) } function Ee(Ce) { return Ce === 64 ? (fe.consume(Ce), be) : asciiAtext(Ce) ? (fe.consume(Ce), Ee) : pe(Ce) } function be(Ce) { return asciiAlphanumeric(Ce) ? Ae(Ce) : pe(Ce) } function Ae(Ce) { return Ce === 46 ? (fe.consume(Ce), me = 0, be) : Ce === 62 ? (fe.exit("autolinkProtocol").type = "autolinkEmail", fe.enter("autolinkMarker"), fe.consume(Ce), fe.exit("autolinkMarker"), fe.exit("autolink"), K) : Se(Ce) } function Se(Ce) { if ((Ce === 45 || asciiAlphanumeric(Ce)) && me++ < 63) { const we = Ce === 45 ? Se : Ae; return fe.consume(Ce), we } return pe(Ce) } } const blankLine = { partial: !0, tokenize: tokenizeBlankLine }; function tokenizeBlankLine(fe, K, pe) { return me; function me(xe) { return markdownSpace(xe) ? factorySpace(fe, ge, "linePrefix")(xe) : ge(xe) } function ge(xe) { return xe === null || markdownLineEnding(xe) ? K(xe) : pe(xe) } } const blockQuote = { continuation: { tokenize: tokenizeBlockQuoteContinuation }, exit: exit$1, name: "blockQuote", tokenize: tokenizeBlockQuoteStart }; function tokenizeBlockQuoteStart(fe, K, pe) { const me = this; return ge; function ge(ye) { if (ye === 62) { const ve = me.containerState; return ve.open || (fe.enter("blockQuote", { _container: !0 }), ve.open = !0), fe.enter("blockQuotePrefix"), fe.enter("blockQuoteMarker"), fe.consume(ye), fe.exit("blockQuoteMarker"), xe } return pe(ye) } function xe(ye) { return markdownSpace(ye) ? (fe.enter("blockQuotePrefixWhitespace"), fe.consume(ye), fe.exit("blockQuotePrefixWhitespace"), fe.exit("blockQuotePrefix"), K) : (fe.exit("blockQuotePrefix"), K(ye)) } } function tokenizeBlockQuoteContinuation(fe, K, pe) { const me = this; return ge; function ge(ye) { return markdownSpace(ye) ? factorySpace(fe, xe, "linePrefix", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ye) : xe(ye) } function xe(ye) { return fe.attempt(blockQuote, K, pe)(ye) } } function exit$1(fe) { fe.exit("blockQuote") } const characterEscape = { name: "characterEscape", tokenize: tokenizeCharacterEscape }; function tokenizeCharacterEscape(fe, K, pe) { return me; function me(xe) { return fe.enter("characterEscape"), fe.enter("escapeMarker"), fe.consume(xe), fe.exit("escapeMarker"), ge } function ge(xe) { return asciiPunctuation(xe) ? (fe.enter("characterEscapeValue"), fe.consume(xe), fe.exit("characterEscapeValue"), fe.exit("characterEscape"), K) : pe(xe) } } const characterReference = { name: "characterReference", tokenize: tokenizeCharacterReference }; function tokenizeCharacterReference(fe, K, pe) { const me = this; let ge = 0, xe, ye; return ve; function ve(Ae) { return fe.enter("characterReference"), fe.enter("characterReferenceMarker"), fe.consume(Ae), fe.exit("characterReferenceMarker"), _e } function _e(Ae) { return Ae === 35 ? (fe.enter("characterReferenceMarkerNumeric"), fe.consume(Ae), fe.exit("characterReferenceMarkerNumeric"), Ee) : (fe.enter("characterReferenceValue"), xe = 31, ye = asciiAlphanumeric, be(Ae)) } function Ee(Ae) { return Ae === 88 || Ae === 120 ? (fe.enter("characterReferenceMarkerHexadecimal"), fe.consume(Ae), fe.exit("characterReferenceMarkerHexadecimal"), fe.enter("characterReferenceValue"), xe = 6, ye = asciiHexDigit, be) : (fe.enter("characterReferenceValue"), xe = 7, ye = asciiDigit, be(Ae)) } function be(Ae) { if (Ae === 59 && ge) { const Se = fe.exit("characterReferenceValue"); return ye === asciiAlphanumeric && !decodeNamedCharacterReference(me.sliceSerialize(Se)) ? pe(Ae) : (fe.enter("characterReferenceMarker"), fe.consume(Ae), fe.exit("characterReferenceMarker"), fe.exit("characterReference"), K) } return ye(Ae) && ge++ < xe ? (fe.consume(Ae), be) : pe(Ae) } } const nonLazyContinuation = { partial: !0, tokenize: tokenizeNonLazyContinuation }, codeFenced = { concrete: !0, name: "codeFenced", tokenize: tokenizeCodeFenced }; function tokenizeCodeFenced(fe, K, pe) { const me = this, ge = { partial: !0, tokenize: ke }; let xe = 0, ye = 0, ve; return _e; function _e(Oe) { return Ee(Oe) } function Ee(Oe) { const Ue = me.events[me.events.length - 1]; return xe = Ue && Ue[1].type === "linePrefix" ? Ue[2].sliceSerialize(Ue[1], !0).length : 0, ve = Oe, fe.enter("codeFenced"), fe.enter("codeFencedFence"), fe.enter("codeFencedFenceSequence"), be(Oe) } function be(Oe) { return Oe === ve ? (ye++, fe.consume(Oe), be) : ye < 3 ? pe(Oe) : (fe.exit("codeFencedFenceSequence"), markdownSpace(Oe) ? factorySpace(fe, Ae, "whitespace")(Oe) : Ae(Oe)) } function Ae(Oe) { return Oe === null || markdownLineEnding(Oe) ? (fe.exit("codeFencedFence"), me.interrupt ? K(Oe) : fe.check(nonLazyContinuation, Be, Ne)(Oe)) : (fe.enter("codeFencedFenceInfo"), fe.enter("chunkString", { contentType: "string" }), Se(Oe)) } function Se(Oe) { return Oe === null || markdownLineEnding(Oe) ? (fe.exit("chunkString"), fe.exit("codeFencedFenceInfo"), Ae(Oe)) : markdownSpace(Oe) ? (fe.exit("chunkString"), fe.exit("codeFencedFenceInfo"), factorySpace(fe, Ce, "whitespace")(Oe)) : Oe === 96 && Oe === ve ? pe(Oe) : (fe.consume(Oe), Se) } function Ce(Oe) { return Oe === null || markdownLineEnding(Oe) ? Ae(Oe) : (fe.enter("codeFencedFenceMeta"), fe.enter("chunkString", { contentType: "string" }), we(Oe)) } function we(Oe) { return Oe === null || markdownLineEnding(Oe) ? (fe.exit("chunkString"), fe.exit("codeFencedFenceMeta"), Ae(Oe)) : Oe === 96 && Oe === ve ? pe(Oe) : (fe.consume(Oe), we) } function Be(Oe) { return fe.attempt(ge, Ne, De)(Oe) } function De(Oe) { return fe.enter("lineEnding"), fe.consume(Oe), fe.exit("lineEnding"), Re } function Re(Oe) { return xe > 0 && markdownSpace(Oe) ? factorySpace(fe, Ie, "linePrefix", xe + 1)(Oe) : Ie(Oe) } function Ie(Oe) { return Oe === null || markdownLineEnding(Oe) ? fe.check(nonLazyContinuation, Be, Ne)(Oe) : (fe.enter("codeFlowValue"), Pe(Oe)) } function Pe(Oe) { return Oe === null || markdownLineEnding(Oe) ? (fe.exit("codeFlowValue"), Ie(Oe)) : (fe.consume(Oe), Pe) } function Ne(Oe) { return fe.exit("codeFenced"), K(Oe) } function ke(Oe, Ue, He) { let Ge = 0; return ze; function ze(ot) { return Oe.enter("lineEnding"), Oe.consume(ot), Oe.exit("lineEnding"), We } function We(ot) { return Oe.enter("codeFencedFence"), markdownSpace(ot) ? factorySpace(Oe, Xe, "linePrefix", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ot) : Xe(ot) } function Xe(ot) { return ot === ve ? (Oe.enter("codeFencedFenceSequence"), Ye(ot)) : He(ot) } function Ye(ot) { return ot === ve ? (Ge++, Oe.consume(ot), Ye) : Ge >= ye ? (Oe.exit("codeFencedFenceSequence"), markdownSpace(ot) ? factorySpace(Oe, Ze, "whitespace")(ot) : Ze(ot)) : He(ot) } function Ze(ot) { return ot === null || markdownLineEnding(ot) ? (Oe.exit("codeFencedFence"), Ue(ot)) : He(ot) } } } function tokenizeNonLazyContinuation(fe, K, pe) { const me = this; return ge; function ge(ye) { return ye === null ? pe(ye) : (fe.enter("lineEnding"), fe.consume(ye), fe.exit("lineEnding"), xe) } function xe(ye) { return me.parser.lazy[me.now().line] ? pe(ye) : K(ye) } } const codeIndented = { name: "codeIndented", tokenize: tokenizeCodeIndented }, furtherStart = { partial: !0, tokenize: tokenizeFurtherStart }; function tokenizeCodeIndented(fe, K, pe) { const me = this; return ge; function ge(Ee) { return fe.enter("codeIndented"), factorySpace(fe, xe, "linePrefix", 5)(Ee) } function xe(Ee) { const be = me.events[me.events.length - 1]; return be && be[1].type === "linePrefix" && be[2].sliceSerialize(be[1], !0).length >= 4 ? ye(Ee) : pe(Ee) } function ye(Ee) { return Ee === null ? _e(Ee) : markdownLineEnding(Ee) ? fe.attempt(furtherStart, ye, _e)(Ee) : (fe.enter("codeFlowValue"), ve(Ee)) } function ve(Ee) { return Ee === null || markdownLineEnding(Ee) ? (fe.exit("codeFlowValue"), ye(Ee)) : (fe.consume(Ee), ve) } function _e(Ee) { return fe.exit("codeIndented"), K(Ee) } } function tokenizeFurtherStart(fe, K, pe) { const me = this; return ge; function ge(ye) { return me.parser.lazy[me.now().line] ? pe(ye) : markdownLineEnding(ye) ? (fe.enter("lineEnding"), fe.consume(ye), fe.exit("lineEnding"), ge) : factorySpace(fe, xe, "linePrefix", 5)(ye) } function xe(ye) { const ve = me.events[me.events.length - 1]; return ve && ve[1].type === "linePrefix" && ve[2].sliceSerialize(ve[1], !0).length >= 4 ? K(ye) : markdownLineEnding(ye) ? ge(ye) : pe(ye) } } const codeText = { name: "codeText", previous: previous$1, resolve: resolveCodeText, tokenize: tokenizeCodeText }; function resolveCodeText(fe) { let K = fe.length - 4, pe = 3, me, ge; if ((fe[pe][1].type === "lineEnding" || fe[pe][1].type === "space") && (fe[K][1].type === "lineEnding" || fe[K][1].type === "space")) { for (me = pe; ++me < K;)if (fe[me][1].type === "codeTextData") { fe[pe][1].type = "codeTextPadding", fe[K][1].type = "codeTextPadding", pe += 2, K -= 2; break } } for (me = pe - 1, K++; ++me <= K;)ge === void 0 ? me !== K && fe[me][1].type !== "lineEnding" && (ge = me) : (me === K || fe[me][1].type === "lineEnding") && (fe[ge][1].type = "codeTextData", me !== ge + 2 && (fe[ge][1].end = fe[me - 1][1].end, fe.splice(ge + 2, me - ge - 2), K -= me - ge - 2, me = ge + 2), ge = void 0); return fe } function previous$1(fe) { return fe !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function tokenizeCodeText(fe, K, pe) { let me = 0, ge, xe; return ye; function ye(Ae) { return fe.enter("codeText"), fe.enter("codeTextSequence"), ve(Ae) } function ve(Ae) { return Ae === 96 ? (fe.consume(Ae), me++, ve) : (fe.exit("codeTextSequence"), _e(Ae)) } function _e(Ae) { return Ae === null ? pe(Ae) : Ae === 32 ? (fe.enter("space"), fe.consume(Ae), fe.exit("space"), _e) : Ae === 96 ? (xe = fe.enter("codeTextSequence"), ge = 0, be(Ae)) : markdownLineEnding(Ae) ? (fe.enter("lineEnding"), fe.consume(Ae), fe.exit("lineEnding"), _e) : (fe.enter("codeTextData"), Ee(Ae)) } function Ee(Ae) { return Ae === null || Ae === 32 || Ae === 96 || markdownLineEnding(Ae) ? (fe.exit("codeTextData"), _e(Ae)) : (fe.consume(Ae), Ee) } function be(Ae) { return Ae === 96 ? (fe.consume(Ae), ge++, be) : ge === me ? (fe.exit("codeTextSequence"), fe.exit("codeText"), K(Ae)) : (xe.type = "codeTextData", Ee(Ae)) } } class SpliceBuffer { constructor(K) { this.left = K ? [...K] : [], this.right = [] } get(K) { if (K < 0 || K >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + K + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return K < this.left.length ? this.left[K] : this.right[this.right.length - K + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(K, pe) { const me = pe ?? Number.POSITIVE_INFINITY; return me < this.left.length ? this.left.slice(K, me) : K > this.left.length ? this.right.slice(this.right.length - me + this.left.length, this.right.length - K + this.left.length).reverse() : this.left.slice(K).concat(this.right.slice(this.right.length - me + this.left.length).reverse()) } splice(K, pe, me) { const ge = pe || 0; this.setCursor(Math.trunc(K)); const xe = this.right.splice(this.right.length - ge, Number.POSITIVE_INFINITY); return me && chunkedPush(this.left, me), xe.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(K) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(K) } pushMany(K) { this.setCursor(Number.POSITIVE_INFINITY), chunkedPush(this.left, K) } unshift(K) { this.setCursor(0), this.right.push(K) } unshiftMany(K) { this.setCursor(0), chunkedPush(this.right, K.reverse()) } setCursor(K) { if (!(K === this.left.length || K > this.left.length && this.right.length === 0 || K < 0 && this.left.length === 0)) if (K < this.left.length) { const pe = this.left.splice(K, Number.POSITIVE_INFINITY); chunkedPush(this.right, pe.reverse()) } else { const pe = this.right.splice(this.left.length + this.right.length - K, Number.POSITIVE_INFINITY); chunkedPush(this.left, pe.reverse()) } } } function chunkedPush(fe, K) { let pe = 0; if (K.length < 1e4) fe.push(...K); else for (; pe < K.length;)fe.push(...K.slice(pe, pe + 1e4)), pe += 1e4 } function subtokenize(fe) { const K = {}; let pe = -1, me, ge, xe, ye, ve, _e, Ee; const be = new SpliceBuffer(fe); for (; ++pe < be.length;) { for (; pe in K;)pe = K[pe]; if (me = be.get(pe), pe && me[1].type === "chunkFlow" && be.get(pe - 1)[1].type === "listItemPrefix" && (_e = me[1]._tokenizer.events, xe = 0, xe < _e.length && _e[xe][1].type === "lineEndingBlank" && (xe += 2), xe < _e.length && _e[xe][1].type === "content")) for (; ++xe < _e.length && _e[xe][1].type !== "content";)_e[xe][1].type === "chunkText" && (_e[xe][1]._isInFirstContentOfListItem = !0, xe++); if (me[0] === "enter") me[1].contentType && (Object.assign(K, subcontent(be, pe)), pe = K[pe], Ee = !0); else if (me[1]._container) { for (xe = pe, ge = void 0; xe--;)if (ye = be.get(xe), ye[1].type === "lineEnding" || ye[1].type === "lineEndingBlank") ye[0] === "enter" && (ge && (be.get(ge)[1].type = "lineEndingBlank"), ye[1].type = "lineEnding", ge = xe); else if (!(ye[1].type === "linePrefix" || ye[1].type === "listItemIndent")) break; ge && (me[1].end = { ...be.get(ge)[1].start }, ve = be.slice(ge, pe), ve.unshift(me), be.splice(ge, pe - ge + 1, ve)) } } return splice(fe, 0, Number.POSITIVE_INFINITY, be.slice(0)), !Ee } function subcontent(fe, K) { const pe = fe.get(K)[1], me = fe.get(K)[2]; let ge = K - 1; const xe = []; let ye = pe._tokenizer; ye || (ye = me.parser[pe.contentType](pe.start), pe._contentTypeTextTrailing && (ye._contentTypeTextTrailing = !0)); const ve = ye.events, _e = [], Ee = {}; let be, Ae, Se = -1, Ce = pe, we = 0, Be = 0; const De = [Be]; for (; Ce;) { for (; fe.get(++ge)[1] !== Ce;); xe.push(ge), Ce._tokenizer || (be = me.sliceStream(Ce), Ce.next || be.push(null), Ae && ye.defineSkip(Ce.start), Ce._isInFirstContentOfListItem && (ye._gfmTasklistFirstContentOfListItem = !0), ye.write(be), Ce._isInFirstContentOfListItem && (ye._gfmTasklistFirstContentOfListItem = void 0)), Ae = Ce, Ce = Ce.next } for (Ce = pe; ++Se < ve.length;)ve[Se][0] === "exit" && ve[Se - 1][0] === "enter" && ve[Se][1].type === ve[Se - 1][1].type && ve[Se][1].start.line !== ve[Se][1].end.line && (Be = Se + 1, De.push(Be), Ce._tokenizer = void 0, Ce.previous = void 0, Ce = Ce.next); for (ye.events = [], Ce ? (Ce._tokenizer = void 0, Ce.previous = void 0) : De.pop(), Se = De.length; Se--;) { const Re = ve.slice(De[Se], De[Se + 1]), Ie = xe.pop(); _e.push([Ie, Ie + Re.length - 1]), fe.splice(Ie, 2, Re) } for (_e.reverse(), Se = -1; ++Se < _e.length;)Ee[we + _e[Se][0]] = we + _e[Se][1], we += _e[Se][1] - _e[Se][0] - 1; return Ee } const content$1 = { resolve: resolveContent, tokenize: tokenizeContent }, continuationConstruct = { partial: !0, tokenize: tokenizeContinuation }; function resolveContent(fe) { return subtokenize(fe), fe } function tokenizeContent(fe, K) { let pe; return me; function me(ve) { return fe.enter("content"), pe = fe.enter("chunkContent", { contentType: "content" }), ge(ve) } function ge(ve) { return ve === null ? xe(ve) : markdownLineEnding(ve) ? fe.check(continuationConstruct, ye, xe)(ve) : (fe.consume(ve), ge) } function xe(ve) { return fe.exit("chunkContent"), fe.exit("content"), K(ve) } function ye(ve) { return fe.consume(ve), fe.exit("chunkContent"), pe.next = fe.enter("chunkContent", { contentType: "content", previous: pe }), pe = pe.next, ge } } function tokenizeContinuation(fe, K, pe) { const me = this; return ge; function ge(ye) { return fe.exit("chunkContent"), fe.enter("lineEnding"), fe.consume(ye), fe.exit("lineEnding"), factorySpace(fe, xe, "linePrefix") } function xe(ye) { if (ye === null || markdownLineEnding(ye)) return pe(ye); const ve = me.events[me.events.length - 1]; return !me.parser.constructs.disable.null.includes("codeIndented") && ve && ve[1].type === "linePrefix" && ve[2].sliceSerialize(ve[1], !0).length >= 4 ? K(ye) : fe.interrupt(me.parser.constructs.flow, pe, K)(ye) } } function factoryDestination(fe, K, pe, me, ge, xe, ye, ve, _e) { const Ee = _e || Number.POSITIVE_INFINITY; let be = 0; return Ae; function Ae(Re) { return Re === 60 ? (fe.enter(me), fe.enter(ge), fe.enter(xe), fe.consume(Re), fe.exit(xe), Se) : Re === null || Re === 32 || Re === 41 || asciiControl(Re) ? pe(Re) : (fe.enter(me), fe.enter(ye), fe.enter(ve), fe.enter("chunkString", { contentType: "string" }), Be(Re)) } function Se(Re) { return Re === 62 ? (fe.enter(xe), fe.consume(Re), fe.exit(xe), fe.exit(ge), fe.exit(me), K) : (fe.enter(ve), fe.enter("chunkString", { contentType: "string" }), Ce(Re)) } function Ce(Re) { return Re === 62 ? (fe.exit("chunkString"), fe.exit(ve), Se(Re)) : Re === null || Re === 60 || markdownLineEnding(Re) ? pe(Re) : (fe.consume(Re), Re === 92 ? we : Ce) } function we(Re) { return Re === 60 || Re === 62 || Re === 92 ? (fe.consume(Re), Ce) : Ce(Re) } function Be(Re) { return !be && (Re === null || Re === 41 || markdownLineEndingOrSpace(Re)) ? (fe.exit("chunkString"), fe.exit(ve), fe.exit(ye), fe.exit(me), K(Re)) : be < Ee && Re === 40 ? (fe.consume(Re), be++, Be) : Re === 41 ? (fe.consume(Re), be--, Be) : Re === null || Re === 32 || Re === 40 || asciiControl(Re) ? pe(Re) : (fe.consume(Re), Re === 92 ? De : Be) } function De(Re) { return Re === 40 || Re === 41 || Re === 92 ? (fe.consume(Re), Be) : Be(Re) } } function factoryLabel(fe, K, pe, me, ge, xe) { const ye = this; let ve = 0, _e; return Ee; function Ee(Ce) { return fe.enter(me), fe.enter(ge), fe.consume(Ce), fe.exit(ge), fe.enter(xe), be } function be(Ce) { return ve > 999 || Ce === null || Ce === 91 || Ce === 93 && !_e || Ce === 94 && !ve && "_hiddenFootnoteSupport" in ye.parser.constructs ? pe(Ce) : Ce === 93 ? (fe.exit(xe), fe.enter(ge), fe.consume(Ce), fe.exit(ge), fe.exit(me), K) : markdownLineEnding(Ce) ? (fe.enter("lineEnding"), fe.consume(Ce), fe.exit("lineEnding"), be) : (fe.enter("chunkString", { contentType: "string" }), Ae(Ce)) } function Ae(Ce) { return Ce === null || Ce === 91 || Ce === 93 || markdownLineEnding(Ce) || ve++ > 999 ? (fe.exit("chunkString"), be(Ce)) : (fe.consume(Ce), _e || (_e = !markdownSpace(Ce)), Ce === 92 ? Se : Ae) } function Se(Ce) { return Ce === 91 || Ce === 92 || Ce === 93 ? (fe.consume(Ce), ve++, Ae) : Ae(Ce) } } function factoryTitle(fe, K, pe, me, ge, xe) { let ye; return ve; function ve(Se) { return Se === 34 || Se === 39 || Se === 40 ? (fe.enter(me), fe.enter(ge), fe.consume(Se), fe.exit(ge), ye = Se === 40 ? 41 : Se, _e) : pe(Se) } function _e(Se) { return Se === ye ? (fe.enter(ge), fe.consume(Se), fe.exit(ge), fe.exit(me), K) : (fe.enter(xe), Ee(Se)) } function Ee(Se) { return Se === ye ? (fe.exit(xe), _e(ye)) : Se === null ? pe(Se) : markdownLineEnding(Se) ? (fe.enter("lineEnding"), fe.consume(Se), fe.exit("lineEnding"), factorySpace(fe, Ee, "linePrefix")) : (fe.enter("chunkString", { contentType: "string" }), be(Se)) } function be(Se) { return Se === ye || Se === null || markdownLineEnding(Se) ? (fe.exit("chunkString"), Ee(Se)) : (fe.consume(Se), Se === 92 ? Ae : be) } function Ae(Se) { return Se === ye || Se === 92 ? (fe.consume(Se), be) : be(Se) } } function factoryWhitespace(fe, K) { let pe; return me; function me(ge) { return markdownLineEnding(ge) ? (fe.enter("lineEnding"), fe.consume(ge), fe.exit("lineEnding"), pe = !0, me) : markdownSpace(ge) ? factorySpace(fe, me, pe ? "linePrefix" : "lineSuffix")(ge) : K(ge) } } function normalizeIdentifier(fe) { return fe.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const definition$1 = { name: "definition", tokenize: tokenizeDefinition }, titleBefore = { partial: !0, tokenize: tokenizeTitleBefore }; function tokenizeDefinition(fe, K, pe) { const me = this; let ge; return xe; function xe(Ce) { return fe.enter("definition"), ye(Ce) } function ye(Ce) { return factoryLabel.call(me, fe, ve, pe, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(Ce) } function ve(Ce) { return ge = normalizeIdentifier(me.sliceSerialize(me.events[me.events.length - 1][1]).slice(1, -1)), Ce === 58 ? (fe.enter("definitionMarker"), fe.consume(Ce), fe.exit("definitionMarker"), _e) : pe(Ce) } function _e(Ce) { return markdownLineEndingOrSpace(Ce) ? factoryWhitespace(fe, Ee)(Ce) : Ee(Ce) } function Ee(Ce) { return factoryDestination(fe, be, pe, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(Ce) } function be(Ce) { return fe.attempt(titleBefore, Ae, Ae)(Ce) } function Ae(Ce) { return markdownSpace(Ce) ? factorySpace(fe, Se, "whitespace")(Ce) : Se(Ce) } function Se(Ce) { return Ce === null || markdownLineEnding(Ce) ? (fe.exit("definition"), me.parser.defined.push(ge), K(Ce)) : pe(Ce) } } function tokenizeTitleBefore(fe, K, pe) { return me; function me(ve) { return markdownLineEndingOrSpace(ve) ? factoryWhitespace(fe, ge)(ve) : pe(ve) } function ge(ve) { return factoryTitle(fe, xe, pe, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(ve) } function xe(ve) { return markdownSpace(ve) ? factorySpace(fe, ye, "whitespace")(ve) : ye(ve) } function ye(ve) { return ve === null || markdownLineEnding(ve) ? K(ve) : pe(ve) } } const hardBreakEscape = { name: "hardBreakEscape", tokenize: tokenizeHardBreakEscape }; function tokenizeHardBreakEscape(fe, K, pe) { return me; function me(xe) { return fe.enter("hardBreakEscape"), fe.consume(xe), ge } function ge(xe) { return markdownLineEnding(xe) ? (fe.exit("hardBreakEscape"), K(xe)) : pe(xe) } } const headingAtx = { name: "headingAtx", resolve: resolveHeadingAtx, tokenize: tokenizeHeadingAtx }; function resolveHeadingAtx(fe, K) { let pe = fe.length - 2, me = 3, ge, xe; return fe[me][1].type === "whitespace" && (me += 2), pe - 2 > me && fe[pe][1].type === "whitespace" && (pe -= 2), fe[pe][1].type === "atxHeadingSequence" && (me === pe - 1 || pe - 4 > me && fe[pe - 2][1].type === "whitespace") && (pe -= me + 1 === pe ? 2 : 4), pe > me && (ge = { type: "atxHeadingText", start: fe[me][1].start, end: fe[pe][1].end }, xe = { type: "chunkText", start: fe[me][1].start, end: fe[pe][1].end, contentType: "text" }, splice(fe, me, pe - me + 1, [["enter", ge, K], ["enter", xe, K], ["exit", xe, K], ["exit", ge, K]])), fe } function tokenizeHeadingAtx(fe, K, pe) { let me = 0; return ge; function ge(be) { return fe.enter("atxHeading"), xe(be) } function xe(be) { return fe.enter("atxHeadingSequence"), ye(be) } function ye(be) { return be === 35 && me++ < 6 ? (fe.consume(be), ye) : be === null || markdownLineEndingOrSpace(be) ? (fe.exit("atxHeadingSequence"), ve(be)) : pe(be) } function ve(be) { return be === 35 ? (fe.enter("atxHeadingSequence"), _e(be)) : be === null || markdownLineEnding(be) ? (fe.exit("atxHeading"), K(be)) : markdownSpace(be) ? factorySpace(fe, ve, "whitespace")(be) : (fe.enter("atxHeadingText"), Ee(be)) } function _e(be) { return be === 35 ? (fe.consume(be), _e) : (fe.exit("atxHeadingSequence"), ve(be)) } function Ee(be) { return be === null || be === 35 || markdownLineEndingOrSpace(be) ? (fe.exit("atxHeadingText"), ve(be)) : (fe.consume(be), Ee) } } const htmlBlockNames = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], htmlRawNames = ["pre", "script", "style", "textarea"], htmlFlow = { concrete: !0, name: "htmlFlow", resolveTo: resolveToHtmlFlow, tokenize: tokenizeHtmlFlow }, blankLineBefore$1 = { partial: !0, tokenize: tokenizeBlankLineBefore }, nonLazyContinuationStart = { partial: !0, tokenize: tokenizeNonLazyContinuationStart }; function resolveToHtmlFlow(fe) { let K = fe.length; for (; K-- && !(fe[K][0] === "enter" && fe[K][1].type === "htmlFlow");); return K > 1 && fe[K - 2][1].type === "linePrefix" && (fe[K][1].start = fe[K - 2][1].start, fe[K + 1][1].start = fe[K - 2][1].start, fe.splice(K - 2, 2)), fe } function tokenizeHtmlFlow(fe, K, pe) { const me = this; let ge, xe, ye, ve, _e; return Ee; function Ee(ct) { return be(ct) } function be(ct) { return fe.enter("htmlFlow"), fe.enter("htmlFlowData"), fe.consume(ct), Ae } function Ae(ct) { return ct === 33 ? (fe.consume(ct), Se) : ct === 47 ? (fe.consume(ct), xe = !0, Be) : ct === 63 ? (fe.consume(ct), ge = 3, me.interrupt ? K : Je) : asciiAlpha(ct) ? (fe.consume(ct), ye = String.fromCharCode(ct), De) : pe(ct) } function Se(ct) { return ct === 45 ? (fe.consume(ct), ge = 2, Ce) : ct === 91 ? (fe.consume(ct), ge = 5, ve = 0, we) : asciiAlpha(ct) ? (fe.consume(ct), ge = 4, me.interrupt ? K : Je) : pe(ct) } function Ce(ct) { return ct === 45 ? (fe.consume(ct), me.interrupt ? K : Je) : pe(ct) } function we(ct) { const nn = "CDATA["; return ct === nn.charCodeAt(ve++) ? (fe.consume(ct), ve === nn.length ? me.interrupt ? K : Xe : we) : pe(ct) } function Be(ct) { return asciiAlpha(ct) ? (fe.consume(ct), ye = String.fromCharCode(ct), De) : pe(ct) } function De(ct) { if (ct === null || ct === 47 || ct === 62 || markdownLineEndingOrSpace(ct)) { const nn = ct === 47, $t = ye.toLowerCase(); return !nn && !xe && htmlRawNames.includes($t) ? (ge = 1, me.interrupt ? K(ct) : Xe(ct)) : htmlBlockNames.includes(ye.toLowerCase()) ? (ge = 6, nn ? (fe.consume(ct), Re) : me.interrupt ? K(ct) : Xe(ct)) : (ge = 7, me.interrupt && !me.parser.lazy[me.now().line] ? pe(ct) : xe ? Ie(ct) : Pe(ct)) } return ct === 45 || asciiAlphanumeric(ct) ? (fe.consume(ct), ye += String.fromCharCode(ct), De) : pe(ct) } function Re(ct) { return ct === 62 ? (fe.consume(ct), me.interrupt ? K : Xe) : pe(ct) } function Ie(ct) { return markdownSpace(ct) ? (fe.consume(ct), Ie) : ze(ct) } function Pe(ct) { return ct === 47 ? (fe.consume(ct), ze) : ct === 58 || ct === 95 || asciiAlpha(ct) ? (fe.consume(ct), Ne) : markdownSpace(ct) ? (fe.consume(ct), Pe) : ze(ct) } function Ne(ct) { return ct === 45 || ct === 46 || ct === 58 || ct === 95 || asciiAlphanumeric(ct) ? (fe.consume(ct), Ne) : ke(ct) } function ke(ct) { return ct === 61 ? (fe.consume(ct), Oe) : markdownSpace(ct) ? (fe.consume(ct), ke) : Pe(ct) } function Oe(ct) { return ct === null || ct === 60 || ct === 61 || ct === 62 || ct === 96 ? pe(ct) : ct === 34 || ct === 39 ? (fe.consume(ct), _e = ct, Ue) : markdownSpace(ct) ? (fe.consume(ct), Oe) : He(ct) } function Ue(ct) { return ct === _e ? (fe.consume(ct), _e = null, Ge) : ct === null || markdownLineEnding(ct) ? pe(ct) : (fe.consume(ct), Ue) } function He(ct) { return ct === null || ct === 34 || ct === 39 || ct === 47 || ct === 60 || ct === 61 || ct === 62 || ct === 96 || markdownLineEndingOrSpace(ct) ? ke(ct) : (fe.consume(ct), He) } function Ge(ct) { return ct === 47 || ct === 62 || markdownSpace(ct) ? Pe(ct) : pe(ct) } function ze(ct) { return ct === 62 ? (fe.consume(ct), We) : pe(ct) } function We(ct) { return ct === null || markdownLineEnding(ct) ? Xe(ct) : markdownSpace(ct) ? (fe.consume(ct), We) : pe(ct) } function Xe(ct) { return ct === 45 && ge === 2 ? (fe.consume(ct), qe) : ct === 60 && ge === 1 ? (fe.consume(ct), Qe) : ct === 62 && ge === 4 ? (fe.consume(ct), jt) : ct === 63 && ge === 3 ? (fe.consume(ct), Je) : ct === 93 && ge === 5 ? (fe.consume(ct), Nt) : markdownLineEnding(ct) && (ge === 6 || ge === 7) ? (fe.exit("htmlFlowData"), fe.check(blankLineBefore$1, Xt, Ye)(ct)) : ct === null || markdownLineEnding(ct) ? (fe.exit("htmlFlowData"), Ye(ct)) : (fe.consume(ct), Xe) } function Ye(ct) { return fe.check(nonLazyContinuationStart, Ze, Xt)(ct) } function Ze(ct) { return fe.enter("lineEnding"), fe.consume(ct), fe.exit("lineEnding"), ot } function ot(ct) { return ct === null || markdownLineEnding(ct) ? Ye(ct) : (fe.enter("htmlFlowData"), Xe(ct)) } function qe(ct) { return ct === 45 ? (fe.consume(ct), Je) : Xe(ct) } function Qe(ct) { return ct === 47 ? (fe.consume(ct), ye = "", st) : Xe(ct) } function st(ct) { if (ct === 62) { const nn = ye.toLowerCase(); return htmlRawNames.includes(nn) ? (fe.consume(ct), jt) : Xe(ct) } return asciiAlpha(ct) && ye.length < 8 ? (fe.consume(ct), ye += String.fromCharCode(ct), st) : Xe(ct) } function Nt(ct) { return ct === 93 ? (fe.consume(ct), Je) : Xe(ct) } function Je(ct) { return ct === 62 ? (fe.consume(ct), jt) : ct === 45 && ge === 2 ? (fe.consume(ct), Je) : Xe(ct) } function jt(ct) { return ct === null || markdownLineEnding(ct) ? (fe.exit("htmlFlowData"), Xt(ct)) : (fe.consume(ct), jt) } function Xt(ct) { return fe.exit("htmlFlow"), K(ct) } } function tokenizeNonLazyContinuationStart(fe, K, pe) { const me = this; return ge; function ge(ye) { return markdownLineEnding(ye) ? (fe.enter("lineEnding"), fe.consume(ye), fe.exit("lineEnding"), xe) : pe(ye) } function xe(ye) { return me.parser.lazy[me.now().line] ? pe(ye) : K(ye) } } function tokenizeBlankLineBefore(fe, K, pe) { return me; function me(ge) { return fe.enter("lineEnding"), fe.consume(ge), fe.exit("lineEnding"), fe.attempt(blankLine, K, pe) } } const htmlText = { name: "htmlText", tokenize: tokenizeHtmlText }; function tokenizeHtmlText(fe, K, pe) { const me = this; let ge, xe, ye; return ve; function ve(Je) { return fe.enter("htmlText"), fe.enter("htmlTextData"), fe.consume(Je), _e } function _e(Je) { return Je === 33 ? (fe.consume(Je), Ee) : Je === 47 ? (fe.consume(Je), ke) : Je === 63 ? (fe.consume(Je), Pe) : asciiAlpha(Je) ? (fe.consume(Je), He) : pe(Je) } function Ee(Je) { return Je === 45 ? (fe.consume(Je), be) : Je === 91 ? (fe.consume(Je), xe = 0, we) : asciiAlpha(Je) ? (fe.consume(Je), Ie) : pe(Je) } function be(Je) { return Je === 45 ? (fe.consume(Je), Ce) : pe(Je) } function Ae(Je) { return Je === null ? pe(Je) : Je === 45 ? (fe.consume(Je), Se) : markdownLineEnding(Je) ? (ye = Ae, Qe(Je)) : (fe.consume(Je), Ae) } function Se(Je) { return Je === 45 ? (fe.consume(Je), Ce) : Ae(Je) } function Ce(Je) { return Je === 62 ? qe(Je) : Je === 45 ? Se(Je) : Ae(Je) } function we(Je) { const jt = "CDATA["; return Je === jt.charCodeAt(xe++) ? (fe.consume(Je), xe === jt.length ? Be : we) : pe(Je) } function Be(Je) { return Je === null ? pe(Je) : Je === 93 ? (fe.consume(Je), De) : markdownLineEnding(Je) ? (ye = Be, Qe(Je)) : (fe.consume(Je), Be) } function De(Je) { return Je === 93 ? (fe.consume(Je), Re) : Be(Je) } function Re(Je) { return Je === 62 ? qe(Je) : Je === 93 ? (fe.consume(Je), Re) : Be(Je) } function Ie(Je) { return Je === null || Je === 62 ? qe(Je) : markdownLineEnding(Je) ? (ye = Ie, Qe(Je)) : (fe.consume(Je), Ie) } function Pe(Je) { return Je === null ? pe(Je) : Je === 63 ? (fe.consume(Je), Ne) : markdownLineEnding(Je) ? (ye = Pe, Qe(Je)) : (fe.consume(Je), Pe) } function Ne(Je) { return Je === 62 ? qe(Je) : Pe(Je) } function ke(Je) { return asciiAlpha(Je) ? (fe.consume(Je), Oe) : pe(Je) } function Oe(Je) { return Je === 45 || asciiAlphanumeric(Je) ? (fe.consume(Je), Oe) : Ue(Je) } function Ue(Je) { return markdownLineEnding(Je) ? (ye = Ue, Qe(Je)) : markdownSpace(Je) ? (fe.consume(Je), Ue) : qe(Je) } function He(Je) { return Je === 45 || asciiAlphanumeric(Je) ? (fe.consume(Je), He) : Je === 47 || Je === 62 || markdownLineEndingOrSpace(Je) ? Ge(Je) : pe(Je) } function Ge(Je) { return Je === 47 ? (fe.consume(Je), qe) : Je === 58 || Je === 95 || asciiAlpha(Je) ? (fe.consume(Je), ze) : markdownLineEnding(Je) ? (ye = Ge, Qe(Je)) : markdownSpace(Je) ? (fe.consume(Je), Ge) : qe(Je) } function ze(Je) { return Je === 45 || Je === 46 || Je === 58 || Je === 95 || asciiAlphanumeric(Je) ? (fe.consume(Je), ze) : We(Je) } function We(Je) { return Je === 61 ? (fe.consume(Je), Xe) : markdownLineEnding(Je) ? (ye = We, Qe(Je)) : markdownSpace(Je) ? (fe.consume(Je), We) : Ge(Je) } function Xe(Je) { return Je === null || Je === 60 || Je === 61 || Je === 62 || Je === 96 ? pe(Je) : Je === 34 || Je === 39 ? (fe.consume(Je), ge = Je, Ye) : markdownLineEnding(Je) ? (ye = Xe, Qe(Je)) : markdownSpace(Je) ? (fe.consume(Je), Xe) : (fe.consume(Je), Ze) } function Ye(Je) { return Je === ge ? (fe.consume(Je), ge = void 0, ot) : Je === null ? pe(Je) : markdownLineEnding(Je) ? (ye = Ye, Qe(Je)) : (fe.consume(Je), Ye) } function Ze(Je) { return Je === null || Je === 34 || Je === 39 || Je === 60 || Je === 61 || Je === 96 ? pe(Je) : Je === 47 || Je === 62 || markdownLineEndingOrSpace(Je) ? Ge(Je) : (fe.consume(Je), Ze) } function ot(Je) { return Je === 47 || Je === 62 || markdownLineEndingOrSpace(Je) ? Ge(Je) : pe(Je) } function qe(Je) { return Je === 62 ? (fe.consume(Je), fe.exit("htmlTextData"), fe.exit("htmlText"), K) : pe(Je) } function Qe(Je) { return fe.exit("htmlTextData"), fe.enter("lineEnding"), fe.consume(Je), fe.exit("lineEnding"), st } function st(Je) { return markdownSpace(Je) ? factorySpace(fe, Nt, "linePrefix", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(Je) : Nt(Je) } function Nt(Je) { return fe.enter("htmlTextData"), ye(Je) } } const labelEnd = { name: "labelEnd", resolveAll: resolveAllLabelEnd, resolveTo: resolveToLabelEnd, tokenize: tokenizeLabelEnd }, resourceConstruct = { tokenize: tokenizeResource }, referenceFullConstruct = { tokenize: tokenizeReferenceFull }, referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed }; function resolveAllLabelEnd(fe) { let K = -1; const pe = []; for (; ++K < fe.length;) { const me = fe[K][1]; if (pe.push(fe[K]), me.type === "labelImage" || me.type === "labelLink" || me.type === "labelEnd") { const ge = me.type === "labelImage" ? 4 : 2; me.type = "data", K += ge } } return fe.length !== pe.length && splice(fe, 0, fe.length, pe), fe } function resolveToLabelEnd(fe, K) { let pe = fe.length, me = 0, ge, xe, ye, ve; for (; pe--;)if (ge = fe[pe][1], xe) { if (ge.type === "link" || ge.type === "labelLink" && ge._inactive) break; fe[pe][0] === "enter" && ge.type === "labelLink" && (ge._inactive = !0) } else if (ye) { if (fe[pe][0] === "enter" && (ge.type === "labelImage" || ge.type === "labelLink") && !ge._balanced && (xe = pe, ge.type !== "labelLink")) { me = 2; break } } else ge.type === "labelEnd" && (ye = pe); const _e = { type: fe[xe][1].type === "labelLink" ? "link" : "image", start: { ...fe[xe][1].start }, end: { ...fe[fe.length - 1][1].end } }, Ee = { type: "label", start: { ...fe[xe][1].start }, end: { ...fe[ye][1].end } }, be = { type: "labelText", start: { ...fe[xe + me + 2][1].end }, end: { ...fe[ye - 2][1].start } }; return ve = [["enter", _e, K], ["enter", Ee, K]], ve = push(ve, fe.slice(xe + 1, xe + me + 3)), ve = push(ve, [["enter", be, K]]), ve = push(ve, resolveAll(K.parser.constructs.insideSpan.null, fe.slice(xe + me + 4, ye - 3), K)), ve = push(ve, [["exit", be, K], fe[ye - 2], fe[ye - 1], ["exit", Ee, K]]), ve = push(ve, fe.slice(ye + 1)), ve = push(ve, [["exit", _e, K]]), splice(fe, xe, fe.length, ve), fe } function tokenizeLabelEnd(fe, K, pe) { const me = this; let ge = me.events.length, xe, ye; for (; ge--;)if ((me.events[ge][1].type === "labelImage" || me.events[ge][1].type === "labelLink") && !me.events[ge][1]._balanced) { xe = me.events[ge][1]; break } return ve; function ve(Se) { return xe ? xe._inactive ? Ae(Se) : (ye = me.parser.defined.includes(normalizeIdentifier(me.sliceSerialize({ start: xe.end, end: me.now() }))), fe.enter("labelEnd"), fe.enter("labelMarker"), fe.consume(Se), fe.exit("labelMarker"), fe.exit("labelEnd"), _e) : pe(Se) } function _e(Se) { return Se === 40 ? fe.attempt(resourceConstruct, be, ye ? be : Ae)(Se) : Se === 91 ? fe.attempt(referenceFullConstruct, be, ye ? Ee : Ae)(Se) : ye ? be(Se) : Ae(Se) } function Ee(Se) { return fe.attempt(referenceCollapsedConstruct, be, Ae)(Se) } function be(Se) { return K(Se) } function Ae(Se) { return xe._balanced = !0, pe(Se) } } function tokenizeResource(fe, K, pe) { return me; function me(Ae) { return fe.enter("resource"), fe.enter("resourceMarker"), fe.consume(Ae), fe.exit("resourceMarker"), ge } function ge(Ae) { return markdownLineEndingOrSpace(Ae) ? factoryWhitespace(fe, xe)(Ae) : xe(Ae) } function xe(Ae) { return Ae === 41 ? be(Ae) : factoryDestination(fe, ye, ve, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(Ae) } function ye(Ae) { return markdownLineEndingOrSpace(Ae) ? factoryWhitespace(fe, _e)(Ae) : be(Ae) } function ve(Ae) { return pe(Ae) } function _e(Ae) { return Ae === 34 || Ae === 39 || Ae === 40 ? factoryTitle(fe, Ee, pe, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(Ae) : be(Ae) } function Ee(Ae) { return markdownLineEndingOrSpace(Ae) ? factoryWhitespace(fe, be)(Ae) : be(Ae) } function be(Ae) { return Ae === 41 ? (fe.enter("resourceMarker"), fe.consume(Ae), fe.exit("resourceMarker"), fe.exit("resource"), K) : pe(Ae) } } function tokenizeReferenceFull(fe, K, pe) { const me = this; return ge; function ge(ve) { return factoryLabel.call(me, fe, xe, ye, "reference", "referenceMarker", "referenceString")(ve) } function xe(ve) { return me.parser.defined.includes(normalizeIdentifier(me.sliceSerialize(me.events[me.events.length - 1][1]).slice(1, -1))) ? K(ve) : pe(ve) } function ye(ve) { return pe(ve) } } function tokenizeReferenceCollapsed(fe, K, pe) { return me; function me(xe) { return fe.enter("reference"), fe.enter("referenceMarker"), fe.consume(xe), fe.exit("referenceMarker"), ge } function ge(xe) { return xe === 93 ? (fe.enter("referenceMarker"), fe.consume(xe), fe.exit("referenceMarker"), fe.exit("reference"), K) : pe(xe) } } const labelStartImage = { name: "labelStartImage", resolveAll: labelEnd.resolveAll, tokenize: tokenizeLabelStartImage }; function tokenizeLabelStartImage(fe, K, pe) { const me = this; return ge; function ge(ve) { return fe.enter("labelImage"), fe.enter("labelImageMarker"), fe.consume(ve), fe.exit("labelImageMarker"), xe } function xe(ve) { return ve === 91 ? (fe.enter("labelMarker"), fe.consume(ve), fe.exit("labelMarker"), fe.exit("labelImage"), ye) : pe(ve) } function ye(ve) { return ve === 94 && "_hiddenFootnoteSupport" in me.parser.constructs ? pe(ve) : K(ve) } } const labelStartLink = { name: "labelStartLink", resolveAll: labelEnd.resolveAll, tokenize: tokenizeLabelStartLink }; function tokenizeLabelStartLink(fe, K, pe) { const me = this; return ge; function ge(ye) { return fe.enter("labelLink"), fe.enter("labelMarker"), fe.consume(ye), fe.exit("labelMarker"), fe.exit("labelLink"), xe } function xe(ye) { return ye === 94 && "_hiddenFootnoteSupport" in me.parser.constructs ? pe(ye) : K(ye) } } const lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding }; function tokenizeLineEnding(fe, K) { return pe; function pe(me) { return fe.enter("lineEnding"), fe.consume(me), fe.exit("lineEnding"), factorySpace(fe, K, "linePrefix") } } const thematicBreak$2 = { name: "thematicBreak", tokenize: tokenizeThematicBreak }; function tokenizeThematicBreak(fe, K, pe) { let me = 0, ge; return xe; function xe(Ee) { return fe.enter("thematicBreak"), ye(Ee) } function ye(Ee) { return ge = Ee, ve(Ee) } function ve(Ee) { return Ee === ge ? (fe.enter("thematicBreakSequence"), _e(Ee)) : me >= 3 && (Ee === null || markdownLineEnding(Ee)) ? (fe.exit("thematicBreak"), K(Ee)) : pe(Ee) } function _e(Ee) { return Ee === ge ? (fe.consume(Ee), me++, _e) : (fe.exit("thematicBreakSequence"), markdownSpace(Ee) ? factorySpace(fe, ve, "whitespace")(Ee) : ve(Ee)) } } const list$2 = { continuation: { tokenize: tokenizeListContinuation }, exit: tokenizeListEnd, name: "list", tokenize: tokenizeListStart }, listItemPrefixWhitespaceConstruct = { partial: !0, tokenize: tokenizeListItemPrefixWhitespace }, indentConstruct = { partial: !0, tokenize: tokenizeIndent$1 }; function tokenizeListStart(fe, K, pe) { const me = this, ge = me.events[me.events.length - 1]; let xe = ge && ge[1].type === "linePrefix" ? ge[2].sliceSerialize(ge[1], !0).length : 0, ye = 0; return ve; function ve(Ce) { const we = me.containerState.type || (Ce === 42 || Ce === 43 || Ce === 45 ? "listUnordered" : "listOrdered"); if (we === "listUnordered" ? !me.containerState.marker || Ce === me.containerState.marker : asciiDigit(Ce)) { if (me.containerState.type || (me.containerState.type = we, fe.enter(we, { _container: !0 })), we === "listUnordered") return fe.enter("listItemPrefix"), Ce === 42 || Ce === 45 ? fe.check(thematicBreak$2, pe, Ee)(Ce) : Ee(Ce); if (!me.interrupt || Ce === 49) return fe.enter("listItemPrefix"), fe.enter("listItemValue"), _e(Ce) } return pe(Ce) } function _e(Ce) { return asciiDigit(Ce) && ++ye < 10 ? (fe.consume(Ce), _e) : (!me.interrupt || ye < 2) && (me.containerState.marker ? Ce === me.containerState.marker : Ce === 41 || Ce === 46) ? (fe.exit("listItemValue"), Ee(Ce)) : pe(Ce) } function Ee(Ce) { return fe.enter("listItemMarker"), fe.consume(Ce), fe.exit("listItemMarker"), me.containerState.marker = me.containerState.marker || Ce, fe.check(blankLine, me.interrupt ? pe : be, fe.attempt(listItemPrefixWhitespaceConstruct, Se, Ae)) } function be(Ce) { return me.containerState.initialBlankLine = !0, xe++, Se(Ce) } function Ae(Ce) { return markdownSpace(Ce) ? (fe.enter("listItemPrefixWhitespace"), fe.consume(Ce), fe.exit("listItemPrefixWhitespace"), Se) : pe(Ce) } function Se(Ce) { return me.containerState.size = xe + me.sliceSerialize(fe.exit("listItemPrefix"), !0).length, K(Ce) } } function tokenizeListContinuation(fe, K, pe) { const me = this; return me.containerState._closeFlow = void 0, fe.check(blankLine, ge, xe); function ge(ve) { return me.containerState.furtherBlankLines = me.containerState.furtherBlankLines || me.containerState.initialBlankLine, factorySpace(fe, K, "listItemIndent", me.containerState.size + 1)(ve) } function xe(ve) { return me.containerState.furtherBlankLines || !markdownSpace(ve) ? (me.containerState.furtherBlankLines = void 0, me.containerState.initialBlankLine = void 0, ye(ve)) : (me.containerState.furtherBlankLines = void 0, me.containerState.initialBlankLine = void 0, fe.attempt(indentConstruct, K, ye)(ve)) } function ye(ve) { return me.containerState._closeFlow = !0, me.interrupt = void 0, factorySpace(fe, fe.attempt(list$2, K, pe), "linePrefix", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ve) } } function tokenizeIndent$1(fe, K, pe) { const me = this; return factorySpace(fe, ge, "listItemIndent", me.containerState.size + 1); function ge(xe) { const ye = me.events[me.events.length - 1]; return ye && ye[1].type === "listItemIndent" && ye[2].sliceSerialize(ye[1], !0).length === me.containerState.size ? K(xe) : pe(xe) } } function tokenizeListEnd(fe) { fe.exit(this.containerState.type) } function tokenizeListItemPrefixWhitespace(fe, K, pe) { const me = this; return factorySpace(fe, ge, "listItemPrefixWhitespace", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function ge(xe) { const ye = me.events[me.events.length - 1]; return !markdownSpace(xe) && ye && ye[1].type === "listItemPrefixWhitespace" ? K(xe) : pe(xe) } } const setextUnderline = { name: "setextUnderline", resolveTo: resolveToSetextUnderline, tokenize: tokenizeSetextUnderline }; function resolveToSetextUnderline(fe, K) { let pe = fe.length, me, ge, xe; for (; pe--;)if (fe[pe][0] === "enter") { if (fe[pe][1].type === "content") { me = pe; break } fe[pe][1].type === "paragraph" && (ge = pe) } else fe[pe][1].type === "content" && fe.splice(pe, 1), !xe && fe[pe][1].type === "definition" && (xe = pe); const ye = { type: "setextHeading", start: { ...fe[me][1].start }, end: { ...fe[fe.length - 1][1].end } }; return fe[ge][1].type = "setextHeadingText", xe ? (fe.splice(ge, 0, ["enter", ye, K]), fe.splice(xe + 1, 0, ["exit", fe[me][1], K]), fe[me][1].end = { ...fe[xe][1].end }) : fe[me][1] = ye, fe.push(["exit", ye, K]), fe } function tokenizeSetextUnderline(fe, K, pe) { const me = this; let ge; return xe; function xe(Ee) { let be = me.events.length, Ae; for (; be--;)if (me.events[be][1].type !== "lineEnding" && me.events[be][1].type !== "linePrefix" && me.events[be][1].type !== "content") { Ae = me.events[be][1].type === "paragraph"; break } return !me.parser.lazy[me.now().line] && (me.interrupt || Ae) ? (fe.enter("setextHeadingLine"), ge = Ee, ye(Ee)) : pe(Ee) } function ye(Ee) { return fe.enter("setextHeadingLineSequence"), ve(Ee) } function ve(Ee) { return Ee === ge ? (fe.consume(Ee), ve) : (fe.exit("setextHeadingLineSequence"), markdownSpace(Ee) ? factorySpace(fe, _e, "lineSuffix")(Ee) : _e(Ee)) } function _e(Ee) { return Ee === null || markdownLineEnding(Ee) ? (fe.exit("setextHeadingLine"), K(Ee)) : pe(Ee) } } const blankLineBefore = { tokenize: tokenizeNextBlank, partial: !0 }, trouble = "https://github.com/micromark/micromark-extension-mdxjs-esm", allowedAcornTypes = new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]); function mdxjsEsm(fe) {
	const K = { tokenize: ge, concrete: !0 }; if (!fe || !fe.acorn || !fe.acorn.parse) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); const pe = fe.acorn, me = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, fe.acornOptions, { locations: !0 }); return { flow: { 101: K, 105: K } }; function ge(xe, ye, ve) {
		const _e = this, Ee = _e.parser.definedModuleSpecifiers || (_e.parser.definedModuleSpecifiers = []), be = this.events.length + 1; let Ae = ""; return _e.interrupt ? ve : Se; function Se(Ie) { return _e.now().column > 1 ? ve(Ie) : (xe.enter("mdxjsEsm"), xe.enter("mdxjsEsmData"), xe.consume(Ie), Ae += String.fromCharCode(Ie), Ce) } function Ce(Ie) { return asciiAlpha(Ie) ? (xe.consume(Ie), Ae += String.fromCharCode(Ie), Ce) : (Ae === "import" || Ae === "export") && Ie === 32 ? (xe.consume(Ie), we) : ve(Ie) } function we(Ie) { return Ie === null || markdownLineEnding(Ie) ? (xe.exit("mdxjsEsmData"), Be(Ie)) : (xe.consume(Ie), we) } function Be(Ie) { return Ie === null ? Re(Ie) : markdownLineEnding(Ie) ? xe.check(blankLineBefore, Re, De)(Ie) : (xe.enter("mdxjsEsmData"), we(Ie)) } function De(Ie) { return xe.enter("lineEnding"), xe.consume(Ie), xe.exit("lineEnding"), Be } function Re(Ie) {
			const Pe = eventsToAcorn(_e.events.slice(be), {
				acorn: pe, acornOptions: me, tokenTypes: ["mdxjsEsmData"], prefix: Ee.length > 0 ? "var " + Ee.join(",") + `
`: ""
			}); if (Pe.error) { if (Ie !== null && Pe.swallow) return De(Ie); const ke = new VFileMessage("Could not parse import/exports with acorn", { cause: Pe.error, place: { line: Pe.error.loc.line, column: Pe.error.loc.column + 1, offset: Pe.error.pos }, ruleId: "acorn", source: "micromark-extension-mdxjs-esm" }); throw ke.url = trouble + "#could-not-parse-importexports-with-acorn", ke } Ee.length > 0 && Pe.estree.body.shift(); let Ne = -1; for (; ++Ne < Pe.estree.body.length;) { const ke = Pe.estree.body[Ne]; if (!allowedAcornTypes.has(ke.type)) { const Oe = new VFileMessage("Unexpected `" + ke.type + "` in code: only import/exports are supported", { place: positionFromEstree(ke), ruleId: "non-esm", source: "micromark-extension-mdxjs-esm" }); throw Oe.url = trouble + "#unexpected-type-in-code-only-importexports-are-supported", Oe } if (ke.type === "ImportDeclaration" && !_e.interrupt) { let Oe = -1; for (; ++Oe < ke.specifiers.length;) { const Ue = ke.specifiers[Oe]; Ee.push(Ue.local.name) } } } return Object.assign(xe.exit("mdxjsEsm"), fe.addResult ? { estree: Pe.estree } : void 0), ye(Ie)
		}
	}
} function tokenizeNextBlank(fe, K, pe) { return me; function me(ge) { return fe.enter("lineEndingBlank"), fe.consume(ge), fe.exit("lineEndingBlank"), fe.attempt(blankLine, K, pe) } } const hasOwnProperty = {}.hasOwnProperty; function combineExtensions(fe) { const K = {}; let pe = -1; for (; ++pe < fe.length;)syntaxExtension(K, fe[pe]); return K } function syntaxExtension(fe, K) { let pe; for (pe in K) { const ge = (hasOwnProperty.call(fe, pe) ? fe[pe] : void 0) || (fe[pe] = {}), xe = K[pe]; let ye; if (xe) for (ye in xe) { hasOwnProperty.call(ge, ye) || (ge[ye] = []); const ve = xe[ye]; constructs(ge[ye], Array.isArray(ve) ? ve : ve ? [ve] : []) } } } function constructs(fe, K) { let pe = -1; const me = []; for (; ++pe < K.length;)(K[pe].add === "after" ? fe : me).push(K[pe]); splice(fe, 0, 0, me) } function mdxjs(fe) { const K = Object.assign({ acorn: acornExports.Parser.extend(acornJsx()), acornOptions: { ecmaVersion: 2024, sourceType: "module" }, addResult: !0 }, fe); return combineExtensions([mdxjsEsm(K), mdxExpression(K), mdxJsx(K), mdxMd()]) } const emptyOptions$3 = {}; function remarkMdx(fe) { const K = this, pe = fe || emptyOptions$3, me = K.data(), ge = me.micromarkExtensions || (me.micromarkExtensions = []), xe = me.fromMarkdownExtensions || (me.fromMarkdownExtensions = []), ye = me.toMarkdownExtensions || (me.toMarkdownExtensions = []); ge.push(mdxjs(pe)), xe.push(mdxFromMarkdown()), ye.push(mdxToMarkdown(pe)) } const emptyOptions$2 = {}; function toString$2(fe, K) { const pe = emptyOptions$2, me = typeof pe.includeImageAlt == "boolean" ? pe.includeImageAlt : !0, ge = typeof pe.includeHtml == "boolean" ? pe.includeHtml : !0; return one$1(fe, me, ge) } function one$1(fe, K, pe) { if (node(fe)) { if ("value" in fe) return fe.type === "html" && !pe ? "" : fe.value; if (K && "alt" in fe && fe.alt) return fe.alt; if ("children" in fe) return all$1(fe.children, K, pe) } return Array.isArray(fe) ? all$1(fe, K, pe) : "" } function all$1(fe, K, pe) { const me = []; let ge = -1; for (; ++ge < fe.length;)me[ge] = one$1(fe[ge], K, pe); return me.join("") } function node(fe) { return !!(fe && typeof fe == "object") } function decodeNumericCharacterReference(fe, K) { const pe = Number.parseInt(fe, K); return pe < 9 || pe === 11 || pe > 13 && pe < 32 || pe > 126 && pe < 160 || pe > 55295 && pe < 57344 || pe > 64975 && pe < 65008 || (pe & 65535) === 65535 || (pe & 65535) === 65534 || pe > 1114111 ? "" : String.fromCodePoint(pe) } function normalizeUri(fe) { const K = []; let pe = -1, me = 0, ge = 0; for (; ++pe < fe.length;) { const xe = fe.charCodeAt(pe); let ye = ""; if (xe === 37 && asciiAlphanumeric(fe.charCodeAt(pe + 1)) && asciiAlphanumeric(fe.charCodeAt(pe + 2))) ge = 2; else if (xe < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(xe)) || (ye = String.fromCharCode(xe)); else if (xe > 55295 && xe < 57344) { const ve = fe.charCodeAt(pe + 1); xe < 56320 && ve > 56319 && ve < 57344 ? (ye = String.fromCharCode(xe, ve), ge = 1) : ye = "" } else ye = String.fromCharCode(xe); ye && (K.push(fe.slice(me, pe), encodeURIComponent(ye)), me = pe + ge + 1, ye = ""), ge && (pe += ge, ge = 0) } return K.join("") + fe.slice(me) } const content = { tokenize: initializeContent }; function initializeContent(fe) { const K = fe.attempt(this.parser.constructs.contentInitial, me, ge); let pe; return K; function me(ve) { if (ve === null) { fe.consume(ve); return } return fe.enter("lineEnding"), fe.consume(ve), fe.exit("lineEnding"), factorySpace(fe, K, "linePrefix") } function ge(ve) { return fe.enter("paragraph"), xe(ve) } function xe(ve) { const _e = fe.enter("chunkText", { contentType: "text", previous: pe }); return pe && (pe.next = _e), pe = _e, ye(ve) } function ye(ve) { if (ve === null) { fe.exit("chunkText"), fe.exit("paragraph"), fe.consume(ve); return } return markdownLineEnding(ve) ? (fe.consume(ve), fe.exit("chunkText"), xe) : (fe.consume(ve), ye) } } const document$2 = { tokenize: initializeDocument }, containerConstruct = { tokenize: tokenizeContainer }; function initializeDocument(fe) { const K = this, pe = []; let me = 0, ge, xe, ye; return ve; function ve(Pe) { if (me < pe.length) { const Ne = pe[me]; return K.containerState = Ne[1], fe.attempt(Ne[0].continuation, _e, Ee)(Pe) } return Ee(Pe) } function _e(Pe) { if (me++, K.containerState._closeFlow) { K.containerState._closeFlow = void 0, ge && Ie(); const Ne = K.events.length; let ke = Ne, Oe; for (; ke--;)if (K.events[ke][0] === "exit" && K.events[ke][1].type === "chunkFlow") { Oe = K.events[ke][1].end; break } Re(me); let Ue = Ne; for (; Ue < K.events.length;)K.events[Ue][1].end = { ...Oe }, Ue++; return splice(K.events, ke + 1, 0, K.events.slice(Ne)), K.events.length = Ue, Ee(Pe) } return ve(Pe) } function Ee(Pe) { if (me === pe.length) { if (!ge) return Se(Pe); if (ge.currentConstruct && ge.currentConstruct.concrete) return we(Pe); K.interrupt = !!(ge.currentConstruct && !ge._gfmTableDynamicInterruptHack) } return K.containerState = {}, fe.check(containerConstruct, be, Ae)(Pe) } function be(Pe) { return ge && Ie(), Re(me), Se(Pe) } function Ae(Pe) { return K.parser.lazy[K.now().line] = me !== pe.length, ye = K.now().offset, we(Pe) } function Se(Pe) { return K.containerState = {}, fe.attempt(containerConstruct, Ce, we)(Pe) } function Ce(Pe) { return me++, pe.push([K.currentConstruct, K.containerState]), Se(Pe) } function we(Pe) { if (Pe === null) { ge && Ie(), Re(0), fe.consume(Pe); return } return ge = ge || K.parser.flow(K.now()), fe.enter("chunkFlow", { _tokenizer: ge, contentType: "flow", previous: xe }), Be(Pe) } function Be(Pe) { if (Pe === null) { De(fe.exit("chunkFlow"), !0), Re(0), fe.consume(Pe); return } return markdownLineEnding(Pe) ? (fe.consume(Pe), De(fe.exit("chunkFlow")), me = 0, K.interrupt = void 0, ve) : (fe.consume(Pe), Be) } function De(Pe, Ne) { const ke = K.sliceStream(Pe); if (Ne && ke.push(null), Pe.previous = xe, xe && (xe.next = Pe), xe = Pe, ge.defineSkip(Pe.start), ge.write(ke), K.parser.lazy[Pe.start.line]) { let Oe = ge.events.length; for (; Oe--;)if (ge.events[Oe][1].start.offset < ye && (!ge.events[Oe][1].end || ge.events[Oe][1].end.offset > ye)) return; const Ue = K.events.length; let He = Ue, Ge, ze; for (; He--;)if (K.events[He][0] === "exit" && K.events[He][1].type === "chunkFlow") { if (Ge) { ze = K.events[He][1].end; break } Ge = !0 } for (Re(me), Oe = Ue; Oe < K.events.length;)K.events[Oe][1].end = { ...ze }, Oe++; splice(K.events, He + 1, 0, K.events.slice(Ue)), K.events.length = Oe } } function Re(Pe) { let Ne = pe.length; for (; Ne-- > Pe;) { const ke = pe[Ne]; K.containerState = ke[1], ke[0].exit.call(K, fe) } pe.length = Pe } function Ie() { ge.write([null]), xe = void 0, ge = void 0, K.containerState._closeFlow = void 0 } } function tokenizeContainer(fe, K, pe) { return factorySpace(fe, fe.attempt(this.parser.constructs.document, K, pe), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } const flow$1 = { tokenize: initializeFlow }; function initializeFlow(fe) { const K = this, pe = fe.attempt(blankLine, me, fe.attempt(this.parser.constructs.flowInitial, ge, factorySpace(fe, fe.attempt(this.parser.constructs.flow, ge, fe.attempt(content$1, ge)), "linePrefix"))); return pe; function me(xe) { if (xe === null) { fe.consume(xe); return } return fe.enter("lineEndingBlank"), fe.consume(xe), fe.exit("lineEndingBlank"), K.currentConstruct = void 0, pe } function ge(xe) { if (xe === null) { fe.consume(xe); return } return fe.enter("lineEnding"), fe.consume(xe), fe.exit("lineEnding"), K.currentConstruct = void 0, pe } } const resolver = { resolveAll: createResolver() }, string$1 = initializeFactory("string"), text$4 = initializeFactory("text"); function initializeFactory(fe) { return { resolveAll: createResolver(fe === "text" ? resolveAllLineSuffixes : void 0), tokenize: K }; function K(pe) { const me = this, ge = this.parser.constructs[fe], xe = pe.attempt(ge, ye, ve); return ye; function ye(be) { return Ee(be) ? xe(be) : ve(be) } function ve(be) { if (be === null) { pe.consume(be); return } return pe.enter("data"), pe.consume(be), _e } function _e(be) { return Ee(be) ? (pe.exit("data"), xe(be)) : (pe.consume(be), _e) } function Ee(be) { if (be === null) return !0; const Ae = ge[be]; let Se = -1; if (Ae) for (; ++Se < Ae.length;) { const Ce = Ae[Se]; if (!Ce.previous || Ce.previous.call(me, me.previous)) return !0 } return !1 } } } function createResolver(fe) { return K; function K(pe, me) { let ge = -1, xe; for (; ++ge <= pe.length;)xe === void 0 ? pe[ge] && pe[ge][1].type === "data" && (xe = ge, ge++) : (!pe[ge] || pe[ge][1].type !== "data") && (ge !== xe + 2 && (pe[xe][1].end = pe[ge - 1][1].end, pe.splice(xe + 2, ge - xe - 2), ge = xe + 2), xe = void 0); return fe ? fe(pe, me) : pe } } function resolveAllLineSuffixes(fe, K) { let pe = 0; for (; ++pe <= fe.length;)if ((pe === fe.length || fe[pe][1].type === "lineEnding") && fe[pe - 1][1].type === "data") { const me = fe[pe - 1][1], ge = K.sliceStream(me); let xe = ge.length, ye = -1, ve = 0, _e; for (; xe--;) { const Ee = ge[xe]; if (typeof Ee == "string") { for (ye = Ee.length; Ee.charCodeAt(ye - 1) === 32;)ve++, ye--; if (ye) break; ye = -1 } else if (Ee === -2) _e = !0, ve++; else if (Ee !== -1) { xe++; break } } if (K._contentTypeTextTrailing && pe === fe.length && (ve = 0), ve) { const Ee = { type: pe === fe.length || _e || ve < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: xe ? ye : me.start._bufferIndex + ye, _index: me.start._index + xe, line: me.end.line, column: me.end.column - ve, offset: me.end.offset - ve }, end: { ...me.end } }; me.end = { ...Ee.start }, me.start.offset === me.end.offset ? Object.assign(me, Ee) : (fe.splice(pe, 0, ["enter", Ee, K], ["exit", Ee, K]), pe += 2) } pe++ } return fe } const document$1 = { 42: list$2, 43: list$2, 45: list$2, 48: list$2, 49: list$2, 50: list$2, 51: list$2, 52: list$2, 53: list$2, 54: list$2, 55: list$2, 56: list$2, 57: list$2, 62: blockQuote }, contentInitial = { 91: definition$1 }, flowInitial = { [-2]: codeIndented, [-1]: codeIndented, 32: codeIndented }, flow = { 35: headingAtx, 42: thematicBreak$2, 45: [setextUnderline, thematicBreak$2], 60: htmlFlow, 61: setextUnderline, 95: thematicBreak$2, 96: codeFenced, 126: codeFenced }, string = { 38: characterReference, 92: characterEscape }, text$3 = { [-5]: lineEnding, [-4]: lineEnding, [-3]: lineEnding, 33: labelStartImage, 38: characterReference, 42: attention, 60: [autolink, htmlText], 91: labelStartLink, 92: [hardBreakEscape, characterEscape], 93: labelEnd, 95: attention, 96: codeText }, insideSpan = { null: [attention, resolver] }, attentionMarkers = { null: [42, 95] }, disable = { null: [] }, defaultConstructs = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers, contentInitial, disable, document: document$1, flow, flowInitial, insideSpan, string, text: text$3 }, Symbol.toStringTag, { value: "Module" })); function createTokenizer(fe, K, pe) { let me = { _bufferIndex: -1, _index: 0, line: pe && pe.line || 1, column: pe && pe.column || 1, offset: pe && pe.offset || 0 }; const ge = {}, xe = []; let ye = [], ve = []; const _e = { attempt: Ue(ke), check: Ue(Oe), consume: Ie, enter: Pe, exit: Ne, interrupt: Ue(Oe, { interrupt: !0 }) }, Ee = { code: null, containerState: {}, defineSkip: Be, events: [], now: we, parser: fe, previous: null, sliceSerialize: Se, sliceStream: Ce, write: Ae }; let be = K.tokenize.call(Ee, _e); return K.resolveAll && xe.push(K), Ee; function Ae(We) { return ye = push(ye, We), De(), ye[ye.length - 1] !== null ? [] : (He(K, 0), Ee.events = resolveAll(xe, Ee.events, Ee), Ee.events) } function Se(We, Xe) { return serializeChunks(Ce(We), Xe) } function Ce(We) { return sliceChunks(ye, We) } function we() { const { _bufferIndex: We, _index: Xe, line: Ye, column: Ze, offset: ot } = me; return { _bufferIndex: We, _index: Xe, line: Ye, column: Ze, offset: ot } } function Be(We) { ge[We.line] = We.column, ze() } function De() { let We; for (; me._index < ye.length;) { const Xe = ye[me._index]; if (typeof Xe == "string") for (We = me._index, me._bufferIndex < 0 && (me._bufferIndex = 0); me._index === We && me._bufferIndex < Xe.length;)Re(Xe.charCodeAt(me._bufferIndex)); else Re(Xe) } } function Re(We) { be = be(We) } function Ie(We) { markdownLineEnding(We) ? (me.line++, me.column = 1, me.offset += We === -3 ? 2 : 1, ze()) : We !== -1 && (me.column++, me.offset++), me._bufferIndex < 0 ? me._index++ : (me._bufferIndex++, me._bufferIndex === ye[me._index].length && (me._bufferIndex = -1, me._index++)), Ee.previous = We } function Pe(We, Xe) { const Ye = Xe || {}; return Ye.type = We, Ye.start = we(), Ee.events.push(["enter", Ye, Ee]), ve.push(Ye), Ye } function Ne(We) { const Xe = ve.pop(); return Xe.end = we(), Ee.events.push(["exit", Xe, Ee]), Xe } function ke(We, Xe) { He(We, Xe.from) } function Oe(We, Xe) { Xe.restore() } function Ue(We, Xe) { return Ye; function Ye(Ze, ot, qe) { let Qe, st, Nt, Je; return Array.isArray(Ze) ? Xt(Ze) : "tokenize" in Ze ? Xt([Ze]) : jt(Ze); function jt(an) { return gn; function gn(Mn) { const Xn = Mn !== null && an[Mn], Ln = Mn !== null && an.null, Gn = [...Array.isArray(Xn) ? Xn : Xn ? [Xn] : [], ...Array.isArray(Ln) ? Ln : Ln ? [Ln] : []]; return Xt(Gn)(Mn) } } function Xt(an) { return Qe = an, st = 0, an.length === 0 ? qe : ct(an[st]) } function ct(an) { return gn; function gn(Mn) { return Je = Ge(), Nt = an, an.partial || (Ee.currentConstruct = an), an.name && Ee.parser.constructs.disable.null.includes(an.name) ? $t() : an.tokenize.call(Xe ? Object.assign(Object.create(Ee), Xe) : Ee, _e, nn, $t)(Mn) } } function nn(an) { return We(Nt, Je), ot } function $t(an) { return Je.restore(), ++st < Qe.length ? ct(Qe[st]) : qe } } } function He(We, Xe) { We.resolveAll && !xe.includes(We) && xe.push(We), We.resolve && splice(Ee.events, Xe, Ee.events.length - Xe, We.resolve(Ee.events.slice(Xe), Ee)), We.resolveTo && (Ee.events = We.resolveTo(Ee.events, Ee)) } function Ge() { const We = we(), Xe = Ee.previous, Ye = Ee.currentConstruct, Ze = Ee.events.length, ot = Array.from(ve); return { from: Ze, restore: qe }; function qe() { me = We, Ee.previous = Xe, Ee.currentConstruct = Ye, Ee.events.length = Ze, ve = ot, ze() } } function ze() { me.line in ge && me.column < 2 && (me.column = ge[me.line], me.offset += ge[me.line] - 1) } } function sliceChunks(fe, K) { const pe = K.start._index, me = K.start._bufferIndex, ge = K.end._index, xe = K.end._bufferIndex; let ye; if (pe === ge) ye = [fe[pe].slice(me, xe)]; else { if (ye = fe.slice(pe, ge), me > -1) { const ve = ye[0]; typeof ve == "string" ? ye[0] = ve.slice(me) : ye.shift() } xe > 0 && ye.push(fe[ge].slice(0, xe)) } return ye } function serializeChunks(fe, K) {
	let pe = -1; const me = []; let ge; for (; ++pe < fe.length;) {
		const xe = fe[pe]; let ye; if (typeof xe == "string") ye = xe; else switch (xe) {
			case -5: { ye = "\r"; break } case -4: {
				ye = `
`; break
			} case -3: {
				ye = `\r
`; break
			} case -2: { ye = K ? " " : "	"; break } case -1: { if (!K && ge) continue; ye = " "; break } default: ye = String.fromCharCode(xe)
		}ge = xe === -2, me.push(ye)
	} return me.join("")
} function parse(fe) { const me = { constructs: combineExtensions([defaultConstructs, ...(fe || {}).extensions || []]), content: ge(content), defined: [], document: ge(document$2), flow: ge(flow$1), lazy: {}, string: ge(string$1), text: ge(text$4) }; return me; function ge(xe) { return ye; function ye(ve) { return createTokenizer(me, xe, ve) } } } function postprocess(fe) { for (; !subtokenize(fe);); return fe } const search = /[\0\t\n\r]/g; function preprocess() { let fe = 1, K = "", pe = !0, me; return ge; function ge(xe, ye, ve) { const _e = []; let Ee, be, Ae, Se, Ce; for (xe = K + (typeof xe == "string" ? xe.toString() : new TextDecoder(ye || void 0).decode(xe)), Ae = 0, K = "", pe && (xe.charCodeAt(0) === 65279 && Ae++, pe = void 0); Ae < xe.length;) { if (search.lastIndex = Ae, Ee = search.exec(xe), Se = Ee && Ee.index !== void 0 ? Ee.index : xe.length, Ce = xe.charCodeAt(Se), !Ee) { K = xe.slice(Ae); break } if (Ce === 10 && Ae === Se && me) _e.push(-3), me = void 0; else switch (me && (_e.push(-5), me = void 0), Ae < Se && (_e.push(xe.slice(Ae, Se)), fe += Se - Ae), Ce) { case 0: { _e.push(65533), fe++; break } case 9: { for (be = Math.ceil(fe / 4) * 4, _e.push(-2); fe++ < be;)_e.push(-1); break } case 10: { _e.push(-4), fe = 1; break } default: me = !0, fe = 1 }Ae = Se + 1 } return ve && (me && _e.push(-5), K && _e.push(K), _e.push(null)), _e } } const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function decodeString(fe) { return fe.replace(characterEscapeOrReference, decode$1) } function decode$1(fe, K, pe) { if (K) return K; if (pe.charCodeAt(0) === 35) { const ge = pe.charCodeAt(1), xe = ge === 120 || ge === 88; return decodeNumericCharacterReference(pe.slice(xe ? 2 : 1), xe ? 16 : 10) } return decodeNamedCharacterReference(pe) || fe } const own$2 = {}.hasOwnProperty; function fromMarkdown(fe, K, pe) { return typeof K != "string" && (pe = K, K = void 0), compiler(pe)(postprocess(parse(pe).document().write(preprocess()(fe, K, !0)))) } function compiler(fe) { const K = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: xe(Hn), autolinkProtocol: Ge, autolinkEmail: Ge, atxHeading: xe(nr), blockQuote: xe(Ln), characterEscape: Ge, characterReference: Ge, codeFenced: xe(Gn), codeFencedFenceInfo: ye, codeFencedFenceMeta: ye, codeIndented: xe(Gn, ye), codeText: xe(wn, ye), codeTextData: Ge, data: Ge, codeFlowValue: Ge, definition: xe(Bn), definitionDestinationString: ye, definitionLabelString: ye, definitionTitleString: ye, emphasis: xe(Gt), hardBreakEscape: xe(Kn), hardBreakTrailing: xe(Kn), htmlFlow: xe(vn, ye), htmlFlowData: Ge, htmlText: xe(vn, ye), htmlTextData: Ge, image: xe(yn), label: ye, link: xe(Hn), listItem: xe(Ht), listItemValue: Se, listOrdered: xe(kn, Ae), listUnordered: xe(kn), paragraph: xe(Dt), reference: ct, referenceString: ye, resourceDestinationString: ye, resourceTitleString: ye, setextHeading: xe(nr), strong: xe(fn), thematicBreak: xe(cn) }, exit: { atxHeading: _e(), atxHeadingSequence: ke, autolink: _e(), autolinkEmail: Xn, autolinkProtocol: Mn, blockQuote: _e(), characterEscapeValue: ze, characterReferenceMarkerHexadecimal: $t, characterReferenceMarkerNumeric: $t, characterReferenceValue: an, characterReference: gn, codeFenced: _e(De), codeFencedFence: Be, codeFencedFenceInfo: Ce, codeFencedFenceMeta: we, codeFlowValue: ze, codeIndented: _e(Re), codeText: _e(ot), codeTextData: ze, data: ze, definition: _e(), definitionDestinationString: Ne, definitionLabelString: Ie, definitionTitleString: Pe, emphasis: _e(), hardBreakEscape: _e(Xe), hardBreakTrailing: _e(Xe), htmlFlow: _e(Ye), htmlFlowData: ze, htmlText: _e(Ze), htmlTextData: ze, image: _e(Qe), label: Nt, labelText: st, lineEnding: We, link: _e(qe), listItem: _e(), listOrdered: _e(), listUnordered: _e(), paragraph: _e(), referenceString: nn, resourceDestinationString: Je, resourceTitleString: jt, resource: Xt, setextHeading: _e(He), setextHeadingLineSequence: Ue, setextHeadingText: Oe, strong: _e(), thematicBreak: _e() } }; configure(K, (fe || {}).mdastExtensions || []); const pe = {}; return me; function me(Wt) { let un = { type: "root", children: [] }; const Ft = { stack: [un], tokenStack: [], config: K, enter: ve, exit: Ee, buffer: ye, resume: be, data: pe }, Sn = []; let lr = -1; for (; ++lr < Wt.length;)if (Wt[lr][1].type === "listOrdered" || Wt[lr][1].type === "listUnordered") if (Wt[lr][0] === "enter") Sn.push(lr); else { const jn = Sn.pop(); lr = ge(Wt, jn, lr) } for (lr = -1; ++lr < Wt.length;) { const jn = K[Wt[lr][0]]; own$2.call(jn, Wt[lr][1].type) && jn[Wt[lr][1].type].call(Object.assign({ sliceSerialize: Wt[lr][2].sliceSerialize }, Ft), Wt[lr][1]) } if (Ft.tokenStack.length > 0) { const jn = Ft.tokenStack[Ft.tokenStack.length - 1]; (jn[1] || defaultOnError).call(Ft, void 0, jn[0]) } for (un.position = { start: point(Wt.length > 0 ? Wt[0][1].start : { line: 1, column: 1, offset: 0 }), end: point(Wt.length > 0 ? Wt[Wt.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, lr = -1; ++lr < K.transforms.length;)un = K.transforms[lr](un) || un; return un } function ge(Wt, un, Ft) { let Sn = un - 1, lr = -1, jn = !1, Pn, fr, Yn, sr; for (; ++Sn <= Ft;) { const Ar = Wt[Sn]; switch (Ar[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { Ar[0] === "enter" ? lr++ : lr--, sr = void 0; break } case "lineEndingBlank": { Ar[0] === "enter" && (Pn && !sr && !lr && !Yn && (Yn = Sn), sr = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: sr = void 0 }if (!lr && Ar[0] === "enter" && Ar[1].type === "listItemPrefix" || lr === -1 && Ar[0] === "exit" && (Ar[1].type === "listUnordered" || Ar[1].type === "listOrdered")) { if (Pn) { let Er = Sn; for (fr = void 0; Er--;) { const Rr = Wt[Er]; if (Rr[1].type === "lineEnding" || Rr[1].type === "lineEndingBlank") { if (Rr[0] === "exit") continue; fr && (Wt[fr][1].type = "lineEndingBlank", jn = !0), Rr[1].type = "lineEnding", fr = Er } else if (!(Rr[1].type === "linePrefix" || Rr[1].type === "blockQuotePrefix" || Rr[1].type === "blockQuotePrefixWhitespace" || Rr[1].type === "blockQuoteMarker" || Rr[1].type === "listItemIndent")) break } Yn && (!fr || Yn < fr) && (Pn._spread = !0), Pn.end = Object.assign({}, fr ? Wt[fr][1].start : Ar[1].end), Wt.splice(fr || Sn, 0, ["exit", Pn, Ar[2]]), Sn++, Ft++ } if (Ar[1].type === "listItemPrefix") { const Er = { type: "listItem", _spread: !1, start: Object.assign({}, Ar[1].start), end: void 0 }; Pn = Er, Wt.splice(Sn, 0, ["enter", Er, Ar[2]]), Sn++, Ft++, Yn = void 0, sr = !0 } } } return Wt[un][1]._spread = jn, Ft } function xe(Wt, un) { return Ft; function Ft(Sn) { ve.call(this, Wt(Sn), Sn), un && un.call(this, Sn) } } function ye() { this.stack.push({ type: "fragment", children: [] }) } function ve(Wt, un, Ft) { this.stack[this.stack.length - 1].children.push(Wt), this.stack.push(Wt), this.tokenStack.push([un, Ft || void 0]), Wt.position = { start: point(un.start), end: void 0 } } function _e(Wt) { return un; function un(Ft) { Wt && Wt.call(this, Ft), Ee.call(this, Ft) } } function Ee(Wt, un) { const Ft = this.stack.pop(), Sn = this.tokenStack.pop(); if (Sn) Sn[0].type !== Wt.type && (un ? un.call(this, Wt, Sn[0]) : (Sn[1] || defaultOnError).call(this, Wt, Sn[0])); else throw new Error("Cannot close `" + Wt.type + "` (" + stringifyPosition({ start: Wt.start, end: Wt.end }) + "): its not open"); Ft.position.end = point(Wt.end) } function be() { return toString$2(this.stack.pop()) } function Ae() { this.data.expectingFirstListItemValue = !0 } function Se(Wt) { if (this.data.expectingFirstListItemValue) { const un = this.stack[this.stack.length - 2]; un.start = Number.parseInt(this.sliceSerialize(Wt), 10), this.data.expectingFirstListItemValue = void 0 } } function Ce() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.lang = Wt } function we() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.meta = Wt } function Be() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function De() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.value = Wt.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function Re() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.value = Wt.replace(/(\r?\n|\r)$/g, "") } function Ie(Wt) { const un = this.resume(), Ft = this.stack[this.stack.length - 1]; Ft.label = un, Ft.identifier = normalizeIdentifier(this.sliceSerialize(Wt)).toLowerCase() } function Pe() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.title = Wt } function Ne() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.url = Wt } function ke(Wt) { const un = this.stack[this.stack.length - 1]; if (!un.depth) { const Ft = this.sliceSerialize(Wt).length; un.depth = Ft } } function Oe() { this.data.setextHeadingSlurpLineEnding = !0 } function Ue(Wt) { const un = this.stack[this.stack.length - 1]; un.depth = this.sliceSerialize(Wt).codePointAt(0) === 61 ? 1 : 2 } function He() { this.data.setextHeadingSlurpLineEnding = void 0 } function Ge(Wt) { const Ft = this.stack[this.stack.length - 1].children; let Sn = Ft[Ft.length - 1]; (!Sn || Sn.type !== "text") && (Sn = en(), Sn.position = { start: point(Wt.start), end: void 0 }, Ft.push(Sn)), this.stack.push(Sn) } function ze(Wt) { const un = this.stack.pop(); un.value += this.sliceSerialize(Wt), un.position.end = point(Wt.end) } function We(Wt) { const un = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { const Ft = un.children[un.children.length - 1]; Ft.position.end = point(Wt.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && K.canContainEols.includes(un.type) && (Ge.call(this, Wt), ze.call(this, Wt)) } function Xe() { this.data.atHardBreak = !0 } function Ye() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.value = Wt } function Ze() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.value = Wt } function ot() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.value = Wt } function qe() { const Wt = this.stack[this.stack.length - 1]; if (this.data.inReference) { const un = this.data.referenceType || "shortcut"; Wt.type += "Reference", Wt.referenceType = un, delete Wt.url, delete Wt.title } else delete Wt.identifier, delete Wt.label; this.data.referenceType = void 0 } function Qe() { const Wt = this.stack[this.stack.length - 1]; if (this.data.inReference) { const un = this.data.referenceType || "shortcut"; Wt.type += "Reference", Wt.referenceType = un, delete Wt.url, delete Wt.title } else delete Wt.identifier, delete Wt.label; this.data.referenceType = void 0 } function st(Wt) { const un = this.sliceSerialize(Wt), Ft = this.stack[this.stack.length - 2]; Ft.label = decodeString(un), Ft.identifier = normalizeIdentifier(un).toLowerCase() } function Nt() { const Wt = this.stack[this.stack.length - 1], un = this.resume(), Ft = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, Ft.type === "link") { const Sn = Wt.children; Ft.children = Sn } else Ft.alt = un } function Je() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.url = Wt } function jt() { const Wt = this.resume(), un = this.stack[this.stack.length - 1]; un.title = Wt } function Xt() { this.data.inReference = void 0 } function ct() { this.data.referenceType = "collapsed" } function nn(Wt) { const un = this.resume(), Ft = this.stack[this.stack.length - 1]; Ft.label = un, Ft.identifier = normalizeIdentifier(this.sliceSerialize(Wt)).toLowerCase(), this.data.referenceType = "full" } function $t(Wt) { this.data.characterReferenceType = Wt.type } function an(Wt) { const un = this.sliceSerialize(Wt), Ft = this.data.characterReferenceType; let Sn; Ft ? (Sn = decodeNumericCharacterReference(un, Ft === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Sn = decodeNamedCharacterReference(un); const lr = this.stack[this.stack.length - 1]; lr.value += Sn } function gn(Wt) { const un = this.stack.pop(); un.position.end = point(Wt.end) } function Mn(Wt) { ze.call(this, Wt); const un = this.stack[this.stack.length - 1]; un.url = this.sliceSerialize(Wt) } function Xn(Wt) { ze.call(this, Wt); const un = this.stack[this.stack.length - 1]; un.url = "mailto:" + this.sliceSerialize(Wt) } function Ln() { return { type: "blockquote", children: [] } } function Gn() { return { type: "code", lang: null, meta: null, value: "" } } function wn() { return { type: "inlineCode", value: "" } } function Bn() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function Gt() { return { type: "emphasis", children: [] } } function nr() { return { type: "heading", depth: 0, children: [] } } function Kn() { return { type: "break" } } function vn() { return { type: "html", value: "" } } function yn() { return { type: "image", title: null, url: "", alt: null } } function Hn() { return { type: "link", title: null, url: "", children: [] } } function kn(Wt) { return { type: "list", ordered: Wt.type === "listOrdered", start: null, spread: Wt._spread, children: [] } } function Ht(Wt) { return { type: "listItem", spread: Wt._spread, checked: null, children: [] } } function Dt() { return { type: "paragraph", children: [] } } function fn() { return { type: "strong", children: [] } } function en() { return { type: "text", value: "" } } function cn() { return { type: "thematicBreak" } } } function point(fe) { return { line: fe.line, column: fe.column, offset: fe.offset } } function configure(fe, K) { let pe = -1; for (; ++pe < K.length;) { const me = K[pe]; Array.isArray(me) ? configure(fe, me) : extension(fe, me) } } function extension(fe, K) { let pe; for (pe in K) if (own$2.call(K, pe)) switch (pe) { case "canContainEols": { const me = K[pe]; me && fe[pe].push(...me); break } case "transforms": { const me = K[pe]; me && fe[pe].push(...me); break } case "enter": case "exit": { const me = K[pe]; me && Object.assign(fe[pe], me); break } } } function defaultOnError(fe, K) { throw fe ? new Error("Cannot close `" + fe.type + "` (" + stringifyPosition({ start: fe.start, end: fe.end }) + "): a different token (`" + K.type + "`, " + stringifyPosition({ start: K.start, end: K.end }) + ") is open") : new Error("Cannot close document, a token (`" + K.type + "`, " + stringifyPosition({ start: K.start, end: K.end }) + ") is still open") } function remarkParse(fe) { const K = this; K.parser = pe; function pe(me) { return fromMarkdown(me, { ...K.data("settings"), ...fe, extensions: K.data("micromarkExtensions") || [], mdastExtensions: K.data("fromMarkdownExtensions") || [] }) } } function blockquote$1(fe, K) { const pe = { type: "element", tagName: "blockquote", properties: {}, children: fe.wrap(fe.all(K), !0) }; return fe.patch(K, pe), fe.applyData(K, pe) } function hardBreak$1(fe, K) {
	const pe = { type: "element", tagName: "br", properties: {}, children: [] }; return fe.patch(K, pe), [fe.applyData(K, pe), {
		type: "text", value: `
`}]
} function code$2(fe, K) {
	const pe = K.value ? K.value + `
`: "", me = {}; K.lang && (me.className = ["language-" + K.lang]); let ge = { type: "element", tagName: "code", properties: me, children: [{ type: "text", value: pe }] }; return K.meta && (ge.data = { meta: K.meta }), fe.patch(K, ge), ge = fe.applyData(K, ge), ge = { type: "element", tagName: "pre", properties: {}, children: [ge] }, fe.patch(K, ge), ge
} function strikethrough(fe, K) { const pe = { type: "element", tagName: "del", properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } function emphasis$1(fe, K) { const pe = { type: "element", tagName: "em", properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } function footnoteReference$1(fe, K) { const pe = typeof fe.options.clobberPrefix == "string" ? fe.options.clobberPrefix : "user-content-", me = String(K.identifier).toUpperCase(), ge = normalizeUri(me.toLowerCase()), xe = fe.footnoteOrder.indexOf(me); let ye, ve = fe.footnoteCounts.get(me); ve === void 0 ? (ve = 0, fe.footnoteOrder.push(me), ye = fe.footnoteOrder.length) : ye = xe + 1, ve += 1, fe.footnoteCounts.set(me, ve); const _e = { type: "element", tagName: "a", properties: { href: "#" + pe + "fn-" + ge, id: pe + "fnref-" + ge + (ve > 1 ? "-" + ve : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(ye) }] }; fe.patch(K, _e); const Ee = { type: "element", tagName: "sup", properties: {}, children: [_e] }; return fe.patch(K, Ee), fe.applyData(K, Ee) } function heading$1(fe, K) { const pe = { type: "element", tagName: "h" + K.depth, properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } function html$2(fe, K) { if (fe.options.allowDangerousHtml) { const pe = { type: "raw", value: K.value }; return fe.patch(K, pe), fe.applyData(K, pe) } } function revert(fe, K) { const pe = K.referenceType; let me = "]"; if (pe === "collapsed" ? me += "[]" : pe === "full" && (me += "[" + (K.label || K.identifier) + "]"), K.type === "imageReference") return [{ type: "text", value: "![" + K.alt + me }]; const ge = fe.all(K), xe = ge[0]; xe && xe.type === "text" ? xe.value = "[" + xe.value : ge.unshift({ type: "text", value: "[" }); const ye = ge[ge.length - 1]; return ye && ye.type === "text" ? ye.value += me : ge.push({ type: "text", value: me }), ge } function imageReference$1(fe, K) { const pe = String(K.identifier).toUpperCase(), me = fe.definitionById.get(pe); if (!me) return revert(fe, K); const ge = { src: normalizeUri(me.url || ""), alt: K.alt }; me.title !== null && me.title !== void 0 && (ge.title = me.title); const xe = { type: "element", tagName: "img", properties: ge, children: [] }; return fe.patch(K, xe), fe.applyData(K, xe) } function image$1(fe, K) { const pe = { src: normalizeUri(K.url) }; K.alt !== null && K.alt !== void 0 && (pe.alt = K.alt), K.title !== null && K.title !== void 0 && (pe.title = K.title); const me = { type: "element", tagName: "img", properties: pe, children: [] }; return fe.patch(K, me), fe.applyData(K, me) } function inlineCode$1(fe, K) { const pe = { type: "text", value: K.value.replace(/\r?\n|\r/g, " ") }; fe.patch(K, pe); const me = { type: "element", tagName: "code", properties: {}, children: [pe] }; return fe.patch(K, me), fe.applyData(K, me) } function linkReference$1(fe, K) { const pe = String(K.identifier).toUpperCase(), me = fe.definitionById.get(pe); if (!me) return revert(fe, K); const ge = { href: normalizeUri(me.url || "") }; me.title !== null && me.title !== void 0 && (ge.title = me.title); const xe = { type: "element", tagName: "a", properties: ge, children: fe.all(K) }; return fe.patch(K, xe), fe.applyData(K, xe) } function link$1(fe, K) { const pe = { href: normalizeUri(K.url) }; K.title !== null && K.title !== void 0 && (pe.title = K.title); const me = { type: "element", tagName: "a", properties: pe, children: fe.all(K) }; return fe.patch(K, me), fe.applyData(K, me) } function listItem$1(fe, K, pe) {
	const me = fe.all(K), ge = pe ? listLoose(pe) : listItemLoose(K), xe = {}, ye = []; if (typeof K.checked == "boolean") { const be = me[0]; let Ae; be && be.type === "element" && be.tagName === "p" ? Ae = be : (Ae = { type: "element", tagName: "p", properties: {}, children: [] }, me.unshift(Ae)), Ae.children.length > 0 && Ae.children.unshift({ type: "text", value: " " }), Ae.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: K.checked, disabled: !0 }, children: [] }), xe.className = ["task-list-item"] } let ve = -1; for (; ++ve < me.length;) {
		const be = me[ve]; (ge || ve !== 0 || be.type !== "element" || be.tagName !== "p") && ye.push({
			type: "text", value: `
`}), be.type === "element" && be.tagName === "p" && !ge ? ye.push(...be.children) : ye.push(be)
	} const _e = me[me.length - 1]; _e && (ge || _e.type !== "element" || _e.tagName !== "p") && ye.push({
		type: "text", value: `
`}); const Ee = { type: "element", tagName: "li", properties: xe, children: ye }; return fe.patch(K, Ee), fe.applyData(K, Ee)
} function listLoose(fe) { let K = !1; if (fe.type === "list") { K = fe.spread || !1; const pe = fe.children; let me = -1; for (; !K && ++me < pe.length;)K = listItemLoose(pe[me]) } return K } function listItemLoose(fe) { const K = fe.spread; return K ?? fe.children.length > 1 } function list$1(fe, K) { const pe = {}, me = fe.all(K); let ge = -1; for (typeof K.start == "number" && K.start !== 1 && (pe.start = K.start); ++ge < me.length;) { const ye = me[ge]; if (ye.type === "element" && ye.tagName === "li" && ye.properties && Array.isArray(ye.properties.className) && ye.properties.className.includes("task-list-item")) { pe.className = ["contains-task-list"]; break } } const xe = { type: "element", tagName: K.ordered ? "ol" : "ul", properties: pe, children: fe.wrap(me, !0) }; return fe.patch(K, xe), fe.applyData(K, xe) } function paragraph$1(fe, K) { const pe = { type: "element", tagName: "p", properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } function root$1(fe, K) { const pe = { type: "root", children: fe.wrap(fe.all(K)) }; return fe.patch(K, pe), fe.applyData(K, pe) } function strong$1(fe, K) { const pe = { type: "element", tagName: "strong", properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } function table(fe, K) { const pe = fe.all(K), me = pe.shift(), ge = []; if (me) { const ye = { type: "element", tagName: "thead", properties: {}, children: fe.wrap([me], !0) }; fe.patch(K.children[0], ye), ge.push(ye) } if (pe.length > 0) { const ye = { type: "element", tagName: "tbody", properties: {}, children: fe.wrap(pe, !0) }, ve = pointStart(K.children[1]), _e = pointEnd(K.children[K.children.length - 1]); ve && _e && (ye.position = { start: ve, end: _e }), ge.push(ye) } const xe = { type: "element", tagName: "table", properties: {}, children: fe.wrap(ge, !0) }; return fe.patch(K, xe), fe.applyData(K, xe) } function tableRow$1(fe, K, pe) { const me = pe ? pe.children : void 0, xe = (me ? me.indexOf(K) : 1) === 0 ? "th" : "td", ye = pe && pe.type === "table" ? pe.align : void 0, ve = ye ? ye.length : K.children.length; let _e = -1; const Ee = []; for (; ++_e < ve;) { const Ae = K.children[_e], Se = {}, Ce = ye ? ye[_e] : void 0; Ce && (Se.align = Ce); let we = { type: "element", tagName: xe, properties: Se, children: [] }; Ae && (we.children = fe.all(Ae), fe.patch(Ae, we), we = fe.applyData(Ae, we)), Ee.push(we) } const be = { type: "element", tagName: "tr", properties: {}, children: fe.wrap(Ee, !0) }; return fe.patch(K, be), fe.applyData(K, be) } function tableCell(fe, K) { const pe = { type: "element", tagName: "td", properties: {}, children: fe.all(K) }; return fe.patch(K, pe), fe.applyData(K, pe) } const tab = 9, space = 32; function trimLines(fe) { const K = String(fe), pe = /\r?\n|\r/g; let me = pe.exec(K), ge = 0; const xe = []; for (; me;)xe.push(trimLine(K.slice(ge, me.index), ge > 0, !0), me[0]), ge = me.index + me[0].length, me = pe.exec(K); return xe.push(trimLine(K.slice(ge), ge > 0, !1)), xe.join("") } function trimLine(fe, K, pe) { let me = 0, ge = fe.length; if (K) { let xe = fe.codePointAt(me); for (; xe === tab || xe === space;)me++, xe = fe.codePointAt(me) } if (pe) { let xe = fe.codePointAt(ge - 1); for (; xe === tab || xe === space;)ge--, xe = fe.codePointAt(ge - 1) } return ge > me ? fe.slice(me, ge) : "" } function text$2(fe, K) { const pe = { type: "text", value: trimLines(String(K.value)) }; return fe.patch(K, pe), fe.applyData(K, pe) } function thematicBreak$1(fe, K) { const pe = { type: "element", tagName: "hr", properties: {}, children: [] }; return fe.patch(K, pe), fe.applyData(K, pe) } const handlers = { blockquote: blockquote$1, break: hardBreak$1, code: code$2, delete: strikethrough, emphasis: emphasis$1, footnoteReference: footnoteReference$1, heading: heading$1, html: html$2, imageReference: imageReference$1, image: image$1, inlineCode: inlineCode$1, linkReference: linkReference$1, link: link$1, listItem: listItem$1, list: list$1, paragraph: paragraph$1, root: root$1, strong: strong$1, table, tableCell, tableRow: tableRow$1, text: text$2, thematicBreak: thematicBreak$1, toml: ignore, yaml: ignore, definition: ignore, footnoteDefinition: ignore }; function ignore() { } const VOID = -1, PRIMITIVE = 0, ARRAY = 1, OBJECT = 2, DATE = 3, REGEXP = 4, MAP = 5, SET = 6, ERROR = 7, BIGINT = 8, env = typeof self == "object" ? self : globalThis, deserializer = (fe, K) => { const pe = (ge, xe) => (fe.set(xe, ge), ge), me = ge => { if (fe.has(ge)) return fe.get(ge); const [xe, ye] = K[ge]; switch (xe) { case PRIMITIVE: case VOID: return pe(ye, ge); case ARRAY: { const ve = pe([], ge); for (const _e of ye) ve.push(me(_e)); return ve } case OBJECT: { const ve = pe({}, ge); for (const [_e, Ee] of ye) ve[me(_e)] = me(Ee); return ve } case DATE: return pe(new Date(ye), ge); case REGEXP: { const { source: ve, flags: _e } = ye; return pe(new RegExp(ve, _e), ge) } case MAP: { const ve = pe(new Map, ge); for (const [_e, Ee] of ye) ve.set(me(_e), me(Ee)); return ve } case SET: { const ve = pe(new Set, ge); for (const _e of ye) ve.add(me(_e)); return ve } case ERROR: { const { name: ve, message: _e } = ye; return pe(new env[ve](_e), ge) } case BIGINT: return pe(BigInt(ye), ge); case "BigInt": return pe(Object(BigInt(ye)), ge); case "ArrayBuffer": return pe(new Uint8Array(ye).buffer, ye); case "DataView": { const { buffer: ve } = new Uint8Array(ye); return pe(new DataView(ve), ye) } }return pe(new env[xe](ye), ge) }; return me }, deserialize = fe => deserializer(new Map, fe)(0), EMPTY = "", { toString: toString$1 } = {}, { keys } = Object, typeOf = fe => { const K = typeof fe; if (K !== "object" || !fe) return [PRIMITIVE, K]; const pe = toString$1.call(fe).slice(8, -1); switch (pe) { case "Array": return [ARRAY, EMPTY]; case "Object": return [OBJECT, EMPTY]; case "Date": return [DATE, EMPTY]; case "RegExp": return [REGEXP, EMPTY]; case "Map": return [MAP, EMPTY]; case "Set": return [SET, EMPTY]; case "DataView": return [ARRAY, pe] }return pe.includes("Array") ? [ARRAY, pe] : pe.includes("Error") ? [ERROR, pe] : [OBJECT, pe] }, shouldSkip = ([fe, K]) => fe === PRIMITIVE && (K === "function" || K === "symbol"), serializer = (fe, K, pe, me) => { const ge = (ye, ve) => { const _e = me.push(ye) - 1; return pe.set(ve, _e), _e }, xe = ye => { if (pe.has(ye)) return pe.get(ye); let [ve, _e] = typeOf(ye); switch (ve) { case PRIMITIVE: { let be = ye; switch (_e) { case "bigint": ve = BIGINT, be = ye.toString(); break; case "function": case "symbol": if (fe) throw new TypeError("unable to serialize " + _e); be = null; break; case "undefined": return ge([VOID], ye) }return ge([ve, be], ye) } case ARRAY: { if (_e) { let Se = ye; return _e === "DataView" ? Se = new Uint8Array(ye.buffer) : _e === "ArrayBuffer" && (Se = new Uint8Array(ye)), ge([_e, [...Se]], ye) } const be = [], Ae = ge([ve, be], ye); for (const Se of ye) be.push(xe(Se)); return Ae } case OBJECT: { if (_e) switch (_e) { case "BigInt": return ge([_e, ye.toString()], ye); case "Boolean": case "Number": case "String": return ge([_e, ye.valueOf()], ye) }if (K && "toJSON" in ye) return xe(ye.toJSON()); const be = [], Ae = ge([ve, be], ye); for (const Se of keys(ye)) (fe || !shouldSkip(typeOf(ye[Se]))) && be.push([xe(Se), xe(ye[Se])]); return Ae } case DATE: return ge([ve, ye.toISOString()], ye); case REGEXP: { const { source: be, flags: Ae } = ye; return ge([ve, { source: be, flags: Ae }], ye) } case MAP: { const be = [], Ae = ge([ve, be], ye); for (const [Se, Ce] of ye) (fe || !(shouldSkip(typeOf(Se)) || shouldSkip(typeOf(Ce)))) && be.push([xe(Se), xe(Ce)]); return Ae } case SET: { const be = [], Ae = ge([ve, be], ye); for (const Se of ye) (fe || !shouldSkip(typeOf(Se))) && be.push(xe(Se)); return Ae } }const { message: Ee } = ye; return ge([ve, { name: _e, message: Ee }], ye) }; return xe }, serialize$1 = (fe, { json: K, lossy: pe } = {}) => { const me = []; return serializer(!(K || pe), !!K, new Map, me)(fe), me }, structuredClone$1 = typeof structuredClone == "function" ? (fe, K) => K && ("json" in K || "lossy" in K) ? deserialize(serialize$1(fe, K)) : structuredClone(fe) : (fe, K) => deserialize(serialize$1(fe, K)); function defaultFootnoteBackContent(fe, K) { const pe = [{ type: "text", value: "" }]; return K > 1 && pe.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(K) }] }), pe } function defaultFootnoteBackLabel(fe, K) { return "Back to reference " + (fe + 1) + (K > 1 ? "-" + K : "") } function footer(fe) {
	const K = typeof fe.options.clobberPrefix == "string" ? fe.options.clobberPrefix : "user-content-", pe = fe.options.footnoteBackContent || defaultFootnoteBackContent, me = fe.options.footnoteBackLabel || defaultFootnoteBackLabel, ge = fe.options.footnoteLabel || "Footnotes", xe = fe.options.footnoteLabelTagName || "h2", ye = fe.options.footnoteLabelProperties || { className: ["sr-only"] }, ve = []; let _e = -1; for (; ++_e < fe.footnoteOrder.length;) { const Ee = fe.footnoteById.get(fe.footnoteOrder[_e]); if (!Ee) continue; const be = fe.all(Ee), Ae = String(Ee.identifier).toUpperCase(), Se = normalizeUri(Ae.toLowerCase()); let Ce = 0; const we = [], Be = fe.footnoteCounts.get(Ae); for (; Be !== void 0 && ++Ce <= Be;) { we.length > 0 && we.push({ type: "text", value: " " }); let Ie = typeof pe == "string" ? pe : pe(_e, Ce); typeof Ie == "string" && (Ie = { type: "text", value: Ie }), we.push({ type: "element", tagName: "a", properties: { href: "#" + K + "fnref-" + Se + (Ce > 1 ? "-" + Ce : ""), dataFootnoteBackref: "", ariaLabel: typeof me == "string" ? me : me(_e, Ce), className: ["data-footnote-backref"] }, children: Array.isArray(Ie) ? Ie : [Ie] }) } const De = be[be.length - 1]; if (De && De.type === "element" && De.tagName === "p") { const Ie = De.children[De.children.length - 1]; Ie && Ie.type === "text" ? Ie.value += " " : De.children.push({ type: "text", value: " " }), De.children.push(...we) } else be.push(...we); const Re = { type: "element", tagName: "li", properties: { id: K + "fn-" + Se }, children: fe.wrap(be, !0) }; fe.patch(Ee, Re), ve.push(Re) } if (ve.length !== 0) return {
		type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: xe, properties: { ...structuredClone$1(ye), id: "footnote-label" }, children: [{ type: "text", value: ge }] }, {
			type: "text", value: `
`}, { type: "element", tagName: "ol", properties: {}, children: fe.wrap(ve, !0) }, {
			type: "text", value: `
`}]
	}
} const convert$1 = function (fe) { if (fe == null) return ok; if (typeof fe == "function") return castFactory$1(fe); if (typeof fe == "object") return Array.isArray(fe) ? anyFactory(fe) : propsFactory(fe); if (typeof fe == "string") return typeFactory$1(fe); throw new Error("Expected function, string, or object as test") }; function anyFactory(fe) { const K = []; let pe = -1; for (; ++pe < fe.length;)K[pe] = convert$1(fe[pe]); return castFactory$1(me); function me(...ge) { let xe = -1; for (; ++xe < K.length;)if (K[xe].apply(this, ge)) return !0; return !1 } } function propsFactory(fe) { const K = fe; return castFactory$1(pe); function pe(me) { const ge = me; let xe; for (xe in fe) if (ge[xe] !== K[xe]) return !1; return !0 } } function typeFactory$1(fe) { return castFactory$1(K); function K(pe) { return pe && pe.type === fe } } function castFactory$1(fe) { return K; function K(pe, me, ge) { return !!(looksLikeANode(pe) && fe.call(this, pe, typeof me == "number" ? me : void 0, ge || void 0)) } } function ok() { return !0 } function looksLikeANode(fe) { return fe !== null && typeof fe == "object" && "type" in fe } function color$2(fe) { return fe } const empty = [], CONTINUE$1 = !0, EXIT$1 = !1, SKIP$1 = "skip"; function visitParents$1(fe, K, pe, me) { let ge; typeof K == "function" && typeof pe != "function" ? (me = pe, pe = K) : ge = K; const xe = convert$1(ge), ye = me ? -1 : 1; ve(fe, void 0, [])(); function ve(_e, Ee, be) { const Ae = _e && typeof _e == "object" ? _e : {}; if (typeof Ae.type == "string") { const Ce = typeof Ae.tagName == "string" ? Ae.tagName : typeof Ae.name == "string" ? Ae.name : void 0; Object.defineProperty(Se, "name", { value: "node (" + (_e.type + (Ce ? "<" + Ce + ">" : "")) + ")" }) } return Se; function Se() { let Ce = empty, we, Be, De; if ((!K || xe(_e, Ee, be[be.length - 1] || void 0)) && (Ce = toResult$1(pe(_e, be)), Ce[0] === EXIT$1)) return Ce; if ("children" in _e && _e.children) { const Re = _e; if (Re.children && Ce[0] !== SKIP$1) for (Be = (me ? Re.children.length : -1) + ye, De = be.concat(Re); Be > -1 && Be < Re.children.length;) { const Ie = Re.children[Be]; if (we = ve(Ie, Be, De)(), we[0] === EXIT$1) return we; Be = typeof we[1] == "number" ? we[1] : Be + ye } } return Ce } } } function toResult$1(fe) { return Array.isArray(fe) ? fe : typeof fe == "number" ? [CONTINUE$1, fe] : fe == null ? empty : [fe] } function visit$1(fe, K, pe, me) { let ge, xe, ye; typeof K == "function" && typeof pe != "function" ? (xe = void 0, ye = K, ge = pe) : (xe = K, ye = pe, ge = me), visitParents$1(fe, xe, ve, ge); function ve(_e, Ee) { const be = Ee[Ee.length - 1], Ae = be ? be.children.indexOf(_e) : void 0; return ye(_e, Ae, be) } } const own$1 = {}.hasOwnProperty, emptyOptions$1 = {}; function createState(fe, K) { const pe = K || emptyOptions$1, me = new Map, ge = new Map, xe = new Map, ye = { ...handlers, ...pe.handlers }, ve = { all: Ee, applyData, definitionById: me, footnoteById: ge, footnoteCounts: xe, footnoteOrder: [], handlers: ye, one: _e, options: pe, patch, wrap: wrap$1 }; return visit$1(fe, function (be) { if (be.type === "definition" || be.type === "footnoteDefinition") { const Ae = be.type === "definition" ? me : ge, Se = String(be.identifier).toUpperCase(); Ae.has(Se) || Ae.set(Se, be) } }), ve; function _e(be, Ae) { const Se = be.type, Ce = ve.handlers[Se]; if (own$1.call(ve.handlers, Se) && Ce) return Ce(ve, be, Ae); if (ve.options.passThrough && ve.options.passThrough.includes(Se)) { if ("children" in be) { const { children: Be, ...De } = be, Re = structuredClone$1(De); return Re.children = ve.all(be), Re } return structuredClone$1(be) } return (ve.options.unknownHandler || defaultUnknownHandler)(ve, be, Ae) } function Ee(be) { const Ae = []; if ("children" in be) { const Se = be.children; let Ce = -1; for (; ++Ce < Se.length;) { const we = ve.one(Se[Ce], be); if (we) { if (Ce && Se[Ce - 1].type === "break" && (!Array.isArray(we) && we.type === "text" && (we.value = trimMarkdownSpaceStart(we.value)), !Array.isArray(we) && we.type === "element")) { const Be = we.children[0]; Be && Be.type === "text" && (Be.value = trimMarkdownSpaceStart(Be.value)) } Array.isArray(we) ? Ae.push(...we) : Ae.push(we) } } } return Ae } } function patch(fe, K) { fe.position && (K.position = position(fe)) } function applyData(fe, K) { let pe = K; if (fe && fe.data) { const me = fe.data.hName, ge = fe.data.hChildren, xe = fe.data.hProperties; if (typeof me == "string") if (pe.type === "element") pe.tagName = me; else { const ye = "children" in pe ? pe.children : [pe]; pe = { type: "element", tagName: me, properties: {}, children: ye } } pe.type === "element" && xe && Object.assign(pe.properties, structuredClone$1(xe)), "children" in pe && pe.children && ge !== null && ge !== void 0 && (pe.children = ge) } return pe } function defaultUnknownHandler(fe, K) { const pe = K.data || {}, me = "value" in K && !(own$1.call(pe, "hProperties") || own$1.call(pe, "hChildren")) ? { type: "text", value: K.value } : { type: "element", tagName: "div", properties: {}, children: fe.all(K) }; return fe.patch(K, me), fe.applyData(K, me) } function wrap$1(fe, K) {
	const pe = []; let me = -1; for (K && pe.push({
		type: "text", value: `
`}); ++me < fe.length;)me && pe.push({
			type: "text", value: `
`}), pe.push(fe[me]); return K && fe.length > 0 && pe.push({
				type: "text", value: `
`}), pe
} function trimMarkdownSpaceStart(fe) { let K = 0, pe = fe.charCodeAt(K); for (; pe === 9 || pe === 32;)K++, pe = fe.charCodeAt(K); return fe.slice(K) } function toHast(fe, K) {
	const pe = createState(fe, K), me = pe.one(fe, void 0), ge = footer(pe), xe = Array.isArray(me) ? { type: "root", children: me } : me || { type: "root", children: [] }; return ge && xe.children.push({
		type: "text", value: `
`}, ge), xe
} function remarkRehype(fe, K) { return fe && "run" in fe ? async function (pe, me) { const ge = toHast(pe, { file: me, ...K }); await fe.run(ge, me) } : function (pe, me) { return toHast(pe, { file: me, ...fe || K }) } } function bail(fe) { if (fe) throw fe } var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray = function (K) { return typeof Array.isArray == "function" ? Array.isArray(K) : toStr.call(K) === "[object Array]" }, isPlainObject$2 = function (K) { if (!K || toStr.call(K) !== "[object Object]") return !1; var pe = hasOwn.call(K, "constructor"), me = K.constructor && K.constructor.prototype && hasOwn.call(K.constructor.prototype, "isPrototypeOf"); if (K.constructor && !pe && !me) return !1; var ge; for (ge in K); return typeof ge > "u" || hasOwn.call(K, ge) }, setProperty = function (K, pe) { defineProperty && pe.name === "__proto__" ? defineProperty(K, pe.name, { enumerable: !0, configurable: !0, value: pe.newValue, writable: !0 }) : K[pe.name] = pe.newValue }, getProperty = function (K, pe) { if (pe === "__proto__") if (hasOwn.call(K, pe)) { if (gOPD) return gOPD(K, pe).value } else return; return K[pe] }, extend$1 = function fe() { var K, pe, me, ge, xe, ye, ve = arguments[0], _e = 1, Ee = arguments.length, be = !1; for (typeof ve == "boolean" && (be = ve, ve = arguments[1] || {}, _e = 2), (ve == null || typeof ve != "object" && typeof ve != "function") && (ve = {}); _e < Ee; ++_e)if (K = arguments[_e], K != null) for (pe in K) me = getProperty(ve, pe), ge = getProperty(K, pe), ve !== ge && (be && ge && (isPlainObject$2(ge) || (xe = isArray(ge))) ? (xe ? (xe = !1, ye = me && isArray(me) ? me : []) : ye = me && isPlainObject$2(me) ? me : {}, setProperty(ve, { name: pe, newValue: fe(be, ye, ge) })) : typeof ge < "u" && setProperty(ve, { name: pe, newValue: ge })); return ve }; const extend$2 = getDefaultExportFromCjs(extend$1); function isPlainObject$1(fe) { if (typeof fe != "object" || fe === null) return !1; const K = Object.getPrototypeOf(fe); return (K === null || K === Object.prototype || Object.getPrototypeOf(K) === null) && !(Symbol.toStringTag in fe) && !(Symbol.iterator in fe) } function trough() { const fe = [], K = { run: pe, use: me }; return K; function pe(...ge) { let xe = -1; const ye = ge.pop(); if (typeof ye != "function") throw new TypeError("Expected function as last argument, not " + ye); ve(null, ...ge); function ve(_e, ...Ee) { const be = fe[++xe]; let Ae = -1; if (_e) { ye(_e); return } for (; ++Ae < ge.length;)(Ee[Ae] === null || Ee[Ae] === void 0) && (Ee[Ae] = ge[Ae]); ge = Ee, be ? wrap(be, ve)(...Ee) : ye(null, ...Ee) } } function me(ge) { if (typeof ge != "function") throw new TypeError("Expected `middelware` to be a function, not " + ge); return fe.push(ge), K } } function wrap(fe, K) { let pe; return me; function me(...ye) { const ve = fe.length > ye.length; let _e; ve && ye.push(ge); try { _e = fe.apply(this, ye) } catch (Ee) { const be = Ee; if (ve && pe) throw be; return ge(be) } ve || (_e && _e.then && typeof _e.then == "function" ? _e.then(xe, ge) : _e instanceof Error ? ge(_e) : xe(_e)) } function ge(ye, ...ve) { pe || (pe = !0, K(ye, ...ve)) } function xe(ye) { ge(null, ye) } } const CallableInstance = function (fe) { const me = this.constructor.prototype, ge = me[fe], xe = function () { return ge.apply(xe, arguments) }; return Object.setPrototypeOf(xe, me), xe }, own = {}.hasOwnProperty; class Processor extends CallableInstance { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = trough() } copy() { const K = new Processor; let pe = -1; for (; ++pe < this.attachers.length;) { const me = this.attachers[pe]; K.use(...me) } return K.data(extend$2(!0, {}, this.namespace)), K } data(K, pe) { return typeof K == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen), this.namespace[K] = pe, this) : own.call(this.namespace, K) && this.namespace[K] || void 0 : K ? (assertUnfrozen("data", this.frozen), this.namespace = K, this) : this.namespace } freeze() { if (this.frozen) return this; const K = this; for (; ++this.freezeIndex < this.attachers.length;) { const [pe, ...me] = this.attachers[this.freezeIndex]; if (me[0] === !1) continue; me[0] === !0 && (me[0] = void 0); const ge = pe.call(K, ...me); typeof ge == "function" && this.transformers.use(ge) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(K) { this.freeze(); const pe = vfile(K), me = this.parser || this.Parser; return assertParser("parse", me), me(String(pe), pe) } process(K, pe) { const me = this; return this.freeze(), assertParser("process", this.parser || this.Parser), assertCompiler("process", this.compiler || this.Compiler), pe ? ge(void 0, pe) : new Promise(ge); function ge(xe, ye) { const ve = vfile(K), _e = me.parse(ve); me.run(_e, ve, function (be, Ae, Se) { if (be || !Ae || !Se) return Ee(be); const Ce = Ae, we = me.stringify(Ce, Se); looksLikeAValue(we) ? Se.value = we : Se.result = we, Ee(be, Se) }); function Ee(be, Ae) { be || !Ae ? ye(be) : xe ? xe(Ae) : pe(void 0, Ae) } } } processSync(K) { let pe = !1, me; return this.freeze(), assertParser("processSync", this.parser || this.Parser), assertCompiler("processSync", this.compiler || this.Compiler), this.process(K, ge), assertDone("processSync", "process", pe), me; function ge(xe, ye) { pe = !0, bail(xe), me = ye } } run(K, pe, me) { assertNode(K), this.freeze(); const ge = this.transformers; return !me && typeof pe == "function" && (me = pe, pe = void 0), me ? xe(void 0, me) : new Promise(xe); function xe(ye, ve) { const _e = vfile(pe); ge.run(K, _e, Ee); function Ee(be, Ae, Se) { const Ce = Ae || K; be ? ve(be) : ye ? ye(Ce) : me(void 0, Ce, Se) } } } runSync(K, pe) { let me = !1, ge; return this.run(K, pe, xe), assertDone("runSync", "run", me), ge; function xe(ye, ve) { bail(ye), ge = ve, me = !0 } } stringify(K, pe) { this.freeze(); const me = vfile(pe), ge = this.compiler || this.Compiler; return assertCompiler("stringify", ge), assertNode(K), ge(K, me) } use(K, ...pe) { const me = this.attachers, ge = this.namespace; if (assertUnfrozen("use", this.frozen), K != null) if (typeof K == "function") _e(K, pe); else if (typeof K == "object") Array.isArray(K) ? ve(K) : ye(K); else throw new TypeError("Expected usable value, not `" + K + "`"); return this; function xe(Ee) { if (typeof Ee == "function") _e(Ee, []); else if (typeof Ee == "object") if (Array.isArray(Ee)) { const [be, ...Ae] = Ee; _e(be, Ae) } else ye(Ee); else throw new TypeError("Expected usable value, not `" + Ee + "`") } function ye(Ee) { if (!("plugins" in Ee) && !("settings" in Ee)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); ve(Ee.plugins), Ee.settings && (ge.settings = extend$2(!0, ge.settings, Ee.settings)) } function ve(Ee) { let be = -1; if (Ee != null) if (Array.isArray(Ee)) for (; ++be < Ee.length;) { const Ae = Ee[be]; xe(Ae) } else throw new TypeError("Expected a list of plugins, not `" + Ee + "`") } function _e(Ee, be) { let Ae = -1, Se = -1; for (; ++Ae < me.length;)if (me[Ae][0] === Ee) { Se = Ae; break } if (Se === -1) me.push([Ee, ...be]); else if (be.length > 0) { let [Ce, ...we] = be; const Be = me[Se][1]; isPlainObject$1(Be) && isPlainObject$1(Ce) && (Ce = extend$2(!0, Be, Ce)), me[Se] = [Ee, Ce, ...we] } } } } const unified = new Processor().freeze(); function assertParser(fe, K) { if (typeof K != "function") throw new TypeError("Cannot `" + fe + "` without `parser`") } function assertCompiler(fe, K) { if (typeof K != "function") throw new TypeError("Cannot `" + fe + "` without `compiler`") } function assertUnfrozen(fe, K) { if (K) throw new Error("Cannot call `" + fe + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function assertNode(fe) { if (!isPlainObject$1(fe) || typeof fe.type != "string") throw new TypeError("Expected node, got `" + fe + "`") } function assertDone(fe, K, pe) { if (!pe) throw new Error("`" + fe + "` finished async. Use `" + K + "` instead") } function vfile(fe) { return looksLikeAVFile(fe) ? fe : new VFile(fe) } function looksLikeAVFile(fe) { return !!(fe && typeof fe == "object" && "message" in fe && "messages" in fe) } function looksLikeAValue(fe) { return typeof fe == "string" || isUint8Array(fe) } function isUint8Array(fe) { return !!(fe && typeof fe == "object" && "byteLength" in fe && "byteOffset" in fe) } function create(fe, K) { const pe = ["start", "end", "loc", "range"]; let me = -1; for (; ++me < pe.length;) { const ge = pe[me]; ge in fe && (K[ge] = fe[ge]) } } function specifiersToDeclarations(fe, K) { let pe = -1; const me = [], ge = []; let xe; for (; ++pe < fe.length;) { const ye = fe[pe]; ye.type === "ImportNamespaceSpecifier" ? xe = ye : ge.push(ye) } if (xe) { const ye = { type: "VariableDeclarator", id: xe.local, init: K }; create(xe, ye), me.push(ye) } return me.push({ type: "VariableDeclarator", id: { type: "ObjectPattern", properties: ge.map(function (ye) { let ve = ye.type === "ImportSpecifier" ? ye.imported : ye.type === "ExportSpecifier" ? ye.exported : { type: "Identifier", name: "default" }, _e = ye.local; ye.type === "ExportSpecifier" && (_e = ve, ve = ye.local), _e.type; const Ee = { type: "Property", kind: "init", shorthand: ve.type === "Identifier" && _e.type === "Identifier" && ve.name === _e.name, method: !1, computed: !1, key: ve, value: _e }; return create(ye, Ee), Ee }) }, init: xe ? { type: "Identifier", name: xe.local.name } : K }), me } function toIdOrMemberExpression(fe) { let K = -1, pe; for (; ++K < fe.length;) { const me = fe[K], ge = typeof me == "string" && name(me) ? { type: "Identifier", name: me } : { type: "Literal", value: me }; pe = pe ? { type: "MemberExpression", object: pe, property: ge, computed: ge.type === "Literal", optional: !1 } : ge } return pe.type, pe } function toJsxIdOrMemberExpression(fe) { let K = -1, pe; for (; ++K < fe.length;) { const me = fe[K]; typeof me == "string" && name(me, { jsx: !0 }); const ge = { type: "JSXIdentifier", name: me }; pe = pe ? { type: "JSXMemberExpression", object: pe, property: ge } : ge } return pe } function recmaBuildJsxTransform(fe) { const { outputFormat: K } = fe || {}; return function (pe) { if (pe.comments && (pe.comments = pe.comments.filter(function (me) { return !me.data?._mdxIsPragmaComment })), K === "function-body") { let me = 0; for (; me < pe.body.length;) { const xe = pe.body[me]; if ("directive" in xe && xe.directive) me++; else break } const ge = pe.body[me]; ge && ge.type === "ImportDeclaration" && typeof ge.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(ge.source.value) && (pe.body[me] = { type: "VariableDeclaration", kind: "const", declarations: specifiersToDeclarations(ge.specifiers, toIdOrMemberExpression(["arguments", 0])) }) } } } function createVisitors() { const fe = [{ block: !1, defined: [] }]; return { enter: K, exit: pe, scopes: fe }; function K(xe) { if (xe.type === "ArrowFunctionExpression") { fe.push({ block: !1, defined: [] }); for (const ye of xe.params) ge(ye, !1) } else if (xe.type === "BlockStatement" || xe.type === "DoWhileStatement" || xe.type === "ForInStatement" || xe.type === "ForOfStatement" || xe.type === "ForStatement" || xe.type === "WhileStatement") fe.push({ block: !0, defined: [] }); else if (xe.type === "CatchClause") fe.push({ block: !0, defined: [] }), xe.param && ge(xe.param, !0); else if (xe.type === "ClassDeclaration") me(xe.id.name, !1); else if (xe.type === "FunctionDeclaration") { me(xe.id.name, !1), fe.push({ block: !1, defined: [] }); for (const ye of xe.params) ge(ye, !1) } else if (xe.type === "FunctionExpression") { xe.id && me(xe.id.name, !1), fe.push({ block: !1, defined: [] }); for (const ye of xe.params) ge(ye, !1) } else if (xe.type === "ImportDeclaration") for (const ye of xe.specifiers) me(ye.local.name, !1); else if (xe.type === "VariableDeclaration") for (const ye of xe.declarations) ge(ye.id, xe.kind !== "var") } function pe(xe) { if (xe.type === "ArrowFunctionExpression" || xe.type === "FunctionDeclaration" || xe.type === "FunctionExpression") { const ye = fe.pop(); ye.block } else if (xe.type === "BlockStatement" || xe.type === "CatchClause" || xe.type === "DoWhileStatement" || xe.type === "ForInStatement" || xe.type === "ForOfStatement" || xe.type === "ForStatement" || xe.type === "WhileStatement") { const ye = fe.pop(); ye.block } } function me(xe, ye) { let ve = fe.length, _e; for (; ve-- && (_e = fe[ve], !(ye || !_e.block));); _e.defined.push(xe) } function ge(xe, ye) { if (xe.type === "ArrayPattern") for (const ve of xe.elements) ve && ge(ve, ye); else if (xe.type === "AssignmentPattern") ge(xe.left, ye); else if (xe.type === "Identifier") me(xe.name, ye); else if (xe.type === "ObjectPattern") for (const ve of xe.properties) ve.type === "Property" ? ge(ve.value, ye) : (ve.type, ge(ve, ye)); else xe.type, ge(xe.argument, ye) } } class WalkerBase { constructor() { this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: K => this.replacement = K } } replace(K, pe, me, ge) { K && pe && (me != null ? K[pe][me] = ge : K[pe] = ge) } remove(K, pe, me) { K && pe && (me != null ? K[pe].splice(me, 1) : delete K[pe]) } } class SyncWalker extends WalkerBase { constructor(K, pe) { super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: me => this.replacement = me }, this.enter = K, this.leave = pe } visit(K, pe, me, ge) { if (K) { if (this.enter) { const ye = this.should_skip, ve = this.should_remove, _e = this.replacement; this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, K, pe, me, ge), this.replacement && (K = this.replacement, this.replace(pe, me, ge, K)), this.should_remove && this.remove(pe, me, ge); const Ee = this.should_skip, be = this.should_remove; if (this.should_skip = ye, this.should_remove = ve, this.replacement = _e, Ee) return K; if (be) return null } let xe; for (xe in K) { const ye = K[xe]; if (ye && typeof ye == "object") if (Array.isArray(ye)) { const ve = ye; for (let _e = 0; _e < ve.length; _e += 1) { const Ee = ve[_e]; isNode(Ee) && (this.visit(Ee, K, xe, _e) || _e--) } } else isNode(ye) && this.visit(ye, K, xe, null) } if (this.leave) { const ye = this.replacement, ve = this.should_remove; this.replacement = null, this.should_remove = !1, this.leave.call(this.context, K, pe, me, ge), this.replacement && (K = this.replacement, this.replace(pe, me, ge, K)), this.should_remove && this.remove(pe, me, ge); const _e = this.should_remove; if (this.replacement = ye, this.should_remove = ve, _e) return null } } return K } } function isNode(fe) { return fe !== null && typeof fe == "object" && "type" in fe && typeof fe.type == "string" } function walk(fe, { enter: K, leave: pe }) { return new SyncWalker(K, pe).visit(fe, null) } function declarationToExpression(fe) { return fe.type === "FunctionDeclaration" ? { ...fe, type: "FunctionExpression" } : (fe.type, { ...fe, type: "ClassExpression" }) } function isDeclaration(fe) { return fe.type === "FunctionDeclaration" || fe.type === "ClassDeclaration" || fe.type === "VariableDeclaration" } function recmaDocument(fe) { const K = fe.baseUrl || void 0, pe = typeof K == "object" ? K.href : K, me = fe.outputFormat || "program", ge = fe.pragma === void 0 ? "React.createElement" : fe.pragma, xe = fe.pragmaFrag === void 0 ? "React.Fragment" : fe.pragmaFrag, ye = fe.pragmaImportSource || "react", ve = fe.jsxImportSource || "react", _e = fe.jsxRuntime || "automatic"; return function (be, Ae) { const Se = [], Ce = []; let we = 0, Be, De, Re; if (_e === "classic" && xe && injectPragma(be, "@jsxFrag", xe), _e === "classic" && ge && injectPragma(be, "@jsx", ge), _e === "automatic" && ve && injectPragma(be, "@jsxImportSource", ve), injectPragma(be, "@jsxRuntime", _e), _e === "classic" && ye) { if (!ge) throw new Error("Missing `pragma` in classic runtime with `pragmaImportSource`"); ke({ type: "ImportDeclaration", specifiers: [{ type: "ImportDefaultSpecifier", local: { type: "Identifier", name: ge.split(".")[0] } }], source: { type: "Literal", value: ye } }) } for (Re of be.body) if (Re.type === "ExportDefaultDeclaration") Be && Ae.fail("Unexpected duplicate layout, expected a single layout (previous: " + stringifyPosition(positionFromEstree(Be)) + ")", { ancestors: [be, Re], place: positionFromEstree(Re), ruleId: "duplicate-layout", source: "recma-document" }), Be = Re, Ce.push({ type: "VariableDeclaration", kind: "const", declarations: [{ type: "VariableDeclarator", id: { type: "Identifier", name: "MDXLayout" }, init: isDeclaration(Re.declaration) ? declarationToExpression(Re.declaration) : Re.declaration }] }); else if (Re.type === "ExportNamedDeclaration" && Re.source) { const Oe = Re.source; Re.specifiers = Re.specifiers.filter(function (Ue) { if (Ue.exported.type === "Identifier" && Ue.exported.name === "default") { Be && Ae.fail("Unexpected duplicate layout, expected a single layout (previous: " + stringifyPosition(positionFromEstree(Be)) + ")", { ancestors: [be, Re, Ue], place: positionFromEstree(Re), ruleId: "duplicate-layout", source: "recma-document" }), Be = Ue; const He = []; if (Ue.local.type === "Identifier" && Ue.local.name === "default") He.push({ type: "ImportDefaultSpecifier", local: { type: "Identifier", name: "MDXLayout" } }); else { const We = { type: "ImportSpecifier", imported: Ue.local, local: { type: "Identifier", name: "MDXLayout" } }; create(Ue.local, We), He.push(We) } const Ge = { type: "Literal", value: Oe.value }; create(Oe, Ge); const ze = { type: "ImportDeclaration", specifiers: He, source: Ge }; return create(Ue, ze), ke(ze), !1 } return !0 }), Re.specifiers.length > 0 && Ne(Re) } else Re.type === "ExportNamedDeclaration" || Re.type === "ExportAllDeclaration" ? Ne(Re) : Re.type === "ImportDeclaration" ? ke(Re) : Re.type === "ExpressionStatement" && (Re.expression.type === "JSXElement" || Re.expression.type === "JSXFragment") ? (De = !0, Ce.push(...Ee(Re.expression, me, !!Be))) : Ce.push(Re); De || Ce.push(...Ee(void 0, me, !!Be)), Se.push(["MDXContent", "default"]), me === "function-body" && Ce.push({ type: "ReturnStatement", argument: { type: "ObjectExpression", properties: [...Array.from({ length: we }).map(function (Oe, Ue) { return { type: "SpreadElement", argument: { type: "Identifier", name: "_exportAll" + (Ue + 1) } } }), ...Se.map(function (Oe) { return { type: "Property", kind: "init", method: !1, computed: !1, shorthand: typeof Oe == "string", key: { type: "Identifier", name: typeof Oe == "string" ? Oe : Oe[1] }, value: { type: "Identifier", name: typeof Oe == "string" ? Oe : Oe[0] } } })] } }), be.body = Ce; let Ie = !1, Pe = !1; (pe || me === "function-body") && walk(be, { enter(Oe) { if ((Oe.type === "ExportAllDeclaration" || Oe.type === "ExportNamedDeclaration" || Oe.type === "ImportDeclaration") && Oe.source) { let Ue = Oe.source.value; try { new URL(Ue) } catch { (Ue.startsWith("/") || Ue.startsWith("./") || Ue.startsWith("../")) && (Ue = new URL(Ue, pe).href) } const He = { type: "Literal", value: Ue }; create(Oe.source, He), Oe.source = He; return } if (Oe.type === "ImportExpression") { Pe = !0; const Ue = { type: "CallExpression", callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" }, arguments: [Oe.source], optional: !1 }; Oe.source = Ue; return } if (Oe.type === "MemberExpression" && "object" in Oe && Oe.object.type === "MetaProperty" && Oe.property.type === "Identifier" && Oe.object.meta.name === "import" && Oe.object.property.name === "meta" && Oe.property.name === "url") { Ie = !0; const Ue = { type: "Identifier", name: "_importMetaUrl" }; create(Oe, Ue), this.replace(Ue) } } }), Pe && (pe || (Ie = !0), be.body.push(resolveDynamicMdxSpecifier(pe ? { type: "Literal", value: pe } : { type: "Identifier", name: "_importMetaUrl" }))), Ie && be.body.unshift(...createImportMetaUrlVariable()); function Ne(Oe) { if (Oe.type === "ExportNamedDeclaration") { if (Oe.declaration) { const Ue = createVisitors(); walk(Oe, { enter(He) { Ue.enter(He), (He.type === "ArrowFunctionExpression" || He.type === "FunctionDeclaration" || He.type === "FunctionExpression") && (this.skip(), Ue.exit(He)) }, leave: Ue.exit }), Se.push(...Ue.scopes[0].defined) } for (Re of Oe.specifiers) Re.exported.type === "Identifier" ? Se.push(Re.exported.name) : (Re.exported.value, Se.push(Re.exported.value)) } ke(Oe) } function ke(Oe) { let Ue, He; if (me === "function-body") if (Oe.type === "ImportDeclaration" || Oe.type === "ExportAllDeclaration" || Oe.type === "ExportNamedDeclaration" && Oe.source) { Oe.source; const Ge = { type: "ImportExpression", source: Oe.source }; create(Oe, Ge), He = { type: "AwaitExpression", argument: Ge }, (Oe.type === "ImportDeclaration" || Oe.type === "ExportNamedDeclaration") && Oe.specifiers.length === 0 ? Ue = { type: "ExpressionStatement", expression: He } : Ue = { type: "VariableDeclaration", kind: "const", declarations: Oe.type === "ExportAllDeclaration" ? [{ type: "VariableDeclarator", id: { type: "Identifier", name: "_exportAll" + ++we }, init: He }] : specifiersToDeclarations(Oe.specifiers, He) } } else if (Oe.declaration) Ue = Oe.declaration; else { const Ge = []; for (const ze of Oe.specifiers) ze.exported.type === "Identifier" && ze.local.type === "Identifier" && ze.local.name !== ze.exported.name && Ge.push({ type: "VariableDeclarator", id: ze.exported, init: ze.local }); Ge.length > 0 && (Ue = { type: "VariableDeclaration", kind: "const", declarations: Ge }) } else Ue = Oe; Ue && Ce.push(Ue) } }; function Ee(be, Ae, Se) { let we = { type: "JSXElement", openingElement: { type: "JSXOpeningElement", name: { type: "JSXIdentifier", name: "MDXLayout" }, attributes: [{ type: "JSXSpreadAttribute", argument: { type: "Identifier", name: "props" } }], selfClosing: !1 }, closingElement: { type: "JSXClosingElement", name: { type: "JSXIdentifier", name: "MDXLayout" } }, children: [{ type: "JSXElement", openingElement: { type: "JSXOpeningElement", name: { type: "JSXIdentifier", name: "_createMdxContent" }, attributes: [{ type: "JSXSpreadAttribute", argument: { type: "Identifier", name: "props" } }], selfClosing: !0 }, closingElement: null, children: [] }] }; Se || (we = { type: "ConditionalExpression", test: { type: "Identifier", name: "MDXLayout" }, consequent: we, alternate: { type: "CallExpression", callee: { type: "Identifier", name: "_createMdxContent" }, arguments: [{ type: "Identifier", name: "props" }], optional: !1 } }); let Be = be || { type: "Identifier", name: "undefined" }; Be.type === "JSXFragment" && Be.children.length === 1 && Be.children[0].type === "JSXElement" && (Be = Be.children[0]); let De = !1; walk(Be, { enter(Ie) { if (Ie.type === "ArrowFunctionExpression" || Ie.type === "FunctionDeclaration" || Ie.type === "FunctionExpression") return this.skip(); (Ie.type === "AwaitExpression" || Ie.type === "ForOfStatement" && Ie.await) && (De = !0) } }); const Re = { type: "FunctionDeclaration", id: { type: "Identifier", name: "MDXContent" }, params: [{ type: "AssignmentPattern", left: { type: "Identifier", name: "props" }, right: { type: "ObjectExpression", properties: [] } }], body: { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: we }] } }; return [{ type: "FunctionDeclaration", async: De, id: { type: "Identifier", name: "_createMdxContent" }, params: [{ type: "Identifier", name: "props" }], body: { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: Be }] } }, Ae === "program" ? { type: "ExportDefaultDeclaration", declaration: Re } : Re] } } function injectPragma(fe, K, pe) { fe.comments?.unshift({ type: "Block", value: K + " " + pe, data: { _mdxIsPragmaComment: !0 } }) } function resolveDynamicMdxSpecifier(fe) { return { type: "FunctionDeclaration", id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" }, generator: !1, async: !1, params: [{ type: "Identifier", name: "d" }], body: { type: "BlockStatement", body: [{ type: "IfStatement", test: { type: "BinaryExpression", left: { type: "UnaryExpression", operator: "typeof", prefix: !0, argument: { type: "Identifier", name: "d" } }, operator: "!==", right: { type: "Literal", value: "string" } }, consequent: { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }, alternate: null }, { type: "TryStatement", block: { type: "BlockStatement", body: [{ type: "ExpressionStatement", expression: { type: "NewExpression", callee: { type: "Identifier", name: "URL" }, arguments: [{ type: "Identifier", name: "d" }] } }, { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }] }, handler: { type: "CatchClause", param: null, body: { type: "BlockStatement", body: [] } }, finalizer: null }, { type: "IfStatement", test: { type: "LogicalExpression", left: { type: "LogicalExpression", left: { type: "CallExpression", callee: toIdOrMemberExpression(["d", "startsWith"]), arguments: [{ type: "Literal", value: "/" }], optional: !1 }, operator: "||", right: { type: "CallExpression", callee: toIdOrMemberExpression(["d", "startsWith"]), arguments: [{ type: "Literal", value: "./" }], optional: !1 } }, operator: "||", right: { type: "CallExpression", callee: toIdOrMemberExpression(["d", "startsWith"]), arguments: [{ type: "Literal", value: "../" }], optional: !1 } }, consequent: { type: "ReturnStatement", argument: { type: "MemberExpression", object: { type: "NewExpression", callee: { type: "Identifier", name: "URL" }, arguments: [{ type: "Identifier", name: "d" }, fe] }, property: { type: "Identifier", name: "href" }, computed: !1, optional: !1 } }, alternate: null }, { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }] } } } function createImportMetaUrlVariable() { return [{ type: "VariableDeclaration", declarations: [{ type: "VariableDeclarator", id: { type: "Identifier", name: "_importMetaUrl" }, init: toIdOrMemberExpression(["arguments", 0, "baseUrl"]) }], kind: "const" }, { type: "IfStatement", test: { type: "UnaryExpression", operator: "!", prefix: !0, argument: { type: "Identifier", name: "_importMetaUrl" } }, consequent: { type: "ThrowStatement", argument: { type: "NewExpression", callee: { type: "Identifier", name: "Error" }, arguments: [{ type: "Literal", value: "Unexpected missing `options.baseUrl` needed to support `export  from`, `import`, or `import.meta.url` when generating `function-body`" }] } }, alternate: null }] } function toBinaryAddition(fe) { let K = -1, pe; for (; ++K < fe.length;) { const me = fe[K]; pe = pe ? { type: "BinaryExpression", left: pe, operator: "+", right: me } : me } return pe } function recmaJsxRewrite(fe) { const { development: K, outputFormat: pe, providerImportSource: me } = fe; return function (ge, xe) { const ye = createVisitors(), ve = []; let _e = !1, Ee = !1; if (walk(ge, { enter(be) { ye.enter(be), (be.type === "FunctionDeclaration" || be.type === "FunctionExpression" || be.type === "ArrowFunctionExpression") && (ve.push({ components: [], idToInvalidComponentName: new Map, node: be, objects: [], references: {}, tags: [] }), isNamedFunction(be, "MDXContent") && !inScope(ye.scopes, "MDXLayout") && ve[0].components.push("MDXLayout")); const Ae = ve[0]; if (!(!Ae || !isNamedFunction(Ae.node, "_createMdxContent") && !me) && be.type === "JSXElement") { let Se = be.openingElement.name; if (Se.type === "JSXMemberExpression") { const Ce = []; for (; Se.type === "JSXMemberExpression";)Ce.unshift(Se.property.name), Se = Se.object; Ce.unshift(Se.name); const we = Ce.join("."), Be = Se.name, De = inScope(ye.scopes, Be); !Object.hasOwn(Ae.references, we) && (!De || ve.length === 1 && ve[0].node.type === "FunctionDeclaration" && isNamedFunction(ve[0].node, "_createMdxContent")) && (Ae.references[we] = { component: !0, node: be }), !Ae.objects.includes(Be) && !De && Ae.objects.push(Be) } else if (Se.type !== "JSXNamespacedName") { if (name(Se.name) && !/^[a-z]/.test(Se.name)) { const Ce = Se.name; inScope(ye.scopes, Ce) || (Ce !== "MDXLayout" && !Object.hasOwn(Ae.references, Ce) && (Ae.references[Ce] = { component: !0, node: be }), Ae.components.includes(Ce) || Ae.components.push(Ce)) } else if (!(be.data && be.data._mdxExplicitJsx)) { const Ce = Se.name; Ae.tags.includes(Ce) || Ae.tags.push(Ce); let we = ["_components", Ce]; if (name(Ce) === !1) { let Be = Ae.idToInvalidComponentName.get(Ce); Be === void 0 && (Be = `_component${Ae.idToInvalidComponentName.size}`, Ae.idToInvalidComponentName.set(Ce, Be)), we = [Be] } be.openingElement.name = toJsxIdOrMemberExpression(we), be.closingElement && (be.closingElement.name = toJsxIdOrMemberExpression(we)) } } } }, leave(be) { ye.exit(be); const Ae = [], Se = [], Ce = [], we = []; if (be.type === "FunctionDeclaration" || be.type === "FunctionExpression" || be.type === "ArrowFunctionExpression") { const Be = ve[ve.length - 1]; let De; for (De of Be.tags.sort()) Ae.push({ type: "Property", kind: "init", key: name(De) ? { type: "Identifier", name: De } : { type: "Literal", value: De }, value: { type: "Literal", value: De }, method: !1, shorthand: !1, computed: !1 }); Se.push(...Be.components); for (De of Be.objects) Se.includes(De) || Se.push(De); Se.sort(); const Re = []; if (Ae.length > 0 || Se.length > 0 || Be.idToInvalidComponentName.size > 0) { if (me && (_e = !0, Ce.push({ type: "CallExpression", callee: { type: "Identifier", name: "_provideComponents" }, arguments: [], optional: !1 })), (isNamedFunction(Be.node, "MDXContent") || isNamedFunction(Be.node, "_createMdxContent")) && Ce.push(toIdOrMemberExpression(["props", "components"])), Ae.length > 0 || Ce.length > 1) for (const Ue of Ce) Ae.push({ type: "SpreadElement", argument: Ue }); let ke = Ae.length > 0 ? { type: "ObjectExpression", properties: Ae } : { type: "LogicalExpression", operator: "||", left: Ce[0], right: { type: "ObjectExpression", properties: [] } }, Oe; if (Se.length > 0 && (Oe = { type: "ObjectPattern", properties: Se.map(function (Ue) { return { type: "Property", kind: "init", key: { type: "Identifier", name: Ue === "MDXLayout" ? "wrapper" : Ue }, value: { type: "Identifier", name: Ue }, method: !1, shorthand: Ue !== "MDXLayout", computed: !1 } }) }), Be.tags.length > 0 && (we.push({ type: "VariableDeclarator", id: { type: "Identifier", name: "_components" }, init: ke }), ke = { type: "Identifier", name: "_components" }), isNamedFunction(Be.node, "_createMdxContent")) for (const [Ue, He] of [...Be.idToInvalidComponentName].sort(function ([Ge], [ze]) { return Ge.localeCompare(ze) })) we.push({ type: "VariableDeclarator", id: { type: "Identifier", name: He }, init: { type: "MemberExpression", object: { type: "Identifier", name: "_components" }, property: { type: "Literal", value: Ue }, computed: !0, optional: !1 } }); Oe && we.push({ type: "VariableDeclarator", id: Oe, init: ke }), we.length > 0 && Re.push({ type: "VariableDeclaration", kind: "const", declarations: we }) } let Ie; for (Ie in Be.references) if (Object.hasOwn(Be.references, Ie)) { const ke = Ie.split("."); let Oe = 0; for (; ++Oe < ke.length;) { const Ue = ke.slice(0, Oe).join("."); Object.hasOwn(Be.references, Ue) || (Be.references[Ue] = { component: !1, node: Be.references[Ie].node }) } } const Pe = Object.keys(Be.references).sort(); let Ne = -1; for (; ++Ne < Pe.length;) { const ke = Pe[Ne], Oe = Be.references[ke], Ue = stringifyPosition(positionFromEstree(Oe.node)), He = [{ type: "Literal", value: ke }, { type: "Literal", value: Oe.component }]; Ee = !0, K && Ue && He.push({ type: "Literal", value: Ue }), Re.push({ type: "IfStatement", test: { type: "UnaryExpression", operator: "!", prefix: !0, argument: toIdOrMemberExpression(ke.split(".")) }, consequent: { type: "ExpressionStatement", expression: { type: "CallExpression", callee: { type: "Identifier", name: "_missingMdxReference" }, arguments: He, optional: !1 } }, alternate: void 0 }) } Re.length > 0 && (be.body.type !== "BlockStatement" && (be.body = { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: be.body }] }), be.body.body.unshift(...Re)), ve.pop() } } }), _e && me && ge.body.unshift(createImportProvider(me, pe)), Ee) { const be = [{ type: "Literal", value: "Expected " }, { type: "ConditionalExpression", test: { type: "Identifier", name: "component" }, consequent: { type: "Literal", value: "component" }, alternate: { type: "Literal", value: "object" } }, { type: "Literal", value: " `" }, { type: "Identifier", name: "id" }, { type: "Literal", value: "` to be defined: you likely forgot to import, pass, or provide it." }], Ae = [{ type: "Identifier", name: "id" }, { type: "Identifier", name: "component" }]; K && (be.push({ type: "ConditionalExpression", test: { type: "Identifier", name: "place" }, consequent: toBinaryAddition([{ type: "Literal", value: "\nIts referenced in your code at `" }, { type: "Identifier", name: "place" }, { type: "Literal", value: (xe.path ? "` in `" + xe.path : "") + "`" }]), alternate: { type: "Literal", value: "" } }), Ae.push({ type: "Identifier", name: "place" })), ge.body.push({ type: "FunctionDeclaration", id: { type: "Identifier", name: "_missingMdxReference" }, generator: !1, async: !1, params: Ae, body: { type: "BlockStatement", body: [{ type: "ThrowStatement", argument: { type: "NewExpression", callee: { type: "Identifier", name: "Error" }, arguments: [toBinaryAddition(be)] } }] } }) } pe === "function-body" && ge.body.unshift({ type: "ExpressionStatement", expression: { type: "Literal", value: "use strict" }, directive: "use strict" }) } } function createImportProvider(fe, K) { const pe = [{ type: "ImportSpecifier", imported: { type: "Identifier", name: "useMDXComponents" }, local: { type: "Identifier", name: "_provideComponents" } }]; return K === "function-body" ? { type: "VariableDeclaration", kind: "const", declarations: specifiersToDeclarations(pe, toIdOrMemberExpression(["arguments", 0])) } : { type: "ImportDeclaration", specifiers: pe, source: { type: "Literal", value: fe } } } function isNamedFunction(fe, K) { return !!(fe && "id" in fe && fe.id && fe.id.name === K) } function inScope(fe, K) { let pe = fe.length; for (; pe--;)if (fe[pe].defined.includes(K)) return !0; return !1 } function rehypeRemoveRaw() { return function (fe) { visit$1(fe, "raw", function (K, pe, me) { if (me && typeof pe == "number") return me.children.splice(pe, 1), pe }) } } const js = /\s+/g, html$1 = /[\t\n\v\f\r ]+/g; function collapseWhiteSpace(fe, K) { K ? typeof K == "string" && (K = { style: K }) : K = {}; const pe = K.preserveLineEndings ? replaceLineEnding : replaceSpace; return String(fe).replace(K.style === "html" ? html$1 : js, K.trim ? trimFactory(pe) : pe) } function replaceLineEnding(fe) { const K = /\r?\n|\r/.exec(fe); return K ? K[0] : " " } function replaceSpace() { return " " } function trimFactory(fe) { return K; function K(pe, me, ge) { return me === 0 || me + pe.length === ge.length ? "" : fe(pe) } } function remarkMarkAndUnravel() { return function (fe) { visit$1(fe, function (K, pe, me) { let ge = -1, xe = !0, ye = !1; if (me && typeof pe == "number" && K.type === "paragraph") { const ve = K.children; for (; ++ge < ve.length;) { const _e = ve[ge]; if (_e.type === "mdxJsxTextElement" || _e.type === "mdxTextExpression") ye = !0; else if (!(_e.type === "text" && collapseWhiteSpace(_e.value, { style: "html", trim: !0 }) === "")) { xe = !1; break } } if (xe && ye) { ge = -1; const _e = []; for (; ++ge < ve.length;) { const Ee = ve[ge]; Ee.type === "mdxJsxTextElement" && (Ee.type = "mdxJsxFlowElement"), Ee.type === "mdxTextExpression" && (Ee.type = "mdxFlowExpression"), Ee.type === "text" && /^[\t\r\n ]+$/.test(String(Ee.value)) || _e.push(Ee) } return me.children.splice(pe, 1, ..._e), pe } } if (K.type === "mdxJsxFlowElement" || K.type === "mdxJsxTextElement") { const ve = K.data || (K.data = {}); ve._mdxExplicitJsx = !0 } (K.type === "mdxFlowExpression" || K.type === "mdxTextExpression" || K.type === "mdxjsEsm") && K.data && K.data.estree && walk(K.data.estree, { enter(ve) { if (ve.type === "JSXElement") { const _e = ve.data || (ve.data = {}); _e._mdxExplicitJsx = !0 } } }) }) } } const nodeTypes = ["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]; let warned = !1; function createProcessor(fe) { const K = fe || {}; K.format, (K.jsxRuntime === "classic" || K.pragma || K.pragmaFrag || K.pragmaImportSource) && !warned && (warned = !0, console.warn("Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate")); const pe = unified().use(remarkParse); K.format !== "md" && pe.use(remarkMdx); const me = K.remarkRehypeOptions || {}; return pe.use(remarkMarkAndUnravel).use(K.remarkPlugins || []).use(remarkRehype, { ...me, allowDangerousHtml: !0, passThrough: [...me.passThrough || [], ...nodeTypes] }).use(K.rehypePlugins || []), K.format === "md" && pe.use(rehypeRemoveRaw), pe.use(rehypeRecma, K).use(recmaDocument, K).use(recmaJsxRewrite, K), K.jsx || pe.use(recmaJsx$1, K).use(recmaBuildJsxTransform, K), pe.use(recmaJsx).use(recmaStringify, K).use(K.recmaPlugins || []), pe } function compile(fe, K) { const { file: pe, options: me } = resolveFileAndOptions(fe, K); return createProcessor(me).process(pe) } function resolveEvaluateOptions(fe) { const { Fragment: K, baseUrl: pe, development: me, jsx: ge, jsxDEV: xe, jsxs: ye, useMDXComponents: ve, ..._e } = fe || {}; if (!K) throw new Error("Expected `Fragment` given to `evaluate`"); if (me) { if (!xe) throw new Error("Expected `jsxDEV` given to `evaluate`") } else { if (!ge) throw new Error("Expected `jsx` given to `evaluate`"); if (!ye) throw new Error("Expected `jsxs` given to `evaluate`") } return { compiletime: { ..._e, development: me, outputFormat: "function-body", providerImportSource: ve ? "#" : void 0 }, runtime: { Fragment: K, baseUrl: pe, jsx: ge, jsxDEV: xe, jsxs: ye, useMDXComponents: ve } } } const AsyncFunction = Object.getPrototypeOf(run).constructor; async function run(fe, K) { return new AsyncFunction(String(fe))(K) } async function evaluate(fe, K) { const { compiletime: pe, runtime: me } = resolveEvaluateOptions(K); return run(await compile(fe, pe), me) } function escapeStringRegexp(fe) { if (typeof fe != "string") throw new TypeError("Expected a string"); return fe.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } function findAndReplace(fe, K, pe) { const ge = convert$1((pe || {}).ignore || []), xe = toPairs(K); let ye = -1; for (; ++ye < xe.length;)visitParents$1(fe, "text", ve); function ve(Ee, be) { let Ae = -1, Se; for (; ++Ae < be.length;) { const Ce = be[Ae], we = Se ? Se.children : void 0; if (ge(Ce, we ? we.indexOf(Ce) : void 0, Se)) return; Se = Ce } if (Se) return _e(Ee, be) } function _e(Ee, be) { const Ae = be[be.length - 1], Se = xe[ye][0], Ce = xe[ye][1]; let we = 0; const De = Ae.children.indexOf(Ee); let Re = !1, Ie = []; Se.lastIndex = 0; let Pe = Se.exec(Ee.value); for (; Pe;) { const Ne = Pe.index, ke = { index: Pe.index, input: Pe.input, stack: [...be, Ee] }; let Oe = Ce(...Pe, ke); if (typeof Oe == "string" && (Oe = Oe.length > 0 ? { type: "text", value: Oe } : void 0), Oe === !1 ? Se.lastIndex = Ne + 1 : (we !== Ne && Ie.push({ type: "text", value: Ee.value.slice(we, Ne) }), Array.isArray(Oe) ? Ie.push(...Oe) : Oe && Ie.push(Oe), we = Ne + Pe[0].length, Re = !0), !Se.global) break; Pe = Se.exec(Ee.value) } return Re ? (we < Ee.value.length && Ie.push({ type: "text", value: Ee.value.slice(we) }), Ae.children.splice(De, 1, ...Ie)) : Ie = [Ee], De + Ie.length } } function toPairs(fe) { const K = []; if (!Array.isArray(fe)) throw new TypeError("Expected find and replace tuple or list of tuples"); const pe = !fe[0] || Array.isArray(fe[0]) ? fe : [fe]; let me = -1; for (; ++me < pe.length;) { const ge = pe[me]; K.push([toExpression(ge[0]), toFunction(ge[1])]) } return K } function toExpression(fe) { return typeof fe == "string" ? new RegExp(escapeStringRegexp(fe), "g") : fe } function toFunction(fe) { return typeof fe == "function" ? fe : function () { return fe } } const inConstruct = "phrasing", notInConstruct = ["autolink", "link", "image", "label"]; function gfmAutolinkLiteralFromMarkdown() { return { transforms: [transformGfmAutolinkLiterals], enter: { literalAutolink: enterLiteralAutolink, literalAutolinkEmail: enterLiteralAutolinkValue, literalAutolinkHttp: enterLiteralAutolinkValue, literalAutolinkWww: enterLiteralAutolinkValue }, exit: { literalAutolink: exitLiteralAutolink, literalAutolinkEmail: exitLiteralAutolinkEmail, literalAutolinkHttp: exitLiteralAutolinkHttp, literalAutolinkWww: exitLiteralAutolinkWww } } } function gfmAutolinkLiteralToMarkdown() { return { unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct, notInConstruct }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct, notInConstruct }, { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }] } } function enterLiteralAutolink(fe) { this.enter({ type: "link", title: null, url: "", children: [] }, fe) } function enterLiteralAutolinkValue(fe) { this.config.enter.autolinkProtocol.call(this, fe) } function exitLiteralAutolinkHttp(fe) { this.config.exit.autolinkProtocol.call(this, fe) } function exitLiteralAutolinkWww(fe) { this.config.exit.data.call(this, fe); const K = this.stack[this.stack.length - 1]; K.type, K.url = "http://" + this.sliceSerialize(fe) } function exitLiteralAutolinkEmail(fe) { this.config.exit.autolinkEmail.call(this, fe) } function exitLiteralAutolink(fe) { this.exit(fe) } function transformGfmAutolinkLiterals(fe) { findAndReplace(fe, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]], { ignore: ["link", "linkReference"] }) } function findUrl(fe, K, pe, me, ge) { let xe = ""; if (!previous(ge) || (/^w/i.test(K) && (pe = K + pe, K = "", xe = "http://"), !isCorrectDomain(pe))) return !1; const ye = splitUrl(pe + me); if (!ye[0]) return !1; const ve = { type: "link", title: null, url: xe + K + ye[0], children: [{ type: "text", value: K + ye[0] }] }; return ye[1] ? [ve, { type: "text", value: ye[1] }] : ve } function findEmail(fe, K, pe, me) { return !previous(me, !0) || /[-\d_]$/.test(pe) ? !1 : { type: "link", title: null, url: "mailto:" + K + "@" + pe, children: [{ type: "text", value: K + "@" + pe }] } } function isCorrectDomain(fe) { const K = fe.split("."); return !(K.length < 2 || K[K.length - 1] && (/_/.test(K[K.length - 1]) || !/[a-zA-Z\d]/.test(K[K.length - 1])) || K[K.length - 2] && (/_/.test(K[K.length - 2]) || !/[a-zA-Z\d]/.test(K[K.length - 2]))) } function splitUrl(fe) { const K = /[!"&'),.:;<>?\]}]+$/.exec(fe); if (!K) return [fe, void 0]; fe = fe.slice(0, K.index); let pe = K[0], me = pe.indexOf(")"); const ge = ccount(fe, "("); let xe = ccount(fe, ")"); for (; me !== -1 && ge > xe;)fe += pe.slice(0, me + 1), pe = pe.slice(me + 1), me = pe.indexOf(")"), xe++; return [fe, pe] } function previous(fe, K) { const pe = fe.input.charCodeAt(fe.index - 1); return (fe.index === 0 || unicodeWhitespace(pe) || unicodePunctuation(pe)) && (!K || pe !== 47) } footnoteReference.peek = footnoteReferencePeek; function enterFootnoteCallString() { this.buffer() } function enterFootnoteCall(fe) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, fe) } function enterFootnoteDefinitionLabelString() { this.buffer() } function enterFootnoteDefinition(fe) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, fe) } function exitFootnoteCallString(fe) { const K = this.resume(), pe = this.stack[this.stack.length - 1]; pe.type, pe.identifier = normalizeIdentifier(this.sliceSerialize(fe)).toLowerCase(), pe.label = K } function exitFootnoteCall(fe) { this.exit(fe) } function exitFootnoteDefinitionLabelString(fe) { const K = this.resume(), pe = this.stack[this.stack.length - 1]; pe.type, pe.identifier = normalizeIdentifier(this.sliceSerialize(fe)).toLowerCase(), pe.label = K } function exitFootnoteDefinition(fe) { this.exit(fe) } function footnoteReferencePeek() { return "[" } function footnoteReference(fe, K, pe, me) { const ge = pe.createTracker(me); let xe = ge.move("[^"); const ye = pe.enter("footnoteReference"), ve = pe.enter("reference"); return xe += ge.move(pe.safe(pe.associationId(fe), { after: "]", before: xe })), ve(), ye(), xe += ge.move("]"), xe } function gfmFootnoteFromMarkdown() { return { enter: { gfmFootnoteCallString: enterFootnoteCallString, gfmFootnoteCall: enterFootnoteCall, gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString, gfmFootnoteDefinition: enterFootnoteDefinition }, exit: { gfmFootnoteCallString: exitFootnoteCallString, gfmFootnoteCall: exitFootnoteCall, gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString, gfmFootnoteDefinition: exitFootnoteDefinition } } } function gfmFootnoteToMarkdown(fe) {
	let K = !1; return fe && fe.firstLineBlank && (K = !0), { handlers: { footnoteDefinition: pe, footnoteReference }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] }; function pe(me, ge, xe, ye) {
		const ve = xe.createTracker(ye); let _e = ve.move("[^"); const Ee = xe.enter("footnoteDefinition"), be = xe.enter("label"); return _e += ve.move(xe.safe(xe.associationId(me), { before: _e, after: "]" })), be(), _e += ve.move("]:"), me.children && me.children.length > 0 && (ve.shift(4), _e += ve.move((K ? `
`: " ") + xe.indentLines(xe.containerFlow(me, ve.current()), K ? mapAll : mapExceptFirst))), Ee(), _e
	}
} function mapExceptFirst(fe, K, pe) { return K === 0 ? fe : mapAll(fe, K, pe) } function mapAll(fe, K, pe) { return (pe ? "" : "    ") + fe } const constructsWithoutStrikethrough = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; handleDelete.peek = peekDelete; function gfmStrikethroughFromMarkdown() { return { canContainEols: ["delete"], enter: { strikethrough: enterStrikethrough }, exit: { strikethrough: exitStrikethrough } } } function gfmStrikethroughToMarkdown() { return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: constructsWithoutStrikethrough }], handlers: { delete: handleDelete } } } function enterStrikethrough(fe) { this.enter({ type: "delete", children: [] }, fe) } function exitStrikethrough(fe) { this.exit(fe) } function handleDelete(fe, K, pe, me) { const ge = pe.createTracker(me), xe = pe.enter("strikethrough"); let ye = ge.move("~~"); return ye += pe.containerPhrasing(fe, { ...ge.current(), before: ye, after: "~" }), ye += ge.move("~~"), xe(), ye } function peekDelete() { return "~" } function defaultStringLength(fe) { return fe.length } function markdownTable(fe, K) {
	const pe = K || {}, me = (pe.align || []).concat(), ge = pe.stringLength || defaultStringLength, xe = [], ye = [], ve = [], _e = []; let Ee = 0, be = -1; for (; ++be < fe.length;) { const Be = [], De = []; let Re = -1; for (fe[be].length > Ee && (Ee = fe[be].length); ++Re < fe[be].length;) { const Ie = serialize(fe[be][Re]); if (pe.alignDelimiters !== !1) { const Pe = ge(Ie); De[Re] = Pe, (_e[Re] === void 0 || Pe > _e[Re]) && (_e[Re] = Pe) } Be.push(Ie) } ye[be] = Be, ve[be] = De } let Ae = -1; if (typeof me == "object" && "length" in me) for (; ++Ae < Ee;)xe[Ae] = toAlignment(me[Ae]); else { const Be = toAlignment(me); for (; ++Ae < Ee;)xe[Ae] = Be } Ae = -1; const Se = [], Ce = []; for (; ++Ae < Ee;) { const Be = xe[Ae]; let De = "", Re = ""; Be === 99 ? (De = ":", Re = ":") : Be === 108 ? De = ":" : Be === 114 && (Re = ":"); let Ie = pe.alignDelimiters === !1 ? 1 : Math.max(1, _e[Ae] - De.length - Re.length); const Pe = De + "-".repeat(Ie) + Re; pe.alignDelimiters !== !1 && (Ie = De.length + Ie + Re.length, Ie > _e[Ae] && (_e[Ae] = Ie), Ce[Ae] = Ie), Se[Ae] = Pe } ye.splice(1, 0, Se), ve.splice(1, 0, Ce), be = -1; const we = []; for (; ++be < ye.length;) { const Be = ye[be], De = ve[be]; Ae = -1; const Re = []; for (; ++Ae < Ee;) { const Ie = Be[Ae] || ""; let Pe = "", Ne = ""; if (pe.alignDelimiters !== !1) { const ke = _e[Ae] - (De[Ae] || 0), Oe = xe[Ae]; Oe === 114 ? Pe = " ".repeat(ke) : Oe === 99 ? ke % 2 ? (Pe = " ".repeat(ke / 2 + .5), Ne = " ".repeat(ke / 2 - .5)) : (Pe = " ".repeat(ke / 2), Ne = Pe) : Ne = " ".repeat(ke) } pe.delimiterStart !== !1 && !Ae && Re.push("|"), pe.padding !== !1 && !(pe.alignDelimiters === !1 && Ie === "") && (pe.delimiterStart !== !1 || Ae) && Re.push(" "), pe.alignDelimiters !== !1 && Re.push(Pe), Re.push(Ie), pe.alignDelimiters !== !1 && Re.push(Ne), pe.padding !== !1 && Re.push(" "), (pe.delimiterEnd !== !1 || Ae !== Ee - 1) && Re.push("|") } we.push(pe.delimiterEnd === !1 ? Re.join("").replace(/ +$/, "") : Re.join("")) } return we.join(`
`)
} function serialize(fe) { return fe == null ? "" : String(fe) } function toAlignment(fe) { const K = typeof fe == "string" ? fe.codePointAt(0) : 0; return K === 67 || K === 99 ? 99 : K === 76 || K === 108 ? 108 : K === 82 || K === 114 ? 114 : 0 } function blockquote(fe, K, pe, me) { const ge = pe.enter("blockquote"), xe = pe.createTracker(me); xe.move("> "), xe.shift(2); const ye = pe.indentLines(pe.containerFlow(fe, xe.current()), map$1); return ge(), ye } function map$1(fe, K, pe) { return ">" + (pe ? "" : " ") + fe } function patternInScope(fe, K) { return listInScope(fe, K.inConstruct, !0) && !listInScope(fe, K.notInConstruct, !1) } function listInScope(fe, K, pe) { if (typeof K == "string" && (K = [K]), !K || K.length === 0) return pe; let me = -1; for (; ++me < K.length;)if (fe.includes(K[me])) return !0; return !1 } function hardBreak(fe, K, pe, me) {
	let ge = -1; for (; ++ge < pe.unsafe.length;)if (pe.unsafe[ge].character === `
`&& patternInScope(pe.stack, pe.unsafe[ge])) return /[ \t]/.test(me.before) ? "" : " "; return `\\
`} function longestStreak(fe, K) { const pe = String(fe); let me = pe.indexOf(K), ge = me, xe = 0, ye = 0; if (typeof K != "string") throw new TypeError("Expected substring"); for (; me !== -1;)me === ge ? ++xe > ye && (ye = xe) : xe = 1, ge = me + K.length, me = pe.indexOf(K, ge); return ye } function formatCodeAsIndented(fe, K) { return !!(K.options.fences === !1 && fe.value && !fe.lang && /[^ \r\n]/.test(fe.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(fe.value)) } function checkFence(fe) { const K = fe.options.fence || "`"; if (K !== "`" && K !== "~") throw new Error("Cannot serialize code with `" + K + "` for `options.fence`, expected `` ` `` or `~`"); return K } function code$1(fe, K, pe, me) {
	const ge = checkFence(pe), xe = fe.value || "", ye = ge === "`" ? "GraveAccent" : "Tilde"; if (formatCodeAsIndented(fe, pe)) { const Ae = pe.enter("codeIndented"), Se = pe.indentLines(xe, map); return Ae(), Se } const ve = pe.createTracker(me), _e = ge.repeat(Math.max(longestStreak(xe, ge) + 1, 3)), Ee = pe.enter("codeFenced"); let be = ve.move(_e); if (fe.lang) { const Ae = pe.enter(`codeFencedLang${ye}`); be += ve.move(pe.safe(fe.lang, { before: be, after: " ", encode: ["`"], ...ve.current() })), Ae() } if (fe.lang && fe.meta) {
		const Ae = pe.enter(`codeFencedMeta${ye}`); be += ve.move(" "), be += ve.move(pe.safe(fe.meta, {
			before: be, after: `
`, encode: ["`"], ...ve.current()
		})), Ae()
	} return be += ve.move(`
`), xe && (be += ve.move(xe + `
`)), be += ve.move(_e), Ee(), be
} function map(fe, K, pe) { return (pe ? "" : "    ") + fe } function checkQuote(fe) { const K = fe.options.quote || '"'; if (K !== '"' && K !== "'") throw new Error("Cannot serialize title with `" + K + "` for `options.quote`, expected `\"`, or `'`"); return K } function definition(fe, K, pe, me) {
	const ge = checkQuote(pe), xe = ge === '"' ? "Quote" : "Apostrophe", ye = pe.enter("definition"); let ve = pe.enter("label"); const _e = pe.createTracker(me); let Ee = _e.move("["); return Ee += _e.move(pe.safe(pe.associationId(fe), { before: Ee, after: "]", ..._e.current() })), Ee += _e.move("]: "), ve(), !fe.url || /[\0- \u007F]/.test(fe.url) ? (ve = pe.enter("destinationLiteral"), Ee += _e.move("<"), Ee += _e.move(pe.safe(fe.url, { before: Ee, after: ">", ..._e.current() })), Ee += _e.move(">")) : (ve = pe.enter("destinationRaw"), Ee += _e.move(pe.safe(fe.url, {
		before: Ee, after: fe.title ? " " : `
`, ..._e.current()
	}))), ve(), fe.title && (ve = pe.enter(`title${xe}`), Ee += _e.move(" " + ge), Ee += _e.move(pe.safe(fe.title, { before: Ee, after: ge, ..._e.current() })), Ee += _e.move(ge), ve()), ye(), Ee
} function checkEmphasis(fe) { const K = fe.options.emphasis || "*"; if (K !== "*" && K !== "_") throw new Error("Cannot serialize emphasis with `" + K + "` for `options.emphasis`, expected `*`, or `_`"); return K } function encodeCharacterReference(fe) { return "&#x" + fe.toString(16).toUpperCase() + ";" } function encodeInfo(fe, K, pe) { const me = classifyCharacter(fe), ge = classifyCharacter(K); return me === void 0 ? ge === void 0 ? pe === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : ge === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : me === 1 ? ge === void 0 ? { inside: !1, outside: !1 } : ge === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : ge === void 0 ? { inside: !1, outside: !1 } : ge === 1 ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } emphasis.peek = emphasisPeek; function emphasis(fe, K, pe, me) { const ge = checkEmphasis(pe), xe = pe.enter("emphasis"), ye = pe.createTracker(me), ve = ye.move(ge); let _e = ye.move(pe.containerPhrasing(fe, { after: ge, before: ve, ...ye.current() })); const Ee = _e.charCodeAt(0), be = encodeInfo(me.before.charCodeAt(me.before.length - 1), Ee, ge); be.inside && (_e = encodeCharacterReference(Ee) + _e.slice(1)); const Ae = _e.charCodeAt(_e.length - 1), Se = encodeInfo(me.after.charCodeAt(0), Ae, ge); Se.inside && (_e = _e.slice(0, -1) + encodeCharacterReference(Ae)); const Ce = ye.move(ge); return xe(), pe.attentionEncodeSurroundingInfo = { after: Se.outside, before: be.outside }, ve + _e + Ce } function emphasisPeek(fe, K, pe) { return pe.options.emphasis || "*" } function formatHeadingAsSetext(fe, K) { let pe = !1; return visit$1(fe, function (me) { if ("value" in me && /\r?\n|\r/.test(me.value) || me.type === "break") return pe = !0, EXIT$1 }), !!((!fe.depth || fe.depth < 3) && toString$2(fe) && (K.options.setext || pe)) } function heading(fe, K, pe, me) {
	const ge = Math.max(Math.min(6, fe.depth || 1), 1), xe = pe.createTracker(me); if (formatHeadingAsSetext(fe, pe)) {
		const be = pe.enter("headingSetext"), Ae = pe.enter("phrasing"), Se = pe.containerPhrasing(fe, {
			...xe.current(), before: `
`, after: `
`}); return Ae(), be(), Se + `
`+ (ge === 1 ? "=" : "-").repeat(Se.length - (Math.max(Se.lastIndexOf("\r"), Se.lastIndexOf(`
`)) + 1))
	} const ye = "#".repeat(ge), ve = pe.enter("headingAtx"), _e = pe.enter("phrasing"); xe.move(ye + " "); let Ee = pe.containerPhrasing(fe, {
		before: "# ", after: `
`, ...xe.current()
	}); return /^[\t ]/.test(Ee) && (Ee = encodeCharacterReference(Ee.charCodeAt(0)) + Ee.slice(1)), Ee = Ee ? ye + " " + Ee : ye, pe.options.closeAtx && (Ee += " " + ye), _e(), ve(), Ee
} html.peek = htmlPeek; function html(fe) { return fe.value || "" } function htmlPeek() { return "<" } image.peek = imagePeek; function image(fe, K, pe, me) { const ge = checkQuote(pe), xe = ge === '"' ? "Quote" : "Apostrophe", ye = pe.enter("image"); let ve = pe.enter("label"); const _e = pe.createTracker(me); let Ee = _e.move("!["); return Ee += _e.move(pe.safe(fe.alt, { before: Ee, after: "]", ..._e.current() })), Ee += _e.move("]("), ve(), !fe.url && fe.title || /[\0- \u007F]/.test(fe.url) ? (ve = pe.enter("destinationLiteral"), Ee += _e.move("<"), Ee += _e.move(pe.safe(fe.url, { before: Ee, after: ">", ..._e.current() })), Ee += _e.move(">")) : (ve = pe.enter("destinationRaw"), Ee += _e.move(pe.safe(fe.url, { before: Ee, after: fe.title ? " " : ")", ..._e.current() }))), ve(), fe.title && (ve = pe.enter(`title${xe}`), Ee += _e.move(" " + ge), Ee += _e.move(pe.safe(fe.title, { before: Ee, after: ge, ..._e.current() })), Ee += _e.move(ge), ve()), Ee += _e.move(")"), ye(), Ee } function imagePeek() { return "!" } imageReference.peek = imageReferencePeek; function imageReference(fe, K, pe, me) { const ge = fe.referenceType, xe = pe.enter("imageReference"); let ye = pe.enter("label"); const ve = pe.createTracker(me); let _e = ve.move("!["); const Ee = pe.safe(fe.alt, { before: _e, after: "]", ...ve.current() }); _e += ve.move(Ee + "]["), ye(); const be = pe.stack; pe.stack = [], ye = pe.enter("reference"); const Ae = pe.safe(pe.associationId(fe), { before: _e, after: "]", ...ve.current() }); return ye(), pe.stack = be, xe(), ge === "full" || !Ee || Ee !== Ae ? _e += ve.move(Ae + "]") : ge === "shortcut" ? _e = _e.slice(0, -1) : _e += ve.move("]"), _e } function imageReferencePeek() { return "!" } inlineCode.peek = inlineCodePeek; function inlineCode(fe, K, pe) { let me = fe.value || "", ge = "`", xe = -1; for (; new RegExp("(^|[^`])" + ge + "([^`]|$)").test(me);)ge += "`"; for (/[^ \r\n]/.test(me) && (/^[ \r\n]/.test(me) && /[ \r\n]$/.test(me) || /^`|`$/.test(me)) && (me = " " + me + " "); ++xe < pe.unsafe.length;) { const ye = pe.unsafe[xe], ve = pe.compilePattern(ye); let _e; if (ye.atBreak) for (; _e = ve.exec(me);) { let Ee = _e.index; me.charCodeAt(Ee) === 10 && me.charCodeAt(Ee - 1) === 13 && Ee--, me = me.slice(0, Ee) + " " + me.slice(_e.index + 1) } } return ge + me + ge } function inlineCodePeek() { return "`" } function formatLinkAsAutolink(fe, K) { const pe = toString$2(fe); return !!(!K.options.resourceLink && fe.url && !fe.title && fe.children && fe.children.length === 1 && fe.children[0].type === "text" && (pe === fe.url || "mailto:" + pe === fe.url) && /^[a-z][a-z+.-]+:/i.test(fe.url) && !/[\0- <>\u007F]/.test(fe.url)) } link.peek = linkPeek; function link(fe, K, pe, me) { const ge = checkQuote(pe), xe = ge === '"' ? "Quote" : "Apostrophe", ye = pe.createTracker(me); let ve, _e; if (formatLinkAsAutolink(fe, pe)) { const be = pe.stack; pe.stack = [], ve = pe.enter("autolink"); let Ae = ye.move("<"); return Ae += ye.move(pe.containerPhrasing(fe, { before: Ae, after: ">", ...ye.current() })), Ae += ye.move(">"), ve(), pe.stack = be, Ae } ve = pe.enter("link"), _e = pe.enter("label"); let Ee = ye.move("["); return Ee += ye.move(pe.containerPhrasing(fe, { before: Ee, after: "](", ...ye.current() })), Ee += ye.move("]("), _e(), !fe.url && fe.title || /[\0- \u007F]/.test(fe.url) ? (_e = pe.enter("destinationLiteral"), Ee += ye.move("<"), Ee += ye.move(pe.safe(fe.url, { before: Ee, after: ">", ...ye.current() })), Ee += ye.move(">")) : (_e = pe.enter("destinationRaw"), Ee += ye.move(pe.safe(fe.url, { before: Ee, after: fe.title ? " " : ")", ...ye.current() }))), _e(), fe.title && (_e = pe.enter(`title${xe}`), Ee += ye.move(" " + ge), Ee += ye.move(pe.safe(fe.title, { before: Ee, after: ge, ...ye.current() })), Ee += ye.move(ge), _e()), Ee += ye.move(")"), ve(), Ee } function linkPeek(fe, K, pe) { return formatLinkAsAutolink(fe, pe) ? "<" : "[" } linkReference.peek = linkReferencePeek; function linkReference(fe, K, pe, me) { const ge = fe.referenceType, xe = pe.enter("linkReference"); let ye = pe.enter("label"); const ve = pe.createTracker(me); let _e = ve.move("["); const Ee = pe.containerPhrasing(fe, { before: _e, after: "]", ...ve.current() }); _e += ve.move(Ee + "]["), ye(); const be = pe.stack; pe.stack = [], ye = pe.enter("reference"); const Ae = pe.safe(pe.associationId(fe), { before: _e, after: "]", ...ve.current() }); return ye(), pe.stack = be, xe(), ge === "full" || !Ee || Ee !== Ae ? _e += ve.move(Ae + "]") : ge === "shortcut" ? _e = _e.slice(0, -1) : _e += ve.move("]"), _e } function linkReferencePeek() { return "[" } function checkBullet(fe) { const K = fe.options.bullet || "*"; if (K !== "*" && K !== "+" && K !== "-") throw new Error("Cannot serialize items with `" + K + "` for `options.bullet`, expected `*`, `+`, or `-`"); return K } function checkBulletOther(fe) { const K = checkBullet(fe), pe = fe.options.bulletOther; if (!pe) return K === "*" ? "-" : "*"; if (pe !== "*" && pe !== "+" && pe !== "-") throw new Error("Cannot serialize items with `" + pe + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (pe === K) throw new Error("Expected `bullet` (`" + K + "`) and `bulletOther` (`" + pe + "`) to be different"); return pe } function checkBulletOrdered(fe) { const K = fe.options.bulletOrdered || "."; if (K !== "." && K !== ")") throw new Error("Cannot serialize items with `" + K + "` for `options.bulletOrdered`, expected `.` or `)`"); return K } function checkRule(fe) { const K = fe.options.rule || "*"; if (K !== "*" && K !== "-" && K !== "_") throw new Error("Cannot serialize rules with `" + K + "` for `options.rule`, expected `*`, `-`, or `_`"); return K } function list(fe, K, pe, me) { const ge = pe.enter("list"), xe = pe.bulletCurrent; let ye = fe.ordered ? checkBulletOrdered(pe) : checkBullet(pe); const ve = fe.ordered ? ye === "." ? ")" : "." : checkBulletOther(pe); let _e = K && pe.bulletLastUsed ? ye === pe.bulletLastUsed : !1; if (!fe.ordered) { const be = fe.children ? fe.children[0] : void 0; if ((ye === "*" || ye === "-") && be && (!be.children || !be.children[0]) && pe.stack[pe.stack.length - 1] === "list" && pe.stack[pe.stack.length - 2] === "listItem" && pe.stack[pe.stack.length - 3] === "list" && pe.stack[pe.stack.length - 4] === "listItem" && pe.indexStack[pe.indexStack.length - 1] === 0 && pe.indexStack[pe.indexStack.length - 2] === 0 && pe.indexStack[pe.indexStack.length - 3] === 0 && (_e = !0), checkRule(pe) === ye && be) { let Ae = -1; for (; ++Ae < fe.children.length;) { const Se = fe.children[Ae]; if (Se && Se.type === "listItem" && Se.children && Se.children[0] && Se.children[0].type === "thematicBreak") { _e = !0; break } } } } _e && (ye = ve), pe.bulletCurrent = ye; const Ee = pe.containerFlow(fe, me); return pe.bulletLastUsed = ye, pe.bulletCurrent = xe, ge(), Ee } function checkListItemIndent(fe) { const K = fe.options.listItemIndent || "one"; if (K !== "tab" && K !== "one" && K !== "mixed") throw new Error("Cannot serialize items with `" + K + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return K } function listItem(fe, K, pe, me) { const ge = checkListItemIndent(pe); let xe = pe.bulletCurrent || checkBullet(pe); K && K.type === "list" && K.ordered && (xe = (typeof K.start == "number" && K.start > -1 ? K.start : 1) + (pe.options.incrementListMarker === !1 ? 0 : K.children.indexOf(fe)) + xe); let ye = xe.length + 1; (ge === "tab" || ge === "mixed" && (K && K.type === "list" && K.spread || fe.spread)) && (ye = Math.ceil(ye / 4) * 4); const ve = pe.createTracker(me); ve.move(xe + " ".repeat(ye - xe.length)), ve.shift(ye); const _e = pe.enter("listItem"), Ee = pe.indentLines(pe.containerFlow(fe, ve.current()), be); return _e(), Ee; function be(Ae, Se, Ce) { return Se ? (Ce ? "" : " ".repeat(ye)) + Ae : (Ce ? xe : xe + " ".repeat(ye - xe.length)) + Ae } } function paragraph(fe, K, pe, me) { const ge = pe.enter("paragraph"), xe = pe.enter("phrasing"), ye = pe.containerPhrasing(fe, me); return xe(), ge(), ye } const phrasing = convert$1(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function root(fe, K, pe, me) { return (fe.children.some(function (ye) { return phrasing(ye) }) ? pe.containerPhrasing : pe.containerFlow).call(pe, fe, me) } function checkStrong(fe) { const K = fe.options.strong || "*"; if (K !== "*" && K !== "_") throw new Error("Cannot serialize strong with `" + K + "` for `options.strong`, expected `*`, or `_`"); return K } strong.peek = strongPeek; function strong(fe, K, pe, me) { const ge = checkStrong(pe), xe = pe.enter("strong"), ye = pe.createTracker(me), ve = ye.move(ge + ge); let _e = ye.move(pe.containerPhrasing(fe, { after: ge, before: ve, ...ye.current() })); const Ee = _e.charCodeAt(0), be = encodeInfo(me.before.charCodeAt(me.before.length - 1), Ee, ge); be.inside && (_e = encodeCharacterReference(Ee) + _e.slice(1)); const Ae = _e.charCodeAt(_e.length - 1), Se = encodeInfo(me.after.charCodeAt(0), Ae, ge); Se.inside && (_e = _e.slice(0, -1) + encodeCharacterReference(Ae)); const Ce = ye.move(ge + ge); return xe(), pe.attentionEncodeSurroundingInfo = { after: Se.outside, before: be.outside }, ve + _e + Ce } function strongPeek(fe, K, pe) { return pe.options.strong || "*" } function text$1(fe, K, pe, me) { return pe.safe(fe.value, me) } function checkRuleRepetition(fe) { const K = fe.options.ruleRepetition || 3; if (K < 3) throw new Error("Cannot serialize rules with repetition `" + K + "` for `options.ruleRepetition`, expected `3` or more"); return K } function thematicBreak(fe, K, pe) { const me = (checkRule(pe) + (pe.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(pe)); return pe.options.ruleSpaces ? me.slice(0, -1) : me } const handle = { blockquote, break: hardBreak, code: code$1, definition, emphasis, hardBreak, heading, html, image, imageReference, inlineCode, link, linkReference, list, listItem, paragraph, root, strong, text: text$1, thematicBreak }; function gfmTableFromMarkdown() { return { enter: { table: enterTable, tableData: enterCell, tableHeader: enterCell, tableRow: enterRow }, exit: { codeText: exitCodeText, table: exitTable, tableData: exit, tableHeader: exit, tableRow: exit } } } function enterTable(fe) { const K = fe._align; this.enter({ type: "table", align: K.map(function (pe) { return pe === "none" ? null : pe }), children: [] }, fe), this.data.inTable = !0 } function exitTable(fe) { this.exit(fe), this.data.inTable = void 0 } function enterRow(fe) { this.enter({ type: "tableRow", children: [] }, fe) } function exit(fe) { this.exit(fe) } function enterCell(fe) { this.enter({ type: "tableCell", children: [] }, fe) } function exitCodeText(fe) { let K = this.resume(); this.data.inTable && (K = K.replace(/\\([\\|])/g, replace)); const pe = this.stack[this.stack.length - 1]; pe.type, pe.value = K, this.exit(fe) } function replace(fe, K) { return K === "|" ? K : fe } function gfmTableToMarkdown(fe) {
	const K = fe || {}, pe = K.tableCellPadding, me = K.tablePipeAlign, ge = K.stringLength, xe = pe ? " " : "|"; return {
		unsafe: [{ character: "\r", inConstruct: "tableCell" }, {
			character: `
`, inConstruct: "tableCell"
		}, { atBreak: !0, character: "|", after: "[	 :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: Se, table: ye, tableCell: _e, tableRow: ve }
	}; function ye(Ce, we, Be, De) { return Ee(be(Ce, Be, De), Ce.align) } function ve(Ce, we, Be, De) {
		const Re = Ae(Ce, Be, De), Ie = Ee([Re]); return Ie.slice(0, Ie.indexOf(`
`))
	} function _e(Ce, we, Be, De) { const Re = Be.enter("tableCell"), Ie = Be.enter("phrasing"), Pe = Be.containerPhrasing(Ce, { ...De, before: xe, after: xe }); return Ie(), Re(), Pe } function Ee(Ce, we) { return markdownTable(Ce, { align: we, alignDelimiters: me, padding: pe, stringLength: ge }) } function be(Ce, we, Be) { const De = Ce.children; let Re = -1; const Ie = [], Pe = we.enter("table"); for (; ++Re < De.length;)Ie[Re] = Ae(De[Re], we, Be); return Pe(), Ie } function Ae(Ce, we, Be) { const De = Ce.children; let Re = -1; const Ie = [], Pe = we.enter("tableRow"); for (; ++Re < De.length;)Ie[Re] = _e(De[Re], Ce, we, Be); return Pe(), Ie } function Se(Ce, we, Be) { let De = handle.inlineCode(Ce, we, Be); return Be.stack.includes("tableCell") && (De = De.replace(/\|/g, "\\$&")), De }
} function gfmTaskListItemFromMarkdown() { return { exit: { taskListCheckValueChecked: exitCheck, taskListCheckValueUnchecked: exitCheck, paragraph: exitParagraphWithTaskListItem } } } function gfmTaskListItemToMarkdown() { return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: listItemWithTaskListItem } } } function exitCheck(fe) { const K = this.stack[this.stack.length - 2]; K.type, K.checked = fe.type === "taskListCheckValueChecked" } function exitParagraphWithTaskListItem(fe) { const K = this.stack[this.stack.length - 2]; if (K && K.type === "listItem" && typeof K.checked == "boolean") { const pe = this.stack[this.stack.length - 1]; pe.type; const me = pe.children[0]; if (me && me.type === "text") { const ge = K.children; let xe = -1, ye; for (; ++xe < ge.length;) { const ve = ge[xe]; if (ve.type === "paragraph") { ye = ve; break } } ye === pe && (me.value = me.value.slice(1), me.value.length === 0 ? pe.children.shift() : pe.position && me.position && typeof me.position.start.offset == "number" && (me.position.start.column++, me.position.start.offset++, pe.position.start = Object.assign({}, me.position.start))) } } this.exit(fe) } function listItemWithTaskListItem(fe, K, pe, me) { const ge = fe.children[0], xe = typeof fe.checked == "boolean" && ge && ge.type === "paragraph", ye = "[" + (fe.checked ? "x" : " ") + "] ", ve = pe.createTracker(me); xe && ve.move(ye); let _e = handle.listItem(fe, K, pe, { ...me, ...ve.current() }); return xe && (_e = _e.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, Ee)), _e; function Ee(be) { return be + ye } } function gfmFromMarkdown() { return [gfmAutolinkLiteralFromMarkdown(), gfmFootnoteFromMarkdown(), gfmStrikethroughFromMarkdown(), gfmTableFromMarkdown(), gfmTaskListItemFromMarkdown()] } function gfmToMarkdown(fe) { return { extensions: [gfmAutolinkLiteralToMarkdown(), gfmFootnoteToMarkdown(fe), gfmStrikethroughToMarkdown(), gfmTableToMarkdown(fe), gfmTaskListItemToMarkdown()] } } const wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: !0 }, domain = { tokenize: tokenizeDomain, partial: !0 }, path = { tokenize: tokenizePath, partial: !0 }, trail = { tokenize: tokenizeTrail, partial: !0 }, emailDomainDotTrail = { tokenize: tokenizeEmailDomainDotTrail, partial: !0 }, wwwAutolink = { name: "wwwAutolink", tokenize: tokenizeWwwAutolink, previous: previousWww }, protocolAutolink = { name: "protocolAutolink", tokenize: tokenizeProtocolAutolink, previous: previousProtocol }, emailAutolink = { name: "emailAutolink", tokenize: tokenizeEmailAutolink, previous: previousEmail }, text = {}; function gfmAutolinkLiteral() { return { text } } let code = 48; for (; code < 123;)text[code] = emailAutolink, code++, code === 58 ? code = 65 : code === 91 && (code = 97); text[43] = emailAutolink; text[45] = emailAutolink; text[46] = emailAutolink; text[95] = emailAutolink; text[72] = [emailAutolink, protocolAutolink]; text[104] = [emailAutolink, protocolAutolink]; text[87] = [emailAutolink, wwwAutolink]; text[119] = [emailAutolink, wwwAutolink]; function tokenizeEmailAutolink(fe, K, pe) { const me = this; let ge, xe; return ye; function ye(Ae) { return !gfmAtext(Ae) || !previousEmail.call(me, me.previous) || previousUnbalanced(me.events) ? pe(Ae) : (fe.enter("literalAutolink"), fe.enter("literalAutolinkEmail"), ve(Ae)) } function ve(Ae) { return gfmAtext(Ae) ? (fe.consume(Ae), ve) : Ae === 64 ? (fe.consume(Ae), _e) : pe(Ae) } function _e(Ae) { return Ae === 46 ? fe.check(emailDomainDotTrail, be, Ee)(Ae) : Ae === 45 || Ae === 95 || asciiAlphanumeric(Ae) ? (xe = !0, fe.consume(Ae), _e) : be(Ae) } function Ee(Ae) { return fe.consume(Ae), ge = !0, _e } function be(Ae) { return xe && ge && asciiAlpha(me.previous) ? (fe.exit("literalAutolinkEmail"), fe.exit("literalAutolink"), K(Ae)) : pe(Ae) } } function tokenizeWwwAutolink(fe, K, pe) { const me = this; return ge; function ge(ye) { return ye !== 87 && ye !== 119 || !previousWww.call(me, me.previous) || previousUnbalanced(me.events) ? pe(ye) : (fe.enter("literalAutolink"), fe.enter("literalAutolinkWww"), fe.check(wwwPrefix, fe.attempt(domain, fe.attempt(path, xe), pe), pe)(ye)) } function xe(ye) { return fe.exit("literalAutolinkWww"), fe.exit("literalAutolink"), K(ye) } } function tokenizeProtocolAutolink(fe, K, pe) { const me = this; let ge = "", xe = !1; return ye; function ye(Ae) { return (Ae === 72 || Ae === 104) && previousProtocol.call(me, me.previous) && !previousUnbalanced(me.events) ? (fe.enter("literalAutolink"), fe.enter("literalAutolinkHttp"), ge += String.fromCodePoint(Ae), fe.consume(Ae), ve) : pe(Ae) } function ve(Ae) { if (asciiAlpha(Ae) && ge.length < 5) return ge += String.fromCodePoint(Ae), fe.consume(Ae), ve; if (Ae === 58) { const Se = ge.toLowerCase(); if (Se === "http" || Se === "https") return fe.consume(Ae), _e } return pe(Ae) } function _e(Ae) { return Ae === 47 ? (fe.consume(Ae), xe ? Ee : (xe = !0, _e)) : pe(Ae) } function Ee(Ae) { return Ae === null || asciiControl(Ae) || markdownLineEndingOrSpace(Ae) || unicodeWhitespace(Ae) || unicodePunctuation(Ae) ? pe(Ae) : fe.attempt(domain, fe.attempt(path, be), pe)(Ae) } function be(Ae) { return fe.exit("literalAutolinkHttp"), fe.exit("literalAutolink"), K(Ae) } } function tokenizeWwwPrefix(fe, K, pe) { let me = 0; return ge; function ge(ye) { return (ye === 87 || ye === 119) && me < 3 ? (me++, fe.consume(ye), ge) : ye === 46 && me === 3 ? (fe.consume(ye), xe) : pe(ye) } function xe(ye) { return ye === null ? pe(ye) : K(ye) } } function tokenizeDomain(fe, K, pe) { let me, ge, xe; return ye; function ye(Ee) { return Ee === 46 || Ee === 95 ? fe.check(trail, _e, ve)(Ee) : Ee === null || markdownLineEndingOrSpace(Ee) || unicodeWhitespace(Ee) || Ee !== 45 && unicodePunctuation(Ee) ? _e(Ee) : (xe = !0, fe.consume(Ee), ye) } function ve(Ee) { return Ee === 95 ? me = !0 : (ge = me, me = void 0), fe.consume(Ee), ye } function _e(Ee) { return ge || me || !xe ? pe(Ee) : K(Ee) } } function tokenizePath(fe, K) { let pe = 0, me = 0; return ge; function ge(ye) { return ye === 40 ? (pe++, fe.consume(ye), ge) : ye === 41 && me < pe ? xe(ye) : ye === 33 || ye === 34 || ye === 38 || ye === 39 || ye === 41 || ye === 42 || ye === 44 || ye === 46 || ye === 58 || ye === 59 || ye === 60 || ye === 63 || ye === 93 || ye === 95 || ye === 126 ? fe.check(trail, K, xe)(ye) : ye === null || markdownLineEndingOrSpace(ye) || unicodeWhitespace(ye) ? K(ye) : (fe.consume(ye), ge) } function xe(ye) { return ye === 41 && me++, fe.consume(ye), ge } } function tokenizeTrail(fe, K, pe) { return me; function me(ve) { return ve === 33 || ve === 34 || ve === 39 || ve === 41 || ve === 42 || ve === 44 || ve === 46 || ve === 58 || ve === 59 || ve === 63 || ve === 95 || ve === 126 ? (fe.consume(ve), me) : ve === 38 ? (fe.consume(ve), xe) : ve === 93 ? (fe.consume(ve), ge) : ve === 60 || ve === null || markdownLineEndingOrSpace(ve) || unicodeWhitespace(ve) ? K(ve) : pe(ve) } function ge(ve) { return ve === null || ve === 40 || ve === 91 || markdownLineEndingOrSpace(ve) || unicodeWhitespace(ve) ? K(ve) : me(ve) } function xe(ve) { return asciiAlpha(ve) ? ye(ve) : pe(ve) } function ye(ve) { return ve === 59 ? (fe.consume(ve), me) : asciiAlpha(ve) ? (fe.consume(ve), ye) : pe(ve) } } function tokenizeEmailDomainDotTrail(fe, K, pe) { return me; function me(xe) { return fe.consume(xe), ge } function ge(xe) { return asciiAlphanumeric(xe) ? pe(xe) : K(xe) } } function previousWww(fe) { return fe === null || fe === 40 || fe === 42 || fe === 95 || fe === 91 || fe === 93 || fe === 126 || markdownLineEndingOrSpace(fe) } function previousProtocol(fe) { return !asciiAlpha(fe) } function previousEmail(fe) { return !(fe === 47 || gfmAtext(fe)) } function gfmAtext(fe) { return fe === 43 || fe === 45 || fe === 46 || fe === 95 || asciiAlphanumeric(fe) } function previousUnbalanced(fe) { let K = fe.length, pe = !1; for (; K--;) { const me = fe[K][1]; if ((me.type === "labelLink" || me.type === "labelImage") && !me._balanced) { pe = !0; break } if (me._gfmAutolinkLiteralWalkedInto) { pe = !1; break } } return fe.length > 0 && !pe && (fe[fe.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), pe } const indent = { tokenize: tokenizeIndent, partial: !0 }; function gfmFootnote() { return { document: { 91: { name: "gfmFootnoteDefinition", tokenize: tokenizeDefinitionStart, continuation: { tokenize: tokenizeDefinitionContinuation }, exit: gfmFootnoteDefinitionEnd } }, text: { 91: { name: "gfmFootnoteCall", tokenize: tokenizeGfmFootnoteCall }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: tokenizePotentialGfmFootnoteCall, resolveTo: resolveToPotentialGfmFootnoteCall } } } } function tokenizePotentialGfmFootnoteCall(fe, K, pe) { const me = this; let ge = me.events.length; const xe = me.parser.gfmFootnotes || (me.parser.gfmFootnotes = []); let ye; for (; ge--;) { const _e = me.events[ge][1]; if (_e.type === "labelImage") { ye = _e; break } if (_e.type === "gfmFootnoteCall" || _e.type === "labelLink" || _e.type === "label" || _e.type === "image" || _e.type === "link") break } return ve; function ve(_e) { if (!ye || !ye._balanced) return pe(_e); const Ee = normalizeIdentifier(me.sliceSerialize({ start: ye.end, end: me.now() })); return Ee.codePointAt(0) !== 94 || !xe.includes(Ee.slice(1)) ? pe(_e) : (fe.enter("gfmFootnoteCallLabelMarker"), fe.consume(_e), fe.exit("gfmFootnoteCallLabelMarker"), K(_e)) } } function resolveToPotentialGfmFootnoteCall(fe, K) { let pe = fe.length; for (; pe--;)if (fe[pe][1].type === "labelImage" && fe[pe][0] === "enter") { fe[pe][1]; break } fe[pe + 1][1].type = "data", fe[pe + 3][1].type = "gfmFootnoteCallLabelMarker"; const me = { type: "gfmFootnoteCall", start: Object.assign({}, fe[pe + 3][1].start), end: Object.assign({}, fe[fe.length - 1][1].end) }, ge = { type: "gfmFootnoteCallMarker", start: Object.assign({}, fe[pe + 3][1].end), end: Object.assign({}, fe[pe + 3][1].end) }; ge.end.column++, ge.end.offset++, ge.end._bufferIndex++; const xe = { type: "gfmFootnoteCallString", start: Object.assign({}, ge.end), end: Object.assign({}, fe[fe.length - 1][1].start) }, ye = { type: "chunkString", contentType: "string", start: Object.assign({}, xe.start), end: Object.assign({}, xe.end) }, ve = [fe[pe + 1], fe[pe + 2], ["enter", me, K], fe[pe + 3], fe[pe + 4], ["enter", ge, K], ["exit", ge, K], ["enter", xe, K], ["enter", ye, K], ["exit", ye, K], ["exit", xe, K], fe[fe.length - 2], fe[fe.length - 1], ["exit", me, K]]; return fe.splice(pe, fe.length - pe + 1, ...ve), fe } function tokenizeGfmFootnoteCall(fe, K, pe) { const me = this, ge = me.parser.gfmFootnotes || (me.parser.gfmFootnotes = []); let xe = 0, ye; return ve; function ve(Ae) { return fe.enter("gfmFootnoteCall"), fe.enter("gfmFootnoteCallLabelMarker"), fe.consume(Ae), fe.exit("gfmFootnoteCallLabelMarker"), _e } function _e(Ae) { return Ae !== 94 ? pe(Ae) : (fe.enter("gfmFootnoteCallMarker"), fe.consume(Ae), fe.exit("gfmFootnoteCallMarker"), fe.enter("gfmFootnoteCallString"), fe.enter("chunkString").contentType = "string", Ee) } function Ee(Ae) { if (xe > 999 || Ae === 93 && !ye || Ae === null || Ae === 91 || markdownLineEndingOrSpace(Ae)) return pe(Ae); if (Ae === 93) { fe.exit("chunkString"); const Se = fe.exit("gfmFootnoteCallString"); return ge.includes(normalizeIdentifier(me.sliceSerialize(Se))) ? (fe.enter("gfmFootnoteCallLabelMarker"), fe.consume(Ae), fe.exit("gfmFootnoteCallLabelMarker"), fe.exit("gfmFootnoteCall"), K) : pe(Ae) } return markdownLineEndingOrSpace(Ae) || (ye = !0), xe++, fe.consume(Ae), Ae === 92 ? be : Ee } function be(Ae) { return Ae === 91 || Ae === 92 || Ae === 93 ? (fe.consume(Ae), xe++, Ee) : Ee(Ae) } } function tokenizeDefinitionStart(fe, K, pe) { const me = this, ge = me.parser.gfmFootnotes || (me.parser.gfmFootnotes = []); let xe, ye = 0, ve; return _e; function _e(we) { return fe.enter("gfmFootnoteDefinition")._container = !0, fe.enter("gfmFootnoteDefinitionLabel"), fe.enter("gfmFootnoteDefinitionLabelMarker"), fe.consume(we), fe.exit("gfmFootnoteDefinitionLabelMarker"), Ee } function Ee(we) { return we === 94 ? (fe.enter("gfmFootnoteDefinitionMarker"), fe.consume(we), fe.exit("gfmFootnoteDefinitionMarker"), fe.enter("gfmFootnoteDefinitionLabelString"), fe.enter("chunkString").contentType = "string", be) : pe(we) } function be(we) { if (ye > 999 || we === 93 && !ve || we === null || we === 91 || markdownLineEndingOrSpace(we)) return pe(we); if (we === 93) { fe.exit("chunkString"); const Be = fe.exit("gfmFootnoteDefinitionLabelString"); return xe = normalizeIdentifier(me.sliceSerialize(Be)), fe.enter("gfmFootnoteDefinitionLabelMarker"), fe.consume(we), fe.exit("gfmFootnoteDefinitionLabelMarker"), fe.exit("gfmFootnoteDefinitionLabel"), Se } return markdownLineEndingOrSpace(we) || (ve = !0), ye++, fe.consume(we), we === 92 ? Ae : be } function Ae(we) { return we === 91 || we === 92 || we === 93 ? (fe.consume(we), ye++, be) : be(we) } function Se(we) { return we === 58 ? (fe.enter("definitionMarker"), fe.consume(we), fe.exit("definitionMarker"), ge.includes(xe) || ge.push(xe), factorySpace(fe, Ce, "gfmFootnoteDefinitionWhitespace")) : pe(we) } function Ce(we) { return K(we) } } function tokenizeDefinitionContinuation(fe, K, pe) { return fe.check(blankLine, K, fe.attempt(indent, K, pe)) } function gfmFootnoteDefinitionEnd(fe) { fe.exit("gfmFootnoteDefinition") } function tokenizeIndent(fe, K, pe) { const me = this; return factorySpace(fe, ge, "gfmFootnoteDefinitionIndent", 5); function ge(xe) { const ye = me.events[me.events.length - 1]; return ye && ye[1].type === "gfmFootnoteDefinitionIndent" && ye[2].sliceSerialize(ye[1], !0).length === 4 ? K(xe) : pe(xe) } } function gfmStrikethrough(fe) { let pe = (fe || {}).singleTilde; const me = { name: "strikethrough", tokenize: xe, resolveAll: ge }; return pe == null && (pe = !0), { text: { 126: me }, insideSpan: { null: [me] }, attentionMarkers: { null: [126] } }; function ge(ye, ve) { let _e = -1; for (; ++_e < ye.length;)if (ye[_e][0] === "enter" && ye[_e][1].type === "strikethroughSequenceTemporary" && ye[_e][1]._close) { let Ee = _e; for (; Ee--;)if (ye[Ee][0] === "exit" && ye[Ee][1].type === "strikethroughSequenceTemporary" && ye[Ee][1]._open && ye[_e][1].end.offset - ye[_e][1].start.offset === ye[Ee][1].end.offset - ye[Ee][1].start.offset) { ye[_e][1].type = "strikethroughSequence", ye[Ee][1].type = "strikethroughSequence"; const be = { type: "strikethrough", start: Object.assign({}, ye[Ee][1].start), end: Object.assign({}, ye[_e][1].end) }, Ae = { type: "strikethroughText", start: Object.assign({}, ye[Ee][1].end), end: Object.assign({}, ye[_e][1].start) }, Se = [["enter", be, ve], ["enter", ye[Ee][1], ve], ["exit", ye[Ee][1], ve], ["enter", Ae, ve]], Ce = ve.parser.constructs.insideSpan.null; Ce && splice(Se, Se.length, 0, resolveAll(Ce, ye.slice(Ee + 1, _e), ve)), splice(Se, Se.length, 0, [["exit", Ae, ve], ["enter", ye[_e][1], ve], ["exit", ye[_e][1], ve], ["exit", be, ve]]), splice(ye, Ee - 1, _e - Ee + 3, Se), _e = Ee + Se.length - 2; break } } for (_e = -1; ++_e < ye.length;)ye[_e][1].type === "strikethroughSequenceTemporary" && (ye[_e][1].type = "data"); return ye } function xe(ye, ve, _e) { const Ee = this.previous, be = this.events; let Ae = 0; return Se; function Se(we) { return Ee === 126 && be[be.length - 1][1].type !== "characterEscape" ? _e(we) : (ye.enter("strikethroughSequenceTemporary"), Ce(we)) } function Ce(we) { const Be = classifyCharacter(Ee); if (we === 126) return Ae > 1 ? _e(we) : (ye.consume(we), Ae++, Ce); if (Ae < 2 && !pe) return _e(we); const De = ye.exit("strikethroughSequenceTemporary"), Re = classifyCharacter(we); return De._open = !Re || Re === 2 && !!Be, De._close = !Be || Be === 2 && !!Re, ve(we) } } } class EditMap { constructor() { this.map = [] } add(K, pe, me) { addImplementation(this, K, pe, me) } consume(K) { if (this.map.sort(function (xe, ye) { return xe[0] - ye[0] }), this.map.length === 0) return; let pe = this.map.length; const me = []; for (; pe > 0;)pe -= 1, me.push(K.slice(this.map[pe][0] + this.map[pe][1]), this.map[pe][2]), K.length = this.map[pe][0]; me.push(K.slice()), K.length = 0; let ge = me.pop(); for (; ge;) { for (const xe of ge) K.push(xe); ge = me.pop() } this.map.length = 0 } } function addImplementation(fe, K, pe, me) { let ge = 0; if (!(pe === 0 && me.length === 0)) { for (; ge < fe.map.length;) { if (fe.map[ge][0] === K) { fe.map[ge][1] += pe, fe.map[ge][2].push(...me); return } ge += 1 } fe.map.push([K, pe, me]) } } function gfmTableAlign(fe, K) { let pe = !1; const me = []; for (; K < fe.length;) { const ge = fe[K]; if (pe) { if (ge[0] === "enter") ge[1].type === "tableContent" && me.push(fe[K + 1][1].type === "tableDelimiterMarker" ? "left" : "none"); else if (ge[1].type === "tableContent") { if (fe[K - 1][1].type === "tableDelimiterMarker") { const xe = me.length - 1; me[xe] = me[xe] === "left" ? "center" : "right" } } else if (ge[1].type === "tableDelimiterRow") break } else ge[0] === "enter" && ge[1].type === "tableDelimiterRow" && (pe = !0); K += 1 } return me } function gfmTable() { return { flow: { null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable } } } } function tokenizeTable(fe, K, pe) { const me = this; let ge = 0, xe = 0, ye; return ve; function ve(ze) { let We = me.events.length - 1; for (; We > -1;) { const Ze = me.events[We][1].type; if (Ze === "lineEnding" || Ze === "linePrefix") We--; else break } const Xe = We > -1 ? me.events[We][1].type : null, Ye = Xe === "tableHead" || Xe === "tableRow" ? Oe : _e; return Ye === Oe && me.parser.lazy[me.now().line] ? pe(ze) : Ye(ze) } function _e(ze) { return fe.enter("tableHead"), fe.enter("tableRow"), Ee(ze) } function Ee(ze) { return ze === 124 || (ye = !0, xe += 1), be(ze) } function be(ze) { return ze === null ? pe(ze) : markdownLineEnding(ze) ? xe > 1 ? (xe = 0, me.interrupt = !0, fe.exit("tableRow"), fe.enter("lineEnding"), fe.consume(ze), fe.exit("lineEnding"), Ce) : pe(ze) : markdownSpace(ze) ? factorySpace(fe, be, "whitespace")(ze) : (xe += 1, ye && (ye = !1, ge += 1), ze === 124 ? (fe.enter("tableCellDivider"), fe.consume(ze), fe.exit("tableCellDivider"), ye = !0, be) : (fe.enter("data"), Ae(ze))) } function Ae(ze) { return ze === null || ze === 124 || markdownLineEndingOrSpace(ze) ? (fe.exit("data"), be(ze)) : (fe.consume(ze), ze === 92 ? Se : Ae) } function Se(ze) { return ze === 92 || ze === 124 ? (fe.consume(ze), Ae) : Ae(ze) } function Ce(ze) { return me.interrupt = !1, me.parser.lazy[me.now().line] ? pe(ze) : (fe.enter("tableDelimiterRow"), ye = !1, markdownSpace(ze) ? factorySpace(fe, we, "linePrefix", me.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ze) : we(ze)) } function we(ze) { return ze === 45 || ze === 58 ? De(ze) : ze === 124 ? (ye = !0, fe.enter("tableCellDivider"), fe.consume(ze), fe.exit("tableCellDivider"), Be) : ke(ze) } function Be(ze) { return markdownSpace(ze) ? factorySpace(fe, De, "whitespace")(ze) : De(ze) } function De(ze) { return ze === 58 ? (xe += 1, ye = !0, fe.enter("tableDelimiterMarker"), fe.consume(ze), fe.exit("tableDelimiterMarker"), Re) : ze === 45 ? (xe += 1, Re(ze)) : ze === null || markdownLineEnding(ze) ? Ne(ze) : ke(ze) } function Re(ze) { return ze === 45 ? (fe.enter("tableDelimiterFiller"), Ie(ze)) : ke(ze) } function Ie(ze) { return ze === 45 ? (fe.consume(ze), Ie) : ze === 58 ? (ye = !0, fe.exit("tableDelimiterFiller"), fe.enter("tableDelimiterMarker"), fe.consume(ze), fe.exit("tableDelimiterMarker"), Pe) : (fe.exit("tableDelimiterFiller"), Pe(ze)) } function Pe(ze) { return markdownSpace(ze) ? factorySpace(fe, Ne, "whitespace")(ze) : Ne(ze) } function Ne(ze) { return ze === 124 ? we(ze) : ze === null || markdownLineEnding(ze) ? !ye || ge !== xe ? ke(ze) : (fe.exit("tableDelimiterRow"), fe.exit("tableHead"), K(ze)) : ke(ze) } function ke(ze) { return pe(ze) } function Oe(ze) { return fe.enter("tableRow"), Ue(ze) } function Ue(ze) { return ze === 124 ? (fe.enter("tableCellDivider"), fe.consume(ze), fe.exit("tableCellDivider"), Ue) : ze === null || markdownLineEnding(ze) ? (fe.exit("tableRow"), K(ze)) : markdownSpace(ze) ? factorySpace(fe, Ue, "whitespace")(ze) : (fe.enter("data"), He(ze)) } function He(ze) { return ze === null || ze === 124 || markdownLineEndingOrSpace(ze) ? (fe.exit("data"), Ue(ze)) : (fe.consume(ze), ze === 92 ? Ge : He) } function Ge(ze) { return ze === 92 || ze === 124 ? (fe.consume(ze), He) : He(ze) } } function resolveTable(fe, K) { let pe = -1, me = !0, ge = 0, xe = [0, 0, 0, 0], ye = [0, 0, 0, 0], ve = !1, _e = 0, Ee, be, Ae; const Se = new EditMap; for (; ++pe < fe.length;) { const Ce = fe[pe], we = Ce[1]; Ce[0] === "enter" ? we.type === "tableHead" ? (ve = !1, _e !== 0 && (flushTableEnd(Se, K, _e, Ee, be), be = void 0, _e = 0), Ee = { type: "table", start: Object.assign({}, we.start), end: Object.assign({}, we.end) }, Se.add(pe, 0, [["enter", Ee, K]])) : we.type === "tableRow" || we.type === "tableDelimiterRow" ? (me = !0, Ae = void 0, xe = [0, 0, 0, 0], ye = [0, pe + 1, 0, 0], ve && (ve = !1, be = { type: "tableBody", start: Object.assign({}, we.start), end: Object.assign({}, we.end) }, Se.add(pe, 0, [["enter", be, K]])), ge = we.type === "tableDelimiterRow" ? 2 : be ? 3 : 1) : ge && (we.type === "data" || we.type === "tableDelimiterMarker" || we.type === "tableDelimiterFiller") ? (me = !1, ye[2] === 0 && (xe[1] !== 0 && (ye[0] = ye[1], Ae = flushCell(Se, K, xe, ge, void 0, Ae), xe = [0, 0, 0, 0]), ye[2] = pe)) : we.type === "tableCellDivider" && (me ? me = !1 : (xe[1] !== 0 && (ye[0] = ye[1], Ae = flushCell(Se, K, xe, ge, void 0, Ae)), xe = ye, ye = [xe[1], pe, 0, 0])) : we.type === "tableHead" ? (ve = !0, _e = pe) : we.type === "tableRow" || we.type === "tableDelimiterRow" ? (_e = pe, xe[1] !== 0 ? (ye[0] = ye[1], Ae = flushCell(Se, K, xe, ge, pe, Ae)) : ye[1] !== 0 && (Ae = flushCell(Se, K, ye, ge, pe, Ae)), ge = 0) : ge && (we.type === "data" || we.type === "tableDelimiterMarker" || we.type === "tableDelimiterFiller") && (ye[3] = pe) } for (_e !== 0 && flushTableEnd(Se, K, _e, Ee, be), Se.consume(K.events), pe = -1; ++pe < K.events.length;) { const Ce = K.events[pe]; Ce[0] === "enter" && Ce[1].type === "table" && (Ce[1]._align = gfmTableAlign(K.events, pe)) } return fe } function flushCell(fe, K, pe, me, ge, xe) { const ye = me === 1 ? "tableHeader" : me === 2 ? "tableDelimiter" : "tableData", ve = "tableContent"; pe[0] !== 0 && (xe.end = Object.assign({}, getPoint(K.events, pe[0])), fe.add(pe[0], 0, [["exit", xe, K]])); const _e = getPoint(K.events, pe[1]); if (xe = { type: ye, start: Object.assign({}, _e), end: Object.assign({}, _e) }, fe.add(pe[1], 0, [["enter", xe, K]]), pe[2] !== 0) { const Ee = getPoint(K.events, pe[2]), be = getPoint(K.events, pe[3]), Ae = { type: ve, start: Object.assign({}, Ee), end: Object.assign({}, be) }; if (fe.add(pe[2], 0, [["enter", Ae, K]]), me !== 2) { const Se = K.events[pe[2]], Ce = K.events[pe[3]]; if (Se[1].end = Object.assign({}, Ce[1].end), Se[1].type = "chunkText", Se[1].contentType = "text", pe[3] > pe[2] + 1) { const we = pe[2] + 1, Be = pe[3] - pe[2] - 1; fe.add(we, Be, []) } } fe.add(pe[3] + 1, 0, [["exit", Ae, K]]) } return ge !== void 0 && (xe.end = Object.assign({}, getPoint(K.events, ge)), fe.add(ge, 0, [["exit", xe, K]]), xe = void 0), xe } function flushTableEnd(fe, K, pe, me, ge) { const xe = [], ye = getPoint(K.events, pe); ge && (ge.end = Object.assign({}, ye), xe.push(["exit", ge, K])), me.end = Object.assign({}, ye), xe.push(["exit", me, K]), fe.add(pe + 1, 0, xe) } function getPoint(fe, K) { const pe = fe[K], me = pe[0] === "enter" ? "start" : "end"; return pe[1][me] } const tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck }; function gfmTaskListItem() { return { text: { 91: tasklistCheck } } } function tokenizeTasklistCheck(fe, K, pe) { const me = this; return ge; function ge(_e) { return me.previous !== null || !me._gfmTasklistFirstContentOfListItem ? pe(_e) : (fe.enter("taskListCheck"), fe.enter("taskListCheckMarker"), fe.consume(_e), fe.exit("taskListCheckMarker"), xe) } function xe(_e) { return markdownLineEndingOrSpace(_e) ? (fe.enter("taskListCheckValueUnchecked"), fe.consume(_e), fe.exit("taskListCheckValueUnchecked"), ye) : _e === 88 || _e === 120 ? (fe.enter("taskListCheckValueChecked"), fe.consume(_e), fe.exit("taskListCheckValueChecked"), ye) : pe(_e) } function ye(_e) { return _e === 93 ? (fe.enter("taskListCheckMarker"), fe.consume(_e), fe.exit("taskListCheckMarker"), fe.exit("taskListCheck"), ve) : pe(_e) } function ve(_e) { return markdownLineEnding(_e) ? K(_e) : markdownSpace(_e) ? fe.check({ tokenize: spaceThenNonSpace }, K, pe)(_e) : pe(_e) } } function spaceThenNonSpace(fe, K, pe) { return factorySpace(fe, me, "whitespace"); function me(ge) { return ge === null ? pe(ge) : K(ge) } } function gfm(fe) { return combineExtensions([gfmAutolinkLiteral(), gfmFootnote(), gfmStrikethrough(fe), gfmTable(), gfmTaskListItem()]) } const emptyOptions = {}; function remarkGfm(fe) { const K = this, pe = fe || emptyOptions, me = K.data(), ge = me.micromarkExtensions || (me.micromarkExtensions = []), xe = me.fromMarkdownExtensions || (me.fromMarkdownExtensions = []), ye = me.toMarkdownExtensions || (me.toMarkdownExtensions = []); ge.push(gfm(pe)), xe.push(gfmFromMarkdown()), ye.push(gfmToMarkdown(pe)) } const convert = function (fe) { return typeFactory(fe) }; function typeFactory(fe) { return castFactory(K); function K(pe) { return pe && pe.type === fe } } function castFactory(fe) { return K; function K(pe, ...me) { return !!(pe && typeof pe == "object" && "type" in pe && fe.call(this, pe, ...me)) } } function color$1(fe) { return fe } const CONTINUE = !0, EXIT = !1, SKIP = "skip", visitParents = function (fe, K, pe, me) { const ge = convert(K), xe = 1; ye(fe, void 0, [])(); function ye(ve, _e, Ee) { const be = ve && typeof ve == "object" ? ve : {}; if (typeof be.type == "string") { const Se = typeof be.tagName == "string" ? be.tagName : typeof be.name == "string" ? be.name : void 0; Object.defineProperty(Ae, "name", { value: "node (" + (ve.type + (Se ? "<" + Se + ">" : "")) + ")" }) } return Ae; function Ae() { let Se = [], Ce, we, Be; if (ge(ve, _e, Ee[Ee.length - 1] || null) && (Se = toResult(pe(ve, Ee)), Se[0] === EXIT)) return Se; if (ve.children && Se[0] !== SKIP) for (we = -1 + xe, Be = Ee.concat(ve); we > -1 && we < ve.children.length;) { if (Ce = ye(ve.children[we], we, Be)(), Ce[0] === EXIT) return Ce; we = typeof Ce[1] == "number" ? Ce[1] : we + xe } return Se } } }; function toResult(fe) { return Array.isArray(fe) ? fe : typeof fe == "number" ? [CONTINUE, fe] : [fe] } const visit = function (fe, K, pe, me) { visitParents(fe, K, ge); function ge(xe, ye) { const ve = ye[ye.length - 1]; return pe(xe, ve ? ve.children.indexOf(xe) : null, ve) } }; function toString(fe) { return "children" in fe ? all(fe) : "value" in fe ? fe.value : "" } function one(fe) { return fe.type === "text" ? fe.value : "children" in fe ? all(fe) : "" } function all(fe) { let K = -1; const pe = []; for (; ++K < fe.children.length;)pe[K] = one(fe.children[K]); return pe.join("") } function define(fe, K, pe) { fe.prototype = K.prototype = pe, pe.constructor = fe } function extend(fe, K) { var pe = Object.create(fe.prototype); for (var me in K) pe[me] = K[me]; return pe } function Color() { } var darker = .7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; define(Color, color, { copy(fe) { return Object.assign(new this.constructor, this, fe) }, displayable() { return this.rgb().displayable() }, hex: color_formatHex, formatHex: color_formatHex, formatHex8: color_formatHex8, formatHsl: color_formatHsl, formatRgb: color_formatRgb, toString: color_formatRgb }); function color_formatHex() { return this.rgb().formatHex() } function color_formatHex8() { return this.rgb().formatHex8() } function color_formatHsl() { return hslConvert(this).formatHsl() } function color_formatRgb() { return this.rgb().formatRgb() } function color(fe) { var K, pe; return fe = (fe + "").trim().toLowerCase(), (K = reHex.exec(fe)) ? (pe = K[1].length, K = parseInt(K[1], 16), pe === 6 ? rgbn(K) : pe === 3 ? new Rgb(K >> 8 & 15 | K >> 4 & 240, K >> 4 & 15 | K & 240, (K & 15) << 4 | K & 15, 1) : pe === 8 ? rgba(K >> 24 & 255, K >> 16 & 255, K >> 8 & 255, (K & 255) / 255) : pe === 4 ? rgba(K >> 12 & 15 | K >> 8 & 240, K >> 8 & 15 | K >> 4 & 240, K >> 4 & 15 | K & 240, ((K & 15) << 4 | K & 15) / 255) : null) : (K = reRgbInteger.exec(fe)) ? new Rgb(K[1], K[2], K[3], 1) : (K = reRgbPercent.exec(fe)) ? new Rgb(K[1] * 255 / 100, K[2] * 255 / 100, K[3] * 255 / 100, 1) : (K = reRgbaInteger.exec(fe)) ? rgba(K[1], K[2], K[3], K[4]) : (K = reRgbaPercent.exec(fe)) ? rgba(K[1] * 255 / 100, K[2] * 255 / 100, K[3] * 255 / 100, K[4]) : (K = reHslPercent.exec(fe)) ? hsla(K[1], K[2] / 100, K[3] / 100, 1) : (K = reHslaPercent.exec(fe)) ? hsla(K[1], K[2] / 100, K[3] / 100, K[4]) : named.hasOwnProperty(fe) ? rgbn(named[fe]) : fe === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null } function rgbn(fe) { return new Rgb(fe >> 16 & 255, fe >> 8 & 255, fe & 255, 1) } function rgba(fe, K, pe, me) { return me <= 0 && (fe = K = pe = NaN), new Rgb(fe, K, pe, me) } function rgbConvert(fe) { return fe instanceof Color || (fe = color(fe)), fe ? (fe = fe.rgb(), new Rgb(fe.r, fe.g, fe.b, fe.opacity)) : new Rgb } function rgb(fe, K, pe, me) { return arguments.length === 1 ? rgbConvert(fe) : new Rgb(fe, K, pe, me ?? 1) } function Rgb(fe, K, pe, me) { this.r = +fe, this.g = +K, this.b = +pe, this.opacity = +me } define(Rgb, rgb, extend(Color, { brighter(fe) { return fe = fe == null ? brighter : Math.pow(brighter, fe), new Rgb(this.r * fe, this.g * fe, this.b * fe, this.opacity) }, darker(fe) { return fe = fe == null ? darker : Math.pow(darker, fe), new Rgb(this.r * fe, this.g * fe, this.b * fe, this.opacity) }, rgb() { return this }, clamp() { return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity)) }, displayable() { return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1 }, hex: rgb_formatHex, formatHex: rgb_formatHex, formatHex8: rgb_formatHex8, formatRgb: rgb_formatRgb, toString: rgb_formatRgb })); function rgb_formatHex() { return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}` } function rgb_formatHex8() { return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}` } function rgb_formatRgb() { const fe = clampa(this.opacity); return `${fe === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${fe === 1 ? ")" : `, ${fe})`}` } function clampa(fe) { return isNaN(fe) ? 1 : Math.max(0, Math.min(1, fe)) } function clampi(fe) { return Math.max(0, Math.min(255, Math.round(fe) || 0)) } function hex(fe) { return fe = clampi(fe), (fe < 16 ? "0" : "") + fe.toString(16) } function hsla(fe, K, pe, me) { return me <= 0 ? fe = K = pe = NaN : pe <= 0 || pe >= 1 ? fe = K = NaN : K <= 0 && (fe = NaN), new Hsl(fe, K, pe, me) } function hslConvert(fe) { if (fe instanceof Hsl) return new Hsl(fe.h, fe.s, fe.l, fe.opacity); if (fe instanceof Color || (fe = color(fe)), !fe) return new Hsl; if (fe instanceof Hsl) return fe; fe = fe.rgb(); var K = fe.r / 255, pe = fe.g / 255, me = fe.b / 255, ge = Math.min(K, pe, me), xe = Math.max(K, pe, me), ye = NaN, ve = xe - ge, _e = (xe + ge) / 2; return ve ? (K === xe ? ye = (pe - me) / ve + (pe < me) * 6 : pe === xe ? ye = (me - K) / ve + 2 : ye = (K - pe) / ve + 4, ve /= _e < .5 ? xe + ge : 2 - xe - ge, ye *= 60) : ve = _e > 0 && _e < 1 ? 0 : ye, new Hsl(ye, ve, _e, fe.opacity) } function hsl(fe, K, pe, me) { return arguments.length === 1 ? hslConvert(fe) : new Hsl(fe, K, pe, me ?? 1) } function Hsl(fe, K, pe, me) { this.h = +fe, this.s = +K, this.l = +pe, this.opacity = +me } define(Hsl, hsl, extend(Color, { brighter(fe) { return fe = fe == null ? brighter : Math.pow(brighter, fe), new Hsl(this.h, this.s, this.l * fe, this.opacity) }, darker(fe) { return fe = fe == null ? darker : Math.pow(darker, fe), new Hsl(this.h, this.s, this.l * fe, this.opacity) }, rgb() { var fe = this.h % 360 + (this.h < 0) * 360, K = isNaN(fe) || isNaN(this.s) ? 0 : this.s, pe = this.l, me = pe + (pe < .5 ? pe : 1 - pe) * K, ge = 2 * pe - me; return new Rgb(hsl2rgb(fe >= 240 ? fe - 240 : fe + 120, ge, me), hsl2rgb(fe, ge, me), hsl2rgb(fe < 120 ? fe + 240 : fe - 120, ge, me), this.opacity) }, clamp() { return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity)) }, displayable() { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 }, formatHsl() { const fe = clampa(this.opacity); return `${fe === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${fe === 1 ? ")" : `, ${fe})`}` } })); function clamph(fe) { return fe = (fe || 0) % 360, fe < 0 ? fe + 360 : fe } function clampt(fe) { return Math.max(0, Math.min(1, fe || 0)) } function hsl2rgb(fe, K, pe) { return (fe < 60 ? K + (pe - K) * fe / 60 : fe < 180 ? pe : fe < 240 ? K + (pe - K) * (240 - fe) / 60 : K) * 255 } function plugin(fe) { return fe === void 0 && (fe = { customClassName: "gfm-color-chip" }), function (K) { visit(K, "element", function (pe) { if (pe.tagName === "code" && pe.properties) { var me = toString(pe), ge = color(me); ge && pe.children.push({ type: "element", tagName: "span", properties: { className: [fe.customClassName], style: "background-color: " + ge.formatHex() + ";" }, children: [] }) } }) } } function rehypeCodeblock() { return fe => { visit$1(fe, "element", (K, pe, me) => { K.tagName === "code" && me && me.type === "element" && me.tagName === "pre" && (K.properties = { block: !0, ...K.properties }) }) } } function MdxText(fe) { return jsxRuntimeExports.jsx(Text, { ...fe }) } function MdxAnchor(fe) { return jsxRuntimeExports.jsx(Anchor, { ...fe }) } function MdxTitle(fe, K) { return jsxRuntimeExports.jsx(Title, { order: K, ...fe }) } function MdxList(fe, K, pe) { return fe.className == "contains-task-list" ? jsxRuntimeExports.jsx(List, { type: pe, ...fe, listStyleType: "none", children: K }) : jsxRuntimeExports.jsx(List, { type: pe, ...fe, children: K }) } function MdxListItem(fe, K) { return jsxRuntimeExports.jsx(List.Item, { ...fe, children: K }) } function MdxCode(fe, K) { return jsxRuntimeExports.jsx(Code, { ...fe, children: K }) } function MdxBlockquote(fe) { return jsxRuntimeExports.jsx(Blockquote, { ...fe }) } function MdxCite(fe) { return jsxRuntimeExports.jsx("cite", { style: { display: "block", fontSize: "0.875rem", marginTop: "0.625rem", color: "#909296", overflow: "hidden", textOverflow: "ellipsis" }, ...fe }) } function MdxTable(fe) { return jsxRuntimeExports.jsx(Table, { ...fe, highlightOnHover: !0, withColumnBorders: !0 }) } function MdxImage(fe) { return jsxRuntimeExports.jsx(Image$1, { maw: 240, mx: "auto", radius: "md", ...fe }) } const components = { p: fe => MdxText(fe), a: fe => MdxAnchor(fe), h1: fe => MdxTitle(fe, 1), h2: fe => MdxTitle(fe, 2), h3: fe => MdxTitle(fe, 3), h4: fe => MdxTitle(fe, 4), h5: fe => MdxTitle(fe, 5), h6: fe => MdxTitle(fe, 6), ul: fe => MdxList(fe, fe.children ?? "", "unordered"), ol: fe => MdxList(fe, fe.children ?? "", "ordered"), li: fe => MdxListItem(fe, fe.children ?? ""), code: fe => MdxCode(fe, fe.children ?? ""), pre: fe => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: fe.children }), blockquote: fe => MdxBlockquote(fe), Cite: fe => MdxCite(fe), table: fe => MdxTable(fe), img: fe => MdxImage(fe), "*": () => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) }; async function parseMarkdown(fe) { const { default: K } = await evaluate(fe, { ...runtime, ...provider, development: !1, remarkPlugins: [remarkGfm], rehypePlugins: [rehypeCodeblock, plugin] }); return K } function Markdown(fe) { const [K, pe] = reactExports.useState(null); return reactExports.useEffect(() => { try { parseMarkdown(fe.children ?? "").then(me => { pe(jsxRuntimeExports.jsx(me, { components })) }) } catch { pe(jsxRuntimeExports.jsx(Title, { order: 2, children: "Error Parsing Markdown..." })) } }, [fe.children]), K } const ErrorBoundaryContext = reactExports.createContext(null), initialState = { didCatch: !1, error: null }; class ErrorBoundary extends reactExports.Component { constructor(K) { super(K), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = initialState } static getDerivedStateFromError(K) { return { didCatch: !0, error: K } } resetErrorBoundary() { const { error: K } = this.state; if (K !== null) { for (var pe, me, ge = arguments.length, xe = new Array(ge), ye = 0; ye < ge; ye++)xe[ye] = arguments[ye]; (pe = (me = this.props).onReset) === null || pe === void 0 || pe.call(me, { args: xe, reason: "imperative-api" }), this.setState(initialState) } } componentDidCatch(K, pe) { var me, ge; (me = (ge = this.props).onError) === null || me === void 0 || me.call(ge, K, pe) } componentDidUpdate(K, pe) { const { didCatch: me } = this.state, { resetKeys: ge } = this.props; if (me && pe.error !== null && hasArrayChanged(K.resetKeys, ge)) { var xe, ye; (xe = (ye = this.props).onReset) === null || xe === void 0 || xe.call(ye, { next: ge, prev: K.resetKeys, reason: "keys" }), this.setState(initialState) } } render() { const { children: K, fallbackRender: pe, FallbackComponent: me, fallback: ge } = this.props, { didCatch: xe, error: ye } = this.state; let ve = K; if (xe) { const _e = { error: ye, resetErrorBoundary: this.resetErrorBoundary }; if (typeof pe == "function") ve = pe(_e); else if (me) ve = reactExports.createElement(me, _e); else if (ge !== void 0) ve = ge; else throw ye } return reactExports.createElement(ErrorBoundaryContext.Provider, { value: { didCatch: xe, error: ye, resetErrorBoundary: this.resetErrorBoundary } }, ve) } } function hasArrayChanged() { let fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; return fe.length !== K.length || fe.some((pe, me) => !Object.is(pe, K[me])) } function MarkdownComponent({ props: { visible: fe, _markdown: K } }) { return fe ? jsxRuntimeExports.jsx(Box, { pb: "xs", px: "sm", style: { maxWidth: "95%" }, children: jsxRuntimeExports.jsx(ErrorBoundary, { fallback: jsxRuntimeExports.jsx(Text, { style: { textAlign: "center" }, children: "Markdown Failed to Render" }), children: jsxRuntimeExports.jsx(Markdown, { children: K }) }) }) : null } var folderWrapper = "_3o7djo0", folderLabel = "_3o7djo1", folderToggleIcon = "_3o7djo2"; const PlotWithAspect = React$4.memo(function ({ jsonStr: K, aspectRatio: pe, onExpand: me }) { const [ge, xe] = React$4.useState(!1); if (K === "") return jsxRuntimeExports.jsx("div", {}); const ye = JSON.parse(K); ye.layout.uirevision = "true"; const { ref: ve, width: _e } = useElementSize(); ye.layout.width = _e, ye.layout.height = _e * pe; const Ee = React$4.useRef(null); return React$4.useEffect(() => { Plotly.react(Ee.current, ye.data, ye.layout, ye.config) }, [ye]), jsxRuntimeExports.jsxs(Paper, { ref: ve, className: folderWrapper, withBorder: !0, style: { position: "relative" }, onMouseEnter: me ? () => xe(!0) : void 0, onMouseLeave: me ? () => xe(!1) : void 0, children: [jsxRuntimeExports.jsx("div", { ref: Ee }), me && ge && jsxRuntimeExports.jsx(Tooltip, { label: "Expand plot", children: jsxRuntimeExports.jsx(ActionIcon, { onClick: me, variant: "subtle", color: "gray", size: "sm", style: { position: "absolute", bottom: 8, right: 8, backgroundColor: "rgba(255, 255, 255, 0.9)", backdropFilter: "blur(4px)", zIndex: 1001 }, children: jsxRuntimeExports.jsx(IconMaximize, { size: 14 }) }) })] }) }); function PlotlyComponent({ props: { visible: fe, _plotly_json_str: K, aspect: pe } }) { if (!fe) return null; const [me, { open: ge, close: xe }] = useDisclosure(!1); return jsxRuntimeExports.jsxs(Box, { children: [jsxRuntimeExports.jsx(PlotWithAspect, { jsonStr: K, aspectRatio: pe, onExpand: ge }), jsxRuntimeExports.jsx(Modal, { opened: me, onClose: xe, size: "xl", children: jsxRuntimeExports.jsx(PlotWithAspect, { jsonStr: K, aspectRatio: pe }) })] }) } var uplotReact = { exports: {} }; const FEAT_TIME = !0, pre = "u-", UPLOT = "uplot", ORI_HZ = pre + "hz", ORI_VT = pre + "vt", TITLE = pre + "title", WRAP = pre + "wrap", UNDER = pre + "under", OVER = pre + "over", AXIS = pre + "axis", OFF = pre + "off", SELECT = pre + "select", CURSOR_X = pre + "cursor-x", CURSOR_Y = pre + "cursor-y", CURSOR_PT = pre + "cursor-pt", LEGEND = pre + "legend", LEGEND_LIVE = pre + "live", LEGEND_INLINE = pre + "inline", LEGEND_SERIES = pre + "series", LEGEND_MARKER = pre + "marker", LEGEND_LABEL = pre + "label", LEGEND_VALUE = pre + "value", WIDTH = "width", HEIGHT = "height", TOP = "top", BOTTOM = "bottom", LEFT = "left", RIGHT = "right", hexBlack = "#000", transparent = hexBlack + "0", mousemove = "mousemove", mousedown = "mousedown", mouseup = "mouseup", mouseenter = "mouseenter", mouseleave = "mouseleave", dblclick = "dblclick", resize = "resize", scroll = "scroll", change = "change", dppxchange = "dppxchange", LEGEND_DISP = "--", domEnv = typeof window < "u", doc = domEnv ? document : null, win = domEnv ? window : null, nav = domEnv ? navigator : null; let pxRatio, query; function setPxRatio() { let fe = devicePixelRatio; pxRatio != fe && (pxRatio = fe, query && off(change, query, setPxRatio), query = matchMedia(`(min-resolution: ${pxRatio - .001}dppx) and (max-resolution: ${pxRatio + .001}dppx)`), on(change, query, setPxRatio), win.dispatchEvent(new CustomEvent(dppxchange))) } function addClass(fe, K) { if (K != null) { let pe = fe.classList; !pe.contains(K) && pe.add(K) } } function remClass(fe, K) { let pe = fe.classList; pe.contains(K) && pe.remove(K) } function setStylePx(fe, K, pe) { fe.style[K] = pe + "px" } function placeTag(fe, K, pe, me) { let ge = doc.createElement(fe); return K != null && addClass(ge, K), pe?.insertBefore(ge, me), ge } function placeDiv(fe, K) { return placeTag("div", fe, K) } const xformCache = new WeakMap; function elTrans(fe, K, pe, me, ge) { let xe = "translate(" + K + "px," + pe + "px)", ye = xformCache.get(fe); xe != ye && (fe.style.transform = xe, xformCache.set(fe, xe), K < 0 || pe < 0 || K > me || pe > ge ? addClass(fe, OFF) : remClass(fe, OFF)) } const colorCache = new WeakMap; function elColor(fe, K, pe) { let me = K + pe, ge = colorCache.get(fe); me != ge && (colorCache.set(fe, me), fe.style.background = K, fe.style.borderColor = pe) } const sizeCache = new WeakMap; function elSize(fe, K, pe, me) { let ge = K + "" + pe, xe = sizeCache.get(fe); ge != xe && (sizeCache.set(fe, ge), fe.style.height = pe + "px", fe.style.width = K + "px", fe.style.marginLeft = me ? -K / 2 + "px" : 0, fe.style.marginTop = me ? -pe / 2 + "px" : 0) } const evOpts = { passive: !0 }, evOpts2 = { ...evOpts, capture: !0 }; function on(fe, K, pe, me) { K.addEventListener(fe, pe, me ? evOpts2 : evOpts) } function off(fe, K, pe, me) { K.removeEventListener(fe, pe, evOpts) } domEnv && setPxRatio(); function closestIdx(fe, K, pe, me) { let ge; pe = pe || 0, me = me || K.length - 1; let xe = me <= 2147483647; for (; me - pe > 1;)ge = xe ? pe + me >> 1 : floor((pe + me) / 2), K[ge] < fe ? pe = ge : me = ge; return fe - K[pe] <= K[me] - fe ? pe : me } function makeIndexOfs(fe) { return (pe, me, ge) => { let xe = -1, ye = -1; for (let ve = me; ve <= ge; ve++)if (fe(pe[ve])) { xe = ve; break } for (let ve = ge; ve >= me; ve--)if (fe(pe[ve])) { ye = ve; break } return [xe, ye] } } const notNullish = fe => fe != null, isPositive = fe => fe != null && fe > 0, nonNullIdxs = makeIndexOfs(notNullish), positiveIdxs = makeIndexOfs(isPositive); function getMinMax(fe, K, pe, me = 0, ge = !1) { let xe = ge ? positiveIdxs : nonNullIdxs, ye = ge ? isPositive : notNullish;[K, pe] = xe(fe, K, pe); let ve = fe[K], _e = fe[K]; if (K > -1) if (me == 1) ve = fe[K], _e = fe[pe]; else if (me == -1) ve = fe[pe], _e = fe[K]; else for (let Ee = K; Ee <= pe; Ee++) { let be = fe[Ee]; ye(be) && (be < ve ? ve = be : be > _e && (_e = be)) } return [ve ?? inf, _e ?? -inf] } function rangeLog(fe, K, pe, me) { let ge = sign(fe), xe = sign(K); fe == K && (ge == -1 ? (fe *= pe, K /= pe) : (fe /= pe, K *= pe)); let ye = pe == 10 ? log10 : log2, ve = ge == 1 ? floor : ceil, _e = xe == 1 ? ceil : floor, Ee = ve(ye(abs(fe))), be = _e(ye(abs(K))), Ae = pow(pe, Ee), Se = pow(pe, be); return pe == 10 && (Ee < 0 && (Ae = roundDec(Ae, -Ee)), be < 0 && (Se = roundDec(Se, -be))), me || pe == 2 ? (fe = Ae * ge, K = Se * xe) : (fe = incrRoundDn(fe, Ae), K = incrRoundUp(K, Se)), [fe, K] } function rangeAsinh(fe, K, pe, me) { let ge = rangeLog(fe, K, pe, me); return fe == 0 && (ge[0] = 0), K == 0 && (ge[1] = 0), ge } const rangePad = .1, autoRangePart = { mode: 3, pad: rangePad }, _eqRangePart = { pad: 0, soft: null, mode: 0 }, _eqRange = { min: _eqRangePart, max: _eqRangePart }; function rangeNum(fe, K, pe, me) { return isObj(pe) ? _rangeNum(fe, K, pe) : (_eqRangePart.pad = pe, _eqRangePart.soft = me ? 0 : null, _eqRangePart.mode = me ? 3 : 0, _rangeNum(fe, K, _eqRange)) } function ifNull(fe, K) { return fe ?? K } function hasData(fe, K, pe) { for (K = ifNull(K, 0), pe = ifNull(pe, fe.length - 1); K <= pe;) { if (fe[K] != null) return !0; K++ } return !1 } function _rangeNum(fe, K, pe) { let me = pe.min, ge = pe.max, xe = ifNull(me.pad, 0), ye = ifNull(ge.pad, 0), ve = ifNull(me.hard, -inf), _e = ifNull(ge.hard, inf), Ee = ifNull(me.soft, inf), be = ifNull(ge.soft, -inf), Ae = ifNull(me.mode, 0), Se = ifNull(ge.mode, 0), Ce = K - fe, we = log10(Ce), Be = max$1(abs(fe), abs(K)), De = log10(Be), Re = abs(De - we); (Ce < 1e-24 || Re > 10) && (Ce = 0, (fe == 0 || K == 0) && (Ce = 1e-24, Ae == 2 && Ee != inf && (xe = 0), Se == 2 && be != -inf && (ye = 0))); let Ie = Ce || Be || 1e3, Pe = log10(Ie), Ne = pow(10, floor(Pe)), ke = Ie * (Ce == 0 ? fe == 0 ? .1 : 1 : xe), Oe = roundDec(incrRoundDn(fe - ke, Ne / 10), 24), Ue = fe >= Ee && (Ae == 1 || Ae == 3 && Oe <= Ee || Ae == 2 && Oe >= Ee) ? Ee : inf, He = max$1(ve, Oe < Ue && fe >= Ue ? Ue : min(Ue, Oe)), Ge = Ie * (Ce == 0 ? K == 0 ? .1 : 1 : ye), ze = roundDec(incrRoundUp(K + Ge, Ne / 10), 24), We = K <= be && (Se == 1 || Se == 3 && ze >= be || Se == 2 && ze <= be) ? be : -inf, Xe = min(_e, ze > We && K <= We ? We : max$1(We, ze)); return He == Xe && He == 0 && (Xe = 100), [He, Xe] } const numFormatter = new Intl.NumberFormat(domEnv ? nav.language : "en-US"), fmtNum = fe => numFormatter.format(fe), M$1 = Math, PI = M$1.PI, abs = M$1.abs, floor = M$1.floor, round = M$1.round, ceil = M$1.ceil, min = M$1.min, max$1 = M$1.max, pow = M$1.pow, sign = M$1.sign, log10 = M$1.log10, log2 = M$1.log2, sinh = (fe, K = 1) => M$1.sinh(fe) * K, asinh = (fe, K = 1) => M$1.asinh(fe / K), inf = 1 / 0; function numIntDigits(fe) { return (log10((fe ^ fe >> 31) - (fe >> 31)) | 0) + 1 } function clamp$1(fe, K, pe) { return min(max$1(fe, K), pe) } function isFn(fe) { return typeof fe == "function" } function fnOrSelf(fe) { return isFn(fe) ? fe : () => fe } const noop = () => { }, retArg0 = fe => fe, retArg1 = (fe, K) => K, retNull = fe => null, retTrue = fe => !0, retEq = (fe, K) => fe == K, regex6 = /\.\d*?(?=9{6,}|0{6,})/gm, fixFloat = fe => { if (isInt(fe) || fixedDec.has(fe)) return fe; const K = `${fe}`, pe = K.match(regex6); if (pe == null) return fe; let me = pe[0].length - 1; if (K.indexOf("e-") != -1) { let [ge, xe] = K.split("e"); return +`${fixFloat(ge)}e${xe}` } return roundDec(fe, me) }; function incrRound(fe, K) { return fixFloat(roundDec(fixFloat(fe / K)) * K) } function incrRoundUp(fe, K) { return fixFloat(ceil(fixFloat(fe / K)) * K) } function incrRoundDn(fe, K) { return fixFloat(floor(fixFloat(fe / K)) * K) } function roundDec(fe, K = 0) { if (isInt(fe)) return fe; let pe = 10 ** K, me = fe * pe * (1 + Number.EPSILON); return round(me) / pe } const fixedDec = new Map; function guessDec(fe) { return (("" + fe).split(".")[1] || "").length } function genIncrs(fe, K, pe, me) { let ge = [], xe = me.map(guessDec); for (let ye = K; ye < pe; ye++) { let ve = abs(ye), _e = roundDec(pow(fe, ye), ve); for (let Ee = 0; Ee < me.length; Ee++) { let be = fe == 10 ? +`${me[Ee]}e${ye}` : me[Ee] * _e, Ae = (ye >= 0 ? 0 : ve) + (ye >= xe[Ee] ? 0 : xe[Ee]), Se = fe == 10 ? be : roundDec(be, Ae); ge.push(Se), fixedDec.set(Se, Ae) } } return ge } const EMPTY_OBJ = {}, EMPTY_ARR = [], nullNullTuple = [null, null], isArr = Array.isArray, isInt = Number.isInteger, isUndef = fe => fe === void 0; function isStr(fe) { return typeof fe == "string" } function isObj(fe) { let K = !1; if (fe != null) { let pe = fe.constructor; K = pe == null || pe == Object } return K } function fastIsObj(fe) { return fe != null && typeof fe == "object" } const TypedArray = Object.getPrototypeOf(Uint8Array), __proto__ = "__proto__"; function copy(fe, K = isObj) { let pe; if (isArr(fe)) { let me = fe.find(ge => ge != null); if (isArr(me) || K(me)) { pe = Array(fe.length); for (let ge = 0; ge < fe.length; ge++)pe[ge] = copy(fe[ge], K) } else pe = fe.slice() } else if (fe instanceof TypedArray) pe = fe.slice(); else if (K(fe)) { pe = {}; for (let me in fe) me != __proto__ && (pe[me] = copy(fe[me], K)) } else pe = fe; return pe } function assign(fe) { let K = arguments; for (let pe = 1; pe < K.length; pe++) { let me = K[pe]; for (let ge in me) ge != __proto__ && (isObj(fe[ge]) ? assign(fe[ge], copy(me[ge])) : fe[ge] = copy(me[ge])) } return fe } const NULL_REMOVE = 0, NULL_RETAIN = 1, NULL_EXPAND = 2; function nullExpand(fe, K, pe) { for (let me = 0, ge, xe = -1; me < K.length; me++) { let ye = K[me]; if (ye > xe) { for (ge = ye - 1; ge >= 0 && fe[ge] == null;)fe[ge--] = null; for (ge = ye + 1; ge < pe && fe[ge] == null;)fe[xe = ge++] = null } } } function join(fe, K) { if (allHeadersSame(fe)) { let ye = fe[0].slice(); for (let ve = 1; ve < fe.length; ve++)ye.push(...fe[ve].slice(1)); return isAsc(ye[0]) || (ye = sortCols(ye)), ye } let pe = new Set; for (let ye = 0; ye < fe.length; ye++) { let _e = fe[ye][0], Ee = _e.length; for (let be = 0; be < Ee; be++)pe.add(_e[be]) } let me = [Array.from(pe).sort((ye, ve) => ye - ve)], ge = me[0].length, xe = new Map; for (let ye = 0; ye < ge; ye++)xe.set(me[0][ye], ye); for (let ye = 0; ye < fe.length; ye++) { let ve = fe[ye], _e = ve[0]; for (let Ee = 1; Ee < ve.length; Ee++) { let be = ve[Ee], Ae = Array(ge).fill(void 0), Se = K ? K[ye][Ee] : NULL_RETAIN, Ce = []; for (let we = 0; we < be.length; we++) { let Be = be[we], De = xe.get(_e[we]); Be === null ? Se != NULL_REMOVE && (Ae[De] = Be, Se == NULL_EXPAND && Ce.push(De)) : Ae[De] = Be } nullExpand(Ae, Ce, ge), me.push(Ae) } } return me } const microTask = typeof queueMicrotask > "u" ? fe => Promise.resolve().then(fe) : queueMicrotask; function sortCols(fe) { let K = fe[0], pe = K.length, me = Array(pe); for (let xe = 0; xe < me.length; xe++)me[xe] = xe; me.sort((xe, ye) => K[xe] - K[ye]); let ge = []; for (let xe = 0; xe < fe.length; xe++) { let ye = fe[xe], ve = Array(pe); for (let _e = 0; _e < pe; _e++)ve[_e] = ye[me[_e]]; ge.push(ve) } return ge } function allHeadersSame(fe) { let K = fe[0][0], pe = K.length; for (let me = 1; me < fe.length; me++) { let ge = fe[me][0]; if (ge.length != pe) return !1; if (ge != K) { for (let xe = 0; xe < pe; xe++)if (ge[xe] != K[xe]) return !1 } } return !0 } function isAsc(fe, K = 100) { const pe = fe.length; if (pe <= 1) return !0; let me = 0, ge = pe - 1; for (; me <= ge && fe[me] == null;)me++; for (; ge >= me && fe[ge] == null;)ge--; if (ge <= me) return !0; const xe = max$1(1, floor((ge - me + 1) / K)); for (let ye = fe[me], ve = me + xe; ve <= ge; ve += xe) { const _e = fe[ve]; if (_e != null) { if (_e <= ye) return !1; ye = _e } } return !0 } const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]; function slice3(fe) { return fe.slice(0, 3) } const days3 = days.map(slice3), months3 = months.map(slice3), engNames = { MMMM: months, MMM: months3, WWWW: days, WWW: days3 }; function zeroPad2(fe) { return (fe < 10 ? "0" : "") + fe } function zeroPad3(fe) { return (fe < 10 ? "00" : fe < 100 ? "0" : "") + fe } const subs = { YYYY: fe => fe.getFullYear(), YY: fe => (fe.getFullYear() + "").slice(2), MMMM: (fe, K) => K.MMMM[fe.getMonth()], MMM: (fe, K) => K.MMM[fe.getMonth()], MM: fe => zeroPad2(fe.getMonth() + 1), M: fe => fe.getMonth() + 1, DD: fe => zeroPad2(fe.getDate()), D: fe => fe.getDate(), WWWW: (fe, K) => K.WWWW[fe.getDay()], WWW: (fe, K) => K.WWW[fe.getDay()], HH: fe => zeroPad2(fe.getHours()), H: fe => fe.getHours(), h: fe => { let K = fe.getHours(); return K == 0 ? 12 : K > 12 ? K - 12 : K }, AA: fe => fe.getHours() >= 12 ? "PM" : "AM", aa: fe => fe.getHours() >= 12 ? "pm" : "am", a: fe => fe.getHours() >= 12 ? "p" : "a", mm: fe => zeroPad2(fe.getMinutes()), m: fe => fe.getMinutes(), ss: fe => zeroPad2(fe.getSeconds()), s: fe => fe.getSeconds(), fff: fe => zeroPad3(fe.getMilliseconds()) }; function fmtDate(fe, K) { K = K || engNames; let pe = [], me = /\{([a-z]+)\}|[^{]+/gi, ge; for (; ge = me.exec(fe);)pe.push(ge[0][0] == "{" ? subs[ge[1]] : ge[0]); return xe => { let ye = ""; for (let ve = 0; ve < pe.length; ve++)ye += typeof pe[ve] == "string" ? pe[ve] : pe[ve](xe, K); return ye } } const localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone; function tzDate(fe, K) { let pe; return K == "UTC" || K == "Etc/UTC" ? pe = new Date(+fe + fe.getTimezoneOffset() * 6e4) : K == localTz ? pe = fe : (pe = new Date(fe.toLocaleString("en-US", { timeZone: K })), pe.setMilliseconds(fe.getMilliseconds())), pe } const onlyWhole = fe => fe % 1 == 0, allMults = [1, 2, 2.5, 5], decIncrs = genIncrs(10, -32, 0, allMults), oneIncrs = genIncrs(10, 0, 32, allMults), wholeIncrs = oneIncrs.filter(onlyWhole), numIncrs = decIncrs.concat(oneIncrs), NL = `
`, yyyy = "{YYYY}", NLyyyy = NL + yyyy, md = "{M}/{D}", NLmd = NL + md, NLmdyy = NLmd + "/{YY}", aa = "{aa}", hmm = "{h}:{mm}", hmmaa = hmm + aa, NLhmmaa = NL + hmmaa, ss = ":{ss}", _$2 = null; function genTimeStuffs(fe) { let K = fe * 1e3, pe = K * 60, me = pe * 60, ge = me * 24, xe = ge * 30, ye = ge * 365, _e = (fe == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults)).concat([K, K * 5, K * 10, K * 15, K * 30, pe, pe * 5, pe * 10, pe * 15, pe * 30, me, me * 2, me * 3, me * 4, me * 6, me * 8, me * 12, ge, ge * 2, ge * 3, ge * 4, ge * 5, ge * 6, ge * 7, ge * 8, ge * 9, ge * 10, ge * 15, xe, xe * 2, xe * 3, xe * 4, xe * 6, ye, ye * 2, ye * 5, ye * 10, ye * 25, ye * 50, ye * 100]); const Ee = [[ye, yyyy, _$2, _$2, _$2, _$2, _$2, _$2, 1], [ge * 28, "{MMM}", NLyyyy, _$2, _$2, _$2, _$2, _$2, 1], [ge, md, NLyyyy, _$2, _$2, _$2, _$2, _$2, 1], [me, "{h}" + aa, NLmdyy, _$2, NLmd, _$2, _$2, _$2, 1], [pe, hmmaa, NLmdyy, _$2, NLmd, _$2, _$2, _$2, 1], [K, ss, NLmdyy + " " + hmmaa, _$2, NLmd + " " + hmmaa, _$2, NLhmmaa, _$2, 1], [fe, ss + ".{fff}", NLmdyy + " " + hmmaa, _$2, NLmd + " " + hmmaa, _$2, NLhmmaa, _$2, 1]]; function be(Ae) { return (Se, Ce, we, Be, De, Re) => { let Ie = [], Pe = De >= ye, Ne = De >= xe && De < ye, ke = Ae(we), Oe = roundDec(ke * fe, 3), Ue = mkDate(ke.getFullYear(), Pe ? 0 : ke.getMonth(), Ne || Pe ? 1 : ke.getDate()), He = roundDec(Ue * fe, 3); if (Ne || Pe) { let Ge = Ne ? De / xe : 0, ze = Pe ? De / ye : 0, We = Oe == He ? Oe : roundDec(mkDate(Ue.getFullYear() + ze, Ue.getMonth() + Ge, 1) * fe, 3), Xe = new Date(round(We / fe)), Ye = Xe.getFullYear(), Ze = Xe.getMonth(); for (let ot = 0; We <= Be; ot++) { let qe = mkDate(Ye + ze * ot, Ze + Ge * ot, 1), Qe = qe - Ae(roundDec(qe * fe, 3)); We = roundDec((+qe + Qe) * fe, 3), We <= Be && Ie.push(We) } } else { let Ge = De >= ge ? ge : De, ze = floor(we) - floor(Oe), We = He + ze + incrRoundUp(Oe - He, Ge); Ie.push(We); let Xe = Ae(We), Ye = Xe.getHours() + Xe.getMinutes() / pe + Xe.getSeconds() / me, Ze = De / me, ot = Se.axes[Ce]._space, qe = Re / ot; for (; We = roundDec(We + De, fe == 1 ? 0 : 3), !(We > Be);)if (Ze > 1) { let Qe = floor(roundDec(Ye + Ze, 6)) % 24, Je = Ae(We).getHours() - Qe; Je > 1 && (Je = -1), We -= Je * me, Ye = (Ye + Ze) % 24; let jt = Ie[Ie.length - 1]; roundDec((We - jt) / De, 3) * qe >= .7 && Ie.push(We) } else Ie.push(We) } return Ie } } return [_e, Ee, be] } const [timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs] = genTimeStuffs(1), [timeIncrsS, _timeAxisStampsS, timeAxisSplitsS] = genTimeStuffs(.001); genIncrs(2, -53, 53, [1]); function timeAxisStamps(fe, K) { return fe.map(pe => pe.map((me, ge) => ge == 0 || ge == 8 || me == null ? me : K(ge == 1 || pe[8] == 0 ? me : pe[1] + me))) } function timeAxisVals(fe, K) { return (pe, me, ge, xe, ye) => { let ve = K.find(we => ye >= we[0]) || K[K.length - 1], _e, Ee, be, Ae, Se, Ce; return me.map(we => { let Be = fe(we), De = Be.getFullYear(), Re = Be.getMonth(), Ie = Be.getDate(), Pe = Be.getHours(), Ne = Be.getMinutes(), ke = Be.getSeconds(), Oe = De != _e && ve[2] || Re != Ee && ve[3] || Ie != be && ve[4] || Pe != Ae && ve[5] || Ne != Se && ve[6] || ke != Ce && ve[7] || ve[1]; return _e = De, Ee = Re, be = Ie, Ae = Pe, Se = Ne, Ce = ke, Oe(Be) }) } } function timeAxisVal(fe, K) { let pe = fmtDate(K); return (me, ge, xe, ye, ve) => ge.map(_e => pe(fe(_e))) } function mkDate(fe, K, pe) { return new Date(fe, K, pe) } function timeSeriesStamp(fe, K) { return K(fe) } const _timeSeriesStamp = "{YYYY}-{MM}-{DD} {h}:{mm}{aa}"; function timeSeriesVal(fe, K) { return (pe, me, ge, xe) => xe == null ? LEGEND_DISP : K(fe(me)) } function legendStroke(fe, K) { let pe = fe.series[K]; return pe.width ? pe.stroke(fe, K) : pe.points.width ? pe.points.stroke(fe, K) : null } function legendFill(fe, K) { return fe.series[K].fill(fe, K) } const legendOpts = { show: !0, live: !0, isolate: !1, mount: noop, markers: { show: !0, width: 2, stroke: legendStroke, fill: legendFill, dash: "solid" }, idx: null, idxs: null, values: [] }; function cursorPointShow(fe, K) { let pe = fe.cursor.points, me = placeDiv(), ge = pe.size(fe, K); setStylePx(me, WIDTH, ge), setStylePx(me, HEIGHT, ge); let xe = ge / -2; setStylePx(me, "marginLeft", xe), setStylePx(me, "marginTop", xe); let ye = pe.width(fe, K, ge); return ye && setStylePx(me, "borderWidth", ye), me } function cursorPointFill(fe, K) { let pe = fe.series[K].points; return pe._fill || pe._stroke } function cursorPointStroke(fe, K) { let pe = fe.series[K].points; return pe._stroke || pe._fill } function cursorPointSize(fe, K) { return fe.series[K].points.size } const moveTuple = [0, 0]; function cursorMove(fe, K, pe) { return moveTuple[0] = K, moveTuple[1] = pe, moveTuple } function filtBtn0(fe, K, pe, me = !0) { return ge => { ge.button == 0 && (!me || ge.target == K) && pe(ge) } } function filtTarg(fe, K, pe, me = !0) { return ge => { (!me || ge.target == K) && pe(ge) } } const cursorOpts = { show: !0, x: !0, y: !0, lock: !1, move: cursorMove, points: { one: !1, show: cursorPointShow, size: cursorPointSize, width: 0, stroke: cursorPointStroke, fill: cursorPointFill }, bind: { mousedown: filtBtn0, mouseup: filtBtn0, click: filtBtn0, dblclick: filtBtn0, mousemove: filtTarg, mouseleave: filtTarg, mouseenter: filtTarg }, drag: { setScale: !0, x: !0, y: !1, dist: 0, uni: null, click: (fe, K) => { K.stopPropagation(), K.stopImmediatePropagation() }, _x: !1, _y: !1 }, focus: { dist: (fe, K, pe, me, ge) => me - ge, prox: -1, bias: 0 }, hover: { skip: [void 0], prox: null, bias: 0 }, left: -10, top: -10, idx: null, dataIdx: null, idxs: null, event: null }, axisLines = { show: !0, stroke: "rgba(0,0,0,0.07)", width: 2 }, grid = assign({}, axisLines, { filter: retArg1 }), ticks = assign({}, grid, { size: 10 }), border = assign({}, axisLines, { show: !1 }), font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"', labelFont = "bold " + font, lineGap = 1.5, xAxisOpts = { show: !0, scale: "x", stroke: hexBlack, space: 50, gap: 5, alignTo: 1, size: 50, labelGap: 0, labelSize: 30, labelFont, side: 2, grid, ticks, border, font, lineGap, rotate: 0 }, numSeriesLabel = "Value", timeSeriesLabel = "Time", xSeriesOpts = { show: !0, scale: "x", auto: !1, sorted: 1, min: inf, max: -inf, idxs: [] }; function numAxisVals(fe, K, pe, me, ge) { return K.map(xe => xe == null ? "" : fmtNum(xe)) } function numAxisSplits(fe, K, pe, me, ge, xe, ye) { let ve = [], _e = fixedDec.get(ge) || 0; pe = ye ? pe : roundDec(incrRoundUp(pe, ge), _e); for (let Ee = pe; Ee <= me; Ee = roundDec(Ee + ge, _e))ve.push(Object.is(Ee, -0) ? 0 : Ee); return ve } function logAxisSplits(fe, K, pe, me, ge, xe, ye) { const ve = [], _e = fe.scales[fe.axes[K].scale].log, Ee = _e == 10 ? log10 : log2, be = floor(Ee(pe)); ge = pow(_e, be), _e == 10 && (ge = numIncrs[closestIdx(ge, numIncrs)]); let Ae = pe, Se = ge * _e; _e == 10 && (Se = numIncrs[closestIdx(Se, numIncrs)]); do ve.push(Ae), Ae = Ae + ge, _e == 10 && !fixedDec.has(Ae) && (Ae = roundDec(Ae, fixedDec.get(ge))), Ae >= Se && (ge = Ae, Se = ge * _e, _e == 10 && (Se = numIncrs[closestIdx(Se, numIncrs)])); while (Ae <= me); return ve } function asinhAxisSplits(fe, K, pe, me, ge, xe, ye) { let _e = fe.scales[fe.axes[K].scale].asinh, Ee = me > _e ? logAxisSplits(fe, K, max$1(_e, pe), me, ge) : [_e], be = me >= 0 && pe <= 0 ? [0] : []; return (pe < -_e ? logAxisSplits(fe, K, max$1(_e, -me), -pe, ge) : [_e]).reverse().map(Se => -Se).concat(be, Ee) } const RE_ALL = /./, RE_12357 = /[12357]/, RE_125 = /[125]/, RE_1 = /1/, _filt = (fe, K, pe, me) => fe.map((ge, xe) => K == 4 && ge == 0 || xe % me == 0 && pe.test(ge.toExponential()[ge < 0 ? 1 : 0]) ? ge : null); function log10AxisValsFilt(fe, K, pe, me, ge) { let xe = fe.axes[pe], ye = xe.scale, ve = fe.scales[ye], _e = fe.valToPos, Ee = xe._space, be = _e(10, ye), Ae = _e(9, ye) - be >= Ee ? RE_ALL : _e(7, ye) - be >= Ee ? RE_12357 : _e(5, ye) - be >= Ee ? RE_125 : RE_1; if (Ae == RE_1) { let Se = abs(_e(1, ye) - be); if (Se < Ee) return _filt(K.slice().reverse(), ve.distr, Ae, ceil(Ee / Se)).reverse() } return _filt(K, ve.distr, Ae, 1) } function log2AxisValsFilt(fe, K, pe, me, ge) { let xe = fe.axes[pe], ye = xe.scale, ve = xe._space, _e = fe.valToPos, Ee = abs(_e(1, ye) - _e(2, ye)); return Ee < ve ? _filt(K.slice().reverse(), 3, RE_ALL, ceil(ve / Ee)).reverse() : K } function numSeriesVal(fe, K, pe, me) { return me == null ? LEGEND_DISP : K == null ? "" : fmtNum(K) } const yAxisOpts = { show: !0, scale: "y", stroke: hexBlack, space: 30, gap: 5, alignTo: 1, size: 50, labelGap: 0, labelSize: 30, labelFont, side: 3, grid, ticks, border, font, lineGap, rotate: 0 }; function ptDia(fe, K) { let pe = 3 + (fe || 1) * 2; return roundDec(pe * K, 3) } function seriesPointsShow(fe, K) { let { scale: pe, idxs: me } = fe.series[0], ge = fe._data[0], xe = fe.valToPos(ge[me[0]], pe, !0), ye = fe.valToPos(ge[me[1]], pe, !0), ve = abs(ye - xe), _e = fe.series[K], Ee = ve / (_e.points.space * pxRatio); return me[1] - me[0] <= Ee } const facet = { scale: null, auto: !0, sorted: 0, min: inf, max: -inf }, gaps = (fe, K, pe, me, ge) => ge, xySeriesOpts = { show: !0, auto: !0, sorted: 0, gaps, alpha: 1, facets: [assign({}, facet, { scale: "x" }), assign({}, facet, { scale: "y" })] }, ySeriesOpts = { scale: "y", auto: !0, sorted: 0, show: !0, spanGaps: !1, gaps, alpha: 1, points: { show: seriesPointsShow, filter: null }, values: null, min: inf, max: -inf, idxs: [], path: null, clip: null }; function clampScale(fe, K, pe, me, ge) { return pe / 10 } const xScaleOpts = { time: FEAT_TIME, auto: !0, distr: 1, log: 10, asinh: 1, min: null, max: null, dir: 1, ori: 0 }, yScaleOpts = assign({}, xScaleOpts, { time: !1, ori: 1 }), syncs = {}; function _sync(fe, K) { let pe = syncs[fe]; return pe || (pe = { key: fe, plots: [], sub(me) { pe.plots.push(me) }, unsub(me) { pe.plots = pe.plots.filter(ge => ge != me) }, pub(me, ge, xe, ye, ve, _e, Ee) { for (let be = 0; be < pe.plots.length; be++)pe.plots[be] != ge && pe.plots[be].pub(me, ge, xe, ye, ve, _e, Ee) } }, fe != null && (syncs[fe] = pe)), pe } const BAND_CLIP_FILL = 1, BAND_CLIP_STROKE = 2; function orient(fe, K, pe) { const me = fe.mode, ge = fe.series[K], xe = me == 2 ? fe._data[K] : fe._data, ye = fe.scales, ve = fe.bbox; let _e = xe[0], Ee = me == 2 ? xe[1] : xe[K], be = me == 2 ? ye[ge.facets[0].scale] : ye[fe.series[0].scale], Ae = me == 2 ? ye[ge.facets[1].scale] : ye[ge.scale], Se = ve.left, Ce = ve.top, we = ve.width, Be = ve.height, De = fe.valToPosH, Re = fe.valToPosV; return be.ori == 0 ? pe(ge, _e, Ee, be, Ae, De, Re, Se, Ce, we, Be, moveToH, lineToH, rectH, arcH, bezierCurveToH) : pe(ge, _e, Ee, be, Ae, Re, De, Ce, Se, Be, we, moveToV, lineToV, rectV, arcV, bezierCurveToV) } function bandFillClipDirs(fe, K) { let pe = 0, me = 0, ge = ifNull(fe.bands, EMPTY_ARR); for (let xe = 0; xe < ge.length; xe++) { let ye = ge[xe]; ye.series[0] == K ? pe = ye.dir : ye.series[1] == K && (ye.dir == 1 ? me |= 1 : me |= 2) } return [pe, me == 1 ? -1 : me == 2 ? 1 : me == 3 ? 2 : 0] } function seriesFillTo(fe, K, pe, me, ge) { let xe = fe.mode, ye = fe.series[K], ve = xe == 2 ? ye.facets[1].scale : ye.scale, _e = fe.scales[ve]; return ge == -1 ? _e.min : ge == 1 ? _e.max : _e.distr == 3 ? _e.dir == 1 ? _e.min : _e.max : 0 } function clipBandLine(fe, K, pe, me, ge, xe) { return orient(fe, K, (ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) => { let Re = ye.pxRound; const Ie = Ee.dir * (Ee.ori == 0 ? 1 : -1), Pe = Ee.ori == 0 ? lineToH : lineToV; let Ne, ke; Ie == 1 ? (Ne = pe, ke = me) : (Ne = me, ke = pe); let Oe = Re(Ae(ve[Ne], Ee, Be, Ce)), Ue = Re(Se(_e[Ne], be, De, we)), He = Re(Ae(ve[ke], Ee, Be, Ce)), Ge = Re(Se(xe == 1 ? be.max : be.min, be, De, we)), ze = new Path2D(ge); return Pe(ze, He, Ge), Pe(ze, Oe, Ge), Pe(ze, Oe, Ue), ze }) } function clipGaps(fe, K, pe, me, ge, xe) { let ye = null; if (fe.length > 0) { ye = new Path2D; const ve = K == 0 ? rectH : rectV; let _e = pe; for (let Ae = 0; Ae < fe.length; Ae++) { let Se = fe[Ae]; if (Se[1] > Se[0]) { let Ce = Se[0] - _e; Ce > 0 && ve(ye, _e, me, Ce, me + xe), _e = Se[1] } } let Ee = pe + ge - _e, be = 10; Ee > 0 && ve(ye, _e, me - be / 2, Ee, me + xe + be) } return ye } function addGap(fe, K, pe) { let me = fe[fe.length - 1]; me && me[0] == K ? me[1] = pe : fe.push([K, pe]) } function findGaps(fe, K, pe, me, ge, xe, ye) { let ve = [], _e = fe.length; for (let Ee = ge == 1 ? pe : me; Ee >= pe && Ee <= me; Ee += ge)if (K[Ee] === null) { let Ae = Ee, Se = Ee; if (ge == 1) for (; ++Ee <= me && K[Ee] === null;)Se = Ee; else for (; --Ee >= pe && K[Ee] === null;)Se = Ee; let Ce = xe(fe[Ae]), we = Se == Ae ? Ce : xe(fe[Se]), Be = Ae - ge; Ce = ye <= 0 && Be >= 0 && Be < _e ? xe(fe[Be]) : Ce; let Re = Se + ge; we = ye >= 0 && Re >= 0 && Re < _e ? xe(fe[Re]) : we, we >= Ce && ve.push([Ce, we]) } return ve } function pxRoundGen(fe) { return fe == 0 ? retArg0 : fe == 1 ? round : K => incrRound(K, fe) } function rect(fe) { let K = fe == 0 ? moveToH : moveToV, pe = fe == 0 ? (ge, xe, ye, ve, _e, Ee) => { ge.arcTo(xe, ye, ve, _e, Ee) } : (ge, xe, ye, ve, _e, Ee) => { ge.arcTo(ye, xe, _e, ve, Ee) }, me = fe == 0 ? (ge, xe, ye, ve, _e) => { ge.rect(xe, ye, ve, _e) } : (ge, xe, ye, ve, _e) => { ge.rect(ye, xe, _e, ve) }; return (ge, xe, ye, ve, _e, Ee = 0, be = 0) => { Ee == 0 && be == 0 ? me(ge, xe, ye, ve, _e) : (Ee = min(Ee, ve / 2, _e / 2), be = min(be, ve / 2, _e / 2), K(ge, xe + Ee, ye), pe(ge, xe + ve, ye, xe + ve, ye + _e, Ee), pe(ge, xe + ve, ye + _e, xe, ye + _e, be), pe(ge, xe, ye + _e, xe, ye, be), pe(ge, xe, ye, xe + ve, ye, Ee), ge.closePath()) } } const moveToH = (fe, K, pe) => { fe.moveTo(K, pe) }, moveToV = (fe, K, pe) => { fe.moveTo(pe, K) }, lineToH = (fe, K, pe) => { fe.lineTo(K, pe) }, lineToV = (fe, K, pe) => { fe.lineTo(pe, K) }, rectH = rect(0), rectV = rect(1), arcH = (fe, K, pe, me, ge, xe) => { fe.arc(K, pe, me, ge, xe) }, arcV = (fe, K, pe, me, ge, xe) => { fe.arc(pe, K, me, ge, xe) }, bezierCurveToH = (fe, K, pe, me, ge, xe, ye) => { fe.bezierCurveTo(K, pe, me, ge, xe, ye) }, bezierCurveToV = (fe, K, pe, me, ge, xe, ye) => { fe.bezierCurveTo(pe, K, ge, me, ye, xe) }; function points(fe) { return (K, pe, me, ge, xe) => orient(K, pe, (ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) => { let { pxRound: Re, points: Ie } = ye, Pe, Ne; Ee.ori == 0 ? (Pe = moveToH, Ne = arcH) : (Pe = moveToV, Ne = arcV); const ke = roundDec(Ie.width * pxRatio, 3); let Oe = (Ie.size - Ie.width) / 2 * pxRatio, Ue = roundDec(Oe * 2, 3), He = new Path2D, Ge = new Path2D, { left: ze, top: We, width: Xe, height: Ye } = K.bbox; rectH(Ge, ze - Ue, We - Ue, Xe + Ue * 2, Ye + Ue * 2); const Ze = ot => { if (_e[ot] != null) { let qe = Re(Ae(ve[ot], Ee, Be, Ce)), Qe = Re(Se(_e[ot], be, De, we)); Pe(He, qe + Oe, Qe), Ne(He, qe, Qe, Oe, 0, PI * 2) } }; if (xe) xe.forEach(Ze); else for (let ot = me; ot <= ge; ot++)Ze(ot); return { stroke: ke > 0 ? He : null, fill: He, clip: Ge, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE } }) } function _drawAcc(fe) { return (K, pe, me, ge, xe, ye) => { me != ge && (xe != me && ye != me && fe(K, pe, me), xe != ge && ye != ge && fe(K, pe, ge), fe(K, pe, ye)) } } const drawAccH = _drawAcc(lineToH), drawAccV = _drawAcc(lineToV); function linear(fe) { const K = ifNull(fe?.alignGaps, 0); return (pe, me, ge, xe) => orient(pe, me, (ye, ve, _e, Ee, be, Ae, Se, Ce, we, Be, De) => { [ge, xe] = nonNullIdxs(_e, ge, xe); let Re = ye.pxRound, Ie = Ye => Re(Ae(Ye, Ee, Be, Ce)), Pe = Ye => Re(Se(Ye, be, De, we)), Ne, ke; Ee.ori == 0 ? (Ne = lineToH, ke = drawAccH) : (Ne = lineToV, ke = drawAccV); const Oe = Ee.dir * (Ee.ori == 0 ? 1 : -1), Ue = { stroke: new Path2D, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL }, He = Ue.stroke; let Ge = !1; if (xe - ge >= Be * 4) { let Ye = ct => pe.posToVal(ct, Ee.key, !0), Ze = null, ot = null, qe, Qe, st, Nt = Ie(ve[Oe == 1 ? ge : xe]), Je = Ie(ve[ge]), jt = Ie(ve[xe]), Xt = Ye(Oe == 1 ? Je + 1 : jt - 1); for (let ct = Oe == 1 ? ge : xe; ct >= ge && ct <= xe; ct += Oe) { let nn = ve[ct], an = (Oe == 1 ? nn < Xt : nn > Xt) ? Nt : Ie(nn), gn = _e[ct]; an == Nt ? gn != null ? (Qe = gn, Ze == null ? (Ne(He, an, Pe(Qe)), qe = Ze = ot = Qe) : Qe < Ze ? Ze = Qe : Qe > ot && (ot = Qe)) : gn === null && (Ge = !0) : (Ze != null && ke(He, Nt, Pe(Ze), Pe(ot), Pe(qe), Pe(Qe)), gn != null ? (Qe = gn, Ne(He, an, Pe(Qe)), Ze = ot = qe = Qe) : (Ze = ot = null, gn === null && (Ge = !0)), Nt = an, Xt = Ye(Nt + Oe)) } Ze != null && Ze != ot && st != Nt && ke(He, Nt, Pe(Ze), Pe(ot), Pe(qe), Pe(Qe)) } else for (let Ye = Oe == 1 ? ge : xe; Ye >= ge && Ye <= xe; Ye += Oe) { let Ze = _e[Ye]; Ze === null ? Ge = !0 : Ze != null && Ne(He, Ie(ve[Ye]), Pe(Ze)) } let [We, Xe] = bandFillClipDirs(pe, me); if (ye.fill != null || We != 0) { let Ye = Ue.fill = new Path2D(He), Ze = ye.fillTo(pe, me, ye.min, ye.max, We), ot = Pe(Ze), qe = Ie(ve[ge]), Qe = Ie(ve[xe]); Oe == -1 && ([Qe, qe] = [qe, Qe]), Ne(Ye, Qe, ot), Ne(Ye, qe, ot) } if (!ye.spanGaps) { let Ye = []; Ge && Ye.push(...findGaps(ve, _e, ge, xe, Oe, Ie, K)), Ue.gaps = Ye = ye.gaps(pe, me, ge, xe, Ye), Ue.clip = clipGaps(Ye, Ee.ori, Ce, we, Be, De) } return Xe != 0 && (Ue.band = Xe == 2 ? [clipBandLine(pe, me, ge, xe, He, -1), clipBandLine(pe, me, ge, xe, He, 1)] : clipBandLine(pe, me, ge, xe, He, Xe)), Ue }) } function stepped(fe) { const K = ifNull(fe.align, 1), pe = ifNull(fe.ascDesc, !1), me = ifNull(fe.alignGaps, 0), ge = ifNull(fe.extend, !1); return (xe, ye, ve, _e) => orient(xe, ye, (Ee, be, Ae, Se, Ce, we, Be, De, Re, Ie, Pe) => { [ve, _e] = nonNullIdxs(Ae, ve, _e); let Ne = Ee.pxRound, { left: ke, width: Oe } = xe.bbox, Ue = Je => Ne(we(Je, Se, Ie, De)), He = Je => Ne(Be(Je, Ce, Pe, Re)), Ge = Se.ori == 0 ? lineToH : lineToV; const ze = { stroke: new Path2D, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL }, We = ze.stroke, Xe = Se.dir * (Se.ori == 0 ? 1 : -1); let Ye = He(Ae[Xe == 1 ? ve : _e]), Ze = Ue(be[Xe == 1 ? ve : _e]), ot = Ze, qe = Ze; ge && K == -1 && (qe = ke, Ge(We, qe, Ye)), Ge(We, Ze, Ye); for (let Je = Xe == 1 ? ve : _e; Je >= ve && Je <= _e; Je += Xe) { let jt = Ae[Je]; if (jt == null) continue; let Xt = Ue(be[Je]), ct = He(jt); K == 1 ? Ge(We, Xt, Ye) : Ge(We, ot, ct), Ge(We, Xt, ct), Ye = ct, ot = Xt } let Qe = ot; ge && K == 1 && (Qe = ke + Oe, Ge(We, Qe, Ye)); let [st, Nt] = bandFillClipDirs(xe, ye); if (Ee.fill != null || st != 0) { let Je = ze.fill = new Path2D(We), jt = Ee.fillTo(xe, ye, Ee.min, Ee.max, st), Xt = He(jt); Ge(Je, Qe, Xt), Ge(Je, qe, Xt) } if (!Ee.spanGaps) { let Je = []; Je.push(...findGaps(be, Ae, ve, _e, Xe, Ue, me)); let jt = Ee.width * pxRatio / 2, Xt = pe || K == 1 ? jt : -jt, ct = pe || K == -1 ? -jt : jt; Je.forEach(nn => { nn[0] += Xt, nn[1] += ct }), ze.gaps = Je = Ee.gaps(xe, ye, ve, _e, Je), ze.clip = clipGaps(Je, Se.ori, De, Re, Ie, Pe) } return Nt != 0 && (ze.band = Nt == 2 ? [clipBandLine(xe, ye, ve, _e, We, -1), clipBandLine(xe, ye, ve, _e, We, 1)] : clipBandLine(xe, ye, ve, _e, We, Nt)), ze }) } function findColWidth(fe, K, pe, me, ge, xe, ye = inf) { if (fe.length > 1) { let ve = null; for (let _e = 0, Ee = 1 / 0; _e < fe.length; _e++)if (K[_e] !== void 0) { if (ve != null) { let be = abs(fe[_e] - fe[ve]); be < Ee && (Ee = be, ye = abs(pe(fe[_e], me, ge, xe) - pe(fe[ve], me, ge, xe))) } ve = _e } } return ye } function bars(fe) { fe = fe || EMPTY_OBJ; const K = ifNull(fe.size, [.6, inf, 1]), pe = fe.align || 0, me = fe.gap || 0; let ge = fe.radius; ge = ge == null ? [0, 0] : typeof ge == "number" ? [ge, 0] : ge; const xe = fnOrSelf(ge), ye = 1 - K[0], ve = ifNull(K[1], inf), _e = ifNull(K[2], 1), Ee = ifNull(fe.disp, EMPTY_OBJ), be = ifNull(fe.each, Ce => { }), { fill: Ae, stroke: Se } = Ee; return (Ce, we, Be, De) => orient(Ce, we, (Re, Ie, Pe, Ne, ke, Oe, Ue, He, Ge, ze, We) => { let Xe = Re.pxRound, Ye = pe, Ze = me * pxRatio, ot = ve * pxRatio, qe = _e * pxRatio, Qe, st; Ne.ori == 0 ? [Qe, st] = xe(Ce, we) : [st, Qe] = xe(Ce, we); const Nt = Ne.dir * (Ne.ori == 0 ? 1 : -1); let Je = Ne.ori == 0 ? rectH : rectV, jt = Ne.ori == 0 ? be : (cn, Wt, un, Ft, Sn, lr, jn) => { be(cn, Wt, un, Sn, Ft, jn, lr) }, Xt = ifNull(Ce.bands, EMPTY_ARR).find(cn => cn.series[0] == we), ct = Xt != null ? Xt.dir : 0, nn = Re.fillTo(Ce, we, Re.min, Re.max, ct), $t = Xe(Ue(nn, ke, We, Ge)), an, gn, Mn, Xn = ze, Ln = Xe(Re.width * pxRatio), Gn = !1, wn = null, Bn = null, Gt = null, nr = null; Ae != null && (Ln == 0 || Se != null) && (Gn = !0, wn = Ae.values(Ce, we, Be, De), Bn = new Map, new Set(wn).forEach(cn => { cn != null && Bn.set(cn, new Path2D) }), Ln > 0 && (Gt = Se.values(Ce, we, Be, De), nr = new Map, new Set(Gt).forEach(cn => { cn != null && nr.set(cn, new Path2D) }))); let { x0: Kn, size: vn } = Ee; if (Kn != null && vn != null) { Ye = 1, Ie = Kn.values(Ce, we, Be, De), Kn.unit == 2 && (Ie = Ie.map(un => Ce.posToVal(He + un * ze, Ne.key, !0))); let cn = vn.values(Ce, we, Be, De); vn.unit == 2 ? gn = cn[0] * ze : gn = Oe(cn[0], Ne, ze, He) - Oe(0, Ne, ze, He), Xn = findColWidth(Ie, Pe, Oe, Ne, ze, He, Xn), Mn = Xn - gn + Ze } else Xn = findColWidth(Ie, Pe, Oe, Ne, ze, He, Xn), Mn = Xn * ye + Ze, gn = Xn - Mn; Mn < 1 && (Mn = 0), Ln >= gn / 2 && (Ln = 0), Mn < 5 && (Xe = retArg0); let yn = Mn > 0, Hn = Xn - Mn - (yn ? Ln : 0); gn = Xe(clamp$1(Hn, qe, ot)), an = (Ye == 0 ? gn / 2 : Ye == Nt ? 0 : gn) - Ye * Nt * ((Ye == 0 ? Ze / 2 : 0) + (yn ? Ln / 2 : 0)); const kn = { stroke: null, fill: null, clip: null, band: null, gaps: null, flags: 0 }, Ht = Gn ? null : new Path2D; let Dt = null; if (Xt != null) Dt = Ce.data[Xt.series[1]]; else { let { y0: cn, y1: Wt } = Ee; cn != null && Wt != null && (Pe = Wt.values(Ce, we, Be, De), Dt = cn.values(Ce, we, Be, De)) } let fn = Qe * gn, en = st * gn; for (let cn = Nt == 1 ? Be : De; cn >= Be && cn <= De; cn += Nt) { let Wt = Pe[cn]; if (Wt == null) continue; if (Dt != null) { let Yn = Dt[cn] ?? 0; if (Wt - Yn == 0) continue; $t = Ue(Yn, ke, We, Ge) } let un = Ne.distr != 2 || Ee != null ? Ie[cn] : cn, Ft = Oe(un, Ne, ze, He), Sn = Ue(ifNull(Wt, nn), ke, We, Ge), lr = Xe(Ft - an), jn = Xe(max$1(Sn, $t)), Pn = Xe(min(Sn, $t)), fr = jn - Pn; if (Wt != null) { let Yn = Wt < 0 ? en : fn, sr = Wt < 0 ? fn : en; Gn ? (Ln > 0 && Gt[cn] != null && Je(nr.get(Gt[cn]), lr, Pn + floor(Ln / 2), gn, max$1(0, fr - Ln), Yn, sr), wn[cn] != null && Je(Bn.get(wn[cn]), lr, Pn + floor(Ln / 2), gn, max$1(0, fr - Ln), Yn, sr)) : Je(Ht, lr, Pn + floor(Ln / 2), gn, max$1(0, fr - Ln), Yn, sr), jt(Ce, we, cn, lr - Ln / 2, Pn, gn + Ln, fr) } } return Ln > 0 ? kn.stroke = Gn ? nr : Ht : Gn || (kn._fill = Re.width == 0 ? Re._fill : Re._stroke ?? Re._fill, kn.width = 0), kn.fill = Gn ? Bn : Ht, kn }) } function splineInterp(fe, K) { const pe = ifNull(K?.alignGaps, 0); return (me, ge, xe, ye) => orient(me, ge, (ve, _e, Ee, be, Ae, Se, Ce, we, Be, De, Re) => { [xe, ye] = nonNullIdxs(Ee, xe, ye); let Ie = ve.pxRound, Pe = Qe => Ie(Se(Qe, be, De, we)), Ne = Qe => Ie(Ce(Qe, Ae, Re, Be)), ke, Oe, Ue; be.ori == 0 ? (ke = moveToH, Ue = lineToH, Oe = bezierCurveToH) : (ke = moveToV, Ue = lineToV, Oe = bezierCurveToV); const He = be.dir * (be.ori == 0 ? 1 : -1); let Ge = Pe(_e[He == 1 ? xe : ye]), ze = Ge, We = [], Xe = []; for (let Qe = He == 1 ? xe : ye; Qe >= xe && Qe <= ye; Qe += He)if (Ee[Qe] != null) { let Nt = _e[Qe], Je = Pe(Nt); We.push(ze = Je), Xe.push(Ne(Ee[Qe])) } const Ye = { stroke: fe(We, Xe, ke, Ue, Oe, Ie), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL }, Ze = Ye.stroke; let [ot, qe] = bandFillClipDirs(me, ge); if (ve.fill != null || ot != 0) { let Qe = Ye.fill = new Path2D(Ze), st = ve.fillTo(me, ge, ve.min, ve.max, ot), Nt = Ne(st); Ue(Qe, ze, Nt), Ue(Qe, Ge, Nt) } if (!ve.spanGaps) { let Qe = []; Qe.push(...findGaps(_e, Ee, xe, ye, He, Pe, pe)), Ye.gaps = Qe = ve.gaps(me, ge, xe, ye, Qe), Ye.clip = clipGaps(Qe, be.ori, we, Be, De, Re) } return qe != 0 && (Ye.band = qe == 2 ? [clipBandLine(me, ge, xe, ye, Ze, -1), clipBandLine(me, ge, xe, ye, Ze, 1)] : clipBandLine(me, ge, xe, ye, Ze, qe)), Ye }) } function monotoneCubic(fe) { return splineInterp(_monotoneCubic, fe) } function _monotoneCubic(fe, K, pe, me, ge, xe) { const ye = fe.length; if (ye < 2) return null; const ve = new Path2D; if (pe(ve, fe[0], K[0]), ye == 2) me(ve, fe[1], K[1]); else { let _e = Array(ye), Ee = Array(ye - 1), be = Array(ye - 1), Ae = Array(ye - 1); for (let Se = 0; Se < ye - 1; Se++)be[Se] = K[Se + 1] - K[Se], Ae[Se] = fe[Se + 1] - fe[Se], Ee[Se] = be[Se] / Ae[Se]; _e[0] = Ee[0]; for (let Se = 1; Se < ye - 1; Se++)Ee[Se] === 0 || Ee[Se - 1] === 0 || Ee[Se - 1] > 0 != Ee[Se] > 0 ? _e[Se] = 0 : (_e[Se] = 3 * (Ae[Se - 1] + Ae[Se]) / ((2 * Ae[Se] + Ae[Se - 1]) / Ee[Se - 1] + (Ae[Se] + 2 * Ae[Se - 1]) / Ee[Se]), isFinite(_e[Se]) || (_e[Se] = 0)); _e[ye - 1] = Ee[ye - 2]; for (let Se = 0; Se < ye - 1; Se++)ge(ve, fe[Se] + Ae[Se] / 3, K[Se] + _e[Se] * Ae[Se] / 3, fe[Se + 1] - Ae[Se] / 3, K[Se + 1] - _e[Se + 1] * Ae[Se] / 3, fe[Se + 1], K[Se + 1]) } return ve } const cursorPlots = new Set; function invalidateRects() { for (let fe of cursorPlots) fe.syncRect(!0) } domEnv && (on(resize, win, invalidateRects), on(scroll, win, invalidateRects, !0), on(dppxchange, win, () => { uPlot.pxRatio = pxRatio })); const linearPath = linear(), pointsPath = points(); function setDefaults(fe, K, pe, me) { return (me ? [fe[0], fe[1]].concat(fe.slice(2)) : [fe[0]].concat(fe.slice(1))).map((xe, ye) => setDefault(xe, ye, K, pe)) } function setDefaults2(fe, K) { return fe.map((pe, me) => me == 0 ? {} : assign({}, K, pe)) } function setDefault(fe, K, pe, me) { return assign({}, K == 0 ? pe : me, fe) } function snapNumX(fe, K, pe) { return K == null ? nullNullTuple : [K, pe] } const snapTimeX = snapNumX; function snapNumY(fe, K, pe) { return K == null ? nullNullTuple : rangeNum(K, pe, rangePad, !0) } function snapLogY(fe, K, pe, me) { return K == null ? nullNullTuple : rangeLog(K, pe, fe.scales[me].log, !1) } const snapLogX = snapLogY; function snapAsinhY(fe, K, pe, me) { return K == null ? nullNullTuple : rangeAsinh(K, pe, fe.scales[me].log, !1) } const snapAsinhX = snapAsinhY; function findIncr(fe, K, pe, me, ge) { let xe = max$1(numIntDigits(fe), numIntDigits(K)), ye = K - fe, ve = closestIdx(ge / me * ye, pe); do { let _e = pe[ve], Ee = me * _e / ye; if (Ee >= ge && xe + (_e < 5 ? fixedDec.get(_e) : 0) <= 17) return [_e, Ee] } while (++ve < pe.length); return [0, 0] } function pxRatioFont(fe) { let K, pe; return fe = fe.replace(/(\d+)px/, (me, ge) => (K = round((pe = +ge) * pxRatio)) + "px"), [fe, K, pe] } function syncFontSize(fe) { fe.show && [fe.font, fe.labelFont].forEach(K => { let pe = roundDec(K[2] * pxRatio, 1); K[0] = K[0].replace(/[0-9.]+px/, pe + "px"), K[1] = pe }) } function uPlot(fe, K, pe) {
	const me = { mode: ifNull(fe.mode, 1) }, ge = me.mode; function xe(at, kt, Kt, tn) { let xn = kt.valToPct(at); return tn + Kt * (kt.dir == -1 ? 1 - xn : xn) } function ye(at, kt, Kt, tn) { let xn = kt.valToPct(at); return tn + Kt * (kt.dir == -1 ? xn : 1 - xn) } function ve(at, kt, Kt, tn) { return kt.ori == 0 ? xe(at, kt, Kt, tn) : ye(at, kt, Kt, tn) } me.valToPosH = xe, me.valToPosV = ye; let _e = !1; me.status = 0; const Ee = me.root = placeDiv(UPLOT); if (fe.id != null && (Ee.id = fe.id), addClass(Ee, fe.class), fe.title) { let at = placeDiv(TITLE, Ee); at.textContent = fe.title } const be = placeTag("canvas"), Ae = me.ctx = be.getContext("2d"), Se = placeDiv(WRAP, Ee); on("click", Se, at => { at.target === we && (ai != pr || vi != zr) && Fi.click(me, at) }, !0); const Ce = me.under = placeDiv(UNDER, Se); Se.appendChild(be); const we = me.over = placeDiv(OVER, Se); fe = copy(fe); const Be = +ifNull(fe.pxAlign, 1), De = pxRoundGen(Be); (fe.plugins || []).forEach(at => { at.opts && (fe = at.opts(me, fe) || fe) }); const Re = fe.ms || .001, Ie = me.series = ge == 1 ? setDefaults(fe.series || [], xSeriesOpts, ySeriesOpts, !1) : setDefaults2(fe.series || [null], xySeriesOpts), Pe = me.axes = setDefaults(fe.axes || [], xAxisOpts, yAxisOpts, !0), Ne = me.scales = {}, ke = me.bands = fe.bands || []; ke.forEach(at => { at.fill = fnOrSelf(at.fill || null), at.dir = ifNull(at.dir, -1) }); const Oe = ge == 2 ? Ie[1].facets[0].scale : Ie[0].scale, Ue = { axes: $r, series: kr }, He = (fe.drawOrder || ["axes", "series"]).map(at => Ue[at]); function Ge(at) { const kt = at.distr == 3 ? Kt => log10(Kt > 0 ? Kt : at.clamp(me, Kt, at.min, at.max, at.key)) : at.distr == 4 ? Kt => asinh(Kt, at.asinh) : at.distr == 100 ? Kt => at.fwd(Kt) : Kt => Kt; return Kt => { let tn = kt(Kt), { _min: xn, _max: En } = at, er = En - xn; return (tn - xn) / er } } function ze(at) { let kt = Ne[at]; if (kt == null) { let Kt = (fe.scales || EMPTY_OBJ)[at] || EMPTY_OBJ; if (Kt.from != null) { ze(Kt.from); let tn = assign({}, Ne[Kt.from], Kt, { key: at }); tn.valToPct = Ge(tn), Ne[at] = tn } else { kt = Ne[at] = assign({}, at == Oe ? xScaleOpts : yScaleOpts, Kt), kt.key = at; let tn = kt.time, xn = kt.range, En = isArr(xn); if ((at != Oe || ge == 2 && !tn) && (En && (xn[0] == null || xn[1] == null) && (xn = { min: xn[0] == null ? autoRangePart : { mode: 1, hard: xn[0], soft: xn[0] }, max: xn[1] == null ? autoRangePart : { mode: 1, hard: xn[1], soft: xn[1] } }, En = !1), !En && isObj(xn))) { let er = xn; xn = (cr, xr, Cr) => xr == null ? nullNullTuple : rangeNum(xr, Cr, er) } kt.range = fnOrSelf(xn || (tn ? snapTimeX : at == Oe ? kt.distr == 3 ? snapLogX : kt.distr == 4 ? snapAsinhX : snapNumX : kt.distr == 3 ? snapLogY : kt.distr == 4 ? snapAsinhY : snapNumY)), kt.auto = fnOrSelf(En ? !1 : kt.auto), kt.clamp = fnOrSelf(kt.clamp || clampScale), kt._min = kt._max = null, kt.valToPct = Ge(kt) } } } ze("x"), ze("y"), ge == 1 && Ie.forEach(at => { ze(at.scale) }), Pe.forEach(at => { ze(at.scale) }); for (let at in fe.scales) ze(at); const We = Ne[Oe], Xe = We.distr; let Ye, Ze; We.ori == 0 ? (addClass(Ee, ORI_HZ), Ye = xe, Ze = ye) : (addClass(Ee, ORI_VT), Ye = ye, Ze = xe); const ot = {}; for (let at in Ne) { let kt = Ne[at]; (kt.min != null || kt.max != null) && (ot[at] = { min: kt.min, max: kt.max }, kt.min = kt.max = null) } const qe = fe.tzDate || (at => new Date(round(at / Re))), Qe = fe.fmtDate || fmtDate, st = Re == 1 ? timeAxisSplitsMs(qe) : timeAxisSplitsS(qe), Nt = timeAxisVals(qe, timeAxisStamps(Re == 1 ? _timeAxisStampsMs : _timeAxisStampsS, Qe)), Je = timeSeriesVal(qe, timeSeriesStamp(_timeSeriesStamp, Qe)), jt = [], Xt = me.legend = assign({}, legendOpts, fe.legend), ct = me.cursor = assign({}, cursorOpts, { drag: { y: ge == 2 } }, fe.cursor), nn = Xt.show, $t = ct.show, an = Xt.markers; Xt.idxs = jt, an.width = fnOrSelf(an.width), an.dash = fnOrSelf(an.dash), an.stroke = fnOrSelf(an.stroke), an.fill = fnOrSelf(an.fill); let gn, Mn, Xn, Ln = [], Gn = [], wn, Bn = !1, Gt = {}; if (Xt.live) { const at = Ie[1] ? Ie[1].values : null; Bn = at != null, wn = Bn ? at(me, 1, 0) : { _: 0 }; for (let kt in wn) Gt[kt] = LEGEND_DISP } if (nn) if (gn = placeTag("table", LEGEND, Ee), Xn = placeTag("tbody", null, gn), Xt.mount(me, gn), Bn) { Mn = placeTag("thead", null, gn, Xn); let at = placeTag("tr", null, Mn); placeTag("th", null, at); for (var nr in wn) placeTag("th", LEGEND_LABEL, at).textContent = nr } else addClass(gn, LEGEND_INLINE), Xt.live && addClass(gn, LEGEND_LIVE); const Kn = { show: !0 }, vn = { show: !1 }; function yn(at, kt) { if (kt == 0 && (Bn || !Xt.live || ge == 2)) return nullNullTuple; let Kt = [], tn = placeTag("tr", LEGEND_SERIES, Xn, Xn.childNodes[kt]); addClass(tn, at.class), at.show || addClass(tn, OFF); let xn = placeTag("th", null, tn); if (an.show) { let cr = placeDiv(LEGEND_MARKER, xn); if (kt > 0) { let xr = an.width(me, kt); xr && (cr.style.border = xr + "px " + an.dash(me, kt) + " " + an.stroke(me, kt)), cr.style.background = an.fill(me, kt) } } let En = placeDiv(LEGEND_LABEL, xn); at.label instanceof HTMLElement ? En.appendChild(at.label) : En.textContent = at.label, kt > 0 && (an.show || (En.style.color = at.width > 0 ? an.stroke(me, kt) : an.fill(me, kt)), kn("click", xn, cr => { if (ct._lock) return; Si(cr); let xr = Ie.indexOf(at); if ((cr.ctrlKey || cr.metaKey) != Xt.isolate) { let Cr = Ie.some((Sr, Or) => Or > 0 && Or != xr && Sr.show); Ie.forEach((Sr, Or) => { Or > 0 && bs(Or, Cr ? Or == xr ? Kn : vn : Kn, !0, oi.setSeries) }) } else bs(xr, { show: !at.show }, !0, oi.setSeries) }, !1), Hi && kn(mouseenter, xn, cr => { ct._lock || (Si(cr), bs(Ie.indexOf(at), Vs, !0, oi.setSeries)) }, !1)); for (var er in wn) { let cr = placeTag("td", LEGEND_VALUE, tn); cr.textContent = "--", Kt.push(cr) } return [tn, Kt] } const Hn = new Map; function kn(at, kt, Kt, tn = !0) { const xn = Hn.get(kt) || {}, En = ct.bind[at](me, kt, Kt, tn); En && (on(at, kt, xn[at] = En), Hn.set(kt, xn)) } function Ht(at, kt, Kt) { const tn = Hn.get(kt) || {}; for (let xn in tn) (at == null || xn == at) && (off(xn, kt, tn[xn]), delete tn[xn]); at == null && Hn.delete(kt) } let Dt = 0, fn = 0, en = 0, cn = 0, Wt = 0, un = 0, Ft = Wt, Sn = un, lr = en, jn = cn, Pn = 0, fr = 0, Yn = 0, sr = 0; me.bbox = {}; let Ar = !1, Er = !1, Rr = !1, mn = !1, Dn = !1, Rn = !1; function qn(at, kt, Kt) { (Kt || at != me.width || kt != me.height) && ar(at, kt), Bs(!1), Rr = !0, Er = !0, Ws() } function ar(at, kt) { me.width = Dt = en = at, me.height = fn = cn = kt, Wt = un = 0, bi(), ti(); let Kt = me.bbox; Pn = Kt.left = incrRound(Wt * pxRatio, .5), fr = Kt.top = incrRound(un * pxRatio, .5), Yn = Kt.width = incrRound(en * pxRatio, .5), sr = Kt.height = incrRound(cn * pxRatio, .5) } const yr = 3; function dr() { let at = !1, kt = 0; for (; !at;) { kt++; let Kt = ya(kt), tn = $s(kt); at = kt == yr || Kt && tn, at || (ar(me.width, me.height), Er = !0) } } function mi({ width: at, height: kt }) { qn(at, kt) } me.setSize = mi; function bi() { let at = !1, kt = !1, Kt = !1, tn = !1; Pe.forEach((xn, En) => { if (xn.show && xn._show) { let { side: er, _size: cr } = xn, xr = er % 2, Cr = xn.label != null ? xn.labelSize : 0, Sr = cr + Cr; Sr > 0 && (xr ? (en -= Sr, er == 3 ? (Wt += Sr, tn = !0) : Kt = !0) : (cn -= Sr, er == 0 ? (un += Sr, at = !0) : kt = !0)) } }), Vt[0] = at, Vt[1] = Kt, Vt[2] = kt, Vt[3] = tn, en -= Nn[1] + Nn[3], Wt += Nn[3], cn -= Nn[2] + Nn[0], un += Nn[0] } function ti() { let at = Wt + en, kt = un + cn, Kt = Wt, tn = un; function xn(En, er) { switch (En) { case 1: return at += er, at - er; case 2: return kt += er, kt - er; case 3: return Kt -= er, Kt + er; case 0: return tn -= er, tn + er } } Pe.forEach((En, er) => { if (En.show && En._show) { let cr = En.side; En._pos = xn(cr, En._size), En.label != null && (En._lpos = xn(cr, En.labelSize)) } }) } if (ct.dataIdx == null) { let at = ct.hover, kt = at.skip = new Set(at.skip ?? []); kt.add(void 0); let Kt = at.prox = fnOrSelf(at.prox), tn = at.bias ??= 0; ct.dataIdx = (xn, En, er, cr) => { if (En == 0) return er; let xr = er, Cr = Kt(xn, En, er, cr) ?? inf, Sr = Cr >= 0 && Cr < inf, Or = We.ori == 0 ? en : cn, qr = ct.left, ui = K[0], Jr = K[En]; if (kt.has(Jr[er])) { xr = null; let ci = null, jr = null, Ur; if (tn == 0 || tn == -1) for (Ur = er; ci == null && Ur-- > 0;)kt.has(Jr[Ur]) || (ci = Ur); if (tn == 0 || tn == 1) for (Ur = er; jr == null && Ur++ < Jr.length;)kt.has(Jr[Ur]) || (jr = Ur); if (ci != null || jr != null) if (Sr) { let Pi = ci == null ? -1 / 0 : Ye(ui[ci], We, Or, 0), zi = jr == null ? 1 / 0 : Ye(ui[jr], We, Or, 0), Qi = qr - Pi, Mi = zi - qr; Qi <= Mi ? Qi <= Cr && (xr = ci) : Mi <= Cr && (xr = jr) } else xr = jr == null ? ci : ci == null ? jr : er - ci <= jr - er ? ci : jr } else Sr && abs(qr - Ye(ui[er], We, Or, 0)) > Cr && (xr = null); return xr } } const Si = at => { ct.event = at }; ct.idxs = jt, ct._lock = !1; let ri = ct.points; ri.show = fnOrSelf(ri.show), ri.size = fnOrSelf(ri.size), ri.stroke = fnOrSelf(ri.stroke), ri.width = fnOrSelf(ri.width), ri.fill = fnOrSelf(ri.fill); const es = me.focus = assign({}, fe.focus || { alpha: .3 }, ct.focus), Hi = es.prox >= 0, Ai = Hi && ri.one; let gi = [], ts = [], Ii = []; function Nr(at, kt) { let Kt = ri.show(me, kt); if (Kt instanceof HTMLElement) return addClass(Kt, CURSOR_PT), addClass(Kt, at.class), elTrans(Kt, -10, -10, en, cn), we.insertBefore(Kt, gi[kt]), Kt } function hs(at, kt) { if (ge == 1 || kt > 0) { let Kt = ge == 1 && Ne[at.scale].time, tn = at.value; at.value = Kt ? isStr(tn) ? timeSeriesVal(qe, timeSeriesStamp(tn, Qe)) : tn || Je : tn || numSeriesVal, at.label = at.label || (Kt ? timeSeriesLabel : numSeriesLabel) } if (Ai || kt > 0) { at.width = at.width == null ? 1 : at.width, at.paths = at.paths || linearPath || retNull, at.fillTo = fnOrSelf(at.fillTo || seriesFillTo), at.pxAlign = +ifNull(at.pxAlign, Be), at.pxRound = pxRoundGen(at.pxAlign), at.stroke = fnOrSelf(at.stroke || null), at.fill = fnOrSelf(at.fill || null), at._stroke = at._fill = at._paths = at._focus = null; let Kt = ptDia(max$1(1, at.width), 1), tn = at.points = assign({}, { size: Kt, width: max$1(1, Kt * .2), stroke: at.stroke, space: Kt * 2, paths: pointsPath, _stroke: null, _fill: null }, at.points); tn.show = fnOrSelf(tn.show), tn.filter = fnOrSelf(tn.filter), tn.fill = fnOrSelf(tn.fill), tn.stroke = fnOrSelf(tn.stroke), tn.paths = fnOrSelf(tn.paths), tn.pxAlign = at.pxAlign } if (nn) { let Kt = yn(at, kt); Ln.splice(kt, 0, Kt[0]), Gn.splice(kt, 0, Kt[1]), Xt.values.push(null) } if ($t) { jt.splice(kt, 0, null); let Kt = null; Ai ? kt == 0 && (Kt = Nr(at, kt)) : kt > 0 && (Kt = Nr(at, kt)), gi.splice(kt, 0, Kt), ts.splice(kt, 0, 0), Ii.splice(kt, 0, 0) } Kr("addSeries", kt) } function xi(at, kt) { kt = kt ?? Ie.length, at = ge == 1 ? setDefault(at, kt, xSeriesOpts, ySeriesOpts) : setDefault(at, kt, {}, xySeriesOpts), Ie.splice(kt, 0, at), hs(Ie[kt], kt) } me.addSeries = xi; function Rt(at) { if (Ie.splice(at, 1), nn) { Xt.values.splice(at, 1), Gn.splice(at, 1); let kt = Ln.splice(at, 1)[0]; Ht(null, kt.firstChild), kt.remove() } $t && (jt.splice(at, 1), gi.splice(at, 1)[0].remove(), ts.splice(at, 1), Ii.splice(at, 1)), Kr("delSeries", at) } me.delSeries = Rt; const Vt = [!1, !1, !1, !1]; function dn(at, kt) { if (at._show = at.show, at.show) { let Kt = at.side % 2, tn = Ne[at.scale]; tn == null && (at.scale = Kt ? Ie[1].scale : Oe, tn = Ne[at.scale]); let xn = tn.time; at.size = fnOrSelf(at.size), at.space = fnOrSelf(at.space), at.rotate = fnOrSelf(at.rotate), isArr(at.incrs) && at.incrs.forEach(er => { !fixedDec.has(er) && fixedDec.set(er, guessDec(er)) }), at.incrs = fnOrSelf(at.incrs || (tn.distr == 2 ? wholeIncrs : xn ? Re == 1 ? timeIncrsMs : timeIncrsS : numIncrs)), at.splits = fnOrSelf(at.splits || (xn && tn.distr == 1 ? st : tn.distr == 3 ? logAxisSplits : tn.distr == 4 ? asinhAxisSplits : numAxisSplits)), at.stroke = fnOrSelf(at.stroke), at.grid.stroke = fnOrSelf(at.grid.stroke), at.ticks.stroke = fnOrSelf(at.ticks.stroke), at.border.stroke = fnOrSelf(at.border.stroke); let En = at.values; at.values = isArr(En) && !isArr(En[0]) ? fnOrSelf(En) : xn ? isArr(En) ? timeAxisVals(qe, timeAxisStamps(En, Qe)) : isStr(En) ? timeAxisVal(qe, En) : En || Nt : En || numAxisVals, at.filter = fnOrSelf(at.filter || (tn.distr >= 3 && tn.log == 10 ? log10AxisValsFilt : tn.distr == 3 && tn.log == 2 ? log2AxisValsFilt : retArg1)), at.font = pxRatioFont(at.font), at.labelFont = pxRatioFont(at.labelFont), at._size = at.size(me, null, kt, 0), at._space = at._rotate = at._incrs = at._found = at._splits = at._values = null, at._size > 0 && (Vt[kt] = !0, at._el = placeDiv(AXIS, Se)) } } function In(at, kt, Kt, tn) { let [xn, En, er, cr] = Kt, xr = kt % 2, Cr = 0; return xr == 0 && (cr || En) && (Cr = kt == 0 && !xn || kt == 2 && !er ? round(xAxisOpts.size / 3) : 0), xr == 1 && (xn || er) && (Cr = kt == 1 && !En || kt == 3 && !cr ? round(yAxisOpts.size / 2) : 0), Cr } const Vn = me.padding = (fe.padding || [In, In, In, In]).map(at => fnOrSelf(ifNull(at, In))), Nn = me._padding = Vn.map((at, kt) => at(me, kt, Vt, 0)); let ir, Jn = null, ft = null; const qt = ge == 1 ? Ie[0].idxs : null; let sn = null, ln = !1; function pn(at, kt) { if (K = at ?? [], me.data = me._data = K, ge == 2) { ir = 0; for (let Kt = 1; Kt < Ie.length; Kt++)ir += K[Kt][0].length } else { K.length == 0 && (me.data = me._data = K = [[]]), sn = K[0], ir = sn.length; let Kt = K; if (Xe == 2) { Kt = K.slice(); let tn = Kt[0] = Array(ir); for (let xn = 0; xn < ir; xn++)tn[xn] = xn } me._data = K = Kt } if (Bs(!0), Kr("setData"), Xe == 2 && (Rr = !0), kt !== !1) { let Kt = We; Kt.auto(me, ln) ? Tn() : Ds(Oe, Kt.min, Kt.max), mn = mn || ct.left >= 0, Rn = !0, Ws() } } me.setData = pn; function Tn() { ln = !0; let at, kt; ge == 1 && (ir > 0 ? (Jn = qt[0] = 0, ft = qt[1] = ir - 1, at = K[0][Jn], kt = K[0][ft], Xe == 2 ? (at = Jn, kt = ft) : at == kt && (Xe == 3 ? [at, kt] = rangeLog(at, at, We.log, !1) : Xe == 4 ? [at, kt] = rangeAsinh(at, at, We.log, !1) : We.time ? kt = at + round(86400 / Re) : [at, kt] = rangeNum(at, kt, rangePad, !0))) : (Jn = qt[0] = at = null, ft = qt[1] = kt = null)), Ds(Oe, at, kt) } let $n, Zn, rr, br, Un, _r, Lr, Br, ni, wr; function Fr(at, kt, Kt, tn, xn, En) { at ??= transparent, Kt ??= EMPTY_ARR, tn ??= "butt", xn ??= transparent, En ??= "round", at != $n && (Ae.strokeStyle = $n = at), xn != Zn && (Ae.fillStyle = Zn = xn), kt != rr && (Ae.lineWidth = rr = kt), En != Un && (Ae.lineJoin = Un = En), tn != _r && (Ae.lineCap = _r = tn), Kt != br && Ae.setLineDash(br = Kt) } function Dr(at, kt, Kt, tn) { kt != Zn && (Ae.fillStyle = Zn = kt), at != Lr && (Ae.font = Lr = at), Kt != Br && (Ae.textAlign = Br = Kt), tn != ni && (Ae.textBaseline = ni = tn) } function li(at, kt, Kt, tn, xn = 0) { if (tn.length > 0 && at.auto(me, ln) && (kt == null || kt.min == null)) { let En = ifNull(Jn, 0), er = ifNull(ft, tn.length - 1), cr = Kt.min == null ? getMinMax(tn, En, er, xn, at.distr == 3) : [Kt.min, Kt.max]; at.min = min(at.min, Kt.min = cr[0]), at.max = max$1(at.max, Kt.max = cr[1]) } } const Gr = { min: null, max: null }; function Wr() { for (let tn in Ne) { let xn = Ne[tn]; ot[tn] == null && (xn.min == null || ot[Oe] != null && xn.auto(me, ln)) && (ot[tn] = Gr) } for (let tn in Ne) { let xn = Ne[tn]; ot[tn] == null && xn.from != null && ot[xn.from] != null && (ot[tn] = Gr) } ot[Oe] != null && Bs(!0); let at = {}; for (let tn in ot) { let xn = ot[tn]; if (xn != null) { let En = at[tn] = copy(Ne[tn], fastIsObj); if (xn.min != null) assign(En, xn); else if (tn != Oe || ge == 2) if (ir == 0 && En.from == null) { let er = En.range(me, null, null, tn); En.min = er[0], En.max = er[1] } else En.min = inf, En.max = -inf } } if (ir > 0) { Ie.forEach((tn, xn) => { if (ge == 1) { let En = tn.scale, er = ot[En]; if (er == null) return; let cr = at[En]; if (xn == 0) { let xr = cr.range(me, cr.min, cr.max, En); cr.min = xr[0], cr.max = xr[1], Jn = closestIdx(cr.min, K[0]), ft = closestIdx(cr.max, K[0]), ft - Jn > 1 && (K[0][Jn] < cr.min && Jn++, K[0][ft] > cr.max && ft--), tn.min = sn[Jn], tn.max = sn[ft] } else tn.show && tn.auto && li(cr, er, tn, K[xn], tn.sorted); tn.idxs[0] = Jn, tn.idxs[1] = ft } else if (xn > 0 && tn.show && tn.auto) { let [En, er] = tn.facets, cr = En.scale, xr = er.scale, [Cr, Sr] = K[xn], Or = at[cr], qr = at[xr]; Or != null && li(Or, ot[cr], En, Cr, En.sorted), qr != null && li(qr, ot[xr], er, Sr, er.sorted), tn.min = er.min, tn.max = er.max } }); for (let tn in at) { let xn = at[tn], En = ot[tn]; if (xn.from == null && (En == null || En.min == null)) { let er = xn.range(me, xn.min == inf ? null : xn.min, xn.max == -inf ? null : xn.max, tn); xn.min = er[0], xn.max = er[1] } } } for (let tn in at) { let xn = at[tn]; if (xn.from != null) { let En = at[xn.from]; if (En.min == null) xn.min = xn.max = null; else { let er = xn.range(me, En.min, En.max, tn); xn.min = er[0], xn.max = er[1] } } } let kt = {}, Kt = !1; for (let tn in at) { let xn = at[tn], En = Ne[tn]; if (En.min != xn.min || En.max != xn.max) { En.min = xn.min, En.max = xn.max; let er = En.distr; En._min = er == 3 ? log10(En.min) : er == 4 ? asinh(En.min, En.asinh) : er == 100 ? En.fwd(En.min) : En.min, En._max = er == 3 ? log10(En.max) : er == 4 ? asinh(En.max, En.asinh) : er == 100 ? En.fwd(En.max) : En.max, kt[tn] = Kt = !0 } } if (Kt) { Ie.forEach((tn, xn) => { ge == 2 ? xn > 0 && kt.y && (tn._paths = null) : kt[tn.scale] && (tn._paths = null) }); for (let tn in kt) Rr = !0, Kr("setScale", tn); $t && ct.left >= 0 && (mn = Rn = !0) } for (let tn in ot) ot[tn] = null } function ii(at) { let kt = clamp$1(Jn - 1, 0, ir - 1), Kt = clamp$1(ft + 1, 0, ir - 1); for (; at[kt] == null && kt > 0;)kt--; for (; at[Kt] == null && Kt < ir - 1;)Kt++; return [kt, Kt] } function kr() { if (ir > 0) { let at = Ie.some(kt => kt._focus) && wr != es.alpha; at && (Ae.globalAlpha = wr = es.alpha), Ie.forEach((kt, Kt) => { if (Kt > 0 && kt.show && (Zr(Kt, !1), Zr(Kt, !0), kt._paths == null)) { let tn = wr; wr != kt.alpha && (Ae.globalAlpha = wr = kt.alpha); let xn = ge == 2 ? [0, K[Kt][0].length - 1] : ii(K[Kt]); kt._paths = kt.paths(me, Kt, xn[0], xn[1]), wr != tn && (Ae.globalAlpha = wr = tn) } }), Ie.forEach((kt, Kt) => { if (Kt > 0 && kt.show) { let tn = wr; wr != kt.alpha && (Ae.globalAlpha = wr = kt.alpha), kt._paths != null && Xr(Kt, !1); { let xn = kt._paths != null ? kt._paths.gaps : null, En = kt.points.show(me, Kt, Jn, ft, xn), er = kt.points.filter(me, Kt, En, xn); (En || er) && (kt.points._paths = kt.points.paths(me, Kt, Jn, ft, er), Xr(Kt, !0)) } wr != tn && (Ae.globalAlpha = wr = tn), Kr("drawSeries", Kt) } }), at && (Ae.globalAlpha = wr = 1) } } function Zr(at, kt) { let Kt = kt ? Ie[at].points : Ie[at]; Kt._stroke = Kt.stroke(me, at), Kt._fill = Kt.fill(me, at) } function Xr(at, kt) { let Kt = kt ? Ie[at].points : Ie[at], { stroke: tn, fill: xn, clip: En, flags: er, _stroke: cr = Kt._stroke, _fill: xr = Kt._fill, _width: Cr = Kt.width } = Kt._paths; Cr = roundDec(Cr * pxRatio, 3); let Sr = null, Or = Cr % 2 / 2; kt && xr == null && (xr = Cr > 0 ? "#fff" : cr); let qr = Kt.pxAlign == 1 && Or > 0; if (qr && Ae.translate(Or, Or), !kt) { let ui = Pn - Cr / 2, Jr = fr - Cr / 2, ci = Yn + Cr, jr = sr + Cr; Sr = new Path2D, Sr.rect(ui, Jr, ci, jr) } kt ? yi(cr, Cr, Kt.dash, Kt.cap, xr, tn, xn, er, En) : Ri(at, cr, Cr, Kt.dash, Kt.cap, xr, tn, xn, er, Sr, En), qr && Ae.translate(-Or, -Or) } function Ri(at, kt, Kt, tn, xn, En, er, cr, xr, Cr, Sr) { let Or = !1; xr != 0 && ke.forEach((qr, ui) => { if (qr.series[0] == at) { let Jr = Ie[qr.series[1]], ci = K[qr.series[1]], jr = (Jr._paths || EMPTY_OBJ).band; isArr(jr) && (jr = qr.dir == 1 ? jr[0] : jr[1]); let Ur, Pi = null; Jr.show && jr && hasData(ci, Jn, ft) ? (Pi = qr.fill(me, ui) || En, Ur = Jr._paths.clip) : jr = null, yi(kt, Kt, tn, xn, Pi, er, cr, xr, Cr, Sr, Ur, jr), Or = !0 } }), Or || yi(kt, Kt, tn, xn, En, er, cr, xr, Cr, Sr) } const di = BAND_CLIP_FILL | BAND_CLIP_STROKE; function yi(at, kt, Kt, tn, xn, En, er, cr, xr, Cr, Sr, Or) { Fr(at, kt, Kt, tn, xn), (xr || Cr || Or) && (Ae.save(), xr && Ae.clip(xr), Cr && Ae.clip(Cr)), Or ? (cr & di) == di ? (Ae.clip(Or), Sr && Ae.clip(Sr), Ji(xn, er), Vi(at, En, kt)) : cr & BAND_CLIP_STROKE ? (Ji(xn, er), Ae.clip(Or), Vi(at, En, kt)) : cr & BAND_CLIP_FILL && (Ae.save(), Ae.clip(Or), Sr && Ae.clip(Sr), Ji(xn, er), Ae.restore(), Vi(at, En, kt)) : (Ji(xn, er), Vi(at, En, kt)), (xr || Cr || Or) && Ae.restore() } function Vi(at, kt, Kt) { Kt > 0 && (kt instanceof Map ? kt.forEach((tn, xn) => { Ae.strokeStyle = $n = xn, Ae.stroke(tn) }) : kt != null && at && Ae.stroke(kt)) } function Ji(at, kt) { kt instanceof Map ? kt.forEach((Kt, tn) => { Ae.fillStyle = Zn = tn, Ae.fill(Kt) }) : kt != null && at && Ae.fill(kt) } function vs(at, kt, Kt, tn) { let xn = Pe[at], En; if (tn <= 0) En = [0, 0]; else { let er = xn._space = xn.space(me, at, kt, Kt, tn), cr = xn._incrs = xn.incrs(me, at, kt, Kt, tn, er); En = findIncr(kt, Kt, cr, tn, er) } return xn._found = En } function Gs(at, kt, Kt, tn, xn, En, er, cr, xr, Cr) { let Sr = er % 2 / 2; Be == 1 && Ae.translate(Sr, Sr), Fr(cr, er, xr, Cr, cr), Ae.beginPath(); let Or, qr, ui, Jr, ci = xn + (tn == 0 || tn == 3 ? -En : En); Kt == 0 ? (qr = xn, Jr = ci) : (Or = xn, ui = ci); for (let jr = 0; jr < at.length; jr++)kt[jr] != null && (Kt == 0 ? Or = ui = at[jr] : qr = Jr = at[jr], Ae.moveTo(Or, qr), Ae.lineTo(ui, Jr)); Ae.stroke(), Be == 1 && Ae.translate(-Sr, -Sr) } function ya(at) { let kt = !0; return Pe.forEach((Kt, tn) => { if (!Kt.show) return; let xn = Ne[Kt.scale]; if (xn.min == null) { Kt._show && (kt = !1, Kt._show = !1, Bs(!1)); return } else Kt._show || (kt = !1, Kt._show = !0, Bs(!1)); let En = Kt.side, er = En % 2, { min: cr, max: xr } = xn, [Cr, Sr] = vs(tn, cr, xr, er == 0 ? en : cn); if (Sr == 0) return; let Or = xn.distr == 2, qr = Kt._splits = Kt.splits(me, tn, cr, xr, Cr, Sr, Or), ui = xn.distr == 2 ? qr.map(Ur => sn[Ur]) : qr, Jr = xn.distr == 2 ? sn[qr[1]] - sn[qr[0]] : Cr, ci = Kt._values = Kt.values(me, Kt.filter(me, ui, tn, Sr, Jr), tn, Sr, Jr); Kt._rotate = En == 2 ? Kt.rotate(me, ci, tn, Sr) : 0; let jr = Kt._size; Kt._size = ceil(Kt.size(me, ci, tn, at)), jr != null && Kt._size != jr && (kt = !1) }), kt } function $s(at) { let kt = !0; return Vn.forEach((Kt, tn) => { let xn = Kt(me, tn, Vt, at); xn != Nn[tn] && (kt = !1), Nn[tn] = xn }), kt } function $r() {
		for (let at = 0; at < Pe.length; at++) {
			let kt = Pe[at]; if (!kt.show || !kt._show) continue; let Kt = kt.side, tn = Kt % 2, xn, En, er = kt.stroke(me, at), cr = Kt == 0 || Kt == 3 ? -1 : 1, [xr, Cr] = kt._found; if (kt.label != null) { let Li = kt.labelGap * cr, Ts = round((kt._lpos + Li) * pxRatio); Dr(kt.labelFont[0], er, "center", Kt == 2 ? TOP : BOTTOM), Ae.save(), tn == 1 ? (xn = En = 0, Ae.translate(Ts, round(fr + sr / 2)), Ae.rotate((Kt == 3 ? -PI : PI) / 2)) : (xn = round(Pn + Yn / 2), En = Ts); let _s = isFn(kt.label) ? kt.label(me, at, xr, Cr) : kt.label; Ae.fillText(_s, xn, En), Ae.restore() } if (Cr == 0) continue; let Sr = Ne[kt.scale], Or = tn == 0 ? Yn : sr, qr = tn == 0 ? Pn : fr, ui = kt._splits, Jr = Sr.distr == 2 ? ui.map(Li => sn[Li]) : ui, ci = Sr.distr == 2 ? sn[ui[1]] - sn[ui[0]] : xr, jr = kt.ticks, Ur = kt.border, Pi = jr.show ? jr.size : 0, zi = round(Pi * pxRatio), Qi = round((kt.alignTo == 2 ? kt._size - Pi - kt.gap : kt.gap) * pxRatio), Mi = kt._rotate * -PI / 180, qi = De(kt._pos * pxRatio), Ss = (zi + Qi) * cr, ms = qi + Ss; En = tn == 0 ? ms : 0, xn = tn == 1 ? ms : 0; let Yi = kt.font[0], Ns = kt.align == 1 ? LEFT : kt.align == 2 ? RIGHT : Mi > 0 ? LEFT : Mi < 0 ? RIGHT : tn == 0 ? "center" : Kt == 3 ? RIGHT : LEFT, Js = Mi || tn == 1 ? "middle" : Kt == 2 ? TOP : BOTTOM; Dr(Yi, er, Ns, Js); let Fs = kt.font[1] * kt.lineGap, Cs = ui.map(Li => De(ve(Li, Sr, Or, qr))), Gi = kt._values; for (let Li = 0; Li < Gi.length; Li++) {
				let Ts = Gi[Li]; if (Ts != null) {
					tn == 0 ? xn = Cs[Li] : En = Cs[Li], Ts = "" + Ts; let _s = Ts.indexOf(`
`) == -1 ? [Ts] : Ts.split(/\n/gm); for (let ns = 0; ns < _s.length; ns++) { let Aa = _s[ns]; Mi ? (Ae.save(), Ae.translate(xn, En + ns * Fs), Ae.rotate(Mi), Ae.fillText(Aa, 0, 0), Ae.restore()) : Ae.fillText(Aa, xn, En + ns * Fs) }
				}
			} jr.show && Gs(Cs, jr.filter(me, Jr, at, Cr, ci), tn, Kt, qi, zi, roundDec(jr.width * pxRatio, 3), jr.stroke(me, at), jr.dash, jr.cap); let Zs = kt.grid; Zs.show && Gs(Cs, Zs.filter(me, Jr, at, Cr, ci), tn, tn == 0 ? 2 : 1, tn == 0 ? fr : Pn, tn == 0 ? sr : Yn, roundDec(Zs.width * pxRatio, 3), Zs.stroke(me, at), Zs.dash, Zs.cap), Ur.show && Gs([qi], [1], tn == 0 ? 1 : 0, tn == 0 ? 1 : 2, tn == 1 ? fr : Pn, tn == 1 ? sr : Yn, roundDec(Ur.width * pxRatio, 3), Ur.stroke(me, at), Ur.dash, Ur.cap)
		} Kr("drawAxes")
	} function Bs(at) { Ie.forEach((kt, Kt) => { Kt > 0 && (kt._paths = null, at && (ge == 1 ? (kt.min = null, kt.max = null) : kt.facets.forEach(tn => { tn.min = null, tn.max = null }))) }) } let oa = !1, va = !1, Ki = []; function Pa() { va = !1; for (let at = 0; at < Ki.length; at++)Kr(...Ki[at]); Ki.length = 0 } function Ws() { oa || (microTask(Le), oa = !0) } function wa(at, kt = !1) { oa = !0, va = kt, at(me), Le(), kt && Ki.length > 0 && queueMicrotask(Pa) } me.batch = wa; function Le() { if (Ar && (Wr(), Ar = !1), Rr && (dr(), Rr = !1), Er) { if (setStylePx(Ce, LEFT, Wt), setStylePx(Ce, TOP, un), setStylePx(Ce, WIDTH, en), setStylePx(Ce, HEIGHT, cn), setStylePx(we, LEFT, Wt), setStylePx(we, TOP, un), setStylePx(we, WIDTH, en), setStylePx(we, HEIGHT, cn), setStylePx(Se, WIDTH, Dt), setStylePx(Se, HEIGHT, fn), be.width = round(Dt * pxRatio), be.height = round(fn * pxRatio), Pe.forEach(({ _el: at, _show: kt, _size: Kt, _pos: tn, side: xn }) => { if (at != null) if (kt) { let En = xn === 3 || xn === 0 ? Kt : 0, er = xn % 2 == 1; setStylePx(at, er ? "left" : "top", tn - En), setStylePx(at, er ? "width" : "height", Kt), setStylePx(at, er ? "top" : "left", er ? un : Wt), setStylePx(at, er ? "height" : "width", er ? cn : en), remClass(at, OFF) } else addClass(at, OFF) }), $n = Zn = rr = Un = _r = Lr = Br = ni = br = null, wr = 1, ps(!0), Wt != Ft || un != Sn || en != lr || cn != jn) { Bs(!1); let at = en / lr, kt = cn / jn; if ($t && !mn && ct.left >= 0) { ct.left *= at, ct.top *= kt, Yt && elTrans(Yt, round(ct.left), 0, en, cn), bn && elTrans(bn, 0, round(ct.top), en, cn); for (let Kt = 0; Kt < gi.length; Kt++) { let tn = gi[Kt]; tn != null && (ts[Kt] *= at, Ii[Kt] *= kt, elTrans(tn, ceil(ts[Kt]), ceil(Ii[Kt]), en, cn)) } } if (_i.show && !Dn && _i.left >= 0 && _i.width > 0) { _i.left *= at, _i.width *= at, _i.top *= kt, _i.height *= kt; for (let Kt in Xa) setStylePx(Xs, Kt, _i[Kt]) } Ft = Wt, Sn = un, lr = en, jn = cn } Kr("setSize"), Er = !1 } Dt > 0 && fn > 0 && (Ae.clearRect(0, 0, be.width, be.height), Kr("drawClear"), He.forEach(at => at()), Kr("draw")), _i.show && Dn && (La(_i), Dn = !1), $t && mn && (qs(null, !0, !1), mn = !1), Xt.show && Xt.live && Rn && (Oa(), Rn = !1), _e || (_e = !0, me.status = 1, Kr("ready")), ln = !1, oa = !1 } me.redraw = (at, kt) => { Rr = kt || !1, at !== !1 ? Ds(Oe, We.min, We.max) : Ws() }; function $e(at, kt) { let Kt = Ne[at]; if (Kt.from == null) { if (ir == 0) { let tn = Kt.range(me, kt.min, kt.max, at); kt.min = tn[0], kt.max = tn[1] } if (kt.min > kt.max) { let tn = kt.min; kt.min = kt.max, kt.max = tn } if (ir > 1 && kt.min != null && kt.max != null && kt.max - kt.min < 1e-16) return; at == Oe && Kt.distr == 2 && ir > 0 && (kt.min = closestIdx(kt.min, K[0]), kt.max = closestIdx(kt.max, K[0]), kt.min == kt.max && kt.max++), ot[at] = kt, Ar = !0, Ws() } } me.setScale = $e; let rt, Pt, Yt, bn, On, hr, pr, zr, Hr, Ni, ai, vi, cs = !1; const Fi = ct.drag; let Bi = Fi.x, Di = Fi.y; $t && (ct.x && (rt = placeDiv(CURSOR_X, we)), ct.y && (Pt = placeDiv(CURSOR_Y, we)), We.ori == 0 ? (Yt = rt, bn = Pt) : (Yt = Pt, bn = rt), ai = ct.left, vi = ct.top); const _i = me.select = assign({ show: !0, over: !0, left: 0, width: 0, top: 0, height: 0 }, fe.select), Xs = _i.show ? placeDiv(SELECT, _i.over ? we : Ce) : null; function La(at, kt) { if (_i.show) { for (let Kt in at) _i[Kt] = at[Kt], Kt in Xa && setStylePx(Xs, Kt, at[Kt]); kt !== !1 && Kr("setSelect") } } me.setSelect = La; function oo(at) { if (Ie[at].show) nn && remClass(Ln[at], OFF); else if (nn && addClass(Ln[at], OFF), $t) { let Kt = Ai ? gi[0] : gi[at]; Kt != null && elTrans(Kt, -10, -10, en, cn) } } function Ds(at, kt, Kt) { $e(at, { min: kt, max: Kt }) } function bs(at, kt, Kt, tn) { kt.focus != null && co(at), kt.show != null && Ie.forEach((xn, En) => { En > 0 && (at == En || at == null) && (xn.show = kt.show, oo(En), ge == 2 ? (Ds(xn.facets[0].scale, null, null), Ds(xn.facets[1].scale, null, null)) : Ds(xn.scale, null, null), Ws()) }), Kt !== !1 && Kr("setSeries", at, kt), tn && Ys("setSeries", me, at, kt) } me.setSeries = bs; function Zo(at, kt) { assign(ke[at], kt) } function ls(at, kt) { at.fill = fnOrSelf(at.fill || null), at.dir = ifNull(at.dir, -1), kt = kt ?? ke.length, ke.splice(kt, 0, at) } function lo(at) { at == null ? ke.length = 0 : ke.splice(at, 1) } me.addBand = ls, me.setBand = Zo, me.delBand = lo; function ja(at, kt) { Ie[at].alpha = kt, $t && gi[at] != null && (gi[at].style.opacity = kt), nn && Ln[at] && (Ln[at].style.opacity = kt) } let Hs, Ks, la; const Vs = { focus: !0 }; function co(at) { if (at != la) { let kt = at == null, Kt = es.alpha != 1; Ie.forEach((tn, xn) => { if (ge == 1 || xn > 0) { let En = kt || xn == 0 || xn == at; tn._focus = kt ? null : En, Kt && ja(xn, En ? 1 : es.alpha) } }), la = at, Kt && Ws() } } nn && Hi && kn(mouseleave, gn, at => { ct._lock || (Si(at), la != null && bs(null, Vs, !0, oi.setSeries)) }); function Is(at, kt, Kt) { let tn = Ne[kt]; Kt && (at = at / pxRatio - (tn.ori == 1 ? un : Wt)); let xn = en; tn.ori == 1 && (xn = cn, at = xn - at), tn.dir == -1 && (at = xn - at); let En = tn._min, er = tn._max, cr = at / xn, xr = En + (er - En) * cr, Cr = tn.distr; return Cr == 3 ? pow(10, xr) : Cr == 4 ? sinh(xr, tn.asinh) : Cr == 100 ? tn.bwd(xr) : xr } function Mo(at, kt) { let Kt = Is(at, Oe, kt); return closestIdx(Kt, K[0], Jn, ft) } me.valToIdx = at => closestIdx(at, K[0]), me.posToIdx = Mo, me.posToVal = Is, me.valToPos = (at, kt, Kt) => Ne[kt].ori == 0 ? xe(at, Ne[kt], Kt ? Yn : en, Kt ? Pn : 0) : ye(at, Ne[kt], Kt ? sr : cn, Kt ? fr : 0), me.setCursor = (at, kt, Kt) => { ai = at.left, vi = at.top, qs(null, kt, Kt) }; function uo(at, kt) { setStylePx(Xs, LEFT, _i.left = at), setStylePx(Xs, WIDTH, _i.width = kt) } function Wa(at, kt) { setStylePx(Xs, TOP, _i.top = at), setStylePx(Xs, HEIGHT, _i.height = kt) } let Ea = We.ori == 0 ? uo : Wa, Ma = We.ori == 1 ? uo : Wa; function fo() { if (nn && Xt.live) for (let at = ge == 2 ? 1 : 0; at < Ie.length; at++) { if (at == 0 && Bn) continue; let kt = Xt.values[at], Kt = 0; for (let tn in kt) Gn[at][Kt++].firstChild.nodeValue = kt[tn] } } function Oa(at, kt) { if (at != null && (at.idxs ? at.idxs.forEach((Kt, tn) => { jt[tn] = Kt }) : isUndef(at.idx) || jt.fill(at.idx), Xt.idx = jt[0]), nn && Xt.live) { for (let Kt = 0; Kt < Ie.length; Kt++)(Kt > 0 || ge == 1 && !Bn) && Ps(Kt, jt[Kt]); fo() } Rn = !1, kt !== !1 && Kr("setLegend") } me.setLegend = Oa; function Ps(at, kt) { let Kt = Ie[at], tn = at == 0 && Xe == 2 ? sn : K[at], xn; Bn ? xn = Kt.values(me, at, kt) ?? Gt : (xn = Kt.value(me, kt == null ? null : tn[kt], at, kt), xn = xn == null ? Gt : { _: xn }), Xt.values[at] = xn } function qs(at, kt, Kt) { Hr = ai, Ni = vi, [ai, vi] = ct.move(me, ai, vi), ct.left = ai, ct.top = vi, $t && (Yt && elTrans(Yt, round(ai), 0, en, cn), bn && elTrans(bn, 0, round(vi), en, cn)); let tn, xn = Jn > ft; Hs = inf, Ks = null; let En = We.ori == 0 ? en : cn, er = We.ori == 1 ? en : cn; if (ai < 0 || ir == 0 || xn) { tn = ct.idx = null; for (let cr = 0; cr < Ie.length; cr++) { let xr = gi[cr]; xr != null && elTrans(xr, -10, -10, en, cn) } Hi && bs(null, Vs, !0, at == null && oi.setSeries), Xt.live && (jt.fill(tn), Rn = !0) } else { let cr, xr, Cr; ge == 1 && (cr = We.ori == 0 ? ai : vi, xr = Is(cr, Oe), tn = ct.idx = closestIdx(xr, K[0], Jn, ft), Cr = Ye(K[0][tn], We, En, 0)); let Sr = -10, Or = -10, qr = 0, ui = 0, Jr = !0, ci = "", jr = ""; for (let Ur = ge == 2 ? 1 : 0; Ur < Ie.length; Ur++) { let Pi = Ie[Ur], zi = jt[Ur], Qi = zi == null ? null : ge == 1 ? K[Ur][zi] : K[Ur][1][zi], Mi = ct.dataIdx(me, Ur, tn, xr), qi = Mi == null ? null : ge == 1 ? K[Ur][Mi] : K[Ur][1][Mi]; if (Rn = Rn || qi != Qi || Mi != zi, jt[Ur] = Mi, Ur > 0 && Pi.show) { let Ss = Mi == null ? -10 : Mi == tn ? Cr : Ye(ge == 1 ? K[0][Mi] : K[Ur][0][Mi], We, En, 0), ms = qi == null ? -10 : Ze(qi, ge == 1 ? Ne[Pi.scale] : Ne[Pi.facets[1].scale], er, 0); if (Hi && qi != null) { let Yi = We.ori == 1 ? ai : vi, Ns = abs(es.dist(me, Ur, Mi, ms, Yi)); if (Ns < Hs) { let Js = es.bias; if (Js != 0) { let Fs = Is(Yi, Pi.scale), Cs = qi >= 0 ? 1 : -1, Gi = Fs >= 0 ? 1 : -1; Gi == Cs && (Gi == 1 ? Js == 1 ? qi >= Fs : qi <= Fs : Js == 1 ? qi <= Fs : qi >= Fs) && (Hs = Ns, Ks = Ur) } else Hs = Ns, Ks = Ur } } if (Rn || Ai) { let Yi, Ns; We.ori == 0 ? (Yi = Ss, Ns = ms) : (Yi = ms, Ns = Ss); let Js, Fs, Cs, Gi, Zs, Li, Ts = !0, _s = ri.bbox; if (_s != null) { Ts = !1; let ns = _s(me, Ur); Cs = ns.left, Gi = ns.top, Js = ns.width, Fs = ns.height } else Cs = Yi, Gi = Ns, Js = Fs = ri.size(me, Ur); if (Li = ri.fill(me, Ur), Zs = ri.stroke(me, Ur), Ai) Ur == Ks && Hs <= es.prox && (Sr = Cs, Or = Gi, qr = Js, ui = Fs, Jr = Ts, ci = Li, jr = Zs); else { let ns = gi[Ur]; ns != null && (ts[Ur] = Cs, Ii[Ur] = Gi, elSize(ns, Js, Fs, Ts), elColor(ns, Li, Zs), elTrans(ns, ceil(Cs), ceil(Gi), en, cn)) } } } } if (Ai) { let Ur = es.prox, Pi = la == null ? Hs <= Ur : Hs > Ur || Ks != la; if (Rn || Pi) { let zi = gi[0]; zi != null && (ts[0] = Sr, Ii[0] = Or, elSize(zi, qr, ui, Jr), elColor(zi, ci, jr), elTrans(zi, ceil(Sr), ceil(Or), en, cn)) } } } if (_i.show && cs) if (at != null) { let [cr, xr] = oi.scales, [Cr, Sr] = oi.match, [Or, qr] = at.cursor.sync.scales, ui = at.cursor.drag; if (Bi = ui._x, Di = ui._y, Bi || Di) { let { left: Jr, top: ci, width: jr, height: Ur } = at.select, Pi = at.scales[Or].ori, zi = at.posToVal, Qi, Mi, qi, Ss, ms, Yi = cr != null && Cr(cr, Or), Ns = xr != null && Sr(xr, qr); Yi && Bi ? (Pi == 0 ? (Qi = Jr, Mi = jr) : (Qi = ci, Mi = Ur), qi = Ne[cr], Ss = Ye(zi(Qi, Or), qi, En, 0), ms = Ye(zi(Qi + Mi, Or), qi, En, 0), Ea(min(Ss, ms), abs(ms - Ss))) : Ea(0, En), Ns && Di ? (Pi == 1 ? (Qi = Jr, Mi = jr) : (Qi = ci, Mi = Ur), qi = Ne[xr], Ss = Ze(zi(Qi, qr), qi, er, 0), ms = Ze(zi(Qi + Mi, qr), qi, er, 0), Ma(min(Ss, ms), abs(ms - Ss))) : Ma(0, er) } else Et() } else { let cr = abs(Hr - On), xr = abs(Ni - hr); if (We.ori == 1) { let qr = cr; cr = xr, xr = qr } Bi = Fi.x && cr >= Fi.dist, Di = Fi.y && xr >= Fi.dist; let Cr = Fi.uni; Cr != null ? Bi && Di && (Bi = cr >= Cr, Di = xr >= Cr, !Bi && !Di && (xr > cr ? Di = !0 : Bi = !0)) : Fi.x && Fi.y && (Bi || Di) && (Bi = Di = !0); let Sr, Or; Bi && (We.ori == 0 ? (Sr = pr, Or = ai) : (Sr = zr, Or = vi), Ea(min(Sr, Or), abs(Or - Sr)), Di || Ma(0, er)), Di && (We.ori == 1 ? (Sr = pr, Or = ai) : (Sr = zr, Or = vi), Ma(min(Sr, Or), abs(Or - Sr)), Bi || Ea(0, En)), !Bi && !Di && (Ea(0, 0), Ma(0, 0)) } if (Fi._x = Bi, Fi._y = Di, at == null) { if (Kt) { if (ba != null) { let [cr, xr] = oi.scales; oi.values[0] = cr != null ? Is(We.ori == 0 ? ai : vi, cr) : null, oi.values[1] = xr != null ? Is(We.ori == 1 ? ai : vi, xr) : null } Ys(mousemove, me, ai, vi, en, cn, tn) } if (Hi) { let cr = Kt && oi.setSeries, xr = es.prox; la == null ? Hs <= xr && bs(Ks, Vs, !0, cr) : Hs > xr ? bs(null, Vs, !0, cr) : Ks != la && bs(Ks, Vs, !0, cr) } } Rn && (Xt.idx = tn, Oa()), kt !== !1 && Kr("setCursor") } let As = null; Object.defineProperty(me, "rect", { get() { return As == null && ps(!1), As } }); function ps(at = !1) { at ? As = null : (As = we.getBoundingClientRect(), Kr("syncRect", As)) } function Ls(at, kt, Kt, tn, xn, En, er) { ct._lock || cs && at != null && at.movementX == 0 && at.movementY == 0 || (ca(at, kt, Kt, tn, xn, En, er, !1, at != null), at != null ? qs(null, !0, !0) : qs(kt, !0, !1)) } function ca(at, kt, Kt, tn, xn, En, er, cr, xr) { if (As == null && ps(!1), Si(at), at != null) Kt = at.clientX - As.left, tn = at.clientY - As.top; else { if (Kt < 0 || tn < 0) { ai = -10, vi = -10; return } let [Cr, Sr] = oi.scales, Or = kt.cursor.sync, [qr, ui] = Or.values, [Jr, ci] = Or.scales, [jr, Ur] = oi.match, Pi = kt.axes[0].side % 2 == 1, zi = We.ori == 0 ? en : cn, Qi = We.ori == 1 ? en : cn, Mi = Pi ? En : xn, qi = Pi ? xn : En, Ss = Pi ? tn : Kt, ms = Pi ? Kt : tn; if (Jr != null ? Kt = jr(Cr, Jr) ? ve(qr, Ne[Cr], zi, 0) : -10 : Kt = zi * (Ss / Mi), ci != null ? tn = Ur(Sr, ci) ? ve(ui, Ne[Sr], Qi, 0) : -10 : tn = Qi * (ms / qi), We.ori == 1) { let Yi = Kt; Kt = tn, tn = Yi } } xr && (kt == null || kt.cursor.event.type == mousemove) && ((Kt <= 1 || Kt >= en - 1) && (Kt = incrRound(Kt, en)), (tn <= 1 || tn >= cn - 1) && (tn = incrRound(tn, cn))), cr ? (On = Kt, hr = tn, [pr, zr] = ct.move(me, Kt, tn)) : (ai = Kt, vi = tn) } const Xa = { width: 0, height: 0, left: 0, top: 0 }; function Et() { La(Xa, !1) } let wt, rn, _n, Wn; function or(at, kt, Kt, tn, xn, En, er) { cs = !0, Bi = Di = Fi._x = Fi._y = !1, ca(at, kt, Kt, tn, xn, En, er, !0, !1), at != null && (kn(mouseup, doc, gr, !1), Ys(mousedown, me, pr, zr, en, cn, null)); let { left: cr, top: xr, width: Cr, height: Sr } = _i; wt = cr, rn = xr, _n = Cr, Wn = Sr } function gr(at, kt, Kt, tn, xn, En, er) { cs = Fi._x = Fi._y = !1, ca(at, kt, Kt, tn, xn, En, er, !1, !0); let { left: cr, top: xr, width: Cr, height: Sr } = _i, Or = Cr > 0 || Sr > 0, qr = wt != cr || rn != xr || _n != Cr || Wn != Sr; if (Or && qr && La(_i), Fi.setScale && Or && qr) { let ui = cr, Jr = Cr, ci = xr, jr = Sr; if (We.ori == 1 && (ui = xr, Jr = Sr, ci = cr, jr = Cr), Bi && Ds(Oe, Is(ui, Oe), Is(ui + Jr, Oe)), Di) for (let Ur in Ne) { let Pi = Ne[Ur]; Ur != Oe && Pi.from == null && Pi.min != inf && Ds(Ur, Is(ci + jr, Ur), Is(ci, Ur)) } Et() } else ct.lock && (ct._lock = !ct._lock, qs(kt, !0, at != null)); at != null && (Ht(mouseup, doc), Ys(mouseup, me, ai, vi, en, cn, null)) } function Qn(at, kt, Kt, tn, xn, En, er) { if (ct._lock) return; Si(at); let cr = cs; if (cs) { let xr = !0, Cr = !0, Sr = 10, Or, qr; We.ori == 0 ? (Or = Bi, qr = Di) : (Or = Di, qr = Bi), Or && qr && (xr = ai <= Sr || ai >= en - Sr, Cr = vi <= Sr || vi >= cn - Sr), Or && xr && (ai = ai < pr ? 0 : en), qr && Cr && (vi = vi < zr ? 0 : cn), qs(null, !0, !0), cs = !1 } ai = -10, vi = -10, jt.fill(null), qs(null, !0, !0), cr && (cs = cr) } function ur(at, kt, Kt, tn, xn, En, er) { ct._lock || (Si(at), Tn(), Et(), at != null && Ys(dblclick, me, ai, vi, en, cn, null)) } function Tr() { Pe.forEach(syncFontSize), qn(me.width, me.height, !0) } on(dppxchange, win, Tr); const Ir = {}; Ir.mousedown = or, Ir.mousemove = Ls, Ir.mouseup = gr, Ir.dblclick = ur, Ir.setSeries = (at, kt, Kt, tn) => { let xn = oi.match[2]; Kt = xn(me, kt, Kt), Kt != -1 && bs(Kt, tn, !0, !1) }, $t && (kn(mousedown, we, or), kn(mousemove, we, Ls), kn(mouseenter, we, at => { Si(at), ps(!1) }), kn(mouseleave, we, Qn), kn(dblclick, we, ur), cursorPlots.add(me), me.syncRect = ps); const ei = me.hooks = fe.hooks || {}; function Kr(at, kt, Kt) { va ? Ki.push([at, kt, Kt]) : at in ei && ei[at].forEach(tn => { tn.call(null, me, kt, Kt) }) } (fe.plugins || []).forEach(at => { for (let kt in at.hooks) ei[kt] = (ei[kt] || []).concat(at.hooks[kt]) }); const Zi = (at, kt, Kt) => Kt, oi = assign({ key: null, setSeries: !1, filters: { pub: retTrue, sub: retTrue }, scales: [Oe, Ie[1] ? Ie[1].scale : null], match: [retEq, retEq, Zi], values: [null, null] }, ct.sync); oi.match.length == 2 && oi.match.push(Zi), ct.sync = oi; const ba = oi.key, Wi = _sync(ba); function Ys(at, kt, Kt, tn, xn, En, er) { oi.filters.pub(at, kt, Kt, tn, xn, En, er) && Wi.pub(at, kt, Kt, tn, xn, En, er) } Wi.sub(me); function Na(at, kt, Kt, tn, xn, En, er) { oi.filters.sub(at, kt, Kt, tn, xn, En, er) && Ir[at](null, kt, Kt, tn, xn, En, er) } me.pub = Na; function Os() { Wi.unsub(me), cursorPlots.delete(me), Hn.clear(), off(dppxchange, win, Tr), Ee.remove(), gn?.remove(), Kr("destroy") } me.destroy = Os; function Ka() { Kr("init", fe, K), pn(K || fe.data, !1), ot[Oe] ? $e(Oe, ot[Oe]) : Tn(), Dn = _i.show && (_i.width > 0 || _i.height > 0), mn = Rn = !0, qn(fe.width, fe.height) } return Ie.forEach(hs), Pe.forEach(dn), pe ? pe instanceof HTMLElement ? (pe.appendChild(Ee), Ka()) : pe(me, Ka) : Ka(), me
} uPlot.assign = assign; uPlot.fmtNum = fmtNum; uPlot.rangeNum = rangeNum; uPlot.rangeLog = rangeLog; uPlot.rangeAsinh = rangeAsinh; uPlot.orient = orient; uPlot.pxRatio = pxRatio; uPlot.join = join; uPlot.fmtDate = fmtDate, uPlot.tzDate = tzDate; uPlot.sync = _sync; { uPlot.addGap = addGap, uPlot.clipGaps = clipGaps; let fe = uPlot.paths = { points }; fe.linear = linear, fe.stepped = stepped, fe.bars = bars, fe.spline = monotoneCubic } const uPlot_esm = Object.freeze(Object.defineProperty({ __proto__: null, default: uPlot }, Symbol.toStringTag, { value: "Module" })), require$$1 = getAugmentedNamespace(uPlot_esm); (function (fe, K) {
	(function (me, ge) { fe.exports = ge(reactExports, require$$1) })(commonjsGlobal, (pe, me) => (() => {
		var ge = { "./common/index.ts": (_e, Ee, be) => { be.r(Ee), be.d(Ee, { dataMatch: () => Ce, optionsUpdateState: () => Se }); var Ae = function (we, Be) { var De = {}; for (var Re in we) Object.prototype.hasOwnProperty.call(we, Re) && Be.indexOf(Re) < 0 && (De[Re] = we[Re]); if (we != null && typeof Object.getOwnPropertySymbols == "function") for (var Ie = 0, Re = Object.getOwnPropertySymbols(we); Ie < Re.length; Ie++)Be.indexOf(Re[Ie]) < 0 && Object.prototype.propertyIsEnumerable.call(we, Re[Ie]) && (De[Re[Ie]] = we[Re[Ie]]); return De }; Object.is || Object.defineProperty(Object, "is", { value: function (Be, De) { return Be === De && (Be !== 0 || 1 / Be === 1 / De) || Be !== Be && De !== De } }); var Se = function (Be, De) { var Re = Be.width, Ie = Be.height, Pe = Ae(Be, ["width", "height"]), Ne = De.width, ke = De.height, Oe = Ae(De, ["width", "height"]), Ue = "keep"; if ((Ie !== ke || Re !== Ne) && (Ue = "update"), Object.keys(Pe).length !== Object.keys(Oe).length) return "create"; for (var He = 0, Ge = Object.keys(Pe); He < Ge.length; He++) { var ze = Ge[He]; if (!Object.is(Pe[ze], Oe[ze])) { Ue = "create"; break } } return Ue }, Ce = function (Be, De) { return Be.length !== De.length ? !1 : Be.every(function (Re, Ie) { var Pe = De[Ie]; return Re.length !== Pe.length ? !1 : Re.every(function (Ne, ke) { return Ne === Pe[ke] }) }) } }, react: _e => { _e.exports = pe }, uplot: _e => { _e.exports = me } }, xe = {}; function ye(_e) { var Ee = xe[_e]; if (Ee !== void 0) return Ee.exports; var be = xe[_e] = { exports: {} }; return ge[_e](be, be.exports, ye), be.exports } ye.n = _e => { var Ee = _e && _e.__esModule ? () => _e.default : () => _e; return ye.d(Ee, { a: Ee }), Ee }, ye.d = (_e, Ee) => { for (var be in Ee) ye.o(Ee, be) && !ye.o(_e, be) && Object.defineProperty(_e, be, { enumerable: !0, get: Ee[be] }) }, ye.o = (_e, Ee) => Object.prototype.hasOwnProperty.call(_e, Ee), ye.r = _e => { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(_e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(_e, "__esModule", { value: !0 }) }; var ve = {}; return (() => {/*!*******************************!*\
  !*** ./react/uplot-react.tsx ***!
  \*******************************/ye.r(ve), ye.d(ve, { default: () => Ce }); var _e = ye("react"), Ee = ye.n(_e), be = ye("uplot"), Ae = ye.n(be), Se = ye("./common/index.ts"); function Ce(we) { var Be = we.options, De = we.data, Re = we.target, Ie = we.onDelete, Pe = we.onCreate, Ne = we.resetScales, ke = Ne === void 0 ? !0 : Ne, Oe = we.className, Ue = (0, _e.useRef)(null), He = (0, _e.useRef)(null), Ge = (0, _e.useRef)(Be), ze = (0, _e.useRef)(Re), We = (0, _e.useRef)(De), Xe = (0, _e.useRef)(Pe), Ye = (0, _e.useRef)(Ie); (0, _e.useEffect)(function () { Xe.current = Pe, Ye.current = Ie }); var Ze = (0, _e.useCallback)(function (qe) { var Qe; qe && ((Qe = Ye.current) === null || Qe === void 0 || Qe.call(Ye, qe), qe.destroy(), Ue.current = null) }, []), ot = (0, _e.useCallback)(function () { var qe, Qe = new (Ae())(Ge.current, We.current, ze.current || He.current); Ue.current = Qe, (qe = Xe.current) === null || qe === void 0 || qe.call(Xe, Qe) }, []); return (0, _e.useEffect)(function () { return ot(), function () { Ze(Ue.current) } }, [ot, Ze]), (0, _e.useEffect)(function () { if (Ge.current !== Be) { var qe = (0, Se.optionsUpdateState)(Ge.current, Be); Ge.current = Be, !Ue.current || qe === "create" ? (Ze(Ue.current), ot()) : qe === "update" && Ue.current.setSize({ width: Be.width, height: Be.height }) } }, [Be, ot, Ze]), (0, _e.useEffect)(function () { We.current !== De && (Ue.current ? (0, Se.dataMatch)(We.current, De) || (ke ? Ue.current.setData(De, !0) : (Ue.current.setData(De, !1), Ue.current.redraw())) : (We.current = De, ot()), We.current = De) }, [De, ke, ot]), (0, _e.useEffect)(function () { return ze.current !== Re && (ze.current = Re, ot()), function () { return Ze(Ue.current) } }, [Re, ot, Ze]), Re ? null : Ee().createElement("div", { ref: He, className: Oe }) }
		})(), ve = ve.default, ve
	})())
})(uplotReact); var uplotReactExports = uplotReact.exports; const UplotReact = getDefaultExportFromCjs(uplotReactExports); function PlotComponent({ props: fe, onExpand: K }) { const [pe, me] = reactExports.useState(!1), { ref: ge, width: xe } = useElementSize(), [ye, ve, _e] = reactExports.useMemo(() => { const Ce = fe.data.map(De => new Float64Array(De.buffer.slice(De.byteOffset, De.byteOffset + De.byteLength))); let we = 1 / 0, Be = -1 / 0; for (const De of Ce[0]) De < we && (we = De), De > Be && (Be = De); return [Ce, we, Be] }, [fe.data]), Ee = reactExports.useMemo(() => ({ width: xe, height: xe / fe.aspect, title: fe.title || void 0, mode: fe.mode || void 0, series: fe.series || [], cursor: fe.cursor || void 0, bands: fe.bands || void 0, scales: fe.scales || void 0, axes: fe.axes || void 0, legend: fe.legend || void 0, focus: fe.focus || void 0 }), [xe, fe]), [be, Ae] = reactExports.useState(), Se = reactExports.useRef({ relMin: 0, relMax: 1 }); return reactExports.useEffect(() => { if (!be) return; const Ce = Object.keys(be.scales)[0], we = be.scales[Ce]; if (we.auto === !1) return; const Be = _e - ve; return be.setScale(Ce, { min: ve + Se.current.relMin * Be, max: ve + Se.current.relMax * Be }), () => { Se.current = { relMin: ((we.min ?? 0) - ve) / Be, relMax: ((we.max ?? 1) - ve) / Be } } }, [ve, _e, be]), jsxRuntimeExports.jsxs(Paper, { ref: ge, className: folderWrapper, withBorder: !0, style: { position: "relative" }, onMouseEnter: K ? () => me(!0) : void 0, onMouseLeave: K ? () => me(!1) : void 0, children: [Ee && jsxRuntimeExports.jsx(UplotReact, { resetScales: !1, onCreate: Ce => { Ae(Ce) }, onDelete: () => { Ae(void 0) }, options: Ee, data: ye }), K && pe && jsxRuntimeExports.jsx(Tooltip, { label: "Expand plot", children: jsxRuntimeExports.jsx(ActionIcon, { onClick: K, variant: "subtle", color: "gray", size: "sm", style: { position: "absolute", top: 8, right: 8, backgroundColor: "rgba(255, 255, 255, 0.9)", backdropFilter: "blur(4px)" }, children: jsxRuntimeExports.jsx(IconMaximize, { size: 14 }) }) })] }) } function UplotComponent(fe) { const [K, { open: pe, close: me }] = useDisclosure(!1); return fe.props.visible === !1 ? null : jsxRuntimeExports.jsxs(Box, { children: [jsxRuntimeExports.jsx(PlotComponent, { ...fe, onExpand: pe }), jsxRuntimeExports.jsx(Modal, { opened: K, onClose: me, size: "xl", children: jsxRuntimeExports.jsx(PlotComponent, { ...fe }) })] }) } function TabGroupComponent({ props: { _tab_labels: fe, _tab_icons_html: K, _tab_container_ids: pe, visible: me } }) { const { GuiContainer: ge } = reactExports.useContext(GuiComponentContext); return me ? jsxRuntimeExports.jsxs(Tabs, { radius: "xs", defaultValue: "0", style: { marginTop: "-0.55em" }, children: [jsxRuntimeExports.jsx(Tabs.List, { children: fe.map((xe, ye) => jsxRuntimeExports.jsx(Tabs.Tab, { value: ye.toString(), styles: { tabSection: { marginRight: "0.5em" }, tab: { padding: "0.75em" } }, leftSection: K[ye] === null ? void 0 : jsxRuntimeExports.jsx("div", { className: htmlIconWrapper, dangerouslySetInnerHTML: { __html: K[ye] } }), children: xe }, ye)) }), pe.map((xe, ye) => jsxRuntimeExports.jsx(Tabs.Panel, { value: ye.toString(), children: jsxRuntimeExports.jsx(ge, { containerUuid: xe }) }, xe))] }) : null } function FolderComponent({ uuid: fe, props: { label: K, visible: pe, expand_by_default: me }, nextGuiUuid: ge }) { const xe = reactExports.useContext(ViewerContext), [ye, { toggle: ve }] = useDisclosure(me), _e = xe.useGui(Ce => Ce.guiUuidSetFromContainerUuid[fe]), Ee = reactExports.useContext(GuiComponentContext), be = _e === void 0 || Object.keys(_e).length === 0, Ae = xe.useGui(Ce => ge == null ? null : Ce.guiConfigFromUuid[ge]?.type), Se = ye ? IconChevronUp : IconChevronDown; return pe ? jsxRuntimeExports.jsxs(Paper, { withBorder: !0, className: folderWrapper, mb: Ae === "GuiFolderMessage" ? "md" : void 0, children: [jsxRuntimeExports.jsxs(Paper, { className: folderLabel, style: { cursor: be ? void 0 : "pointer" }, onClick: ve, children: [K, jsxRuntimeExports.jsx(Se, { className: folderToggleIcon, style: { display: be ? "none" : void 0 } })] }), jsxRuntimeExports.jsx(Collapse, { in: ye && !be, children: jsxRuntimeExports.jsx(Box, { pt: "0.2em", children: jsxRuntimeExports.jsx(GuiComponentContext.Provider, { value: { ...Ee, folderDepth: Ee.folderDepth + 1 }, children: jsxRuntimeExports.jsx(Ee.GuiContainer, { containerUuid: fe }) }) }) }), jsxRuntimeExports.jsx(Collapse, { in: !(ye && !be), children: jsxRuntimeExports.jsx(Box, { p: "xs" }) })] }) : null } function clamp(fe, K, pe) { return Math.max(K, Math.min(pe, fe)) } function MultiSlider({ min: fe, max: K, step: pe = 1, value: me, onChange: ge, marks: xe, fixedEndpoints: ye = !1, minRange: ve, precision: _e = 2, id: Ee, className: be, disabled: Ae = !1, pt: Se, pb: Ce }) { const [we, Be] = reactExports.useState(null), De = reactExports.useRef(null), Re = useMantineTheme(), { colorScheme: Ie } = useMantineColorScheme(), Pe = Ge => (Ge - fe) / (K - fe) * 100, Ne = Ge => { if (!De.current) return 0; const ze = De.current.getBoundingClientRect(), Xe = (Ge - ze.left) / ze.width * (K - fe) + fe; return pe ? Math.round(Xe / pe) * pe : parseFloat(Xe.toFixed(_e)) }, ke = Ge => { if (me.length === 0) return -1; let ze = 1 / 0, We = 0; return me.forEach((Xe, Ye) => { const Ze = Math.abs(Xe - Ge); Ze < ze && (ze = Ze, We = Ye) }), We }, Oe = reactExports.useCallback((Ge, ze) => { const We = [...me]; We[ze] = clamp(Ge, fe, K); const Xe = ve || pe; ze < We.length - 1 && We[ze] > We[ze + 1] - Xe && (We[ze] = We[ze + 1] - Xe), ze > 0 && We[ze] < We[ze - 1] + Xe && (We[ze] = We[ze - 1] + Xe), !(ye && (ze === 0 || ze === We.length - 1)) && ge(We) }, [me, ge, fe, K, pe, ve, ye]), Ue = Ge => { if (Ae || me.length === 0) return; const ze = Ne(Ge.clientX), We = ke(ze); if (We === -1) return; Be(We); const Xe = Ze => { const ot = Ne(Ze.clientX); Oe(ot, We) }, Ye = () => { Be(null), document.removeEventListener("mousemove", Xe), document.removeEventListener("mouseup", Ye) }; document.addEventListener("mousemove", Xe), document.addEventListener("mouseup", Ye) }, He = (Ge, ze) => { if (Ge.stopPropagation(), Ae || me.length === 0 || ze >= me.length) return; Be(ze); const We = Ye => { const Ze = Ne(Ye.clientX); Oe(Ze, ze) }, Xe = () => { Be(null), document.removeEventListener("mousemove", We), document.removeEventListener("mouseup", Xe) }; document.addEventListener("mousemove", We), document.addEventListener("mouseup", Xe) }; return jsxRuntimeExports.jsx(Box, { id: Ee, className: `multi-slider ${be || ""} ${Ae ? "disabled" : ""}`, pt: Se, pb: Ce, children: jsxRuntimeExports.jsxs("div", { ref: De, className: "multi-slider-track-container", onMouseDown: Ue, children: [jsxRuntimeExports.jsx("div", { className: "multi-slider-track" }), me.map((Ge, ze) => jsxRuntimeExports.jsx(Tooltip, { label: Ge.toFixed(_e), opened: we === ze, position: "top", offset: 10, transitionProps: { transition: "fade", duration: 0 }, withinPortal: !0, children: jsxRuntimeExports.jsx("div", { className: `multi-slider-thumb ${we === ze ? "active" : ""}`, style: { left: `${Pe(Ge)}%`, backgroundColor: Ae ? void 0 : Re.colors[Re.primaryColor][Ie === "dark" ? 5 : 6] }, onMouseDown: We => He(We, ze) }) }, `thumb-${ze}`)), xe && xe.map((Ge, ze) => jsxRuntimeExports.jsxs("div", { className: "multi-slider-mark-wrapper", style: { left: `${Pe(Ge.value)}%` }, children: [jsxRuntimeExports.jsx("div", { className: "multi-slider-mark" }), Ge.label && Ge.label !== null && jsxRuntimeExports.jsx("div", { className: "multi-slider-mark-label", children: Ge.label })] }, `mark-${ze}`))] }) }) } function MultiSliderComponent({ uuid: fe, value: K, props: { label: pe, hint: me, visible: ge, disabled: xe, min: ye, max: ve, precision: _e, step: Ee, _marks: be, fixed_endpoints: Ae, min_range: Se } }) { const { setValue: Ce } = React$4.useContext(GuiComponentContext); if (!ge) return null; const we = De => Ce(fe, De), Be = jsxRuntimeExports.jsx(Box, { px: "0.1em", children: jsxRuntimeExports.jsx(MultiSlider, { id: fe, className: be === null ? sliderDefaultMarks : void 0, min: ye, max: ve, step: Ee ?? void 0, fixedEndpoints: Ae, precision: _e, minRange: Se ?? void 0, marks: be === null ? [{ value: ye, label: `${ye.toFixed(6).replace(/\.?0+$/, "")}` }, { value: ve, label: `${ve.toFixed(6).replace(/\.?0+$/, "")}` }] : be, value: K, onChange: we, disabled: xe }) }); return jsxRuntimeExports.jsx(ViserInputComponent, { uuid: fe, hint: me, label: pe, children: Be }) } function UploadButtonComponent({ uuid: fe, props: { disabled: K, mime_type: pe, color: me, _icon_html: ge, label: xe } }) { const ye = reactExports.useContext(ViewerContext), ve = React$4.useRef(null), { isUploading: _e, upload: Ee } = useFileUpload({ viewer: ye, componentUuid: fe }); return jsxRuntimeExports.jsxs(Box, { mx: "xs", mb: "0.5em", children: [jsxRuntimeExports.jsx("input", { type: "file", style: { display: "none" }, id: `file_upload_${fe}`, name: "file", accept: pe, ref: ve, onChange: be => { const Ae = be.target; Ae.files && Ee(Ae.files[0]) } }), jsxRuntimeExports.jsx(Button, { id: fe, fullWidth: !0, color: toMantineColor(me), onClick: () => { ve.current !== null && (ve.current.value = ve.current.defaultValue, ve.current.click()) }, style: { height: "2em" }, disabled: K || _e, size: "sm", leftSection: ge === null ? void 0 : jsxRuntimeExports.jsx("div", { className: htmlIconWrapper, dangerouslySetInnerHTML: { __html: ge } }), children: xe })] }) } function useFileUpload({ viewer: fe, componentUuid: K }) { const pe = fe.useGui(_e => _e.updateUploadState), me = fe.useGui(_e => _e.uploadsInProgress[K]), ge = me?.totalBytes, xe = React$4.useMemo(() => { if (ge === void 0) return ""; let _e = ge; const Ee = ["B", "K", "M", "G", "T", "P"]; let be = 0; for (; _e >= 100 && be < Ee.length - 1;)_e /= 1024, be += 1; return `${_e.toFixed(1)}${Ee[be]}` }, [ge]); React$4.useEffect(() => { if (me === void 0) return; const { notificationId: _e, filename: Ee } = me; if (me.uploadedBytes === 0) notifications.show({ id: _e, title: `Uploading ${Ee} (${xe})`, message: jsxRuntimeExports.jsx(Progress, { size: "sm", value: 0 }), autoClose: !1, withCloseButton: !1, loading: !0 }); else { const be = me.uploadedBytes / me.totalBytes, Ae = be === 1; notifications.update({ id: _e, title: `Uploading ${Ee} (${xe})`, message: Ae ? "File uploaded successfully." : jsxRuntimeExports.jsx(Progress, { size: "sm", transitionDuration: 10, value: 100 * be }), autoClose: Ae, withCloseButton: Ae, loading: !Ae, icon: Ae ? jsxRuntimeExports.jsx(IconCheck, {}) : void 0 }) } }, [me, xe]); const ye = me !== void 0 && me.uploadedBytes < me.totalBytes; async function ve(_e) { const Ee = fe.mutable.current, be = 512 * 1024, Ae = Math.ceil(_e.size / be), Se = v4(), Ce = "upload-" + Se; pe({ componentId: K, uploadedBytes: 0, totalBytes: _e.size, filename: _e.name, notificationId: Ce }), Ee.sendMessage({ type: "FileTransferStartUpload", source_component_uuid: K, transfer_uuid: Se, filename: _e.name, mime_type: _e.type, size_bytes: _e.size, part_count: Ae }); for (let we = 0; we < Ae; we++) { const Be = we * be, De = (we + 1) * be, Ie = await _e.slice(Be, De).arrayBuffer(); Ee.sendMessage({ type: "FileTransferPart", source_component_uuid: K, transfer_uuid: Se, part_index: we, content: new Uint8Array(Ie) }) } } return { isUploading: ye, upload: ve } } function ProgressBarComponent({ value: fe, props: { visible: K, color: pe, animated: me } }) { return K ? jsxRuntimeExports.jsx(Box, { pb: "xs", px: "xs", children: jsxRuntimeExports.jsx(Progress, { radius: "xs", color: toMantineColor(pe), value: fe, animated: me, transitionDuration: 0 }) }) : null } function ImageComponent({ props: fe }) { if (!fe.visible) return null; const [K, pe] = reactExports.useState(null); return reactExports.useEffect(() => { if (fe._data === null) pe(null); else { const me = URL.createObjectURL(new Blob([fe._data], { type: "image/" + fe._format })); return pe(me), () => { URL.revokeObjectURL(me) } } }, [fe._data, fe._format]), K === null ? null : jsxRuntimeExports.jsxs(Box, { px: "xs", children: [fe.label === null ? null : jsxRuntimeExports.jsx(Text, { fz: "sm", style: { display: "block" }, children: fe.label }), jsxRuntimeExports.jsx("img", { src: K, style: { maxWidth: "100%", height: "auto" } })] }) } function HtmlComponent({ props: fe }) { return fe.visible ? jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: fe.content } }) : null } function GeneratedGuiContainer({ containerUuid: fe }) { const pe = React$4.useContext(ViewerContext).useGui(xe => xe.updateGuiProps), me = useThrottledMessageSender(50).send; function ge(xe, ye) { pe(xe, { value: ye }), me({ type: "GuiUpdateMessage", uuid: xe, updates: { value: ye } }) } return jsxRuntimeExports.jsx(GuiComponentContext.Provider, { value: { folderDepth: 0, GuiContainer, messageSender: me, setValue: ge }, children: jsxRuntimeExports.jsx(GuiContainer, { containerUuid: fe }) }) } function GuiContainer({ containerUuid: fe }) { const K = React$4.useContext(ViewerContext), pe = K.useGui(ve => ve.guiUuidSetFromContainerUuid[fe]) ?? {}, me = [...Object.keys(pe)], ge = K.useGui(ve => ve.guiOrderFromUuid); if (pe === void 0) return null; let xe = me.map(ve => ({ uuid: ve, order: ge[ve] })); return xe = xe.sort((ve, _e) => ve.order - _e.order), jsxRuntimeExports.jsx(Box, { pt: "xs", children: xe.map((ve, _e) => jsxRuntimeExports.jsx(GeneratedInput, { guiUuid: ve.uuid, nextGuiUuid: xe[_e + 1]?.uuid ?? null }, ve.uuid)) }) } function GeneratedInput(fe) { const pe = React$4.useContext(ViewerContext).useGui(me => me.guiConfigFromUuid[fe.guiUuid]); if (pe === void 0) return console.error("Tried to render non-existent component", fe.guiUuid), null; switch (pe.type) { case "GuiFolderMessage": return jsxRuntimeExports.jsx(FolderComponent, { ...pe, nextGuiUuid: fe.nextGuiUuid }); case "GuiTabGroupMessage": return jsxRuntimeExports.jsx(TabGroupComponent, { ...pe }); case "GuiMarkdownMessage": return jsxRuntimeExports.jsx(MarkdownComponent, { ...pe }); case "GuiHtmlMessage": return jsxRuntimeExports.jsx(HtmlComponent, { ...pe }); case "GuiPlotlyMessage": return jsxRuntimeExports.jsx(PlotlyComponent, { ...pe }); case "GuiUplotMessage": return jsxRuntimeExports.jsx(UplotComponent, { ...pe }); case "GuiImageMessage": return jsxRuntimeExports.jsx(ImageComponent, { ...pe }); case "GuiButtonMessage": return jsxRuntimeExports.jsx(ButtonComponent, { ...pe }); case "GuiUploadButtonMessage": return jsxRuntimeExports.jsx(UploadButtonComponent, { ...pe }); case "GuiSliderMessage": return jsxRuntimeExports.jsx(SliderComponent, { ...pe }); case "GuiMultiSliderMessage": return jsxRuntimeExports.jsx(MultiSliderComponent, { ...pe }); case "GuiNumberMessage": return jsxRuntimeExports.jsx(NumberInputComponent, { ...pe }); case "GuiTextMessage": return jsxRuntimeExports.jsx(TextInputComponent, { ...pe }); case "GuiCheckboxMessage": return jsxRuntimeExports.jsx(CheckboxComponent, { ...pe }); case "GuiVector2Message": return jsxRuntimeExports.jsx(Vector2Component, { ...pe }); case "GuiVector3Message": return jsxRuntimeExports.jsx(Vector3Component, { ...pe }); case "GuiDropdownMessage": return jsxRuntimeExports.jsx(DropdownComponent, { ...pe }); case "GuiRgbMessage": return jsxRuntimeExports.jsx(RgbComponent, { ...pe }); case "GuiRgbaMessage": return jsxRuntimeExports.jsx(RgbaComponent, { ...pe }); case "GuiButtonGroupMessage": return jsxRuntimeExports.jsx(ButtonGroupComponent, { ...pe }); case "GuiProgressBarMessage": return jsxRuntimeExports.jsx(ProgressBarComponent, { ...pe }); default: assertNeverType(pe) } } function assertNeverType(fe) { throw new Error("Unexpected object: " + fe.type) } const Line = reactExports.forwardRef(function ({ points: K, color: pe = 16777215, vertexColors: me, linewidth: ge, lineWidth: xe, segments: ye, dashed: ve, ..._e }, Ee) { const be = useThree(Be => Be.size), Ae = reactExports.useMemo(() => ye ? new LineSegments2 : new Line2, [ye]), [Se] = reactExports.useState(() => new LineMaterial), Ce = 3, we = reactExports.useMemo(() => { const Be = ye ? new LineSegmentsGeometry : new LineGeometry; if (Be.setPositions(K), me) { const De = new Float32Array(me).map(Re => Re / 255); pe = 16777215, Be.setColors(De, Ce) } return Be }, [K, ye, me, Ce]); return reactExports.useLayoutEffect(() => { Ae.computeLineDistances() }, [K, Ae]), reactExports.useLayoutEffect(() => { ve ? Se.defines.USE_DASH = "" : delete Se.defines.USE_DASH, Se.needsUpdate = !0 }, [ve, Se]), reactExports.useEffect(() => () => { we.dispose(), Se.dispose() }, [we]), jsxRuntimeExports.jsxs("primitive", { object: Ae, ref: Ee, ..._e, children: [jsxRuntimeExports.jsx("primitive", { object: we, attach: "geometry" }), jsxRuntimeExports.jsx("primitive", { object: Se, attach: "material", color: pe, vertexColors: !!me, resolution: [be.width, be.height], linewidth: ge ?? xe ?? 1, dashed: ve, transparent: !1, ..._e })] }) }), shadowArgs = { "shadow-camera-near": .001, "shadow-camera-far": 500, "shadow-bias": -1e-5, "shadow-mapSize-width": 1024, "shadow-mapSize-height": 1024, "shadow-radius": 4 }, inverseProjectionMatrix = new Matrix4; class CSMFrustum { constructor(K) { K = K || {}, this.zNear = K.webGL === !0 ? -1 : 0, this.vertices = { near: [new Vector3, new Vector3, new Vector3, new Vector3], far: [new Vector3, new Vector3, new Vector3, new Vector3] }, K.projectionMatrix !== void 0 && this.setFromProjectionMatrix(K.projectionMatrix, K.maxFar || 1e4) } setFromProjectionMatrix(K, pe) { const me = this.zNear, ge = K.elements[2 * 4 + 3] === 0; return inverseProjectionMatrix.copy(K).invert(), this.vertices.near[0].set(1, 1, me), this.vertices.near[1].set(1, -1, me), this.vertices.near[2].set(-1, -1, me), this.vertices.near[3].set(-1, 1, me), this.vertices.near.forEach(function (xe) { xe.applyMatrix4(inverseProjectionMatrix) }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function (xe) { xe.applyMatrix4(inverseProjectionMatrix); const ye = Math.abs(xe.z); ge ? xe.z *= Math.min(pe / ye, 1) : xe.multiplyScalar(Math.min(pe / ye, 1)) }), this.vertices } split(K, pe) { for (; K.length > pe.length;)pe.push(new CSMFrustum); pe.length = K.length; for (let me = 0; me < K.length; me++) { const ge = pe[me]; if (me === 0) for (let xe = 0; xe < 4; xe++)ge.vertices.near[xe].copy(this.vertices.near[xe]); else for (let xe = 0; xe < 4; xe++)ge.vertices.near[xe].lerpVectors(this.vertices.near[xe], this.vertices.far[xe], K[me - 1]); if (me === K.length - 1) for (let xe = 0; xe < 4; xe++)ge.vertices.far[xe].copy(this.vertices.far[xe]); else for (let xe = 0; xe < 4; xe++)ge.vertices.far[xe].lerpVectors(this.vertices.near[xe], this.vertices.far[xe], K[me]) } } toSpace(K, pe) { for (let me = 0; me < 4; me++)pe.vertices.near[me].copy(this.vertices.near[me]).applyMatrix4(K), pe.vertices.far[me].copy(this.vertices.far[me]).applyMatrix4(K) } } const CSMShader = {
	lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`, lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	`+ ShaderChunk.lights_pars_begin
}, _cameraToLightMatrix = new Matrix4, _lightSpaceFrustum = new CSMFrustum({ webGL: !0 }), _center = new Vector3, _bbox = new Box3, _uniformArray = [], _logArray = [], _lightOrientationMatrix = new Matrix4, _lightOrientationMatrixInverse = new Matrix4, _up = new Vector3(0, 1, 0); class CSM { constructor(K) { this.camera = K.camera, this.parent = K.parent, this.cascades = K.cascades || 3, this.maxFar = K.maxFar || 1e5, this.mode = K.mode || "practical", this.shadowMapSize = K.shadowMapSize || 2048, this.shadowBias = K.shadowBias || 1e-6, this.lightDirection = K.lightDirection || new Vector3(1, -1, 1).normalize(), this.lightIntensity = K.lightIntensity || 3, this.lightNear = K.lightNear || 1, this.lightFar = K.lightFar || 2e3, this.lightMargin = K.lightMargin || 200, this.customSplitsCallback = K.customSplitsCallback, this.fade = !1, this.mainFrustum = new CSMFrustum({ webGL: !0 }), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = new Map, this._createLights(), this.updateFrustums(), this._injectInclude() } _createLights() { for (let K = 0; K < this.cascades; K++) { const pe = new DirectionalLight(16777215, this.lightIntensity); pe.castShadow = !0, pe.shadow.mapSize.width = this.shadowMapSize, pe.shadow.mapSize.height = this.shadowMapSize, pe.shadow.camera.near = this.lightNear, pe.shadow.camera.far = this.lightFar, pe.shadow.bias = this.shadowBias, this.parent.add(pe), this.parent.add(pe.target), this.lights.push(pe) } } _initCascades() { const K = this.camera; K.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(K.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums) } _updateShadowBounds() { const K = this.frustums; for (let pe = 0; pe < K.length; pe++) { const ge = this.lights[pe].shadow.camera, xe = this.frustums[pe], ye = xe.vertices.near, ve = xe.vertices.far, _e = ve[0]; let Ee; _e.distanceTo(ve[2]) > _e.distanceTo(ye[2]) ? Ee = ve[2] : Ee = ye[2]; let be = _e.distanceTo(Ee); if (this.fade) { const Ae = this.camera, Se = Math.max(Ae.far, this.maxFar), Ce = xe.vertices.far[0].z / (Se - Ae.near), we = .25 * Math.pow(Ce, 2) * (Se - Ae.near); be += we } ge.left = -be / 2, ge.right = be / 2, ge.top = be / 2, ge.bottom = -be / 2, ge.updateProjectionMatrix() } } _getBreaks() { const K = this.camera, pe = Math.min(K.far, this.maxFar); switch (this.breaks.length = 0, this.mode) { case "uniform": me(this.cascades, K.near, pe, this.breaks); break; case "logarithmic": ge(this.cascades, K.near, pe, this.breaks); break; case "practical": xe(this.cascades, K.near, pe, .5, this.breaks); break; case "custom": this.customSplitsCallback === void 0 && console.error("CSM: Custom split scheme callback not defined."), this.customSplitsCallback(this.cascades, K.near, pe, this.breaks); break }function me(ye, ve, _e, Ee) { for (let be = 1; be < ye; be++)Ee.push((ve + (_e - ve) * be / ye) / _e); Ee.push(1) } function ge(ye, ve, _e, Ee) { for (let be = 1; be < ye; be++)Ee.push(ve * (_e / ve) ** (be / ye) / _e); Ee.push(1) } function xe(ye, ve, _e, Ee, be) { _uniformArray.length = 0, _logArray.length = 0, ge(ye, ve, _e, _logArray), me(ye, ve, _e, _uniformArray); for (let Ae = 1; Ae < ye; Ae++)be.push(MathUtils.lerp(_uniformArray[Ae - 1], _logArray[Ae - 1], Ee)); be.push(1) } } update() { const K = this.camera, pe = this.frustums; _lightOrientationMatrix.lookAt(new Vector3, this.lightDirection, _up), _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert(); for (let me = 0; me < pe.length; me++) { const ge = this.lights[me], xe = ge.shadow.camera, ye = (xe.right - xe.left) / this.shadowMapSize, ve = (xe.top - xe.bottom) / this.shadowMapSize; _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, K.matrixWorld), pe[me].toSpace(_cameraToLightMatrix, _lightSpaceFrustum); const _e = _lightSpaceFrustum.vertices.near, Ee = _lightSpaceFrustum.vertices.far; _bbox.makeEmpty(); for (let be = 0; be < 4; be++)_bbox.expandByPoint(_e[be]), _bbox.expandByPoint(Ee[be]); _bbox.getCenter(_center), _center.z = _bbox.max.z + this.lightMargin, _center.x = Math.floor(_center.x / ye) * ye, _center.y = Math.floor(_center.y / ve) * ve, _center.applyMatrix4(_lightOrientationMatrix), ge.position.copy(_center), ge.target.position.copy(_center), ge.target.position.x += this.lightDirection.x, ge.target.position.y += this.lightDirection.y, ge.target.position.z += this.lightDirection.z } } _injectInclude() { ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin, ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin } setupMaterial(K) { K.defines = K.defines || {}, K.defines.USE_CSM = 1, K.defines.CSM_CASCADES = this.cascades, this.fade && (K.defines.CSM_FADE = ""); const pe = [], me = this, ge = this.shaders; K.onBeforeCompile = function (xe) { const ye = Math.min(me.camera.far, me.maxFar); me._getExtendedBreaks(pe), xe.uniforms.CSM_cascades = { value: pe }, xe.uniforms.cameraNear = { value: me.camera.near }, xe.uniforms.shadowFar = { value: ye }, ge.set(K, xe) }, ge.set(K, null) } _updateUniforms() { const K = Math.min(this.camera.far, this.maxFar); this.shaders.forEach(function (me, ge) { if (me !== null) { const xe = me.uniforms; this._getExtendedBreaks(xe.CSM_cascades.value), xe.cameraNear.value = this.camera.near, xe.shadowFar.value = K } !this.fade && "CSM_FADE" in ge.defines ? (delete ge.defines.CSM_FADE, ge.needsUpdate = !0) : this.fade && !("CSM_FADE" in ge.defines) && (ge.defines.CSM_FADE = "", ge.needsUpdate = !0) }, this) } _getExtendedBreaks(K) { for (; K.length < this.breaks.length;)K.push(new Vector2); K.length = this.breaks.length; for (let pe = 0; pe < this.cascades; pe++) { const me = this.breaks[pe], ge = this.breaks[pe - 1] || 0; K[pe].x = ge, K[pe].y = me } } updateFrustums() { this._getBreaks(), this._initCascades(), this._updateShadowBounds(), this._updateUniforms() } remove() { for (let K = 0; K < this.lights.length; K++)this.parent.remove(this.lights[K].target), this.parent.remove(this.lights[K]) } dispose() { const K = this.shaders; K.forEach(function (pe, me) { delete me.onBeforeCompile, delete me.defines.USE_CSM, delete me.defines.CSM_CASCADES, delete me.defines.CSM_FADE, pe !== null && (delete pe.uniforms.CSM_cascades, delete pe.uniforms.cameraNear, delete pe.uniforms.shadowFar), me.needsUpdate = !0 }), K.clear() } } let originalLightsFragmentBegin = "", originalLightsParsBegin = "", activeCSMInstances = 0; class CSMProxy { instance; args; constructor(K) { this.args = K, activeCSMInstances === 0 && (originalLightsFragmentBegin = ShaderChunk.lights_fragment_begin, originalLightsParsBegin = ShaderChunk.lights_pars_begin) } attach() { this.instance || (this.instance = new CSM(this.args), activeCSMInstances++) } dispose() { this.instance && (this.instance.remove(), this.instance.dispose(), this.instance = void 0, activeCSMInstances--, activeCSMInstances === 0 && (ShaderChunk.lights_fragment_begin = originalLightsFragmentBegin, ShaderChunk.lights_pars_begin = originalLightsParsBegin)) } } function updateMaterialsInScene(fe) { fe.traverse(K => { const pe = K; pe.isMesh && pe.material && (Array.isArray(pe.material) ? pe.material.forEach(me => { me.needsUpdate = !0 }) : pe.material.needsUpdate = !0) }) } function CsmDirectionalLight({ maxFar: fe = 30, shadowMapSize: K = 1024, lightIntensity: pe = .25, cascades: me = 3, fade: ge = !0, position: xe = [0, 0, 0], shadowBias: ye = -1e-5, lightFar: ve = 2e3, lightMargin: _e = 200, lightNear: Ee = 1e-4, mode: be = "practical", color: Ae = 16777215, castShadow: Se = !0 }) { return Se ? jsxRuntimeExports.jsx(ShadowCsmLight, { maxFar: fe, shadowMapSize: K, lightIntensity: pe / me, cascades: me, fade: ge, position: xe, shadowBias: ye, lightFar: ve, lightMargin: _e, lightNear: Ee, mode: be, color: Ae }, "csm-shadow") : jsxRuntimeExports.jsx("directionalLight", { intensity: pe, position: xe, color: Ae !== void 0 ? new Color$1(Ae) : void 0 }) } function ShadowCsmLight({ maxFar: fe, shadowMapSize: K, lightIntensity: pe, cascades: me, fade: ge, position: xe = [0, -1, 0], shadowBias: ye, lightFar: ve, lightMargin: _e, lightNear: Ee, mode: be, color: Ae }) { const Se = useThree(Oe => Oe.camera), { scene: Ce } = useThree(), we = reactExports.useMemo(() => { let Oe = Ce; for (; Oe;) { if (Oe instanceof Scene) return Oe; Oe = Oe.parent } throw new Error("Could not find scene object in r3f context!") }, [Ce]), Be = reactExports.useMemo(() => new Vector3(-xe[0], -xe[1], -xe[2]).normalize(), [xe]), De = reactExports.useRef(null), Re = reactExports.useMemo(() => new Vector3, []), Ie = reactExports.useMemo(() => new Vector3(0, 0, 0), []), Pe = reactExports.useMemo(() => new Vector3, []), Ne = reactExports.useMemo(() => new CSMProxy({ camera: Se, cascades: me, lightDirection: Be.clone(), lightFar: ve, lightIntensity: pe, lightMargin: _e, lightNear: Ee, maxFar: fe, mode: be, parent: we, shadowBias: ye, shadowMapSize: K }), [Se, we, me, Be, ve, pe, _e, Ee, fe, be, ye, K]), ke = reactExports.useMemo(() => new Color$1(Ae), [Ae]); return reactExports.useEffect(() => { Ne.instance && (Ne.instance.lights.forEach(Oe => { Oe.color = ke }), Ne.instance.fade = ge ?? !1) }, [Ne, ke, ge]), useFrame(() => { !Ne.instance || !De.current || (De.current.getWorldPosition(Re), Pe.subVectors(Ie, Re).normalize(), Ne.instance.lightDirection.copy(Pe), Ne.instance.update()) }), reactExports.useEffect(() => (updateMaterialsInScene(we), () => { requestAnimationFrame(() => { updateMaterialsInScene(we) }) }), [we]), reactExports.useEffect(() => (Ne.attach(), Ne.instance && Ne.instance.lights.forEach(Oe => { Oe.color = ke }), () => { Ne.dispose() }), [Ne, ke]), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("group", { position: xe, ref: De }) }) } const BasicMesh = React$4.forwardRef(function ({ children: K, ...pe }, me) { const ge = React$4.useMemo(() => createStandardMaterial(pe.props), [pe.props.material, pe.props.color, pe.props.wireframe, pe.props.opacity, pe.props.flat_shading, pe.props.side]), xe = React$4.useMemo(() => { const ye = new BufferGeometry; return ye.setAttribute("position", new BufferAttribute(new Float32Array(pe.props.vertices.buffer.slice(pe.props.vertices.byteOffset, pe.props.vertices.byteOffset + pe.props.vertices.byteLength)), 3)), ye.setIndex(new BufferAttribute(new Uint32Array(pe.props.faces.buffer.slice(pe.props.faces.byteOffset, pe.props.faces.byteOffset + pe.props.faces.byteLength)), 1)), ye.computeVertexNormals(), ye.computeBoundingSphere(), ye }, [pe.props.vertices.buffer, pe.props.faces.buffer]); return React$4.useEffect(() => () => { xe && xe.dispose() }, [xe]), React$4.useEffect(() => () => { ge && ge.dispose() }, [ge]), jsxRuntimeExports.jsxs("mesh", { ref: me, geometry: xe, material: ge, castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, children: [jsxRuntimeExports.jsx(OutlinesIfHovered, { alwaysMounted: !0 }), K] }) }), BoxMesh = React$4.forwardRef(function ({ children: K, ...pe }, me) { const ge = React$4.useMemo(() => createStandardMaterial(pe.props), [pe.props.material, pe.props.color, pe.props.wireframe, pe.props.opacity, pe.props.flat_shading, pe.props.side]), xe = React$4.useMemo(() => { const [ye, ve, _e] = pe.props.dimensions; return new BoxGeometry(ye, ve, _e) }, [pe.props.dimensions]); return React$4.useEffect(() => () => { xe && xe.dispose() }, [xe]), React$4.useEffect(() => () => { ge && ge.dispose() }, [ge]), jsxRuntimeExports.jsxs("mesh", { ref: me, geometry: xe, material: ge, castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, children: [jsxRuntimeExports.jsx(OutlinesIfHovered, { alwaysMounted: !0 }), K] }) }), IcosphereMesh = React$4.forwardRef(function ({ children: K, ...pe }, me) { const ge = React$4.useMemo(() => createStandardMaterial(pe.props), [pe.props.material, pe.props.color, pe.props.wireframe, pe.props.opacity, pe.props.flat_shading, pe.props.side]), xe = React$4.useMemo(() => new IcosahedronGeometry(pe.props.radius, pe.props.subdivisions), [pe.props.radius, pe.props.subdivisions]); return React$4.useEffect(() => () => { xe && xe.dispose() }, [xe]), React$4.useEffect(() => () => { ge && ge.dispose() }, [ge]), jsxRuntimeExports.jsxs("mesh", { ref: me, geometry: xe, material: ge, castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, children: [jsxRuntimeExports.jsx(OutlinesIfHovered, { alwaysMounted: !0 }), K] }) }), SkinnedMesh = React$4.forwardRef(function ({ children: K, ...pe }, me) { const ge = React$4.useContext(ViewerContext), xe = React$4.useMemo(() => createStandardMaterial(pe.props), [pe.props.material, pe.props.color, pe.props.wireframe, pe.props.opacity, pe.props.flat_shading, pe.props.side]), ye = React$4.useRef(), { geometry: ve, skeleton: _e } = React$4.useMemo(() => { const be = new BufferGeometry; be.setAttribute("position", new BufferAttribute(new Float32Array(pe.props.vertices.buffer.slice(pe.props.vertices.byteOffset, pe.props.vertices.byteOffset + pe.props.vertices.byteLength)), 3)), be.setIndex(new BufferAttribute(new Uint32Array(pe.props.faces.buffer.slice(pe.props.faces.byteOffset, pe.props.faces.byteOffset + pe.props.faces.byteLength)), 1)), be.computeVertexNormals(), be.computeBoundingSphere(); const Ae = new Float32Array(pe.props.bone_wxyzs.buffer.slice(pe.props.bone_wxyzs.byteOffset, pe.props.bone_wxyzs.byteOffset + pe.props.bone_wxyzs.byteLength)), Se = new Float32Array(pe.props.bone_positions.buffer.slice(pe.props.bone_positions.byteOffset, pe.props.bone_positions.byteOffset + pe.props.bone_positions.byteLength)), Ce = []; ye.current = Ce; for (let Re = 0; Re < Se.length / 3; Re++)Ce.push(new Bone); const we = [], Be = new Quaternion; Ce.forEach((Re, Ie) => { Be.set(Ae[Ie * 4 + 1], Ae[Ie * 4 + 2], Ae[Ie * 4 + 3], Ae[Ie * 4 + 0]); const Pe = new Matrix4; Pe.makeRotationFromQuaternion(Be), Pe.setPosition(Se[Ie * 3 + 0], Se[Ie * 3 + 1], Se[Ie * 3 + 2]), Pe.invert(), we.push(Pe), Re.setRotationFromQuaternion(Be), Re.position.set(Se[Ie * 3 + 0], Se[Ie * 3 + 1], Se[Ie * 3 + 2]) }); const De = new Skeleton(Ce, we); return be.setAttribute("skinIndex", new BufferAttribute(new Uint16Array(pe.props.skin_indices.buffer.slice(pe.props.skin_indices.byteOffset, pe.props.skin_indices.byteOffset + pe.props.skin_indices.byteLength)), 4)), be.setAttribute("skinWeight", new BufferAttribute(new Float32Array(pe.props.skin_weights.buffer.slice(pe.props.skin_weights.byteOffset, pe.props.skin_weights.byteOffset + pe.props.skin_weights.byteLength)), 4)), De.init(), { geometry: be, skeleton: De } }, [pe.props.vertices.buffer, pe.props.faces.buffer, pe.props.skin_indices.buffer, pe.props.skin_weights?.buffer, pe.props.bone_wxyzs.buffer, pe.props.bone_positions.buffer]), Ee = ge.mutable.current; return React$4.useEffect(() => { const be = Ee.skinnedMeshState[pe.name]; return be.initialized = !1, () => { _e && _e.dispose(), ve && ve.dispose() } }, [_e, ve, pe.name, Ee.skinnedMeshState]), React$4.useEffect(() => () => { xe && xe.dispose() }, [xe]), useFrame(() => { const be = Ee.nodeRefFromName[pe.name]; if (be === void 0) return; const Ae = Ee.skinnedMeshState[pe.name], Se = ye.current; _e !== void 0 && Se !== void 0 && (Ae.initialized || (Se.forEach(Ce => { be.add(Ce) }), Ae.initialized = !0), Se.forEach((Ce, we) => { const Be = Ae.poses[we].wxyz, De = Ae.poses[we].position; Ce.quaternion.set(Be[1], Be[2], Be[3], Be[0]), Ce.position.set(De[0], De[1], De[2]) })) }), jsxRuntimeExports.jsxs("skinnedMesh", { ref: me, geometry: ve, material: xe, skeleton: _e, castShadow: pe.props.cast_shadow, receiveShadow: pe.props.receive_shadow, frustumCulled: !1, children: [jsxRuntimeExports.jsx(OutlinesIfHovered, { alwaysMounted: !0 }), K] }) }); function E(fe, K, pe) { pe[0] = fe[0] > K[0] ? K[0] : fe[0], pe[1] = fe[1] < K[1] ? K[1] : fe[1], pe[2] = fe[2] > K[2] ? K[2] : fe[2], pe[3] = fe[3] < K[3] ? K[3] : fe[3], pe[4] = fe[4] > K[4] ? K[4] : fe[4], pe[5] = fe[5] < K[5] ? K[5] : fe[5] } function Z$1(fe, K, pe) { let me = !1; const ge = fe[0] > K[0] ? K[0] : fe[0], xe = fe[1] < K[1] ? K[1] : fe[1], ye = fe[2] > K[2] ? K[2] : fe[2], ve = fe[3] < K[3] ? K[3] : fe[3], _e = fe[4] > K[4] ? K[4] : fe[4], Ee = fe[5] < K[5] ? K[5] : fe[5]; return pe[0] > ge && (pe[0] = ge, me = !0), pe[1] < xe && (pe[1] = xe, me = !0), pe[2] > ye && (pe[2] = ye, me = !0), pe[3] < ve && (pe[3] = ve, me = !0), pe[4] > _e && (pe[4] = _e, me = !0), pe[5] < Ee && (pe[5] = Ee, me = !0), me } function g$1(fe, K) { return !(K[0] > fe[0] || K[1] < fe[1] || K[2] > fe[2] || K[3] < fe[3] || K[4] > fe[4] || K[5] < fe[5]) } function v$1(fe, K) { let pe = !1; return K[0] > fe[0] && (K[0] = fe[0], pe = !0), K[1] < fe[1] && (K[1] = fe[1], pe = !0), K[2] > fe[2] && (K[2] = fe[2], pe = !0), K[3] < fe[3] && (K[3] = fe[3], pe = !0), K[4] > fe[4] && (K[4] = fe[4], pe = !0), K[5] < fe[5] && (K[5] = fe[5], pe = !0), pe } function w$2(fe, K) { fe[0] -= K, fe[1] += K, fe[2] -= K, fe[3] += K, fe[4] -= K, fe[5] += K } function S$2(fe) { const K = fe[1] - fe[0], pe = fe[3] - fe[2], me = fe[5] - fe[4]; return 2 * (K * pe + pe * me + me * K) } function _$1(fe, K) { const pe = fe[0] > K[0] ? K[0] : fe[0], me = fe[1] < K[1] ? K[1] : fe[1], ge = fe[2] > K[2] ? K[2] : fe[2], xe = fe[3] < K[3] ? K[3] : fe[3], ye = fe[4] > K[4] ? K[4] : fe[4], ve = fe[5] < K[5] ? K[5] : fe[5], _e = me - pe, Ee = xe - ge, be = ve - ye; return 2 * (_e * Ee + Ee * be + be * _e) } function H$1(fe) { const K = fe[1] - fe[0], pe = fe[3] - fe[2], me = fe[5] - fe[4]; return K > pe ? K > me ? 0 : 2 : pe > me ? 1 : 2 } function D$1(fe, K) { const pe = fe[0] - K[0], me = K[0] - fe[1]; let ge = pe > me ? pe : me; ge < 0 && (ge = 0); const xe = fe[2] - K[1], ye = K[1] - fe[3]; let ve = xe > ye ? xe : ye; ve < 0 && (ve = 0); const _e = fe[4] - K[2], Ee = K[2] - fe[5]; let be = _e > Ee ? _e : Ee; return be < 0 && (be = 0), ge * ge + ve * ve + be * be } function Y$1(fe, K) { let pe, me, ge, xe, ye, ve; const _e = fe[0] - K[0], Ee = K[0] - fe[1]; _e > Ee ? (pe = _e, me = Ee) : (pe = Ee, me = _e), pe < 0 && (pe = 0); const be = fe[2] - K[1], Ae = K[1] - fe[3]; be > Ae ? (ge = be, xe = Ae) : (ge = Ae, xe = be), ge < 0 && (ge = 0); const Se = fe[4] - K[2], Ce = K[2] - fe[5]; return Se > Ce ? (ye = Se, ve = Ce) : (ye = Ce, ve = Se), ye < 0 && (ye = 0), { min: pe * pe + ge * ge + ye * ye, max: me * me + xe * xe + ve * ve } } let G$1 = class { constructor() { this.array = [] } clear() { this.array = [] } push(K) { const pe = this.array, me = K.inheritedCost, ge = pe.length > 6 ? pe.length - 6 : 0; let xe; for (xe = pe.length - 1; xe >= ge && !(me <= pe[xe].inheritedCost); xe--); xe > pe.length - 7 && pe.splice(xe + 1, 0, K) } pop() { return this.array.pop() } }, $$1 = class { constructor(K = !1) { this.root = null, this._sortedList = new G$1, this.count = 0, this.highPrecision = K, this._typeArray = K ? Float64Array : Float32Array } createFromArray(K, pe, me, ge = 0) { const xe = pe.length, ye = this._typeArray; ye !== (pe[0].BYTES_PER_ELEMENT === 4 ? Float32Array : Float64Array) && console.warn("Different precision."); const ve = new ye(6); let _e, Ee; this.root = be(0, xe, null); function be(we, Be, De) { if (Be === 1) { const Ne = pe[we]; ge > 0 && w$2(Ne, ge); const ke = { box: Ne, object: K[we], parent: De }; return me && me(ke), ke } const Re = Ae(we, Be); Se(); let Ie = Ce(we, Be); (Ie === we || Ie === we + Be) && (Ie = we + (Be >> 1)); const Pe = { box: Re, parent: De }; return Pe.left = be(we, Ie - we, Pe), Pe.right = be(Ie, Be - Ie + we, Pe), Pe } function Ae(we, Be) { const De = new ye(6), Re = we + Be; De[0] = 1 / 0, De[1] = -1 / 0, De[2] = 1 / 0, De[3] = -1 / 0, De[4] = 1 / 0, De[5] = -1 / 0, ve[0] = 1 / 0, ve[1] = -1 / 0, ve[2] = 1 / 0, ve[3] = -1 / 0, ve[4] = 1 / 0, ve[5] = -1 / 0; for (let Ie = we; Ie < Re; Ie++) { const Pe = pe[Ie], Ne = Pe[0], ke = Pe[1], Oe = Pe[2], Ue = Pe[3], He = Pe[4], Ge = Pe[5]; De[0] > Ne && (De[0] = Ne), De[1] < ke && (De[1] = ke), De[2] > Oe && (De[2] = Oe), De[3] < Ue && (De[3] = Ue), De[4] > He && (De[4] = He), De[5] < Ge && (De[5] = Ge); const ze = (ke + Ne) * .5, We = (Ue + Oe) * .5, Xe = (Ge + He) * .5; ve[0] > ze && (ve[0] = ze), ve[1] < ze && (ve[1] = ze), ve[2] > We && (ve[2] = We), ve[3] < We && (ve[3] = We), ve[4] > Xe && (ve[4] = Xe), ve[5] < Xe && (ve[5] = Xe) } return De[0] -= ge, De[1] += ge, De[2] -= ge, De[3] += ge, De[4] -= ge, De[5] += ge, De } function Se() { _e = H$1(ve) * 2, Ee = (ve[_e] + ve[_e + 1]) * .5 } function Ce(we, Be) { let De = we, Re = we + Be - 1; for (; De <= Re;) { const Ie = pe[De]; if ((Ie[_e + 1] + Ie[_e]) * .5 >= Ee) for (; ;) { const Pe = pe[Re]; if ((Pe[_e + 1] + Pe[_e]) * .5 < Ee) { const Ne = K[De]; K[De] = K[Re], K[Re] = Ne; const ke = pe[De]; pe[De] = pe[Re], pe[Re] = ke, Re--; break } if (Re--, Re <= De) return De } De++ } return De } } insert(K, pe, me) { me > 0 && w$2(pe, me); const ge = this.createLeafNode(K, pe); return this.root === null ? this.root = ge : this.insertLeaf(ge), this.count++, ge } insertRange(K, pe, me, ge) { console.warn("Method not optimized yet. It just calls 'insert' N times."); const xe = K.length, ye = me > 0 ? me : me ? null : 0; for (let ve = 0; ve < xe; ve++) { const _e = this.insert(K[ve], pe[ve], ye ?? me[ve]); ge && ge(_e) } } move(K, pe) { if (!K.parent || g$1(K.box, K.parent.box)) { pe > 0 && w$2(K.box, pe); return } pe > 0 && w$2(K.box, pe); const me = this.delete(K); this.insertLeaf(K, me), this.count++ } delete(K) { const pe = K.parent; if (pe === null) return this.root = null, null; const me = pe.parent, ge = pe.left === K ? pe.right : pe.left; return ge.parent = me, K.parent = null, me === null ? (this.root = ge, pe) : (me.left === pe ? me.left = ge : me.right = ge, this.refit(me), this.count--, pe) } clear() { this.root = null } insertLeaf(K, pe) { const me = this.findBestSibling(K.box), ge = me.parent; pe === void 0 ? pe = this.createInternalNode(ge, me, K) : (pe.parent = ge, pe.left = me, pe.right = K), me.parent = pe, K.parent = pe, ge === null ? this.root = pe : ge.left === me ? ge.left = pe : ge.right = pe, this.refitAndRotate(K, me) } createLeafNode(K, pe) { return { box: pe, object: K, parent: null } } createInternalNode(K, pe, me) { return { parent: K, left: pe, right: me, box: new this._typeArray(6) } } findBestSibling(K) { const pe = this.root; let me = pe, ge = _$1(K, pe.box); const xe = S$2(K); if (pe.object !== void 0) return pe; const ye = this._sortedList; ye.clear(); let ve = { node: pe, inheritedCost: ge - S$2(pe.box) }; do { const { node: _e, inheritedCost: Ee } = ve; if (xe + Ee >= ge) break; const be = _e.left, Ae = _e.right, Se = _$1(K, be.box) + Ee, Ce = Se - S$2(be.box), we = _$1(K, Ae.box) + Ee, Be = we - S$2(Ae.box); if (Se > we ? ge > we && (me = Ae, ge = we) : ge > Se && (me = be, ge = Se), Be > Ce) { if (xe + Ce >= ge || (be.object === void 0 && ye.push({ node: be, inheritedCost: Ce }), xe + Be >= ge)) continue; Ae.object === void 0 && ye.push({ node: Ae, inheritedCost: Be }) } else { if (xe + Be >= ge || (Ae.object === void 0 && ye.push({ node: Ae, inheritedCost: Be }), xe + Ce >= ge)) continue; be.object === void 0 && ye.push({ node: be, inheritedCost: Ce }) } } while (ve = ye.pop()); return me } refit(K) { for (E(K.left.box, K.right.box, K.box); K = K.parent;)if (!Z$1(K.left.box, K.right.box, K.box)) return } refitAndRotate(K, pe) { const me = K.box; K = K.parent; const ge = K.box; for (E(me, pe.box, ge); K = K.parent;) { const xe = K.box; if (!v$1(me, xe)) return; const ye = K.left, ve = K.right, _e = ye.box, Ee = ve.box; let be = null, Ae = null, Se = 0; if (ve.object === void 0) { const Ce = ve.left, we = ve.right, Be = S$2(ve.box), De = Be - _$1(_e, Ce.box), Re = Be - _$1(_e, we.box); De > Re ? De > 0 && (be = ye, Ae = we, Se = De) : Re > 0 && (be = ye, Ae = Ce, Se = Re) } if (ye.object === void 0) { const Ce = ye.left, we = ye.right, Be = S$2(ye.box), De = Be - _$1(Ee, Ce.box), Re = Be - _$1(Ee, we.box); De > Re ? De > Se && (be = ve, Ae = we) : Re > Se && (be = ve, Ae = Ce) } be !== null && this.swap(be, Ae) } } swap(K, pe) { const me = K.parent, ge = pe.parent, xe = ge.box; me.left === K ? me.left = pe : me.right = pe, ge.left === pe ? ge.left = K : ge.right = K, K.parent = ge, pe.parent = me, E(ge.left.box, ge.right.box, xe) } }; const X$2 = 0, U$1 = 1; let V$1 = class { constructor(K, pe) { this.coordinateSystem = pe, this.array = K ? new Float64Array(24) : new Float32Array(24) } setFromProjectionMatrix(K) { if (this.updatePlane(0, K[3] + K[0], K[7] + K[4], K[11] + K[8], K[15] + K[12]), this.updatePlane(1, K[3] - K[0], K[7] - K[4], K[11] - K[8], K[15] - K[12]), this.updatePlane(2, K[3] - K[1], K[7] - K[5], K[11] - K[9], K[15] - K[13]), this.updatePlane(3, K[3] + K[1], K[7] + K[5], K[11] + K[9], K[15] + K[13]), this.updatePlane(4, K[3] - K[2], K[7] - K[6], K[11] - K[10], K[15] - K[14]), this.coordinateSystem === X$2) this.updatePlane(5, K[3] + K[2], K[7] + K[6], K[11] + K[10], K[15] + K[14]); else if (this.coordinateSystem === U$1) this.updatePlane(5, K[2], K[6], K[10], K[14]); else throw new Error("Invalid coordinate system: " + this.coordinateSystem); return this } updatePlane(K, pe, me, ge, xe) { const ye = this.array, ve = K * 4, _e = Math.sqrt(pe * pe + me * me + ge * ge); ye[ve + 0] = pe / _e, ye[ve + 1] = me / _e, ye[ve + 2] = ge / _e, ye[ve + 3] = xe / _e } intersectsBoxMask(K, pe) { const me = this.array; let ge, xe, ye, ve, _e, Ee; for (let be = 0; be < 6; be++) { if (!(pe & 32 >> be)) continue; const Ae = be * 4, Se = me[Ae + 0], Ce = me[Ae + 1], we = me[Ae + 2], Be = me[Ae + 3]; if (Se > 0 ? (ge = K[1], ve = K[0]) : (ge = K[0], ve = K[1]), Ce > 0 ? (xe = K[3], _e = K[2]) : (xe = K[2], _e = K[3]), we > 0 ? (ye = K[5], Ee = K[4]) : (ye = K[4], Ee = K[5]), Se * ge + Ce * xe + we * ye < -Be) return -1; Se * ve + Ce * _e + we * Ee > -Be && (pe ^= 32 >> be) } return pe } isIntersected(K, pe) { const me = this.array; for (let ge = 0; ge < 6; ge++) { if (!(pe & 32 >> ge)) continue; const xe = ge * 4, ye = me[xe + 0], ve = me[xe + 1], _e = me[xe + 2], Ee = me[xe + 3], be = ye > 0 ? K[1] : K[0], Ae = ve > 0 ? K[3] : K[2], Se = _e > 0 ? K[5] : K[4]; if (ye * be + ve * Ae + _e * Se < -Ee) return !1 } return !0 } isIntersectedMargin(K, pe, me) { if (pe === 0) return !0; const ge = this.array; for (let xe = 0; xe < 6; xe++) { if (!(pe & 32 >> xe)) continue; const ye = xe * 4, ve = ge[ye + 0], _e = ge[ye + 1], Ee = ge[ye + 2], be = ge[ye + 3], Ae = ve > 0 ? K[1] - me : K[0] + me, Se = _e > 0 ? K[3] - me : K[2] + me, Ce = Ee > 0 ? K[5] - me : K[4] + me; if (ve * Ae + _e * Se + Ee * Ce < -be) return !1 } return !0 } }; function q$1(fe, K, pe, me, ge, xe) { let ye = me[0], ve = K[0], _e = pe[0], Ee = (fe[ye] - ve) * _e, be = (fe[ye ^ 1] - ve) * _e, Ae = Ee > 0 ? Ee : 0, Se = be < 1 / 0 ? be : 1 / 0; return ye = me[1], ve = K[1], _e = pe[1], Ee = (fe[ye + 2] - ve) * _e, Ee > Se || (be = (fe[ye ^ 3] - ve) * _e, Ae > be) || (Ae = Ee > Ae ? Ee : Ae, Se = be < Se ? be : Se, ye = me[2], ve = K[2], _e = pe[2], Ee = (fe[ye + 4] - ve) * _e, Ee > Se) || (be = (fe[ye ^ 5] - ve) * _e, Ae > be) ? !1 : (Ae = Ee > Ae ? Ee : Ae, Se = be < Se ? be : Se, Ae <= xe && Se >= ge) } function O$1(fe, K) { return fe[1] >= K[0] && K[1] >= fe[0] && fe[3] >= K[2] && K[3] >= fe[2] && fe[5] >= K[4] && K[5] >= fe[4] } function W$1(fe, K, pe) { return D$1(pe, fe) <= K * K } class k { constructor(K, pe = X$2) { this._sign = new Uint8Array(3), this.builder = K; const me = K.highPrecision; this.frustum = new V$1(me, pe), this._dirInv = me ? new Float64Array(3) : new Float32Array(3) } get root() { return this.builder.root } createFromArray(K, pe, me, ge) { K?.length > 0 && this.builder.createFromArray(K, pe, me, ge) } insert(K, pe, me) { return this.builder.insert(K, pe, me) } insertRange(K, pe, me, ge) { K?.length > 0 && this.builder.insertRange(K, pe, me, ge) } move(K, pe) { this.builder.move(K, pe) } delete(K) { return this.builder.delete(K) } clear() { this.builder.clear() } traverse(K) { if (this.root === null) return; pe(this.root, 0); function pe(me, ge) { if (me.object !== void 0) { K(me, ge); return } K(me, ge) || (pe(me.left, ge + 1), pe(me.right, ge + 1)) } } intersectsRay(K, pe, me, ge = 0, xe = 1 / 0) { if (this.root === null) return !1; const ye = this._dirInv, ve = this._sign; return ye[0] = 1 / K[0], ye[1] = 1 / K[1], ye[2] = 1 / K[2], ve[0] = ye[0] < 0 ? 1 : 0, ve[1] = ye[1] < 0 ? 1 : 0, ve[2] = ye[2] < 0 ? 1 : 0, _e(this.root); function _e(Ee) { return q$1(Ee.box, pe, ye, ve, ge, xe) ? Ee.object !== void 0 ? me(Ee.object) : _e(Ee.left) || _e(Ee.right) : !1 } } intersectsBox(K, pe) { if (this.root === null) return !1; return me(this.root); function me(ge) { return O$1(K, ge.box) ? ge.object !== void 0 ? pe(ge.object) : me(ge.left) || me(ge.right) : !1 } } intersectsSphere(K, pe, me) { if (this.root === null) return !1; return ge(this.root); function ge(xe) { return W$1(K, pe, xe.box) ? xe.object !== void 0 ? me(xe.object) : ge(xe.left) || ge(xe.right) : !1 } } isNodeIntersected(K, pe) { const me = K.box; let ge; for (; ge = K.parent;) { const ye = ge.left === K ? ge.right : ge.left; if (xe(ye)) return !0; K = ge } return !1; function xe(ye) { return O$1(me, ye.box) ? ye.object !== void 0 ? pe(ye.object) : xe(ye.left) || xe(ye.right) : !1 } } rayIntersections(K, pe, me, ge = 0, xe = 1 / 0) { if (this.root === null) return; const ye = this._dirInv, ve = this._sign; ye[0] = 1 / K[0], ye[1] = 1 / K[1], ye[2] = 1 / K[2], ve[0] = ye[0] < 0 ? 1 : 0, ve[1] = ye[1] < 0 ? 1 : 0, ve[2] = ye[2] < 0 ? 1 : 0, _e(this.root); function _e(Ee) { if (q$1(Ee.box, pe, ye, ve, ge, xe)) { if (Ee.object !== void 0) { me(Ee.object); return } _e(Ee.left), _e(Ee.right) } } } frustumCulling(K, pe) { if (this.root === null) return; const me = this.frustum.setFromProjectionMatrix(K); ge(this.root, 63); function ge(ye, ve) { if (ye.object !== void 0) { me.isIntersected(ye.box, ve) && pe(ye, me, ve); return } if (ve = me.intersectsBoxMask(ye.box, ve), !(ve < 0)) { if (ve === 0) { xe(ye.left), xe(ye.right); return } ge(ye.left, ve), ge(ye.right, ve) } } function xe(ye) { if (ye.object !== void 0) { pe(ye, me, 0); return } xe(ye.left), xe(ye.right) } } frustumCullingLOD(K, pe, me, ge) { if (this.root === null) return; const xe = this.frustum.setFromProjectionMatrix(K); ye(this.root, 63, null); function ye(Ee, be, Ae) { const Se = Ee.box; if (Ae === null && (Ae = _e(Se)), Ee.object !== void 0) { xe.isIntersected(Se, be) && ge(Ee, Ae, xe, be); return } if (be = xe.intersectsBoxMask(Se, be), !(be < 0)) { if (be === 0) { ve(Ee.left, Ae), ve(Ee.right, Ae); return } ye(Ee.left, be, Ae), ye(Ee.right, be, Ae) } } function ve(Ee, be) { if (be === null && (be = _e(Ee.box)), Ee.object !== void 0) { ge(Ee, be, xe, 0); return } ve(Ee.left, be), ve(Ee.right, be) } function _e(Ee) { const { min: be, max: Ae } = Y$1(Ee, pe); for (let Se = me.length - 1; Se > 0; Se--)if (Ae >= me[Se]) return be >= me[Se] ? Se : null; return 0 } } closestPointToPoint(K, pe) { if (this.root === null) return; let me = 1 / 0; return ge(this.root), Math.sqrt(me); function ge(xe) { if (xe.object !== void 0) { if (pe) { const _e = pe(xe.object) ?? D$1(xe.box, K); _e < me && (me = _e) } else me = D$1(xe.box, K); return } const ye = D$1(xe.left.box, K), ve = D$1(xe.right.box, K); ye < ve ? ye < me && (ge(xe.left), ve < me && ge(xe.right)) : ve < me && (ge(xe.right), ye < me && ge(xe.left)) } } } function m$1(fe, K) { return K[0] = fe.x, K[1] = fe.y, K[2] = fe.z, K } function B$1(fe, K) { const pe = fe.min, me = fe.max; return K[0] = pe.x, K[1] = me.x, K[2] = pe.y, K[3] = me.y, K[4] = pe.z, K[5] = me.z, K } class St { constructor(K, pe, me) { if (this.isInstanceEntity = !0, this.position = new Vector3, this.scale = new Vector3(1, 1, 1), this.quaternion = new Quaternion, this.id = pe, this.owner = K, me) { const ge = this.quaternion, xe = this.rotation = new Euler; xe._onChange(() => ge.setFromEuler(xe, !1)), ge._onChange(() => xe.setFromQuaternion(ge, void 0, !1)) } } get visible() { return this.owner.getVisibilityAt(this.id) } set visible(K) { this.owner.setVisibilityAt(this.id, K) } get active() { return this.owner.getActiveAt(this.id) } set active(K) { this.owner.setActiveAt(this.id, K) } get color() { return this.owner.getColorAt(this.id) } set color(K) { this.owner.setColorAt(this.id, K) } get opacity() { return this.owner.getOpacityAt(this.id) } set opacity(K) { this.owner.setOpacityAt(this.id, K) } get morph() { return this.owner.getMorphAt(this.id) } set morph(K) { this.owner.setMorphAt(this.id, K) } get matrix() { return this.owner.getMatrixAt(this.id) } get matrixWorld() { return this.matrix.premultiply(this.owner.matrixWorld) } setMatrixIdentity() { var K; const pe = this.owner, me = pe.matricesTexture._data, ge = this.id, xe = ge * 16; me[xe + 0] = 1, me[xe + 1] = 0, me[xe + 2] = 0, me[xe + 3] = 0, me[xe + 4] = 0, me[xe + 5] = 1, me[xe + 6] = 0, me[xe + 7] = 0, me[xe + 8] = 0, me[xe + 9] = 0, me[xe + 10] = 1, me[xe + 11] = 0, me[xe + 12] = 0, me[xe + 13] = 0, me[xe + 14] = 0, me[xe + 15] = 1, pe.matricesTexture.enqueueUpdate(ge), (K = pe.bvh) == null || K.move(ge) } updateMatrix() { var K; const pe = this.owner, me = this.position, ge = this.quaternion, xe = this.scale, ye = pe.matricesTexture._data, ve = this.id, _e = ve * 16, Ee = ge._x, be = ge._y, Ae = ge._z, Se = ge._w, Ce = Ee + Ee, we = be + be, Be = Ae + Ae, De = Ee * Ce, Re = Ee * we, Ie = Ee * Be, Pe = be * we, Ne = be * Be, ke = Ae * Be, Oe = Se * Ce, Ue = Se * we, He = Se * Be, Ge = xe.x, ze = xe.y, We = xe.z; ye[_e + 0] = (1 - (Pe + ke)) * Ge, ye[_e + 1] = (Re + He) * Ge, ye[_e + 2] = (Ie - Ue) * Ge, ye[_e + 3] = 0, ye[_e + 4] = (Re - He) * ze, ye[_e + 5] = (1 - (De + ke)) * ze, ye[_e + 6] = (Ne + Oe) * ze, ye[_e + 7] = 0, ye[_e + 8] = (Ie + Ue) * We, ye[_e + 9] = (Ne - Oe) * We, ye[_e + 10] = (1 - (De + Pe)) * We, ye[_e + 11] = 0, ye[_e + 12] = me.x, ye[_e + 13] = me.y, ye[_e + 14] = me.z, ye[_e + 15] = 1, pe.matricesTexture.enqueueUpdate(ve), (K = pe.bvh) == null || K.move(ve) } updateMatrixPosition() { var K; const pe = this.owner, me = this.position, ge = pe.matricesTexture._data, xe = this.id, ye = xe * 16; ge[ye + 12] = me.x, ge[ye + 13] = me.y, ge[ye + 14] = me.z, pe.matricesTexture.enqueueUpdate(xe), (K = pe.bvh) == null || K.move(xe) } getUniform(K, pe) { return this.owner.getUniformAt(this.id, K, pe) } updateBones(K = !0, pe) { this.owner.setBonesAt(this.id, K, pe) } setUniform(K, pe) { this.owner.setUniformAt(this.id, K, pe) } copyTo(K) { K.position.copy(this.position), K.scale.copy(this.scale), K.quaternion.copy(this.quaternion), this.rotation && K.rotation.copy(this.rotation) } applyMatrix4(K) { return this.matrix.premultiply(K).decompose(this.position, this.quaternion, this.scale), this } applyQuaternion(K) { return this.quaternion.premultiply(K), this } rotateOnAxis(K, pe) { return X$1.setFromAxisAngle(K, pe), this.quaternion.multiply(X$1), this } rotateOnWorldAxis(K, pe) { return X$1.setFromAxisAngle(K, pe), this.quaternion.premultiply(X$1), this } rotateX(K) { return this.rotateOnAxis(xt, K) } rotateY(K) { return this.rotateOnAxis(mt, K) } rotateZ(K) { return this.rotateOnAxis(_t, K) } translateOnAxis(K, pe) { return pt.copy(K).applyQuaternion(this.quaternion), this.position.add(pt.multiplyScalar(pe)), this } translateX(K) { return this.translateOnAxis(xt, K) } translateY(K) { return this.translateOnAxis(mt, K) } translateZ(K) { return this.translateOnAxis(_t, K) } remove() { return this.owner.removeInstances(this.id), this } } const X$1 = new Quaternion, pt = new Vector3, xt = new Vector3(1, 0, 0), mt = new Vector3(0, 1, 0), _t = new Vector3(0, 0, 1); class Zt { constructor(K, pe = 0, me = !1, ge = !0) { this.nodesMap = new Map, this.LODsMap = new Map, this._geoBoundingSphere = null, this._sphereTarget = null, this.target = K, this.accurateCulling = ge, this._margin = pe; const xe = K._geometry; if (xe.boundingBox || xe.computeBoundingBox(), this.geoBoundingBox = xe.boundingBox, me) { xe.boundingSphere || xe.computeBoundingSphere(); const ye = xe.boundingSphere.center; ye.x === 0 && ye.y === 0 && ye.z === 0 ? (this._geoBoundingSphere = xe.boundingSphere, this._sphereTarget = { centerX: 0, centerY: 0, centerZ: 0, maxScale: 0 }) : (console.warn('"getBoxFromSphere" is ignored because geometry is not centered.'), me = !1) } this.bvh = new k(new $$1, X$2), this._origin = new Float32Array(3), this._dir = new Float32Array(3), this._cameraPos = new Float32Array(3), this._getBoxFromSphere = me } create() { const K = this.target._instancesCount, pe = this.target._instancesArrayCount, me = new Array(K), ge = new Uint32Array(K); let xe = 0; this.clear(); for (let ye = 0; ye < pe; ye++)this.target.getActiveAt(ye) && (me[xe] = this.getBox(ye, new Float32Array(6)), ge[xe] = ye, xe++); this.bvh.createFromArray(ge, me, ye => { this.nodesMap.set(ye.object, ye) }, this._margin) } insert(K) { const pe = this.bvh.insert(K, this.getBox(K, new Float32Array(6)), this._margin); this.nodesMap.set(K, pe) } insertRange(K) { const pe = K.length, me = new Array(pe); for (let ge = 0; ge < pe; ge++)me[ge] = this.getBox(K[ge], new Float32Array(6)); this.bvh.insertRange(K, me, this._margin, ge => { this.nodesMap.set(ge.object, ge) }) } move(K) { const pe = this.nodesMap.get(K); pe && (this.getBox(K, pe.box), this.bvh.move(pe, this._margin)) } delete(K) { const pe = this.nodesMap.get(K); pe && (this.bvh.delete(pe), this.nodesMap.delete(K)) } clear() { this.bvh.clear(), this.nodesMap = new Map } frustumCulling(K, pe) { this._margin > 0 && this.accurateCulling ? this.bvh.frustumCulling(K.elements, (me, ge, xe) => { ge.isIntersectedMargin(me.box, xe, this._margin) && pe(me) }) : this.bvh.frustumCulling(K.elements, pe) } frustumCullingLOD(K, pe, me, ge) { this.LODsMap.has(me) || this.LODsMap.set(me, new Float32Array(me.length)); const xe = this.LODsMap.get(me); for (let ve = 0; ve < me.length; ve++)xe[ve] = me[ve].distance; const ye = this._cameraPos; ye[0] = pe.x, ye[1] = pe.y, ye[2] = pe.z, this._margin > 0 && this.accurateCulling ? this.bvh.frustumCullingLOD(K.elements, ye, xe, (ve, _e, Ee, be) => { Ee.isIntersectedMargin(ve.box, be, this._margin) && ge(ve, _e) }) : this.bvh.frustumCullingLOD(K.elements, ye, xe, ge) } raycast(K, pe) { const me = K.ray, ge = this._origin, xe = this._dir; m$1(me.origin, ge), m$1(me.direction, xe), this.bvh.rayIntersections(xe, ge, pe, K.near, K.far) } intersectBox(K, pe) { this._boxArray || (this._boxArray = new Float32Array(6)); const me = this._boxArray; return B$1(K, me), this.bvh.intersectsBox(me, pe) } getBox(K, pe) { if (this._getBoxFromSphere) { const me = this.target.matricesTexture._data, { centerX: ge, centerY: xe, centerZ: ye, maxScale: ve } = this.getSphereFromMatrix_centeredGeometry(K, me, this._sphereTarget), _e = this._geoBoundingSphere.radius * ve; pe[0] = ge - _e, pe[1] = ge + _e, pe[2] = xe - _e, pe[3] = xe + _e, pe[4] = ye - _e, pe[5] = ye + _e } else yt.copy(this.geoBoundingBox).applyMatrix4(this.target.getMatrixAt(K)), B$1(yt, pe); return pe } getSphereFromMatrix_centeredGeometry(K, pe, me) { const ge = K * 16, xe = pe[ge + 0], ye = pe[ge + 1], ve = pe[ge + 2], _e = pe[ge + 4], Ee = pe[ge + 5], be = pe[ge + 6], Ae = pe[ge + 8], Se = pe[ge + 9], Ce = pe[ge + 10], we = xe * xe + ye * ye + ve * ve, Be = _e * _e + Ee * Ee + be * be, De = Ae * Ae + Se * Se + Ce * Ce; return me.maxScale = Math.sqrt(Math.max(we, Be, De)), me.centerX = pe[ge + 12], me.centerY = pe[ge + 13], me.centerZ = pe[ge + 14], me } } const yt = new Box3; class Qt extends GLBufferAttribute { constructor(K, pe, me, ge, xe, ye = 1) { const ve = K.createBuffer(); super(ve, pe, me, ge, xe.length / me), this.isGLInstancedBufferAttribute = !0, this._needsUpdate = !1, this.isInstancedBufferAttribute = !0, this.meshPerAttribute = ye, this.array = xe, this._cacheArray = xe, K.bindBuffer(K.ARRAY_BUFFER, ve), K.bufferData(K.ARRAY_BUFFER, xe, K.DYNAMIC_DRAW) } update(K, pe) { if (!this._needsUpdate || pe === 0) return; const me = K.getContext(); me.bindBuffer(me.ARRAY_BUFFER, this.buffer), this.array === this._cacheArray ? me.bufferSubData(me.ARRAY_BUFFER, 0, this.array, 0, pe) : (me.bufferData(me.ARRAY_BUFFER, this.array, me.DYNAMIC_DRAW), this._cacheArray = this.array), this._needsUpdate = !1 } clone() { return this } } function Mt(fe, K) { return Math.max(K, Math.ceil(Math.sqrt(fe / K)) * K) } function Jt(fe, K, pe, me) { K === 3 && (console.warn('"channels" cannot be 3. Set to 4. More info: https://github.com/mrdoob/three.js/pull/23228'), K = 4); const ge = Mt(me, pe), xe = new fe(ge * ge * K), ye = fe.name.includes("Float"), ve = fe.name.includes("Uint"), _e = ye ? FloatType : ve ? UnsignedIntType : IntType; let Ee; switch (K) { case 1: Ee = ye ? RedFormat : RedIntegerFormat; break; case 2: Ee = ye ? RGFormat : RGIntegerFormat; break; case 4: Ee = ye ? RGBAFormat : RGBAIntegerFormat; break }return { array: xe, size: ge, type: _e, format: Ee } } let Q$1 = class extends DataTexture {
	constructor(K, pe, me, ge, xe, ye) { pe === 3 && (pe = 4); const { array: ve, format: _e, size: Ee, type: be } = Jt(K, pe, me, ge); super(ve, Ee, Ee, _e, be), this.partialUpdate = !0, this.maxUpdateCalls = 1 / 0, this._utils = null, this._needsUpdate = !1, this._lastWidth = null, this._data = ve, this._channels = pe, this._pixelsPerInstance = me, this._stride = me * pe, this._rowToUpdate = new Array(Ee), this._uniformMap = xe, this._fetchUniformsInFragmentShader = ye, this.needsUpdate = !0 } resize(K) { const pe = Mt(K, this._pixelsPerInstance); if (pe === this.image.width) return; const me = this._data, ge = this._channels; this._rowToUpdate.length = pe; const xe = me.constructor, ye = new xe(pe * pe * ge), ve = Math.min(me.length, ye.length); ye.set(new xe(me.buffer, 0, ve)), this.dispose(), this.image = { data: ye, height: pe, width: pe }, this._data = ye } enqueueUpdate(K) { if (this._needsUpdate = !0, !this.partialUpdate) return; const pe = this.image.width / this._pixelsPerInstance, me = Math.floor(K / pe); this._rowToUpdate[me] = !0 } update(K) { const pe = K.properties.get(this), me = this.version > 0 && pe.__version !== this.version, ge = this._lastWidth !== null && this._lastWidth !== this.image.width; if (!this._needsUpdate || !pe.__webglTexture || me || ge) { this._lastWidth = this.image.width, this._needsUpdate = !1; return } if (this._needsUpdate = !1, !this.partialUpdate) { this.needsUpdate = !0; return } const xe = this.getUpdateRowsInfo(); xe.length !== 0 && (xe.length > this.maxUpdateCalls ? this.needsUpdate = !0 : this.updateRows(pe, K, xe), this._rowToUpdate.fill(!1)) } getUpdateRowsInfo() { const K = this._rowToUpdate, pe = []; for (let me = 0, ge = K.length; me < ge; me++)if (K[me]) { const xe = me; for (; me < ge && K[me]; me++); pe.push({ row: xe, count: me - xe }) } return pe } updateRows(K, pe, me) { const ge = pe.state, xe = pe.getContext(); this._utils ?? (this._utils = new WebGLUtils(xe, pe.extensions, pe.capabilities)); const ye = this._utils.convert(this.format), ve = this._utils.convert(this.type), { data: _e, width: Ee } = this.image, be = this._channels; ge.bindTexture(xe.TEXTURE_2D, K.__webglTexture); const Ae = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), Se = this.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(this.colorSpace), Ce = this.colorSpace === NoColorSpace || Ae === Se ? xe.NONE : xe.BROWSER_DEFAULT_WEBGL; xe.pixelStorei(xe.UNPACK_FLIP_Y_WEBGL, this.flipY), xe.pixelStorei(xe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha), xe.pixelStorei(xe.UNPACK_ALIGNMENT, this.unpackAlignment), xe.pixelStorei(xe.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ce); for (const { count: we, row: Be } of me) xe.texSubImage2D(xe.TEXTURE_2D, 0, 0, Be, Ee, we, ye, ve, _e, Be * Ee * be); this.onUpdate && this.onUpdate() } setUniformAt(K, pe, me) { const { offset: ge, size: xe } = this._uniformMap.get(pe), ye = this._stride; xe === 1 ? this._data[K * ye + ge] = me : me.toArray(this._data, K * ye + ge) } getUniformAt(K, pe, me) { const { offset: ge, size: xe } = this._uniformMap.get(pe), ye = this._stride; return xe === 1 ? this._data[K * ye + ge] : me.fromArray(this._data, K * ye + ge) } getUniformsGLSL(K, pe, me) { const ge = this.getUniformsVertexGLSL(K, pe, me), xe = this.getUniformsFragmentGLSL(K, pe, me); return { vertex: ge, fragment: xe } } getUniformsVertexGLSL(K, pe, me) {
		if (this._fetchUniformsInFragmentShader) return `
        flat varying ${me} ez_v${pe}; 
        void main() {
          ez_v${pe} = ${pe};`; const ge = this.texelsFetchGLSL(K, pe), xe = this.getFromTexelsGLSL(), { assignVarying: ye, declareVarying: ve } = this.getVarying(); return `
      uniform highp sampler2D ${K};  
      ${ve}
      void main() {
        ${ge}
        ${xe}
        ${ye}`
	} getUniformsFragmentGLSL(K, pe, me) {
		if (!this._fetchUniformsInFragmentShader) {
			const { declareVarying: ye, getVarying: ve } = this.getVarying(); return `
      ${ye}
      void main() {
        ${ve}`
		} const ge = this.texelsFetchGLSL(K, `ez_v${pe}`), xe = this.getFromTexelsGLSL(); return `
      uniform highp sampler2D ${K};  
      flat varying ${me} ez_v${pe};
      void main() {
        ${ge}
        ${xe}`
	} texelsFetchGLSL(K, pe) {
		const me = this._pixelsPerInstance; let ge = `
      int size = textureSize(${K}, 0).x;
      int j = int(${pe}) * ${me};
      int x = j % size;
      int y = j / size;
    `; for (let xe = 0; xe < me; xe++)ge += `vec4 ez_texel${xe} = texelFetch(${K}, ivec2(x + ${xe}, y), 0);
`; return ge
	} getFromTexelsGLSL() {
		const K = this._uniformMap; let pe = ""; for (const [me, { type: ge, offset: xe, size: ye }] of K) {
			const ve = Math.floor(xe / this._channels); if (ge === "mat3") pe += `mat3 ${me} = mat3(ez_texel${ve}.rgb, vec3(ez_texel${ve}.a, ez_texel${ve + 1}.rg), vec3(ez_texel${ve + 1}.ba, ez_texel${ve + 2}.r));
`; else if (ge === "mat4") pe += `mat4 ${me} = mat4(ez_texel${ve}, ez_texel${ve + 1}, ez_texel${ve + 2}, ez_texel${ve + 3});
`; else {
				const _e = this.getUniformComponents(xe, ye); pe += `${ge} ${me} = ez_texel${ve}.${_e};
`}
		} return pe
	} getVarying() {
		const K = this._uniformMap; let pe = "", me = "", ge = ""; for (const [xe, { type: ye }] of K) pe += `flat varying ${ye} ez_v${xe};
`, me += `ez_v${xe} = ${xe};
`, ge += `${ye} ${xe} = ez_v${xe};
`; return { declareVarying: pe, assignVarying: me, getVarying: ge }
	} getUniformComponents(K, pe) { const me = K % this._channels; let ge = ""; for (let xe = 0; xe < pe; xe++)ge += te[me + xe]; return ge } copy(K) { return super.copy(K), this.partialUpdate = K.partialUpdate, this.maxUpdateCalls = K.maxUpdateCalls, this._channels = K._channels, this._pixelsPerInstance = K._pixelsPerInstance, this._stride = K._stride, this._rowToUpdate = K._rowToUpdate, this._uniformMap = K._uniformMap, this._fetchUniformsInFragmentShader = K._fetchUniformsInFragmentShader, this }
}; const te = ["r", "g", "b", "a"]; let f$1 = class extends Mesh { constructor(K, pe, me = {}, ge) { if (!K) throw new Error('"geometry" is mandatory.'); if (!pe) throw new Error('"material" is mandatory.'); const { allowsEuler: xe, renderer: ye, createEntities: ve } = me; super(K, null), this.type = "InstancedMesh2", this.isInstancedMesh2 = !0, this.instances = null, this.instanceIndex = null, this.colorsTexture = null, this.morphTexture = null, this.boneTexture = null, this.uniformsTexture = null, this.boundingBox = null, this.boundingSphere = null, this.bvh = null, this.customSort = null, this.raycastOnlyFrustum = !1, this.LODinfo = null, this.autoUpdate = !0, this.bindMode = AttachedBindMode, this.bindMatrix = null, this.bindMatrixInverse = null, this.skeleton = null, this.onFrustumEnter = null, this._renderer = null, this._instancesCount = 0, this._instancesArrayCount = 0, this._count = 0, this._perObjectFrustumCulled = !0, this._sortObjects = !1, this._indexArrayNeedsUpdate = !1, this._useOpacity = !1, this._currentMaterial = null, this._customProgramCacheKeyBase = null, this._onBeforeCompileBase = null, this._propertiesGetBase = null, this._propertiesGetMap = new WeakMap, this._properties = new WeakMap, this._freeIds = [], this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(0), 16), this.instanceColor = null, this._customProgramCacheKey = () => `ezInstancedMesh2_${this.id}_${!!this.colorsTexture}_${this._useOpacity}_${!!this.boneTexture}_${!!this.uniformsTexture}_${this._customProgramCacheKeyBase.call(this._currentMaterial)}`, this._onBeforeCompile = (Ee, be) => { if (this._onBeforeCompileBase && this._onBeforeCompileBase.call(this._currentMaterial, Ee, be), Ee.instancing = !1, Ee.defines ?? (Ee.defines = {}), Ee.defines.USE_INSTANCING_INDIRECT = "", Ee.uniforms.matricesTexture = { value: this.matricesTexture }, this.uniformsTexture) { Ee.uniforms.uniformsTexture = { value: this.uniformsTexture }; const { vertex: Ae, fragment: Se } = this.uniformsTexture.getUniformsGLSL("uniformsTexture", "instanceIndex", "uint"); Ee.vertexShader = Ee.vertexShader.replace("void main() {", Ae), Ee.fragmentShader = Ee.fragmentShader.replace("void main() {", Se) } this.colorsTexture && Ee.fragmentShader.includes("#include <color_pars_fragment>") && (Ee.defines.USE_INSTANCING_COLOR_INDIRECT = "", Ee.uniforms.colorsTexture = { value: this.colorsTexture }, Ee.vertexShader = Ee.vertexShader.replace("<color_vertex>", "<instanced_color_vertex>"), Ee.vertexColors && (Ee.defines.USE_VERTEX_COLOR = ""), this._useOpacity ? Ee.defines.USE_COLOR_ALPHA = "" : Ee.defines.USE_COLOR = ""), this.boneTexture && (Ee.defines.USE_SKINNING = "", Ee.defines.USE_INSTANCING_SKINNING = "", Ee.uniforms.bindMatrix = { value: this.bindMatrix }, Ee.uniforms.bindMatrixInverse = { value: this.bindMatrixInverse }, Ee.uniforms.bonesPerInstance = { value: this.skeleton.bones.length }, Ee.uniforms.boneTexture = { value: this.boneTexture }) }; const _e = me.capacity > 0 ? me.capacity : ee; this._renderer = ye, this._capacity = _e, this._parentLOD = ge, this._geometry = K, this.material = pe, this._allowsEuler = xe ?? !1, this._tempInstance = new St(this, -1, xe), this.availabilityArray = ge?.availabilityArray ?? new Array(_e * 2), this._createEntities = ve, this.initIndexAttribute(), this.initMatricesTexture() } get capacity() { return this._capacity } get count() { return this._count } get instancesCount() { return this._instancesCount } get perObjectFrustumCulled() { return this._perObjectFrustumCulled } set perObjectFrustumCulled(K) { this._perObjectFrustumCulled = K, this._indexArrayNeedsUpdate = !0 } get sortObjects() { return this._sortObjects } set sortObjects(K) { this._sortObjects = K, this._indexArrayNeedsUpdate = !0 } get geometry() { return this._geometry } set geometry(K) { this._geometry = K, this.patchGeometry(K) } onBeforeShadow(K, pe, me, ge, xe, ye, ve) { var _e, Ee, be; this.patchMaterial(K, ye), !(!this.instanceIndex || ve && !this.isFirstGroup(ve.materialIndex)) && (this.autoUpdate && this.performFrustumCulling(ge, me), this.matricesTexture.update(K), (_e = this.colorsTexture) == null || _e.update(K), (Ee = this.uniformsTexture) == null || Ee.update(K), (be = this.boneTexture) == null || be.update(K)) } onBeforeRender(K, pe, me, ge, xe, ye) { var ve, _e, Ee; if (this.patchMaterial(K, xe), !this.instanceIndex) { this._renderer = K; return } ye && !this.isFirstGroup(ye.materialIndex) || (this.autoUpdate && this.performFrustumCulling(me), this.matricesTexture.update(K), (ve = this.colorsTexture) == null || ve.update(K), (_e = this.uniformsTexture) == null || _e.update(K), (Ee = this.boneTexture) == null || Ee.update(K)) } onAfterShadow(K, pe, me, ge, xe, ye, ve) { this.unpatchMaterial(K, ye) } onAfterRender(K, pe, me, ge, xe, ye) { this.unpatchMaterial(K, xe), !(this.instanceIndex || ye && !this.isLastGroup(ye.materialIndex)) && this.initIndexAttribute() } isFirstGroup(K) { const pe = this.material; for (let me = 0; me <= K; me++)if (pe[me].visible) return me === K } isLastGroup(K) { const pe = this.material; for (let me = pe.length - 1; me >= K; me--)if (pe[me].visible) return me === K } initIndexAttribute() { if (!this._renderer) { this._count = 0; return } const K = this._renderer.getContext(), pe = this._capacity, me = new Uint32Array(pe); for (let ge = 0; ge < pe; ge++)me[ge] = ge; this.instanceIndex = new Qt(K, K.UNSIGNED_INT, 1, 4, me), this._geometry.setAttribute("instanceIndex", this.instanceIndex) } initMatricesTexture() { this._parentLOD || (this.matricesTexture = new Q$1(Float32Array, 4, 4, this._capacity)) } initColorsTexture() { this._parentLOD || (this.colorsTexture = new Q$1(Float32Array, 4, 1, this._capacity), this.colorsTexture.colorSpace = ColorManagement.workingColorSpace, this.colorsTexture._data.fill(1), this.materialsNeedsUpdate()) } materialsNeedsUpdate() { if (this.material.isMaterial) { this.material.needsUpdate = !0; return } for (const K of this.material) K.needsUpdate = !0 } patchGeometry(K) { const pe = K.getAttribute("instanceIndex"); if (pe) { if (pe === this.instanceIndex) return; console.warn("The geometry has been cloned because it was already used."), K = K.clone(), K.deleteAttribute("instanceIndex") } this.instanceIndex && K.setAttribute("instanceIndex", this.instanceIndex) } patchMaterial(K, pe) { this._currentMaterial = pe, this._customProgramCacheKeyBase = pe.customProgramCacheKey, this._onBeforeCompileBase = pe.onBeforeCompile, pe.customProgramCacheKey = this._customProgramCacheKey, pe.onBeforeCompile = this._onBeforeCompile; const me = K.properties; if (!this._properties.has(pe)) { const ge = {}; this._properties.set(pe, ge); const xe = this._propertiesGetBase = me.get; this._propertiesGetMap.set(pe, ye => ye === pe ? ge : xe(ye)) } me.get = this._propertiesGetMap.get(pe) } unpatchMaterial(K, pe) { this._currentMaterial = null, K.properties.get = this._propertiesGetBase, pe.onBeforeCompile = this._onBeforeCompileBase, pe.customProgramCacheKey = this._customProgramCacheKeyBase, this._onBeforeCompileBase = null, this._customProgramCacheKeyBase = null } computeBVH(K = {}) { this.bvh || (this.bvh = new Zt(this, K.margin, K.getBBoxFromBSphere, K.accurateCulling)), this.bvh.clear(), this.bvh.create() } disposeBVH() { this.bvh = null } setMatrixAt(K, pe) { var me; if (pe.toArray(this.matricesTexture._data, K * 16), this.instances) { const ge = this.instances[K]; pe.decompose(ge.position, ge.quaternion, ge.scale) } this.matricesTexture.enqueueUpdate(K), (me = this.bvh) == null || me.move(K) } getMatrixAt(K, pe = ne) { return pe.fromArray(this.matricesTexture._data, K * 16) } getPositionAt(K, pe = ie) { const me = K * 16, ge = this.matricesTexture._data; return pe.x = ge[me + 12], pe.y = ge[me + 13], pe.z = ge[me + 14], pe } getPositionAndMaxScaleOnAxisAt(K, pe) { const me = K * 16, ge = this.matricesTexture._data, xe = ge[me + 0], ye = ge[me + 1], ve = ge[me + 2], _e = xe * xe + ye * ye + ve * ve, Ee = ge[me + 4], be = ge[me + 5], Ae = ge[me + 6], Se = Ee * Ee + be * be + Ae * Ae, Ce = ge[me + 8], we = ge[me + 9], Be = ge[me + 10], De = Ce * Ce + we * we + Be * Be; return pe.x = ge[me + 12], pe.y = ge[me + 13], pe.z = ge[me + 14], Math.sqrt(Math.max(_e, Se, De)) } applyMatrixAtToSphere(K, pe, me, ge) { const xe = K * 16, ye = this.matricesTexture._data, ve = ye[xe + 0], _e = ye[xe + 1], Ee = ye[xe + 2], be = ye[xe + 3], Ae = ye[xe + 4], Se = ye[xe + 5], Ce = ye[xe + 6], we = ye[xe + 7], Be = ye[xe + 8], De = ye[xe + 9], Re = ye[xe + 10], Ie = ye[xe + 11], Pe = ye[xe + 12], Ne = ye[xe + 13], ke = ye[xe + 14], Oe = ye[xe + 15], Ue = pe.center, He = me.x, Ge = me.y, ze = me.z, We = 1 / (be * He + we * Ge + Ie * ze + Oe); Ue.x = (ve * He + Ae * Ge + Be * ze + Pe) * We, Ue.y = (_e * He + Se * Ge + De * ze + Ne) * We, Ue.z = (Ee * He + Ce * Ge + Re * ze + ke) * We; const Xe = ve * ve + _e * _e + Ee * Ee, Ye = Ae * Ae + Se * Se + Ce * Ce, Ze = Be * Be + De * De + Re * Re; pe.radius = ge * Math.sqrt(Math.max(Xe, Ye, Ze)) } setVisibilityAt(K, pe) { this.availabilityArray[K * 2] = pe, this._indexArrayNeedsUpdate = !0 } getVisibilityAt(K) { return this.availabilityArray[K * 2] } setActiveAt(K, pe) { this.availabilityArray[K * 2 + 1] = pe, this._indexArrayNeedsUpdate = !0 } getActiveAt(K) { return this.availabilityArray[K * 2 + 1] } getActiveAndVisibilityAt(K) { const pe = K * 2, me = this.availabilityArray; return me[pe] && me[pe + 1] } setActiveAndVisibilityAt(K, pe) { const me = K * 2, ge = this.availabilityArray; ge[me] = pe, ge[me + 1] = pe, this._indexArrayNeedsUpdate = !0 } setColorAt(K, pe) { this.colorsTexture === null && this.initColorsTexture(), pe.isColor ? pe.toArray(this.colorsTexture._data, K * 4) : At$1.set(pe).toArray(this.colorsTexture._data, K * 4), this.colorsTexture.enqueueUpdate(K) } getColorAt(K, pe = At$1) { return pe.fromArray(this.colorsTexture._data, K * 4) } setOpacityAt(K, pe) { this._useOpacity || (this.colorsTexture === null ? this.initColorsTexture() : this.materialsNeedsUpdate(), this._useOpacity = !0), this.colorsTexture._data[K * 4 + 3] = pe, this.colorsTexture.enqueueUpdate(K) } getOpacityAt(K) { return this._useOpacity ? this.colorsTexture._data[K * 4 + 3] : 1 } copyTo(K, pe) { this.getMatrixAt(K, pe.matrix).decompose(pe.position, pe.quaternion, pe.scale) } computeBoundingBox() { const K = this._geometry, pe = this._instancesArrayCount; this.boundingBox ?? (this.boundingBox = new Box3), K.boundingBox === null && K.computeBoundingBox(); const me = K.boundingBox, ge = this.boundingBox; ge.makeEmpty(); for (let xe = 0; xe < pe; xe++)this.getActiveAt(xe) && (gt$1.copy(me).applyMatrix4(this.getMatrixAt(xe)), ge.union(gt$1)) } computeBoundingSphere() { const K = this._geometry, pe = this._instancesArrayCount; this.boundingSphere ?? (this.boundingSphere = new Sphere), K.boundingSphere === null && K.computeBoundingSphere(); const me = K.boundingSphere, ge = this.boundingSphere; ge.makeEmpty(); for (let xe = 0; xe < pe; xe++)this.getActiveAt(xe) && (bt.copy(me).applyMatrix4(this.getMatrixAt(xe)), ge.union(bt)) } clone(K) { const pe = { capacity: this._capacity, renderer: this._renderer, allowsEuler: this._allowsEuler, createEntities: this._createEntities }; return new this.constructor(this.geometry, this.material, pe).copy(this, K) } copy(K, pe) { return super.copy(K, pe), this._instancesCount = K._instancesCount, this._instancesArrayCount = K._instancesArrayCount, this._count = K._capacity, this._capacity = K._capacity, K.boundingBox !== null && (this.boundingBox = K.boundingBox.clone()), K.boundingSphere !== null && (this.boundingSphere = K.boundingSphere.clone()), this.matricesTexture = K.matricesTexture.clone(), this.matricesTexture.image.data = this.matricesTexture.image.data.slice(), K.colorsTexture !== null && (this.colorsTexture = K.colorsTexture.clone(), this.colorsTexture.image.data = this.colorsTexture.image.data.slice()), K.uniformsTexture !== null && (this.uniformsTexture = K.uniformsTexture.clone(), this.uniformsTexture.image.data = this.uniformsTexture.image.data.slice()), K.morphTexture !== null && (this.morphTexture = K.morphTexture.clone(), this.morphTexture.image.data = this.morphTexture.image.data.slice()), K.boneTexture !== null && (this.boneTexture = K.boneTexture.clone(), this.boneTexture.image.data = this.boneTexture.image.data.slice()), this } dispose() { var K, pe, me, ge; this.dispatchEvent({ type: "dispose" }), this.matricesTexture.dispose(), (K = this.colorsTexture) == null || K.dispose(), (pe = this.morphTexture) == null || pe.dispose(), (me = this.boneTexture) == null || me.dispose(), (ge = this.uniformsTexture) == null || ge.dispose() } updateMatrixWorld(K) { super.updateMatrixWorld(K), this.bindMatrixInverse && (this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("Unrecognized bindMode: " + this.bindMode)) } }; const ee = 1e3, gt$1 = new Box3, bt = new Sphere, ne = new Matrix4, At$1 = new Color$1, ie = new Vector3; f$1.prototype.resizeBuffers = function (fe) { var K; const pe = this._capacity; this._capacity = fe; const me = Math.min(fe, pe); if (this.instanceIndex) { const ge = new Uint32Array(fe); ge.set(new Uint32Array(this.instanceIndex.array.buffer, 0, me)), this.instanceIndex.array = ge } if (this.LODinfo) { for (const ge of this.LODinfo.objects) if (ge._capacity = fe, ge.instanceIndex) { const xe = new Uint32Array(fe); xe.set(new Uint32Array(ge.instanceIndex.array.buffer, 0, me)), ge.instanceIndex.array = xe } } if (this.availabilityArray.length = fe * 2, this.matricesTexture.resize(fe), this.colorsTexture && (this.colorsTexture.resize(fe), fe > pe && this.colorsTexture._data.fill(1, pe * 4)), this.morphTexture) { const ge = this.morphTexture.image.data, xe = ge.length / pe; this.morphTexture.dispose(), this.morphTexture = new DataTexture(new Float32Array(xe * fe), xe, fe, RedFormat, FloatType), this.morphTexture.image.data.set(ge) } return (K = this.uniformsTexture) == null || K.resize(fe), this }; f$1.prototype.setInstancesArrayCount = function (fe) { if (fe < this._instancesArrayCount) { const pe = this.bvh; if (pe) for (let me = this._instancesArrayCount - 1; me >= fe; me--)this.getActiveAt(me) && pe.delete(me); this._instancesArrayCount = fe; return } if (fe > this._capacity) { let pe = this._capacity + (this._capacity >> 1) + 512; for (; pe < fe;)pe += (pe >> 1) + 512; this.resizeBuffers(pe) } const K = this._instancesArrayCount; this._instancesArrayCount = fe, this._createEntities && this.createEntities(K) }; function Ut(fe, K) { return fe.depth - K.depth } function Ot(fe, K) { return K.depth - fe.depth } class se { constructor() { this.array = [], this.pool = [] } push(K, pe) { const me = this.pool, ge = this.array, xe = ge.length; xe >= me.length && me.push({ depth: null, index: null, depthSort: null }); const ye = me[xe]; ye.depth = K, ye.index = pe, ge.push(ye) } reset() { this.array.length = 0 } } const J$1 = new Frustum, S$1 = new se, B = new Matrix4, z = new Matrix4, nt = new Vector3, P$1 = new Vector3, R$1 = new Vector3, re = new Vector3, w$1 = new Sphere; f$1.prototype.performFrustumCulling = function (fe, K = fe) { if (!this._parentLOD && this._instancesArrayCount === 0) { this._count = 0; return } const pe = this.LODinfo, me = fe !== K; let ge; if (pe) { ge = me ? pe.shadowRender ?? pe.render : pe.render; for (const xe of pe.objects) xe._count = 0 } ge?.levels.length > 0 ? this.frustumCullingLOD(ge, fe, K) : this._parentLOD || this.frustumCulling(fe), this.instanceIndex.update(this._renderer, this._count) }; f$1.prototype.frustumCulling = function (fe) { var K; const pe = this._sortObjects, me = this._perObjectFrustumCulled, ge = this.instanceIndex.array; if (this.instanceIndex._needsUpdate = !0, !me && !pe) { this.updateIndexArray(); return } if (pe && (z.copy(this.matrixWorld).invert(), P$1.setFromMatrixPosition(fe.matrixWorld).applyMatrix4(z), nt.set(0, 0, -1).transformDirection(fe.matrixWorld).transformDirection(z)), me ? (B.multiplyMatrices(fe.projectionMatrix, fe.matrixWorldInverse).multiply(this.matrixWorld), this.bvh ? this.BVHCulling(fe) : this.linearCulling(fe)) : this.updateRenderList(), pe) { const xe = this.customSort; xe === null ? S$1.array.sort((K = this.material) != null && K.transparent ? Ot : Ut) : xe(S$1.array); const ye = S$1.array, ve = ye.length; for (let _e = 0; _e < ve; _e++)ge[_e] = ye[_e].index; this._count = ve, S$1.reset() } }; f$1.prototype.updateIndexArray = function () { if (!this._indexArrayNeedsUpdate) return; const fe = this.instanceIndex.array, K = this._instancesArrayCount; let pe = 0; for (let me = 0; me < K; me++)this.getActiveAndVisibilityAt(me) && (fe[pe++] = me); this._count = pe, this._indexArrayNeedsUpdate = !1 }; f$1.prototype.updateRenderList = function () { const fe = this._instancesArrayCount; for (let K = 0; K < fe; K++)if (this.getActiveAndVisibilityAt(K)) { const pe = this.getPositionAt(K).sub(P$1).dot(nt); S$1.push(pe, K) } }; f$1.prototype.BVHCulling = function (fe) { const K = this.instanceIndex.array, pe = this._instancesArrayCount, me = this._sortObjects, ge = this.onFrustumEnter; let xe = 0; this.bvh.frustumCulling(B, ye => { const ve = ye.object; if (ve < pe && this.getVisibilityAt(ve) && (!ge || ge(ve, fe))) if (me) { const _e = this.getPositionAt(ve).sub(P$1).dot(nt); S$1.push(_e, ve) } else K[xe++] = ve }), this._count = xe }; f$1.prototype.linearCulling = function (fe) { const K = this.instanceIndex.array; this.geometry.boundingSphere || this.geometry.computeBoundingSphere(); const pe = this._geometry.boundingSphere, me = pe.radius, ge = pe.center, xe = this._instancesArrayCount, ye = ge.x === 0 && ge.y === 0 && ge.z === 0, ve = this._sortObjects, _e = this.onFrustumEnter; let Ee = 0; J$1.setFromProjectionMatrix(B); for (let be = 0; be < xe; be++)if (this.getActiveAndVisibilityAt(be)) { if (ye) { const Ae = this.getPositionAndMaxScaleOnAxisAt(be, w$1.center); w$1.radius = me * Ae } else this.applyMatrixAtToSphere(be, w$1, ge, me); if (J$1.intersectsSphere(w$1) && (!_e || _e(be, fe))) if (ve) { const Ae = re.subVectors(w$1.center, P$1).dot(nt); S$1.push(Ae, be) } else K[Ee++] = be } this._count = Ee }; f$1.prototype.frustumCullingLOD = function (fe, K, pe) { var me, ge; const { count: xe, levels: ye } = fe, ve = K === pe && this._sortObjects; for (let Ee = 0; Ee < ye.length; Ee++)xe[Ee] = 0, ye[Ee].object.instanceIndex && (ye[Ee].object.instanceIndex._needsUpdate = !0); B.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse).multiply(this.matrixWorld), z.copy(this.matrixWorld).invert(), P$1.setFromMatrixPosition(K.matrixWorld).applyMatrix4(z), R$1.setFromMatrixPosition(pe.matrixWorld).applyMatrix4(z); const _e = fe.levels.map(Ee => Ee.object.instanceIndex.array); if (this.bvh ? this.BVHCullingLOD(fe, _e, ve, K, pe) : this.linearCullingLOD(fe, _e, ve, K, pe), ve) { const Ee = this.customSort, be = S$1.array; let Ae = 0, Se = ye[1].distance; Ee === null ? be.sort((me = ye[0].object.material) != null && me.transparent ? Ot : Ut) : Ee(be); for (let Ce = 0, we = be.length; Ce < we; Ce++) { const Be = be[Ce]; Be.depth > Se && (Ae++, Se = ((ge = ye[Ae + 1]) == null ? void 0 : ge.distance) ?? 1 / 0), _e[Ae][xe[Ae]++] = Be.index } S$1.reset() } for (let Ee = 0; Ee < ye.length; Ee++) { const be = ye[Ee].object; be._count = xe[Ee] } }; f$1.prototype.BVHCullingLOD = function (fe, K, pe, me, ge) { const { count: xe, levels: ye } = fe, ve = this._instancesArrayCount, _e = this.onFrustumEnter; pe ? this.bvh.frustumCulling(B, Ee => { const be = Ee.object; if (be < ve && this.getVisibilityAt(be) && (!_e || _e(be, me, ge))) { const Ae = this.getPositionAt(be).distanceToSquared(R$1); S$1.push(Ae, be) } }) : this.bvh.frustumCullingLOD(B, R$1, ye, (Ee, be) => { const Ae = Ee.object; if (Ae < ve && this.getVisibilityAt(Ae)) { if (be === null) { const Se = this.getPositionAt(Ae).distanceToSquared(R$1); be = this.getObjectLODIndexForDistance(ye, Se) } (!_e || _e(Ae, me, ge, be)) && (K[be][xe[be]++] = Ae) } }) }; f$1.prototype.linearCullingLOD = function (fe, K, pe, me, ge) { const { count: xe, levels: ye } = fe; this.geometry.boundingSphere || this.geometry.computeBoundingSphere(); const ve = this._geometry.boundingSphere, _e = ve.radius, Ee = ve.center, be = this._instancesArrayCount, Ae = Ee.x === 0 && Ee.y === 0 && Ee.z === 0, Se = this.onFrustumEnter; J$1.setFromProjectionMatrix(B); for (let Ce = 0; Ce < be; Ce++)if (this.getActiveAndVisibilityAt(Ce)) { if (Ae) { const we = this.getPositionAndMaxScaleOnAxisAt(Ce, w$1.center); w$1.radius = _e * we } else this.applyMatrixAtToSphere(Ce, w$1, Ee, _e); if (J$1.intersectsSphere(w$1)) if (pe) { if (!Se || Se(Ce, me, ge)) continue; const we = w$1.center.distanceToSquared(R$1); S$1.push(we, Ce) } else { const we = w$1.center.distanceToSquared(R$1), Be = this.getObjectLODIndexForDistance(ye, we); (!Se || Se(Ce, me, ge, Be)) && (K[Be][xe[Be]++] = Ce) } } }; f$1.prototype.clearTempInstance = function (fe) { const K = this._tempInstance; return K.id = fe, this.clearInstance(K) }; f$1.prototype.clearTempInstancePosition = function (fe) { const K = this._tempInstance; return K.id = fe, K.position.set(0, 0, 0), K }; f$1.prototype.clearInstance = function (fe) { return fe.position.set(0, 0, 0), fe.scale.set(1, 1, 1), fe.quaternion.identity(), fe }; f$1.prototype.updateInstances = function (fe) { const K = this._instancesArrayCount, pe = this.instances; for (let me = 0; me < K; me++) { if (!this.getActiveAt(me)) continue; const ge = pe ? pe[me] : this.clearTempInstance(me); fe(ge, me), ge.updateMatrix() } return this }; f$1.prototype.updateInstancesPosition = function (fe) { const K = this._instancesArrayCount, pe = this.instances; for (let me = 0; me < K; me++) { if (!this.getActiveAt(me)) continue; const ge = pe ? pe[me] : this.clearTempInstancePosition(me); fe(ge, me), ge.updateMatrixPosition() } return this }; f$1.prototype.createEntities = function (fe) { const K = this._instancesArrayCount; if (!this.instances) this.instances = new Array(K); else if (this.instances.length < K) this.instances.length = K; else return this; const pe = this.instances; for (let me = fe; me < K; me++)pe[me] || (pe[me] = new St(this, me, this._allowsEuler)); return this }; f$1.prototype.addInstances = function (fe, K) { !K && this.bvh && console.warn("InstancedMesh2: if `computeBVH()` has already been called, it is better to valorize the instances in the `onCreation` callback for better performance."); const pe = this._freeIds; if (pe.length > 0) { let xe = -1; const ye = Math.min(pe.length, fe), ve = pe.length - ye; for (let _e = pe.length - 1; _e >= ve; _e--) { const Ee = pe[_e]; Ee > xe && (xe = Ee), this.addInstance(Ee, K) } pe.length -= ye, fe -= ye, this._instancesArrayCount = Math.max(xe + 1, this._instancesArrayCount) } const me = this._instancesArrayCount, ge = me + fe; this.setInstancesArrayCount(ge); for (let xe = me; xe < ge; xe++)this.addInstance(xe, K); return this }; f$1.prototype.addInstance = function (fe, K) { var pe; this._instancesCount++, this.setActiveAndVisibilityAt(fe, !0); const me = this.instances ? this.clearInstance(this.instances[fe]) : this.clearTempInstance(fe); K ? (K(me, fe), me.updateMatrix()) : me.setMatrixIdentity(), (pe = this.bvh) == null || pe.insert(fe) }; f$1.prototype.removeInstances = function (...fe) { const K = this._freeIds, pe = this.bvh; for (const me of fe) me < this._instancesArrayCount && this.getActiveAt(me) && (this.setActiveAt(me, !1), K.push(me), pe?.delete(me), this._instancesCount--); for (let me = this._instancesArrayCount - 1; me >= 0 && !this.getActiveAt(me); me--)this._instancesArrayCount--; return this }; f$1.prototype.clearInstances = function () { var fe; if (this._instancesCount = 0, this._instancesArrayCount = 0, this._freeIds.length = 0, (fe = this.bvh) == null || fe.clear(), this.LODinfo) for (const K of this.LODinfo.objects) K._count = 0; return this }; f$1.prototype.getObjectLODIndexForDistance = function (fe, K) { for (let pe = fe.length - 1; pe > 0; pe--) { const me = fe[pe], ge = me.distance - me.distance * me.hysteresis; if (K >= ge) return pe } return 0 }; f$1.prototype.setFirstLODDistance = function (fe = 0, K = 0) { if (this._parentLOD) throw new Error("Cannot create LOD for this InstancedMesh2."); return this.LODinfo || (this.LODinfo = { render: null, shadowRender: null, objects: [this] }), this.LODinfo.render || (this.LODinfo.render = { levels: [{ distance: fe, hysteresis: K, object: this }], count: [0] }), this }; f$1.prototype.addLOD = function (fe, K, pe = 0, me = 0) { var ge; if (this._parentLOD) throw new Error("Cannot create LOD for this InstancedMesh2."); if (!((ge = this.LODinfo) != null && ge.render) && pe === 0) throw new Error('Cannot set distance to 0 for the first LOD. Use "setFirstLODDistance" before use "addLOD".'); return this.setFirstLODDistance(0, me), this.addLevel(this.LODinfo.render, fe, K, pe, me), this }; f$1.prototype.addShadowLOD = function (fe, K = 0, pe = 0) { if (this._parentLOD) throw new Error("Cannot create LOD for this InstancedMesh2."); this.LODinfo || (this.LODinfo = { render: null, shadowRender: null, objects: [this] }), this.LODinfo.shadowRender || (this.LODinfo.shadowRender = { levels: [], count: [] }); const me = this.addLevel(this.LODinfo.shadowRender, fe, null, K, pe); return me.castShadow = !0, this.castShadow = !0, this }; f$1.prototype.addLevel = function (fe, K, pe, me, ge) { const xe = this.LODinfo.objects, ye = fe.levels; let ve, _e; me = me ** 2; const Ee = xe.findIndex(be => be.geometry === K); if (Ee === -1) { const be = { capacity: this._capacity, renderer: this._renderer }; _e = new f$1(K, pe ?? new ShaderMaterial, be, this), _e.frustumCulled = !1, this.patchLevel(_e), xe.push(_e), this.add(_e) } else _e = xe[Ee], pe && (_e.material = pe); for (ve = 0; ve < ye.length && !(me < ye[ve].distance); ve++); return ye.splice(ve, 0, { distance: me, hysteresis: ge, object: _e }), fe.count.push(0), _e }; f$1.prototype.patchLevel = function (fe) { Object.defineProperty(fe, "matricesTexture", { get() { return this._parentLOD.matricesTexture } }), Object.defineProperty(fe, "colorsTexture", { get() { return this._parentLOD.colorsTexture } }), Object.defineProperty(fe, "uniformsTexture", { get() { return this._parentLOD.uniformsTexture } }), Object.defineProperty(fe, "morphTexture", { get() { return this._parentLOD.morphTexture } }), Object.defineProperty(fe, "boneTexture", { get() { return this._parentLOD.boneTexture } }), Object.defineProperty(fe, "skeleton", { get() { return this._parentLOD.skeleton } }), Object.defineProperty(fe, "bindMatrixInverse", { get() { return this._parentLOD.bindMatrixInverse } }), Object.defineProperty(fe, "bindMatrix", { get() { return this._parentLOD.bindMatrix } }) }; const oe = new Mesh; f$1.prototype.getMorphAt = function (fe, K = oe) { const pe = K.morphTargetInfluences, me = this.morphTexture.source.data.data, ge = pe.length + 1, xe = fe * ge + 1; for (let ye = 0; ye < pe.length; ye++)pe[ye] = me[xe + ye]; return K }; f$1.prototype.setMorphAt = function (fe, K) { const pe = K.morphTargetInfluences, me = pe.length + 1; this.morphTexture === null && !this._parentLOD && (this.morphTexture = new DataTexture(new Float32Array(me * this._capacity), me, this._capacity, RedFormat, FloatType)); const ge = this.morphTexture.source.data.data; let xe = 0; for (const _e of pe) xe += _e; const ye = this._geometry.morphTargetsRelative ? 1 : 1 - xe, ve = me * fe; ge[ve] = ye, ge.set(pe, ve + 1), this.morphTexture.needsUpdate = !0 }; const it = [], tt$1 = new Mesh, ae = new Ray, vt = new Vector3, It = new Vector3, Tt = new Matrix4, Ct$1 = new Sphere; f$1.prototype.raycast = function (fe, K) { if (this._parentLOD || !this.material || this._instancesArrayCount === 0 || !this.instanceIndex) return; tt$1.geometry = this._geometry, tt$1.material = this.material; const pe = fe.ray, me = fe.near, ge = fe.far; Tt.copy(this.matrixWorld).invert(), It.setFromMatrixScale(this.matrixWorld), vt.copy(fe.ray.direction).multiply(It); const xe = vt.length(); fe.ray = ae.copy(fe.ray).applyMatrix4(Tt), fe.near /= xe, fe.far /= xe, this.raycastInstances(fe, K), fe.ray = pe, fe.near = me, fe.far = ge }; f$1.prototype.raycastInstances = function (fe, K) { if (this.bvh) this.bvh.raycast(fe, pe => this.checkObjectIntersection(fe, pe, K)); else { if (this.boundingSphere === null && this.computeBoundingSphere(), Ct$1.copy(this.boundingSphere), !fe.ray.intersectsSphere(Ct$1)) return; const pe = this.instanceIndex.array, me = this.raycastOnlyFrustum && this._perObjectFrustumCulled ? this._count : this._instancesArrayCount; for (let ge = 0; ge < me; ge++)this.checkObjectIntersection(fe, pe[ge], K) } }; f$1.prototype.checkObjectIntersection = function (fe, K, pe) { if (!(K > this._instancesArrayCount || !this.getActiveAndVisibilityAt(K))) { this.getMatrixAt(K, tt$1.matrixWorld), tt$1.raycast(fe, it); for (const me of it) me.instanceId = K, me.object = this, pe.push(me); it.length = 0 } }; f$1.prototype.initSkeleton = function (fe, K = !0) { if (fe && this.skeleton !== fe && !this._parentLOD) { const pe = fe.bones; if (this.skeleton = fe, this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boneTexture = new Q$1(Float32Array, 4, 4 * pe.length, this._capacity), K) for (const me of pe) me.matrixAutoUpdate = !1, me.matrixWorldAutoUpdate = !1; this.materialsNeedsUpdate() } }; f$1.prototype.setBonesAt = function (fe, K = !0, pe) { const me = this.skeleton; if (!me) throw new Error('"setBonesAt" cannot be called before "initSkeleton"'); const ge = me.bones, xe = me.boneInverses; for (let ye = 0, ve = ge.length; ye < ve; ye++) { const _e = ge[ye]; K && (pe != null && pe.has(_e.name) || _e.updateMatrix(), _e.matrixWorld.multiplyMatrices(_e.parent.matrixWorld, _e.matrix)), this.multiplyBoneMatricesAt(fe, ye, _e.matrixWorld, xe[ye]) } this.boneTexture.enqueueUpdate(fe) }; f$1.prototype.multiplyBoneMatricesAt = function (fe, K, pe, me) { const ge = (fe * this.skeleton.bones.length + K) * 16, xe = pe.elements, ye = me.elements, ve = this.boneTexture._data, _e = xe[0], Ee = xe[4], be = xe[8], Ae = xe[12], Se = xe[1], Ce = xe[5], we = xe[9], Be = xe[13], De = xe[2], Re = xe[6], Ie = xe[10], Pe = xe[14], Ne = xe[3], ke = xe[7], Oe = xe[11], Ue = xe[15], He = ye[0], Ge = ye[4], ze = ye[8], We = ye[12], Xe = ye[1], Ye = ye[5], Ze = ye[9], ot = ye[13], qe = ye[2], Qe = ye[6], st = ye[10], Nt = ye[14], Je = ye[3], jt = ye[7], Xt = ye[11], ct = ye[15]; ve[ge + 0] = _e * He + Ee * Xe + be * qe + Ae * Je, ve[ge + 4] = _e * Ge + Ee * Ye + be * Qe + Ae * jt, ve[ge + 8] = _e * ze + Ee * Ze + be * st + Ae * Xt, ve[ge + 12] = _e * We + Ee * ot + be * Nt + Ae * ct, ve[ge + 1] = Se * He + Ce * Xe + we * qe + Be * Je, ve[ge + 5] = Se * Ge + Ce * Ye + we * Qe + Be * jt, ve[ge + 9] = Se * ze + Ce * Ze + we * st + Be * Xt, ve[ge + 13] = Se * We + Ce * ot + we * Nt + Be * ct, ve[ge + 2] = De * He + Re * Xe + Ie * qe + Pe * Je, ve[ge + 6] = De * Ge + Re * Ye + Ie * Qe + Pe * jt, ve[ge + 10] = De * ze + Re * Ze + Ie * st + Pe * Xt, ve[ge + 14] = De * We + Re * ot + Ie * Nt + Pe * ct, ve[ge + 3] = Ne * He + ke * Xe + Oe * qe + Ue * Je, ve[ge + 7] = Ne * Ge + ke * Ye + Oe * Qe + Ue * jt, ve[ge + 11] = Ne * ze + ke * Ze + Oe * st + Ue * Xt, ve[ge + 15] = Ne * We + ke * ot + Oe * Nt + Ue * ct }; f$1.prototype.getUniformAt = function (fe, K, pe) { if (!this.uniformsTexture) throw new Error(`Before get/set uniform, it's necessary to use "initUniformsPerInstance".`); return this.uniformsTexture.getUniformAt(fe, K, pe) }; f$1.prototype.setUniformAt = function (fe, K, pe) { if (!this.uniformsTexture) throw new Error(`Before get/set uniform, it's necessary to use "initUniformsPerInstance".`); this.uniformsTexture.setUniformAt(fe, K, pe), this.uniformsTexture.enqueueUpdate(fe) }; f$1.prototype.initUniformsPerInstance = function (fe) { if (!this._parentLOD) { const { channels: K, pixelsPerInstance: pe, uniformMap: me, fetchInFragmentShader: ge } = this.getUniformSchemaResult(fe); this.uniformsTexture = new Q$1(Float32Array, K, pe, this._capacity, me, ge), this.materialsNeedsUpdate() } }; f$1.prototype.getUniformSchemaResult = function (fe) { let K = 0; const pe = new Map, me = [], ge = fe.vertex ?? {}, xe = fe.fragment ?? {}; let ye = !0; for (const Ee in ge) { const be = ge[Ee], Ae = this.getUniformSize(be); K += Ae, me.push({ name: Ee, type: be, size: Ae }), ye = !1 } for (const Ee in xe) if (!ge[Ee]) { const be = xe[Ee], Ae = this.getUniformSize(be); K += Ae, me.push({ name: Ee, type: be, size: Ae }) } me.sort((Ee, be) => be.size - Ee.size); const ve = []; for (const { name: Ee, size: be, type: Ae } of me) { const Se = this.getUniformOffset(be, ve); pe.set(Ee, { offset: Se, size: be, type: Ae }) } const _e = Math.ceil(K / 4); return { channels: Math.min(K, 4), pixelsPerInstance: _e, uniformMap: pe, fetchInFragmentShader: ye } }; f$1.prototype.getUniformOffset = function (fe, K) { if (fe < 4) { for (let me = 0; me < K.length; me++)if (K[me] + fe <= 4) { const ge = me * 4 + K[me]; return K[me] += fe, ge } } const pe = K.length * 4; for (; fe > 0; fe -= 4)K.push(fe); return pe }; f$1.prototype.getUniformSize = function (fe) { switch (fe) { case "float": return 1; case "vec2": return 2; case "vec3": return 3; case "vec4": return 4; case "mat3": return 9; case "mat4": return 16; default: throw new Error(`Invalid uniform type: ${fe}`) } }; var ce = `#ifdef USE_INSTANCING_INDIRECT\r
  attribute uint instanceIndex;\r
  uniform highp sampler2D matricesTexture;  

  mat4 getInstancedMatrix() {\r
    int size = textureSize( matricesTexture, 0 ).x;\r
    int j = int( instanceIndex ) * 4;\r
    int x = j % size;\r
    int y = j / size;\r
    vec4 v1 = texelFetch( matricesTexture, ivec2( x, y ), 0 );\r
    vec4 v2 = texelFetch( matricesTexture, ivec2( x + 1, y ), 0 );\r
    vec4 v3 = texelFetch( matricesTexture, ivec2( x + 2, y ), 0 );\r
    vec4 v4 = texelFetch( matricesTexture, ivec2( x + 3, y ), 0 );\r
    return mat4( v1, v2, v3, v4 );\r
  }\r
#endif`, he = `#ifdef USE_INSTANCING_COLOR_INDIRECT\r
  uniform highp sampler2D colorsTexture;

  #ifdef USE_COLOR_ALPHA\r
    vec4 getColorTexture() {\r
      int size = textureSize( colorsTexture, 0 ).x;\r
      int j = int( instanceIndex );\r
      int x = j % size;\r
      int y = j / size;\r
      return texelFetch( colorsTexture, ivec2( x, y ), 0 );\r
    }\r
  #else\r
    vec3 getColorTexture() {\r
      int size = textureSize( colorsTexture, 0 ).x;\r
      int j = int( instanceIndex );\r
      int x = j % size;\r
      int y = j / size;\r
      return texelFetch( colorsTexture, ivec2( x, y ), 0 ).rgb;\r
    }\r
  #endif\r
#endif`, ue = `#ifdef USE_INSTANCING_INDIRECT\r
  mat4 instanceMatrix = getInstancedMatrix();

  #ifdef USE_INSTANCING_COLOR_INDIRECT\r
    vColor *= getColorTexture();\r
  #endif\r
#endif`, le = `#ifdef USE_INSTANCING_COLOR_INDIRECT\r
  #ifdef USE_VERTEX_COLOR\r
    vColor = color;\r
  #else\r
    #ifdef USE_COLOR_ALPHA\r
      vColor = vec4( 1.0 );\r
    #else\r
      vColor = vec3( 1.0 );\r
    #endif\r
  #endif\r
#endif`, de = `#ifdef USE_SKINNING\r
  uniform mat4 bindMatrix;\r
  uniform mat4 bindMatrixInverse;\r
  uniform highp sampler2D boneTexture;

  #ifdef USE_INSTANCING_SKINNING\r
    uniform int bonesPerInstance;\r
  #endif

  mat4 getBoneMatrix( const in float i ) {\r
    int size = textureSize( boneTexture, 0 ).x;

    #ifdef USE_INSTANCING_SKINNING\r
      int j = ( bonesPerInstance * int( instanceIndex ) + int( i ) ) * 4;\r
    #else\r
      int j = int( i ) * 4;\r
    #endif

    int x = j % size;\r
    int y = j / size;\r
    vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\r
    vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\r
    vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\r
    vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\r
    return mat4( v1, v2, v3, v4 );\r
  }\r
#endif`; ShaderChunk.instanced_pars_vertex = ce; ShaderChunk.instanced_color_pars_vertex = he; ShaderChunk.instanced_vertex = ue; ShaderChunk.instanced_color_vertex = le; function ht$1(fe) { return fe.replace("#ifdef USE_INSTANCING", "#if defined USE_INSTANCING || defined USE_INSTANCING_INDIRECT") } ShaderChunk.project_vertex = ht$1(ShaderChunk.project_vertex); ShaderChunk.worldpos_vertex = ht$1(ShaderChunk.worldpos_vertex); ShaderChunk.defaultnormal_vertex = ht$1(ShaderChunk.defaultnormal_vertex); ShaderChunk.batching_pars_vertex = ShaderChunk.batching_pars_vertex.concat(`
#include <instanced_pars_vertex>`); ShaderChunk.color_pars_vertex = ShaderChunk.color_pars_vertex.concat(`
#include <instanced_color_pars_vertex>`); ShaderChunk.batching_vertex = ShaderChunk.batching_vertex.concat(`
#include <instanced_vertex>`); ShaderChunk.skinning_pars_vertex = de; ShaderChunk.morphinstance_vertex && (ShaderChunk.morphinstance_vertex = ShaderChunk.morphinstance_vertex.replaceAll("gl_InstanceID", "instanceIndex")); (function () { var fe = "B9h79tEBBBENQ9gEUEU9gEUB9gBB9gVUUUUUEU9gDUUEU9gLUUUUEU9gVUUUUUB9gLUUUUB9gIUUUEU9gD99UE99I8ayDILEVLEVLOOOOORRVBWWBEdddLVE9wEIIVIEBEOWEUEC+g/KEKR/QIhO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9fw9u9j9v9kw9WwvTw949C919m9mwvBE8f9tw79o9v9wT9fw9u9j9v9kw9WwvTw949C919m9mwv9C9v919u9kBDe9tw79o9v9wT9fw9u9j9v9kw9WwvTw949Wwv79p9v9uBIy9tw79o9v9wT9fw9u9j9v9kw69u9kw949C919m9mwvBL8e9tw79o9v9wT9fw9u9j9v9kw69u9kw949C919m9mwv9C9v919u9kBV8a9tw79o9v9wT9fw9u9j9v9kw69u9kw949Wwv79p9v9uBOe9tw79o9v9wT9fw9u9j9v9kw69u9kw949Twg91w9u9jwBRA9tw79o9v9wT9fw9u9j9v9kw69u9kw949Twg91w9u9jw9C9v919u9kBWl9tw79o9v9wT9fw9u9j9v9kws9p2Twv9P9jTBdk9tw79o9v9wT9fw9u9j9v9kws9p2Twv9R919hTBQl9tw79o9v9wT9fw9u9j9v9kws9p2Twvt949wBKe9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94j9h9j9owBpA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94j9h9j9ow9TTv9p9wBSA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94swT9j9o9Sw9t9h9wBZL79iv9rBhdWEBCEKDxcQ+1tyDBK/hKEyU8jJJJJBCJO9rGV8kJJJJBCBHODNALCEFAE0MBABCBrB+Q+KJJBC+gEv86BBAVCJDFCBCJDZ+TJJJB8aDNAItMBAVCJDFADALZmJJJB8aKABAEFHRABCEFHWAVALFCBCBCJDAL9rALCfE0eZ+TJJJB8aAVAVCJDFALZmJJJBHdCJ/ABAL9uHEDNDNALtMBAEC/wfBgGECJDAECJD6eHQCBHKINAKAI9PMEAdCJLFCBCJDZ+TJJJB8aAQAIAK9rAKAQFAI6eGXCSFGECL4CIFCD4HMADAKAL2FHpDNDNDNDNDNAEC9wgGStMBCBHZCEHhApHoAWHaXEKDNAXtMBCBHaCEHhApHcINAdAaFrBBHxAcHECBHOINAdCJLFAOFAErBBGqAx9rGxCETAxCkTCk91CR4786BBAEALFHEAqHxAOCEFGOAX9HMBKARAW9rAM6MIAWCBAMZ+TJJJBGEtMIAEAMFHWAcCEFHcAaCEFGaAL6HhAaAL9HMBXVKKARAW9rAM6MOAWCBAMZ+TJJJB8aCEHEINAWGxAMFHWALAEGOsMLDNARAW9rAM6MBAOCEFHEAWCBAMZ+TJJJB8aAxMEKKCBHWAOAL6MOXIKINDNAXtMBAdAZFrBBHxCBHEAoHOINAdCJLFAEFAOrBBGqAx9rGxCETAxCkTCk91CR4786BBAOALFHOAqHxAECEFGEAX9HMBKKARAa9rAM6MEARAaCBAMZ+TJJJBGlAMFGW9rCk6MDCBHkAdCJLFHcINAdCJLFAkFHyCWH8aCZHaCEHqINDNDNAqCE9HMBCUHOAyrBBMECBHODNINAOGECSsMEAECEFHOAcAEFCEFrBBtMBKKCUCBAECS6eHOXEKAqCETC/+fffEgHOCUAqTCU7CfEgHxCBHEINAOAxAcAEFrBB9NFHOAECEFGECZ9HMBKKAOAaAOAa6GEeHaAqA8aAEeH8aAqCETGqCW6MBKDNDNDNDNA8aCUFpDIEBKAlAkCO4FGEAErBBCDCIA8aCLseAkCI4COgTv86BBA8aCW9HMEAWAy8pBB83BBAWCWFAyCWF8pBB83BBAWCZFHWXDKAlAkCO4FGEAErBBCEAkCI4COgTv86BBKDNCWA8a9tGeMBINAWCB86BBAWCEFHWXBKKCUA8aTCU7HqCBH3AcH5INA5HEAeHxCBHOINAErBBGaAqAaAqCfEgGy6eAOCfEgA8aTvHOAECEFHEAxCUFGxMBKAWAO86BBA5AeFH5AWCEFHWA3AeFG3CZ6MBKCBHEINDNAcAEFrBBGOAy6MBAWAO86BBAWCEFHWKAECEFGECZ9HMBKKDNAkCZFGkAS9PMBAcCZFHcARAW9rCl0MEKKAkAS6MEAWtMEAoCEFHoAZCEFGZAL6HhAWHaAZALsMIXBKKCBHWAhCEgtMEXLKCBHWAhCEgMIKAdApAXCUFAL2FALZmJJJB8aAXAKFHKAWMBKCBHOXDKCBHOARAW9rCAALALCA6e6MEDNALC8f0MBAWCBCAAL9rGEZ+TJJJBAEFHWKAWAdCJDFALZmJJJBALFAB9rHOXEKCBHOKAVCJOF8kJJJJBAOK9HEEUAECAAECA0eABCJ/ABAE9uC/wfBgGDCJDADCJD6eGDFCUFAD9uAE2ADCL4CIFCD4ADv2FCEFKMBCBABbD+Q+KJJBK/YSE3U8jJJJJBC/AE9rGL8kJJJJBCBHVDNAICI9uGOChFAE0MBABCBYDn+KJJBGVC/gEv86BBALC/ABFCfECJEZ+TJJJB8aALCuFGR9CU83IBALC8wFGW9CU83IBALCYFGd9CU83IBALCAFGQ9CU83IBALCkFGK9CU83IBALCZFGX9CU83IBAL9CU83IWAL9CU83IBABAEFC9wFHMABCEFGpAOFHEDNAItMBCMCSAVCB9KGSeHZAVCE9IHhCBHoCBHaCBHcCBHxCBHqINDNAEAM9NMBCBHVXIKAqCUFHVADAcCDTFGOYDBHlAOCWFYDBHkAOCLFYDBHyCBH8aDNDNINALC/ABFAVCSgCITFGOYDLHeDNDNDNAOYDBGOAl9HMBAeAysMEKDNAOAy9HMBAeAk9HMBA8aCEFH8aXEKAOAk9HMEAeAl9HMEA8aCDFH8aKA8aC870MDAxCUFHVADA8aCIgCX2GOC+Y1JJBFYDBAcFCDTFYDBHeADAOCn1JJBFYDBAcFCDTFYDBHkADAOC+Q1JJBFYDBAcFCDTFYDBHlCBHODNINDNALAVCSgCDTFYDBAe9HMBAOHyXDKCUHyAVCUFHVAOCEFGOCZ9HMBKKAyCB9KAyAZ9IgGVCU7AeAosGOgH3DNDNDNDNDNAyCBCSAOeAVeGVCS9HMBAhMBAeAeAaAeCEFAasGVeGaCEFsMECMCSAVeHVKApAVA8aCDTC/wEgv86BBAVCS9HMEAeAa9rGVCETAVC8f917HVINAEAVCfB0CRTAVCfBgv86BBAECEFHEAVCJE6HOAVCR4HVAOtMBKAeHaXDKCpHVApA8aCDTCpv86BBAeHaKAVtMBAVAZ9IMEKALAxCDTFAebDBAxCEFCSgHxKAoA3FHoALC/ABFAqCITFGVAkbDLAVAebDBALC/ABFAqCEFCSgGVCITFGOAebDLAOAlbDBAVCEFHOXIKAVCUFHVA8aCLFG8aC/AB9HMBKKDNADCEAkAosCETAyAoseCX2GVC+Q1JJBFYDBAcFCDTFYDBGltADAVCn1JJBFYDBAcFCDTFYDBG8aCEsgADAVC+Y1JJBFYDBAcFCDTFYDBGyCDsgAoCB9HgASgG5CE9HMBAR9CU83IBAW9CU83IBAd9CU83IBAQ9CU83IBAK9CU83IBAX9CU83IBAL9CU83IWAL9CU83IBCBHoKCBHeAxCUFGVHODNINDNALAOCSgCDTFYDBA8a9HMBAeHkXDKCUHkAOCUFHOAeCEFGeCZ9HMBKKCBHODNINDNALAVCSgCDTFYDBAy9HMBAOHeXDKCUHeAVCUFHVAOCEFGOCZ9HMBKKAoAlAosG8eFH3DNDNAkCM0MBAkCEFHkXEKCBCSA8aA3sGVeHkA3AVFH3KDNDNAeCM0MBAeCEFHeXEKCBCSAyA3sGVeHeA3AVFH3KC9+CUA8eeH8fAeAkCLTvHOCBHVDNDNDNINAVCJ1JJBFrBBAOCfEgsMEAVCEFGVCZ9HMBXDKKAlAo9HAVCM0vA5vMBApAVC/wEv86BBXEKApA8f86BBAEAO86BBAECEFHEKDNA8eMBAlAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKAlHaKDNAkCS9HMBA8aAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKA8aHaKDNAeCS9HMBAyAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKAyHaKALAxCDTFAlbDBAxCEFCSgHVDNDNAkpZBEEEEEEEEEEEEEEBEKALAVCDTFA8abDBAxCDFCSgHVKDNDNAepZBEEEEEEEEEEEEEEBEKALAVCDTFAybDBAVCEFCSgHVKALC/ABFAqCITFGOAlbDLAOA8abDBALC/ABFAqCEFCSgCITFGOA8abDLAOAybDBALC/ABFAqCDFCSgCITFGOAybDLAOAlbDBAqCIFHOAVHxA3HoKApCEFHpAOCSgHqAcCIFGcAI6MBKKCBHVAEAM0MBCBHVINAEAVFAVCJ1JJBFrBB86BBAVCEFGVCZ9HMBKAEAB9rAVFHVKALC/AEF8kJJJJBAVKzEEUCBHDDNINADCEFGDC8f0MECEADTAE6MBKKADCRFCfEgCR9uCI2CDFABCI9u2ChFKMBCBABbDn+KJJBK+cDEWU8jJJJJBCZ9rHLCBHVDNAICVFAE0MBCBHOABCBrBn+KJJBC/QEv86BBAL9CB83IWABCEFHRABAEFC98FHWDNAItMBCBHdINDNARAW6MBCBSKADAdCDTFYDBGQALCWFAOAQALCWFAOCDTFYDB9rGEAEC8f91GEFAE7C507GOCDTFGKYDB9rGEC8e91C9+gAECDT7AOvHEINARAECfB0GVCRTAECfBgv86BBAECR4HEARCEFHRAVMBKAKAQbDBAdCEFGdAI9HMBKKCBHVARAW0MBARCBbBBARAB9rCLFHVKAVKbEEUCBHDDNINADCEFGDC8f0MECEADTAE6MBKKADCWFCfEgCR9uAB2CVFK+DVLI99DUI99LUDNAEtMBCUADCETCUFTCU7+yHVDNDNCUAICUFTCU7+yGOjBBBzmGR+LjBBB9P9dtMBAR+oHWXEKCJJJJ94HWKCBHICBHdINALCLFiDBGRjBBBBjBBJzALiDBGQ+LAR+LmALCWFiDBGK+LmGR+VARjBBBB9beGRnHXAQARnHRALCXFiDBHQDNDNAKjBBBB9gtMBAXHKXEKjBBJzAR+L+TGKAK+MAXjBBBB9geHKjBBJzAX+L+TGXAX+MARjBBBB9geHRKDNDNAQjBBJ+/AQjBBJ+/9geGXjBBJzAXjBBJz9feAVnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHMXEKCJJJJ94HMKDNDNAKjBBJ+/AKjBBJ+/9geGQjBBJzAQjBBJz9feAOnjBBBzjBBB+/AKjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHpXEKCJJJJ94HpKDNDNARjBBJ+/ARjBBJ+/9geGQjBBJzAQjBBJz9feAOnjBBBzjBBB+/ARjBBBB9gemGR+LjBBB9P9dtMBAR+oHSXEKCJJJJ94HSKDNDNADCL9HMBABAdFGZAS86BBAZCIFAM86BBAZCDFAW86BBAZCEFAp86BBXEKABAIFGZAS87EBAZCOFAM87EBAZCLFAW87EBAZCDFAp87EBKALCZFHLAICWFHIAdCLFHdAECUFGEMBKKK/KLLD99EUD99EUDNAEtMBDNDNCUAICUFTCU7+yGVjBBBzmGO+LjBBB9P9dtMBAO+oHIXEKCJJJJ94HIKAIC/8fIgHRINABCOFCICDALCLFiDB+LALiDB+L9eGIALCWFiDB+LALAICDTFiDB+L9eeGIALCXFiDB+LALAICDTFiDB+L9eeGIARv87EBDNDNALAICEFCIgCDTFiDBj/zL+1znjBBJ+/jBBJzALAICDTFiDBjBBBB9deGOnGWjBBJ+/AWjBBJ+/9geGdjBBJzAdjBBJz9feAVnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHQXEKCJJJJ94HQKABAQ87EBDNDNAOALAICDFCIgCDTFiDBj/zL+1znnGWjBBJ+/AWjBBJ+/9geGdjBBJzAdjBBJz9feAVnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHQXEKCJJJJ94HQKABCDFAQ87EBDNDNAOALAICUFCIgCDTFiDBj/zL+1znnGOjBBJ+/AOjBBJ+/9geGWjBBJzAWjBBJz9feAVnjBBBzjBBB+/AOjBBBB9gemGO+LjBBB9P9dtMBAO+oHIXEKCJJJJ94HIKABCLFAI87EBABCWFHBALCZFHLAECUFGEMBKKK+7DDWUE998jJJJJBCZ9rGV8kJJJJBDNAEtMBADCL6MBCEAI9rHOADCD4GDCEADCE0eHRADCDTHWCBHdINC+cUHDALHIARHQINAIiDBAVCXFZ+XJJJB8aAVYDXGKADADAK9IeHDAICLFHIAQCUFGQMBKAOADFGICkTHKCBHDCBAI9rHXARHIINDNDNALADFiDBGMAXZ+WJJJBjBBBzjBBB+/AMjBBBB9gemGM+LjBBB9P9dtMBAM+oHQXEKCJJJJ94HQKABADFAQCfffRgAKvbDBADCLFHDAICUFGIMBKABAWFHBALAWFHLAdCEFGdAE9HMBKKAVCZF8kJJJJBK/tKDcUI998jJJJJBC+QD9rGV8kJJJJBAVC+oEFCBC/kBZ+TJJJB8aCBHODNADtMBCBHOAItMBDNABAE9HMBAVCUADCDTGOADCffffI0eCBYD1+KJJBhJJJJBBGEbD+oEAVCEbD1DAEABAOZmJJJB8aKAVC+YEFCWFCBbDBAV9CB83I+YEAVC+YEFAEADAIAVC+oEFZ+NJJJBCUAICDTGRAICffffI0eGWCBYD1+KJJBhJJJJBBHOAVC+oEFAVYD1DGdCDTFAObDBAVAdCEFGQbD1DAOAVYD+YEGKARZmJJJBHXAVC+oEFAQCDTFADCI9uGMCBYD1+KJJBhJJJJBBGObDBAVAdCDFGRbD1DAOCBAMZ+TJJJBHpAVC+oEFARCDTFAWCBYD1+KJJBhJJJJBBGSbDBAVAdCIFGQbD1DAXHOASHRINARALiDBALAOYDBGWCWAWCW6eCDTFC/EBFiDBmuDBAOCLFHOARCLFHRAICUFGIMBKAVC+oEFAQCDTFCUAMCDTADCffff970eCBYD1+KJJBhJJJJBBGQbDBAVAdCLFbD1DDNADCI6MBAMCEAMCE0eHIAEHOAQHRINARASAOYDBCDTFiDBASAOCLFYDBCDTFiDBmASAOCWFYDBCDTFiDBmuDBAOCXFHOARCLFHRAICUFGIMBKKAVC/MBFHZAVYD+cEHhAVYD+gEHoAVHOCBHWCBHRCBHaCEHcINAOHxCIHqAEARCI2GlCDTFGOCWFYDBHkAOYDBHDABAaCX2FGICLFAOCLFYDBGdbDBAIADbDBAICWFAkbDBApARFCE86BBAZAkbDWAZAdbDLAZADbDBAQARCDTFCBbDBDNAWtMBCIHqAxHIINDNAIYDBGOADsMBAOAdsMBAOAksMBAZAqCDTFAObDBAqCEFHqKAICLFHIAWCUFGWMBKKAaCEFHaAXADCDTFGOAOYDBCUFbDBAXAdCDTFGOAOYDBCUFbDBAXAkCDTFGOAOYDBCUFbDBCBHWINAoAhAEAWAlFCDTFYDBCDTGIFYDBCDTFGkHOAKAIFGdYDBGDHIDNADtMBDNINAOYDBARsMEAOCLFHOAICUFGItMDXBKKAOADCDTAkFC98FYDBbDBAdAdYDBCUFbDBKAWCEFGWCI9HMBKDNDNDNAqtMBCUHRjBBBBHyCBHOINASAZAOCDTFYDBCDTGIFGWiDBH8aAWALCBAOCEFGdAOCS0eCDTFiDBALAXAIFYDBGOCWAOCW6eCDTFC/EBFiDBmGeuDBDNAKAIFYDBGWtMBAeA8a+THeAoAhAIFYDBCDTFHOAWCDTHIINAQAOYDBGWCDTFGDAeADiDBmG8auDBA8aAyAyA8a9dGDeHyAWARADeHRAOCLFHOAIC98FGIMBKKAdHOAdAq9HMBKARCU9HMEKAcAM9PMEINDNApAcFrBBMBAcHRXDKAMAcCEFGc9HMBXDKKAqCZAqCZ6eHWAZHOAxHZARCU9HMEKKAVYD1DHOKAOCDTAVC+oEFFC98FHRDNINAOtMEARYDBCBYD+E+KJJBh+BJJJBBARC98FHRAOCUFHOXBKKAVC+QDF8kJJJJBK/uLEVUCUAICDTGVAICffffI0eGOCBYD1+KJJBhJJJJBBHRALALYD9gGWCDTFARbDBALAWCEFbD9gABARbDBAOCBYD1+KJJBhJJJJBBHRALALYD9gGOCDTFARbDBALAOCEFbD9gABARbDLCUADCDTADCffffI0eCBYD1+KJJBhJJJJBBHRALALYD9gGOCDTFARbDBALAOCEFbD9gABARbDWABYDBCBAVZ+TJJJB8aADCI9uHWDNADtMBABYDBHOAEHLADHRINAOALYDBCDTFGVAVYDBCEFbDBALCLFHLARCUFGRMBKKDNAItMBABYDBHLABYDLHRCBHVAIHOINARAVbDBARCLFHRALYDBAVFHVALCLFHLAOCUFGOMBKKDNADCI6MBAWCEAWCE0eHdABYDLHRABYDWHVCBHLINAECWFYDBHOAECLFYDBHDARAEYDBCDTFGWAWYDBGWCEFbDBAVAWCDTFALbDBARADCDTFGDADYDBGDCEFbDBAVADCDTFALbDBARAOCDTFGOAOYDBGOCEFbDBAVAOCDTFALbDBAECXFHEAdALCEFGL9HMBKKDNAItMBABYDLHEABYDBHLINAEAEYDBALYDB9rbDBALCLFHLAECLFHEAICUFGIMBKKKqBABAEADAIC+01JJBZ+MJJJBKqBABAEADAIC+c+JJJBZ+MJJJBK9dEEUABCfEAICDTZ+TJJJBHLCBHIDNADtMBINDNALAEYDBCDTFGBYDBCU9HMBABAIbDBAICEFHIKAECLFHEADCUFGDMBKKAIK9TEIUCBCBYD+M+KJJBGEABCIFC98gFGBbD+M+KJJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABK9TEIUCBCBYD+M+KJJBGEABCIFC98gFGBbD+M+KJJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK9+EIUzBHEDNDNCBYD+M+KJJBGDAECZTGI9NMBCUHEADAI9rCffIFCZ4NBCUsMEKADHEKCBABAE9rCIFC98gCBYD+M+KJJBFGDbD+M+KJJBDNADzBCZTGE9NMBADAE9rCffIFCZ4NB8aKKXBABAEZ+YJJJBK+BEEIUDNAB+8GDCl4GICfEgGLCfEsMBDNALMBDNABjBBBB9cMBAECBbDBABSKABjBBJ9fnAEZ+XJJJBHBAEAEYDBCNFbDBABSKAEAICfEgC+CUFbDBADCfff+D94gCJJJ/4Iv++HBKABK+gEBDNDNAECJE9IMBABjBBBUnHBDNAECfE9PMBAEC+BUFHEXDKABjBBBUnHBAECPDAECPD6eC+C9+FHEXEKAEC+BU9KMBABjBBJXnHBDNAEC+b9+9NMBAEC/mBFHEXEKABjBBJXnHBAEC+299AEC+2990eC/MEFHEKABAEClTCJJJ/8IF++nKK+eDDBCJWK+EDB4+H9W9n94+p+Gw+J9o+YE9pBBBBBBEBBBDBBBEBBBDBBBBBBBDBBBBBBBEBBBBBBB+L29Hz/69+9Kz/n/76z/RG97z/Z/O9Xz8j/b85z/+/U9Yz/B/K9hz+2/z9dz9E+L9Mz59a8kz+R/t3z+a+Zyz79ohz/J4++8++y+d9v8+BBBB9S+49+z8r+Hbz9m9m/m8+l/Z/O8+/8+pg89Q/X+j878r+Hq8++m+b/E87BBBBBBJzBBJzBBJz+e/v/n8++y+dSz9I/h/68+XD/r8+/H0838+/w+nOzBBBB+wv9o8+UF888+9I/h/68+9C9g/l89/N/M9M89/d8kO8+BBBBF+8Tz9M836zs+2azl/Zpzz818ez9E+LXz/u98f8+819e/68+BC+EQKXEBBBDBBBAwBB", K = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var pe, me = WebAssembly.instantiate(ge(fe), {}).then(function (Se) { pe = Se.instance, pe.exports.__wasm_call_ctors(), pe.exports.meshopt_encodeVertexVersion(0), pe.exports.meshopt_encodeIndexVersion(1) }); function ge(Se) { for (var Ce = new Uint8Array(Se.length), we = 0; we < Se.length; ++we) { var Be = Se.charCodeAt(we); Ce[we] = Be > 96 ? Be - 71 : Be > 64 ? Be - 65 : Be > 47 ? Be + 4 : Be > 46 ? 63 : 62 } for (var De = 0, we = 0; we < Se.length; ++we)Ce[De++] = Ce[we] < 60 ? K[Ce[we]] : (Ce[we] - 60) * 64 + Ce[++we]; return Ce.buffer.slice(0, De) } function xe(Se) { if (!Se) throw new Error("Assertion failed") } function ye(Se) { return new Uint8Array(Se.buffer, Se.byteOffset, Se.byteLength) } function ve(Se, Ce, we) { var Be = pe.exports.sbrk, De = Be(Se.length * 4), Re = Be(Ce * 4), Ie = new Uint8Array(pe.exports.memory.buffer), Pe = ye(Se); Ie.set(Pe, De), we && we(De, De, Se.length, Ce); var Ne = pe.exports.meshopt_optimizeVertexFetchRemap(Re, De, Se.length, Ce); Ie = new Uint8Array(pe.exports.memory.buffer); var ke = new Uint32Array(Ce); new Uint8Array(ke.buffer).set(Ie.subarray(Re, Re + Ce * 4)), Pe.set(Ie.subarray(De, De + Se.length * 4)), Be(De - Be(0)); for (var Oe = 0; Oe < Se.length; ++Oe)Se[Oe] = ke[Se[Oe]]; return [ke, Ne] } function _e(Se, Ce, we, Be, De) { var Re = pe.exports.sbrk, Ie = Re(Ce), Pe = Re(Be * De), Ne = new Uint8Array(pe.exports.memory.buffer); Ne.set(ye(we), Pe); var ke = Se(Ie, Ce, Pe, Be, De), Oe = new Uint8Array(ke); return Oe.set(Ne.subarray(Ie, Ie + ke)), Re(Ie - Re(0)), Oe } function Ee(Se) { for (var Ce = 0, we = 0; we < Se.length; ++we) { var Be = Se[we]; Ce = Ce < Be ? Be : Ce } return Ce } function be(Se, Ce) { if (xe(Ce == 2 || Ce == 4), Ce == 4) return new Uint32Array(Se.buffer, Se.byteOffset, Se.byteLength / 4); var we = new Uint16Array(Se.buffer, Se.byteOffset, Se.byteLength / 2); return new Uint32Array(we) } function Ae(Se, Ce, we, Be, De, Re) { var Ie = pe.exports.sbrk, Pe = Ie(we * Be), Ne = Ie(we * Re), ke = new Uint8Array(pe.exports.memory.buffer); ke.set(ye(Ce), Ne), Se(Pe, we, Be, De, Ne); var Oe = new Uint8Array(we * Be); return Oe.set(ke.subarray(Pe, Pe + we * Be)), Ie(Pe - Ie(0)), Oe } return { ready: me, supported: !0, reorderMesh: function (Se, Ce, we) { var Be = Ce ? we ? pe.exports.meshopt_optimizeVertexCacheStrip : pe.exports.meshopt_optimizeVertexCache : void 0; return ve(Se, Ee(Se) + 1, Be) }, encodeVertexBuffer: function (Se, Ce, we) { xe(we > 0 && we <= 256), xe(we % 4 == 0); var Be = pe.exports.meshopt_encodeVertexBufferBound(Ce, we); return _e(pe.exports.meshopt_encodeVertexBuffer, Be, Se, Ce, we) }, encodeIndexBuffer: function (Se, Ce, we) { xe(we == 2 || we == 4), xe(Ce % 3 == 0); var Be = be(Se, we), De = pe.exports.meshopt_encodeIndexBufferBound(Ce, Ee(Be) + 1); return _e(pe.exports.meshopt_encodeIndexBuffer, De, Be, Ce, 4) }, encodeIndexSequence: function (Se, Ce, we) { xe(we == 2 || we == 4); var Be = be(Se, we), De = pe.exports.meshopt_encodeIndexSequenceBound(Ce, Ee(Be) + 1); return _e(pe.exports.meshopt_encodeIndexSequence, De, Be, Ce, 4) }, encodeGltfBuffer: function (Se, Ce, we, Be) { var De = { ATTRIBUTES: this.encodeVertexBuffer, TRIANGLES: this.encodeIndexBuffer, INDICES: this.encodeIndexSequence }; return xe(De[Be]), De[Be](Se, Ce, we) }, encodeFilterOct: function (Se, Ce, we, Be) { return xe(we == 4 || we == 8), xe(Be >= 1 && Be <= 16), Ae(pe.exports.meshopt_encodeFilterOct, Se, Ce, we, Be, 16) }, encodeFilterQuat: function (Se, Ce, we, Be) { return xe(we == 8), xe(Be >= 4 && Be <= 16), Ae(pe.exports.meshopt_encodeFilterQuat, Se, Ce, we, Be, 16) }, encodeFilterExp: function (Se, Ce, we, Be) { return xe(we > 0 && we % 4 == 0), xe(Be >= 1 && Be <= 24), Ae(pe.exports.meshopt_encodeFilterExp, Se, Ce, we, Be, we) } } })(); (function () { var fe = "B9h79tEBBBE8fV9gBB9gVUUUUUEU9gIUUUB9gEUEU9gIUUUEUIKQBEEEDDDILLVIEBEOWEUEC+Q/IEKR/LEdO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9f9kw9j9v9kw9WwvTw949C919m9mwvBEy9tw79o9v9wT9f9kw9j9v9kw69u9kw949C919m9mwvBDe9tw79o9v9wT9f9kw9j9v9kw69u9kw949Twg91w9u9jwBIl9tw79o9v9wT9f9kw9j9v9kws9p2Twv9P9jTBLk9tw79o9v9wT9f9kw9j9v9kws9p2Twv9R919hTBVl9tw79o9v9wT9f9kw9j9v9kws9p2Twvt949wBOL79iv9rBRQ+p8yQDBK/3SEZU8jJJJJBCJ/EB9rGV8kJJJJBC9+HODNADCEFAL0MBCUHOAIrBBC+gE9HMBAVAIALFGRAD9rADZ1JJJBHWCJ/ABAD9uHOAICEFHLDNADtMBAOC/wfBgGOCJDAOCJD6eHdCBHQINAQAE9PMEAdAEAQ9rAQAdFAE6eGKCSFGOCL4CIFCD4HXDNDNDNDNAOC9wgGMtMBCBHpCEHSAWCJDFHZALHhINARAh9rAX6MIDNARAhAXFGL9rCk6MBCZHOINAWCJ/CBFAOGIFGOC9wFHoDNDNDNDNDNAhAIC9wFGaCO4FrBBAaCI4COg4CIgpLBEDIBKAo9CB83IBAoCWF9CB83IBXIKAoALrBLALrBBGaCO4GcAcCIsGce86BBAOCgFALCLFAcFGorBBAaCL4CIgGcAcCIsGce86BBAOCvFAoAcFGorBBAaCD4CIgGcAcCIsGce86BBAOC7FAoAcFGorBBAaCIgGaAaCIsGae86BBAOCTFAoAaFGarBBALrBEGoCO4GcAcCIsGce86BBAOC91FAaAcFGarBBAoCL4CIgGcAcCIsGce86BBAOC4FAaAcFGarBBAoCD4CIgGcAcCIsGce86BBAOC93FAaAcFGarBBAoCIgGoAoCIsGoe86BBAOC94FAaAoFGarBBALrBDGoCO4GcAcCIsGce86BBAOC95FAaAcFGarBBAoCL4CIgGcAcCIsGce86BBAOC96FAaAcFGarBBAoCD4CIgGcAcCIsGce86BBAOC97FAaAcFGarBBAoCIgGoAoCIsGoe86BBAOC98FAaAoFGorBBALrBIGLCO4GaAaCIsGae86BBAOC99FAoAaFGorBBALCL4CIgGaAaCIsGae86BBAOC9+FAoAaFGorBBALCD4CIgGaAaCIsGae86BBAOCUFAoAaFGOrBBALCIgGLALCIsGLe86BBAOALFHLXDKAoALrBWALrBBGaCL4GcAcCSsGce86BBAOCgFALCWFAcFGorBBAaCSgGaAaCSsGae86BBAOCvFAoAaFGorBBALrBEGaCL4GcAcCSsGce86BBAOC7FAoAcFGorBBAaCSgGaAaCSsGae86BBAOCTFAoAaFGorBBALrBDGaCL4GcAcCSsGce86BBAOC91FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC4FAoAaFGorBBALrBIGaCL4GcAcCSsGce86BBAOC93FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC94FAoAaFGorBBALrBLGaCL4GcAcCSsGce86BBAOC95FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC96FAoAaFGorBBALrBVGaCL4GcAcCSsGce86BBAOC97FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC98FAoAaFGorBBALrBOGaCL4GcAcCSsGce86BBAOC99FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC9+FAoAaFGorBBALrBRGLCL4GaAaCSsGae86BBAOCUFAoAaFGOrBBALCSgGLALCSsGLe86BBAOALFHLXEKAoAL8pBB83BBAoCWFALCWF8pBB83BBALCZFHLKDNAIAM9PMBAICZFHOARAL9rCl0MEKKAIAM6MIALtMIDNAKtMBAWApFrBBHoCBHOAZHIINAIAWCJ/CBFAOFrBBGaCE4CBAaCEg9r7AoFGo86BBAIADFHIAOCEFGOAK9HMBKKAZCEFHZApCEFGpAD6HSALHhApAD9HMEXVKKCBHLASCEgMDXIKALAXAD2FHcDNAKtMBCBHhCEHSAWCJDFHMINARAL9rAX6MIALtMDALAXFHLAWAhFrBBHoCBHOAMHIINAIAWCJ/CBFAOFrBBGaCE4CBAaCEg9r7AoFGo86BBAIADFHIAOCEFGOAK9HMBKAMCEFHMAhCEFGhAD6HSAhAD9HMBKAcHLXIKCBHOCEHSINARAL9rAX6MDALtMEALAXFHLAOCEFGOAD6HSADAO9HMBKAcHLXDKCBHLASCEgtMEKC9+HOXIKABAQAD2FAWCJDFAKAD2Z1JJJB8aAWAWCJDFAKCUFAD2FADZ1JJJB8aAKAQFHQALMBKC9+HOXEKCBC99ARAL9rADCAADCA0eseHOKAVCJ/EBF8kJJJJBAOK/YZEhU8jJJJJBC/AE9rGV8kJJJJBC9+HODNAECI9uGRChFAL0MBCUHOAIrBBGWC/wEgC/gE9HMBAWCSgGdCE0MBAVC/ABFCfECJEZ+JJJJB8aAVCuF9CU83IBAVC8wF9CU83IBAVCYF9CU83IBAVCAF9CU83IBAVCkF9CU83IBAVCZF9CU83IBAV9CU83IWAV9CU83IBAIALFC9wFHQAICEFGWARFHODNAEtMBCMCSAdCEseHKCBHXCBHMCBHdCBHICBHLINDNAOAQ9NMBC9+HOXIKDNDNAWrBBGRC/vE0MBAVC/ABFALARCL4CU7FCSgCITFGpYDLHSApYDBHZDNARCSgGpAK9PMBAVAIARCU7FCSgCDTFYDBAXApeHRAptHpDNDNADCD9HMBABAdCETFGhAZ87EBAhCDFAS87EBAhCLFAR87EBXEKABAdCDTFGhAZbDBAhCLFASbDBAhCWFARbDBKAXApFHXAVC/ABFALCITFGhARbDBAhASbDLAVAICDTFARbDBAVC/ABFALCEFCSgGLCITFGhAZbDBAhARbDLAIApFHIALCEFHLXDKDNDNApCSsMBAMApFApC987FCEFHMXEKAOCEFHRAO8sBBGpCfEgHhDNDNApCU9MMBARHOXEKAOCVFHOAhCfBgHhCRHpDNINAR8sBBGoCfBgApTAhvHhAoCU9KMEARCEFHRApCRFGpC8j9HMBXDKKARCEFHOKAhCE4CBAhCEg9r7AMFHMKDNDNADCD9HMBABAdCETFGRAZ87EBARCDFAS87EBARCLFAM87EBXEKABAdCDTFGRAZbDBARCLFASbDBARCWFAMbDBKAVC/ABFALCITFGRAMbDBARASbDLAVAICDTFAMbDBAVC/ABFALCEFCSgGLCITFGRAZbDBARAMbDLAICEFHIALCEFHLXEKDNARCPE0MBAXCEFGoAVAIAQARCSgFrBBGpCL49rCSgCDTFYDBApCZ6GheHRAVAIAp9rCSgCDTFYDBAoAhFGSApCSgGoeHpAotHoDNDNADCD9HMBABAdCETFGZAX87EBAZCDFAR87EBAZCLFAp87EBXEKABAdCDTFGZAXbDBAZCLFARbDBAZCWFApbDBKAVAICDTFAXbDBAVC/ABFALCITFGZARbDBAZAXbDLAVAICEFGICSgCDTFARbDBAVC/ABFALCEFCSgCITFGZApbDBAZARbDLAVAIAhFCSgGICDTFApbDBAVC/ABFALCDFCSgGLCITFGRAXbDBARApbDLALCEFHLAIAoFHIASAoFHXXEKAXCBAOrBBGZeGaARC/+EsGRFHSAZCSgHcAZCL4HxDNDNAZCS0MBASCEFHoXEKASHoAVAIAx9rCSgCDTFYDBHSKDNDNAcMBAoCEFHXXEKAoHXAVAIAZ9rCSgCDTFYDBHoKDNDNARtMBAOCEFHRXEKAOCDFHRAO8sBEGhCfEgHpDNAhCU9KMBAOCOFHaApCfBgHpCRHODNINAR8sBBGhCfBgAOTApvHpAhCU9KMEARCEFHRAOCRFGOC8j9HMBKAaHRXEKARCEFHRKApCE4CBApCEg9r7AMFGMHaKDNDNAxCSsMBARHpXEKARCEFHpAR8sBBGOCfEgHhDNAOCU9KMBARCVFHSAhCfBgHhCRHODNINAp8sBBGRCfBgAOTAhvHhARCU9KMEApCEFHpAOCRFGOC8j9HMBKASHpXEKApCEFHpKAhCE4CBAhCEg9r7AMFGMHSKDNDNAcCSsMBApHOXEKApCEFHOAp8sBBGRCfEgHhDNARCU9KMBApCVFHoAhCfBgHhCRHRDNINAO8sBBGpCfBgARTAhvHhApCU9KMEAOCEFHOARCRFGRC8j9HMBKAoHOXEKAOCEFHOKAhCE4CBAhCEg9r7AMFGMHoKDNDNADCD9HMBABAdCETFGRAa87EBARCDFAS87EBARCLFAo87EBXEKABAdCDTFGRAabDBARCLFASbDBARCWFAobDBKAVC/ABFALCITFGRASbDBARAabDLAVAICDTFAabDBAVC/ABFALCEFCSgCITFGRAobDBARASbDLAVAICEFGICSgCDTFASbDBAVC/ABFALCDFCSgCITFGRAabDBARAobDLAVAIAZCZ6AxCSsvFGICSgCDTFAobDBAIActAcCSsvFHIALCIFHLKAWCEFHWALCSgHLAICSgHIAdCIFGdAE6MBKKCBC99AOAQseHOKAVC/AEF8kJJJJBAOK+LLEVU8jJJJJBCZ9rHVC9+HODNAECVFAL0MBCUHOAIrBBC/+EgC/QE9HMBAV9CB83IWAICEFHRAIALFC98FHWDNAEtMBDNADCDsMBCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCDTFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGLbDBAOALbDBAdCEFGdAE9HMBXDKKCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCETFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGL87EBAOALbDBAdCEFGdAE9HMBKKCBC99ARAWseHOKAOK+lVOEUE99DUD99EUD99DNDNADCL9HMBAEtMEINDNDNABCDFGD8sBB+yAB8sBBGI+yGL+L+TABCEFGV8sBBGO+yGR+L+TGWjBB/+9CAWAWnjBBBBAWAWjBBBB9gGdeGQ+MGKAQAICB9IeALmGWAWnAKAQAOCB9IeARmGQAQnmm+R+VGLnjBBBzjBBB+/AdemGR+LjBBB9P9dtMBAR+oHIXEKCJJJJ94HIKADAI86BBDNDNAQALnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHDXEKCJJJJ94HDKAVAD86BBDNDNAWALnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHDXEKCJJJJ94HDKABAD86BBABCLFHBAECUFGEMBXDKKAEtMBINDNDNABCLFGD8uEB+yAB8uEBGI+yGL+L+TABCDFGV8uEBGO+yGR+L+TGWjB/+fsAWAWnjBBBBAWAWjBBBB9gGdeGQ+MGKAQAICB9IeALmGWAWnAKAQAOCB9IeARmGQAQnmm+R+VGLnjBBBzjBBB+/AdemGR+LjBBB9P9dtMBAR+oHIXEKCJJJJ94HIKADAI87EBDNDNAQALnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHDXEKCJJJJ94HDKAVAD87EBDNDNAWALnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHDXEKCJJJJ94HDKABAD87EBABCWFHBAECUFGEMBKKK/SILIUI99IUE99DNAEtMBCBHIABHLINDNDNj/zL81zALCOF8uEBGVCIv+y+VGOAL8uEB+ynGRjB/+fsnjBBBzjBBB+/ARjBBBB9gemGW+LjBBB9P9dtMBAW+oHdXEKCJJJJ94HdKALCLF8uEBHQALCDF8uEBHKABAVCEFCIgAIvCETFAd87EBDNDNAOAK+ynGWjB/+fsnjBBBzjBBB+/AWjBBBB9gemGX+LjBBB9P9dtMBAX+oHKXEKCJJJJ94HKKABAVCDFCIgAIvCETFAK87EBDNDNAOAQ+ynGOjB/+fsnjBBBzjBBB+/AOjBBBB9gemGX+LjBBB9P9dtMBAX+oHQXEKCJJJJ94HQKABAVCUFCIgAIvCETFAQ87EBDNDNjBBJzARARn+TAWAWn+TAOAOn+TGRjBBBBARjBBBB9ge+RjB/+fsnjBBBzmGR+LjBBB9P9dtMBAR+oHQXEKCJJJJ94HQKABAVCIgAIvCETFAQ87EBALCWFHLAICLFHIAECUFGEMBKKK9MBDNADCD4AE2GEtMBINABABYDBGDCWTCW91+yADCE91CJJJ/8IFCJJJ98g++nuDBABCLFHBAECUFGEMBKKK9TEIUCBCBYDJ1JJBGEABCIFC98gFGBbDJ1JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABKKKEBCJWKLZ9kBB", K = "B9h79tEBBBEkL9gBB9gVUUUUUEU9gIUUUB9gEUEUIKQBBEBEEDDDILVE9wEEEVIEBEOWEUEC+Q/aEKR/LEdO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9f9kw9j9v9kw9WwvTw949C919m9mwvBDy9tw79o9v9wT9f9kw9j9v9kw69u9kw949C919m9mwvBLe9tw79o9v9wT9f9kw9j9v9kw69u9kw949Twg91w9u9jwBVl9tw79o9v9wT9f9kw9j9v9kws9p2Twv9P9jTBOk9tw79o9v9wT9f9kw9j9v9kws9p2Twv9R919hTBRl9tw79o9v9wT9f9kw9j9v9kws9p2Twvt949wBWL79iv9rBdQ/T9TQLBZIK9+EVU8jJJJJBCZ9rHBCBHEINCBHDCBHIINABCWFADFAICJUAEAD4CEgGLe86BBAIALFHIADCEFGDCW9HMBKAEC+Q+YJJBFAI86BBAECITC+Q1JJBFAB8pIW83IBAECEFGECJD9HMBKK/H8jLhUD97EUO978jJJJJBCJ/KB9rGV8kJJJJBC9+HODNADCEFAL0MBCUHOAIrBBC+gE9HMBAVAIALFGRAD9rAD/8QBBCJ/ABAD9uHOAICEFHLDNADtMBAOC/wfBgGOCJDAOCJD6eHWCBHdINAdAE9PMEAWAEAd9rAdAWFAE6eGQCSFGOC9wgGKCI2HXAKCETHMAOCL4CIFCD4HpABAdAD2FHSCBHZDNINCEHhALHoCBHaDNINARAo9rAp6MIAVCJ/CBFAaAK2FHcAoApFHLCBHIDNAKC/AB6MBARAL9rC/gB6MBCBHOINAcAOFHIDNDNDNDNDNAoAOCO4FrBBGxCIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLBXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLBALCZFHLKDNDNDNDNDNAxCD4CIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLZXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLZALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLZALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLZALCZFHLKDNDNDNDNDNAxCL4CIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLAXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLAALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLAALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLAALCZFHLKDNDNDNDNDNAxCO4pLBEDIBKAIPXBBBBBBBBBBBBBBBBPKL8wXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBAxC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKL8wALCLFAyPqBFAxC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBAxC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKL8wALCWFAyPqBFAxC+Q+YJJBFrBBFHLXEKAIALPBBBPKL8wALCZFHLKAOC/ABFHIAOCJEFAK0MEAIHOARAL9rC/fB0MBKKDNDNAIAK9PMBAICI4HOINARAL9rCk6MDAcAIFHxDNDNDNDNDNAoAICO4FrBBAOCOg4CIgpLBEDIBKAxPXBBBBBBBBBBBBBBBBPKLBXIKAxALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAxALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAxALPBBBPKLBALCZFHLKAOCDFHOAICZFGIAK6MBKKALtMBAaCI6HhALHoAaCEFGOHaAOCLsMDXEKKCBHLAhCEgMDKDNAKtMBAVCJDFAZFHIAVAZFPBDBHyCBHxINAIAVCJ/CBFAxFGOPBLBGlCEP9tAlPXEEEEEEEEEEEEEEEEGqP9OP9hP9RGlAOAKFPBLBG8aCEP9tA8aAqP9OP9hP9RG8aPMBZEhDoIaLcVxOqRlGeAOAMFPBLBG3CEP9tA3AqP9OP9hP9RG3AOAXFPBLBG5CEP9tA5AqP9OP9hP9RG5PMBZEhDoIaLcVxOqRlG8ePMBEZhDIoaLVcxORqlGqAqPMBEDIBEDIBEDIBEDIAyP9uGyP9aDBBAIADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAeA8ePMWdkyQK8aeXM35pS8e8fGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAlA8aPMWkdyQ8aKeX3M5p8eS8fGlA3A5PMWkdyQ8aKeX3M5p8eS8fG8aPMBEZhDIoaLVcxORqlGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAlA8aPMWdkyQK8aeXM35pS8e8fGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFHIAxCZFGxAK6MBKKAZCLFGZAD6MBKASAVCJDFAQAD2/8QBBAVAVCJDFAQCUFAD2FAD/8QBBAQAdFHdC9+HOALMEXIKKC9+HOXEKCBC99ARAL9rADCAADCA0eseHOKAVCJ/KBF8kJJJJBAOKWBZ+BJJJBK/UZEhU8jJJJJBC/AE9rGV8kJJJJBC9+HODNAECI9uGRChFAL0MBCUHOAIrBBGWC/wEgC/gE9HMBAWCSgGdCE0MBAVC/ABFCfECJE/8KBAVCuF9CU83IBAVC8wF9CU83IBAVCYF9CU83IBAVCAF9CU83IBAVCkF9CU83IBAVCZF9CU83IBAV9CU83IWAV9CU83IBAIALFC9wFHQAICEFGWARFHODNAEtMBCMCSAdCEseHKCBHXCBHMCBHdCBHICBHLINDNAOAQ9NMBC9+HOXIKDNDNAWrBBGRC/vE0MBAVC/ABFALARCL4CU7FCSgCITFGpYDLHSApYDBHZDNARCSgGpAK9PMBAVAIARCU7FCSgCDTFYDBAXApeHRAptHpDNDNADCD9HMBABAdCETFGhAZ87EBAhCDFAS87EBAhCLFAR87EBXEKABAdCDTFGhAZbDBAhCLFASbDBAhCWFARbDBKAXApFHXAVC/ABFALCITFGhARbDBAhASbDLAVAICDTFARbDBAVC/ABFALCEFCSgGLCITFGhAZbDBAhARbDLAIApFHIALCEFHLXDKDNDNApCSsMBAMApFApC987FCEFHMXEKAOCEFHRAO8sBBGpCfEgHhDNDNApCU9MMBARHOXEKAOCVFHOAhCfBgHhCRHpDNINAR8sBBGoCfBgApTAhvHhAoCU9KMEARCEFHRApCRFGpC8j9HMBXDKKARCEFHOKAhCE4CBAhCEg9r7AMFHMKDNDNADCD9HMBABAdCETFGRAZ87EBARCDFAS87EBARCLFAM87EBXEKABAdCDTFGRAZbDBARCLFASbDBARCWFAMbDBKAVC/ABFALCITFGRAMbDBARASbDLAVAICDTFAMbDBAVC/ABFALCEFCSgGLCITFGRAZbDBARAMbDLAICEFHIALCEFHLXEKDNARCPE0MBAXCEFGoAVAIAQARCSgFrBBGpCL49rCSgCDTFYDBApCZ6GheHRAVAIAp9rCSgCDTFYDBAoAhFGSApCSgGoeHpAotHoDNDNADCD9HMBABAdCETFGZAX87EBAZCDFAR87EBAZCLFAp87EBXEKABAdCDTFGZAXbDBAZCLFARbDBAZCWFApbDBKAVAICDTFAXbDBAVC/ABFALCITFGZARbDBAZAXbDLAVAICEFGICSgCDTFARbDBAVC/ABFALCEFCSgCITFGZApbDBAZARbDLAVAIAhFCSgGICDTFApbDBAVC/ABFALCDFCSgGLCITFGRAXbDBARApbDLALCEFHLAIAoFHIASAoFHXXEKAXCBAOrBBGZeGaARC/+EsGRFHSAZCSgHcAZCL4HxDNDNAZCS0MBASCEFHoXEKASHoAVAIAx9rCSgCDTFYDBHSKDNDNAcMBAoCEFHXXEKAoHXAVAIAZ9rCSgCDTFYDBHoKDNDNARtMBAOCEFHRXEKAOCDFHRAO8sBEGhCfEgHpDNAhCU9KMBAOCOFHaApCfBgHpCRHODNINAR8sBBGhCfBgAOTApvHpAhCU9KMEARCEFHRAOCRFGOC8j9HMBKAaHRXEKARCEFHRKApCE4CBApCEg9r7AMFGMHaKDNDNAxCSsMBARHpXEKARCEFHpAR8sBBGOCfEgHhDNAOCU9KMBARCVFHSAhCfBgHhCRHODNINAp8sBBGRCfBgAOTAhvHhARCU9KMEApCEFHpAOCRFGOC8j9HMBKASHpXEKApCEFHpKAhCE4CBAhCEg9r7AMFGMHSKDNDNAcCSsMBApHOXEKApCEFHOAp8sBBGRCfEgHhDNARCU9KMBApCVFHoAhCfBgHhCRHRDNINAO8sBBGpCfBgARTAhvHhApCU9KMEAOCEFHOARCRFGRC8j9HMBKAoHOXEKAOCEFHOKAhCE4CBAhCEg9r7AMFGMHoKDNDNADCD9HMBABAdCETFGRAa87EBARCDFAS87EBARCLFAo87EBXEKABAdCDTFGRAabDBARCLFASbDBARCWFAobDBKAVC/ABFALCITFGRASbDBARAabDLAVAICDTFAabDBAVC/ABFALCEFCSgCITFGRAobDBARASbDLAVAICEFGICSgCDTFASbDBAVC/ABFALCDFCSgCITFGRAabDBARAobDLAVAIAZCZ6AxCSsvFGICSgCDTFAobDBAIActAcCSsvFHIALCIFHLKAWCEFHWALCSgHLAICSgHIAdCIFGdAE6MBKKCBC99AOAQseHOKAVC/AEF8kJJJJBAOK+LLEVU8jJJJJBCZ9rHVC9+HODNAECVFAL0MBCUHOAIrBBC/+EgC/QE9HMBAV9CB83IWAICEFHRAIALFC98FHWDNAEtMBDNADCDsMBCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCDTFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGLbDBAOALbDBAdCEFGdAE9HMBXDKKCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCETFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGL87EBAOALbDBAdCEFGdAE9HMBKKCBC99ARAWseHOKAOK+epLIUO97EUE978jJJJJBCA9rHIDNDNADCL9HMBDNAEC98gGLtMBCBHVABHDINADADPBBBGOCkP+rECkP+sEP/6EGRAOCWP+rECkP+sEP/6EARP/gEAOCZP+rECkP+sEP/6EGWP/gEP/kEP/lEGdPXBBBBBBBBBBBBBBBBP+2EGQARPXBBBJBBBJBBBJBBBJGKP9OP9RP/kEGRPXBB/+9CBB/+9CBB/+9CBB/+9CARARP/mEAdAdP/mEAWAQAWAKP9OP9RP/kEGRARP/mEP/kEP/kEP/jEP/nEGWP/mEPXBBN0BBN0BBN0BBN0GQP/kEPXfBBBfBBBfBBBfBBBP9OAOPXBBBfBBBfBBBfBBBfP9OP9QARAWP/mEAQP/kECWP+rEPXBfBBBfBBBfBBBfBBP9OP9QAdAWP/mEAQP/kECZP+rEPXBBfBBBfBBBfBBBfBP9OP9QPKBBADCZFHDAVCLFGVAL6MBKKALAE9PMEAIAECIgGVCDTGDvCBCZAD9r/8KBAIABALCDTFGLAD/8QBBDNAVtMBAIAIPBLBGOCkP+rECkP+sEP/6EGRAOCWP+rECkP+sEP/6EARP/gEAOCZP+rECkP+sEP/6EGWP/gEP/kEP/lEGdPXBBBBBBBBBBBBBBBBP+2EGQARPXBBBJBBBJBBBJBBBJGKP9OP9RP/kEGRPXBB/+9CBB/+9CBB/+9CBB/+9CARARP/mEAdAdP/mEAWAQAWAKP9OP9RP/kEGRARP/mEP/kEP/kEP/jEP/nEGWP/mEPXBBN0BBN0BBN0BBN0GQP/kEPXfBBBfBBBfBBBfBBBP9OAOPXBBBfBBBfBBBfBBBfP9OP9QARAWP/mEAQP/kECWP+rEPXBfBBBfBBBfBBBfBBP9OP9QAdAWP/mEAQP/kECZP+rEPXBBfBBBfBBBfBBBfBP9OP9QPKLBKALAIAD/8QBBSKDNAEC98gGXtMBCBHVABHDINADCZFGLALPBBBGOPXBBBBBBffBBBBBBffGKP9OADPBBBGdAOPMLVORXMpScxql358e8fPXfUBBfUBBfUBBfUBBP9OP/6EAdAOPMBEDIWdQKZhoaky8aeGOCZP+sEP/6EGRP/gEAOCZP+rECZP+sEP/6EGWP/gEP/kEP/lEGOPXB/+fsB/+fsB/+fsB/+fsAWAOPXBBBBBBBBBBBBBBBBP+2EGQAWPXBBBJBBBJBBBJBBBJGMP9OP9RP/kEGWAWP/mEAOAOP/mEARAQARAMP9OP9RP/kEGOAOP/mEP/kEP/kEP/jEP/nEGRP/mEPXBBN0BBN0BBN0BBN0GQP/kECZP+rEAWARP/mEAQP/kEPXffBBffBBffBBffBBP9OP9QGWAOARP/mEAQP/kEPXffBBffBBffBBffBBP9OGOPMWdkyQK8aeXM35pS8e8fP9QPKBBADAdAKP9OAWAOPMBEZhDIoaLVcxORqlP9QPKBBADCAFHDAVCLFGVAX6MBKKAXAE9PMBAIAECIgGVCITGDFCBCAAD9r/8KBAIABAXCITFGLAD/8QBBDNAVtMBAIAIPBLZGOPXBBBBBBffBBBBBBffGKP9OAIPBLBGdAOPMLVORXMpScxql358e8fPXfUBBfUBBfUBBfUBBP9OP/6EAdAOPMBEDIWdQKZhoaky8aeGOCZP+sEP/6EGRP/gEAOCZP+rECZP+sEP/6EGWP/gEP/kEP/lEGOPXB/+fsB/+fsB/+fsB/+fsAWAOPXBBBBBBBBBBBBBBBBP+2EGQAWPXBBBJBBBJBBBJBBBJGMP9OP9RP/kEGWAWP/mEAOAOP/mEARAQARAMP9OP9RP/kEGOAOP/mEP/kEP/kEP/jEP/nEGRP/mEPXBBN0BBN0BBN0BBN0GQP/kECZP+rEAWARP/mEAQP/kEPXffBBffBBffBBffBBP9OP9QGWAOARP/mEAQP/kEPXffBBffBBffBBffBBP9OGOPMWdkyQK8aeXM35pS8e8fP9QPKLZAIAdAKP9OAWAOPMBEZhDIoaLVcxORqlP9QPKLBKALAIAD/8QBBKK/4WLLUE97EUV978jJJJJBC8w9rHIDNAEC98gGLtMBCBHVABHOINAIAOPBBBGRAOCZFGWPBBBGdPMLVORXMpScxql358e8fGQCZP+sEGKCLP+rEPKLBAOPXBBJzBBJzBBJzBBJzPX/zL81z/zL81z/zL81z/zL81zAKPXIBBBIBBBIBBBIBBBP9QP/6EP/nEGKARAdPMBEDIWdQKZhoaky8aeGRCZP+rECZP+sEP/6EP/mEGdAdP/mEAKARCZP+sEP/6EP/mEGXAXP/mEAKAQCZP+rECZP+sEP/6EP/mEGQAQP/mEP/kEP/kEP/lEPXBBBBBBBBBBBBBBBBP+4EP/jEPXB/+fsB/+fsB/+fsB/+fsGKP/mEPXBBN0BBN0BBN0BBN0GRP/kEPXffBBffBBffBBffBBGMP9OAXAKP/mEARP/kECZP+rEP9QGXAQAKP/mEARP/kECZP+rEAdAKP/mEARP/kEAMP9OP9QGKPMBEZhDIoaLVcxORqlGRP5BAIPBLBPeB+t+J83IBAOCWFARP5EAIPBLBPeE+t+J83IBAWAXAKPMWdkyQK8aeXM35pS8e8fGKP5BAIPBLBPeD+t+J83IBAOCkFAKP5EAIPBLBPeI+t+J83IBAOCAFHOAVCLFGVAL6MBKKDNALAE9PMBAIAECIgGVCITGOFCBCAAO9r/8KBAIABALCITFGWAO/8QBBDNAVtMBAIAIPBLBGRAIPBLZGdPMLVORXMpScxql358e8fGQCZP+sEGKCLP+rEPKLAAIPXBBJzBBJzBBJzBBJzPX/zL81z/zL81z/zL81z/zL81zAKPXIBBBIBBBIBBBIBBBP9QP/6EP/nEGKARAdPMBEDIWdQKZhoaky8aeGRCZP+rECZP+sEP/6EP/mEGdAdP/mEAKARCZP+sEP/6EP/mEGXAXP/mEAKAQCZP+rECZP+sEP/6EP/mEGQAQP/mEP/kEP/kEP/lEPXBBBBBBBBBBBBBBBBP+4EP/jEPXB/+fsB/+fsB/+fsB/+fsGKP/mEPXBBN0BBN0BBN0BBN0GRP/kEPXffBBffBBffBBffBBGMP9OAXAKP/mEARP/kECZP+rEP9QGXAQAKP/mEARP/kECZP+rEAdAKP/mEARP/kEAMP9OP9QGKPMBEZhDIoaLVcxORqlGRP5BAIPBLAPeB+t+J83IBAIARP5EAIPBLAPeE+t+J83IWAIAXAKPMWdkyQK8aeXM35pS8e8fGKP5BAIPBLAPeD+t+J83IZAIAKP5EAIPBLAPeI+t+J83IkKAWAIAO/8QBBKK+pDDIUE978jJJJJBC/AB9rHIDNADCD4AE2GLC98gGVtMBCBHDABHEINAEAEPBBBGOCWP+rECWP+sEP/6EAOCEP+sEPXBBJzBBJzBBJzBBJzP+uEPXBBJfBBJfBBJfBBJfP9OP/mEPKBBAECZFHEADCLFGDAV6MBKKDNAVAL9PMBAIALCIgGDCDTGEvCBC/ABAE9r/8KBAIABAVCDTFGVAE/8QBBDNADtMBAIAIPBLBGOCWP+rECWP+sEP/6EAOCEP+sEPXBBJzBBJzBBJzBBJzP+uEPXBBJfBBJfBBJfBBJfP9OP/mEPKLBKAVAIAE/8QBBKK9TEIUCBCBYDJ1JJBGEABCIFC98gFGBbDJ1JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIKKKEBCJWKLZ9tBB", pe = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), me = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var ge = fe; WebAssembly.validate(pe) && (ge = K); var xe, ye = WebAssembly.instantiate(ve(ge), {}).then(function (Ae) { xe = Ae.instance, xe.exports.__wasm_call_ctors() }); function ve(Ae) { for (var Se = new Uint8Array(Ae.length), Ce = 0; Ce < Ae.length; ++Ce) { var we = Ae.charCodeAt(Ce); Se[Ce] = we > 96 ? we - 71 : we > 64 ? we - 65 : we > 47 ? we + 4 : we > 46 ? 63 : 62 } for (var Be = 0, Ce = 0; Ce < Ae.length; ++Ce)Se[Be++] = Se[Ce] < 60 ? me[Se[Ce]] : (Se[Ce] - 60) * 64 + Se[++Ce]; return Se.buffer.slice(0, Be) } function _e(Ae, Se, Ce, we, Be, De) { var Re = xe.exports.sbrk, Ie = Ce + 3 & -4, Pe = Re(Ie * we), Ne = Re(Be.length), ke = new Uint8Array(xe.exports.memory.buffer); ke.set(Be, Ne); var Oe = Ae(Pe, Ce, we, Ne, Be.length); if (Oe == 0 && De && De(Pe, Ie, we), Se.set(ke.subarray(Pe, Pe + Ce * we)), Re(Pe - Re(0)), Oe != 0) throw new Error("Malformed buffer data: " + Oe) } var Ee = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, be = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return { ready: ye, supported: !0, decodeVertexBuffer: function (Ae, Se, Ce, we, Be) { _e(xe.exports.meshopt_decodeVertexBuffer, Ae, Se, Ce, we, xe.exports[Ee[Be]]) }, decodeIndexBuffer: function (Ae, Se, Ce, we) { _e(xe.exports.meshopt_decodeIndexBuffer, Ae, Se, Ce, we) }, decodeIndexSequence: function (Ae, Se, Ce, we) { _e(xe.exports.meshopt_decodeIndexSequence, Ae, Se, Ce, we) }, decodeGltfBuffer: function (Ae, Se, Ce, we, Be, De) { _e(xe.exports[be[Be]], Ae, Se, Ce, we, xe.exports[Ee[De]]) } } })(); var MeshoptSimplifier = function () { var fe = "B9h79tEBBBECd9gEUEU9gEUB9gBB9gQUUUUUUU99UUEU9gVUUUUUB9gLUUUUE999gIUUUE999gLUUUUEU9gIUUUEUIMXDILVORBWWBEWLVE9wEIIVIEBEOWEUECJ/JEKR7OO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BBZ9tw79o9v9wT9f79p9t9w29p9m95BEx9tw79o9v9wT9f79p9t9w29p9m959T9j9h2wBLA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94swT9j9o9Sw9t9h9wBVL79iv9rBOdWEBCEKDdQQ+stXDBK/48yIkUp99hU8jJJJJBCJ/BB9rGQ8kJJJJBAQCkFCBC/kBZ1JJJB8aCUALCDTGKALCffffI0eGXCBYD/s1JJBhJJJJBBHMAQCkFAQYD94GpCDTFAMbDBAQAMbDWAQApCEFbD94AXCBYD/s1JJBhJJJJBBHSAQCkFAQYD94GpCDTFASbDBAQASbDXAQApCEFbD94CUADCITADCffffE0eCBYD/s1JJBhJJJJBBHZAQCkFAQYD94GpCDTFAZbDBAQAZbDZAQApCEFbD94AQCWFAEADALCBZ+CJJJBAXCBYD/s1JJBhJJJJBBHhAQCkFAQYD94GpCDTFAhbDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHoAQCkFAQYD94GpCDTFAobDBAQApCEFbD94ALCD4ALFHaCEHcINAcGpCETHcApAa6MBKCBHxCUApCDTGaApCffffI0eCBYD/s1JJBhJJJJBBHcAQCkFAQYD94GqCDTFAcbDBAQAqCEFbD94AcCfEAaZ1JJJBHlDNALtMBAVCD4HkApCUFHqINAIAxAk2CDTFGyYDLGpCh4Ap7C+f+B+dd2AyYDBGpCh4Ap7C/d/o+b8j27AyYDWGpCh4Ap7C+3f/n8n27HaCBHpDNDNINAlAaAqgGaCDTFG8aYDBGcCUsMEAIAcAk2CDTFAyCXZ+LJJJBtMDApCEFGpAaFHaApAq9NMBXDKKA8aAxbDBAxHcKAhAxCDTFAcbDBAxCEFGxAL9HMBKCBHpAoHcINAcApbDBAcCLFHcALApCEFGp9HMBKCBHpAhHcAoHaINDNApAcYDBGqsMBAaAoAqCDTFGqYDBbDBAqApbDBKAcCLFHcAaCLFHaALApCEFGp9HMBKKCBHaALCBYD/s1JJBhJJJJBBHyAQCkFAQYD94GpCDTFAybDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHpAQCkFAQYD94GcCDTFApbDBAQAcCEFbD94AXCBYD/s1JJBhJJJJBBHcAQCkFAQYD94GqCDTFAcbDBAQAqCEFbD94ApCfEAKZ1JJJBHeAcCfEAKZ1JJJBH3DNALtMBAZCWFH5INDNAMAaCDTGpFYDBG8etMBAZASApFYDBCITFH8fA3ApFHAAeApFHxCBHkINDNDNA8fAkCITFYDBGlAa9HMBAxAabDBAAAabDBXEKDNAMAlCDTGKFYDBGHtMBAZASAKFYDBCITGpFYDBAasMEAHCUFH8aA5ApFHcCBHpINA8aApsMEApCEFHpAcYDBHqAcCWFHcAqAa9HMBKApAH6MEKA3AKFGpAaAlApYDBCUsebDBAxAlAaAxYDBCUsebDBKAkCEFGkA8e9HMBKKAaCEFGaAL9HMBKAhHcAoHaA3HqAeHkCBHpINDNDNApAcYDBG8a9HMBDNApAaYDBG8a9HMBAkYDBH8aDNAqYDBGlCU9HMBA8aCU9HMBAyApFCB86BBXIKAyApFHxDNApAlsMBApA8asMBAxCE86BBXIKAxCL86BBXDKDNApAoA8aCDTGlFYDB9HMBDNAqYDBGxCUsMBApAxsMBAkYDBGKCUsMBApAKsMBA3AlFYDBG8eCUsMBA8eA8asMBAeAlFYDBGlCUsMBAlA8asMBDNAhAxCDTFYDBAhAlCDTFYDB9HMBAhAKCDTFYDBAhA8eCDTFYDB9HMBAyApFCD86BBXLKAyApFCL86BBXIKAyApFCL86BBXDKAyApFCL86BBXEKAyApFAyA8aFrBB86BBKAcCLFHcAaCLFHaAqCLFHqAkCLFHkALApCEFGp9HMBKAWCEgtMBAyHpALHcINDNAprBBCE9HMBApCL86BBKApCEFHpAcCUFGcMBKKCBHkCUALCX2ALC/V+q/V+qE0eCBYD/s1JJBhJJJJBBHMAQCkFAQYD94GpCDTFAMbDBAQApCEFbD94AMAIALAVZ+DJJJB8aCUALC8s2GcALC/d/o/F8u0eCBYD/s1JJBhJJJJBBHpAQCkFAQYD94GaCDTFApbDBAQAaCEFbD94ApCBAcZ1JJJBHZDNADtMBAEHcINDNAMAcCLFYDBG8aCX2FGpiDBAMAcYDBGlCX2FGaiDBGG+TG8jAMAcCWFYDBGxCX2FGqCLFiDBAaCLFiDBG8k+TG8lnAqiDBAG+TG8mApCLFiDBA8k+TG8nn+TGYAYnA8nAqCWFiDBAaCWFiDBG8p+TGinA8lApCWFiDBA8p+TG8nn+TG8lA8lnA8nA8mnAiA8jn+TG8jA8jnmm+RG8mjBBBB9etMBAYA8m+VHYA8jA8m+VH8jA8lA8m+VH8lKAZAhAlCDTFYDBC8s2FGpA8lA8m+RG8mA8lnnG8nApiDBmuDBApA8jA8mA8jnG8rnGiApiDLmuDLApAYA8mAYnG8snGrApiDWmuDWApA8rA8lnG8rApiDXmuDXApA8sA8lnG8uApiDZmuDZApA8sA8jnG8sApiDcmuDcApA8lA8mAYA8pnA8lAGnA8kA8jnmm+MG8knGGnG8lApiDkmuDkApA8jAGnG8jApiD3muD3ApAYAGnGYApiDAmuDAApAGA8knGGApiD8kmuD8kApA8mApiDYmuDYAZAhA8aCDTFYDBC8s2FGpA8nApiDBmuDBApAiApiDLmuDLApArApiDWmuDWApA8rApiDXmuDXApA8uApiDZmuDZApA8sApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApAYApiDAmuDAApAGApiD8kmuD8kApA8mApiDYmuDYAZAhAxCDTFYDBC8s2FGpA8nApiDBmuDBApAiApiDLmuDLApArApiDWmuDWApA8rApiDXmuDXApA8uApiDZmuDZApA8sApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApAYApiDAmuDAApAGApiD8kmuD8kApA8mApiDYmuDYAcCXFHcAkCIFGkAD6MBKCBH8aAEHxINCBHcINAyAEAcC+81JJBFYDBGlA8aFCDTFYDBGaFrBBHpDNDNAyAxAcFYDBGqFrBBGkC99FCfEgCPE0MBApCEsMBApCD9HMEKDNAkCUFCfEgCE0MBAeAqCDTFYDBAa9HMEKDNApCUFCfEgCE0MBA3AaCDTFYDBAq9HMEKDNAkCV2ApFC+g1JJBFrBBtMBAhAaCDTFYDBAhAqCDTFYDB0MEKjBBACjBBJzApCEseH8mAkCEsHKAEAlCDTC+81JJBFYDBA8aFCDTFYDBHlDNAMAaCX2FGpCWFiDBAMAqCX2FGkCWFiDBG8k+TG8lA8lnApiDBAkiDBG8p+TG8jA8jnApCLFiDBAkCLFiDBG8n+TGYAYnmm+RGGjBBBB9etMBA8lAG+VH8lAYAG+VHYA8jAG+VH8jKjBBACA8mAKeH8sDNAMAlCX2FGpiDWA8k+TG8mA8lA8mA8lnApiDBA8p+TGrA8jnAYApiDLA8n+TG8rnmmGin+TG8mA8mnArA8jAin+TG8lA8lnA8rAYAin+TG8jA8jnmm+RGYjBBBB9etMBA8mAY+VH8mA8jAY+VH8jA8lAY+VH8lKAZAhAqCDTFYDBC8s2FGpA8lA8sAGnGYA8lnnGiApiDBmuDBApA8jAYA8jnG8snGrApiDLmuDLApA8mAYA8mnGGnG8rApiDWmuDWApA8sA8lnG8sApiDXmuDXApAGA8lnG8uApiDZmuDZApAGA8jnG8vApiDcmuDcApA8lAYA8mA8knA8lA8pnA8nA8jnmm+MG8knGGnG8lApiDkmuDkApA8jAGnG8jApiD3muD3ApA8mAGnG8mApiDAmuDAApAGA8knGGApiD8kmuD8kApAYApiDYmuDYAZAhAaCDTFYDBC8s2FGpAiApiDBmuDBApArApiDLmuDLApA8rApiDWmuDWApA8sApiDXmuDXApA8uApiDZmuDZApA8vApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApA8mApiDAmuDAApAGApiD8kmuD8kApAYApiDYmuDYKAcCLFGcCX9HMBKAxCXFHxA8aCIFG8aAD6MBKKDNABAEsMBABAEADCDTZ+HJJJB8aKCUADCX2ADC/V+q/V+qE0eCBYD/s1JJBhJJJJBBHAAQCkFAQYD94GpCDTFAAbDBAQApCEFbD94CUADCDTADCffffI0eCBYD/s1JJBhJJJJBBH5AQCkFAQYD94GpCDTFA5bDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHIAQCkFAQYD94GpCDTFAIbDBAQApCEFbD94ALCBYD/s1JJBhJJJJBBH8wAQCkFAQYD94GpCDTFA8wbDBAQApCEFbD94jBBBBHrDNADAO9NMBARARnH8sAACWFH8xAQYDZH8yAQYDXH8zAQYDWH80jBBBBHrINAQCWFABADGSALAhZ+CJJJBCBHHABHxCBHKINCBHpINDNAhAxApFYDBGaCDTGEFYDBGkAhABApC+81JJBFYDBAKFCDTFYDBGcCDTFYDBG8asMBAyAcFrBBGlCV2AyAaFrBBGqFC/Q1JJBFrBBGDAqCV2AlFG8eC/Q1JJBFrBBG8fvCfEgtMBDNA8eC+g1JJBFrBBtMBA8aAk0MEKDNAqAl9HMBAqCUFCfEgCE0MBAeAEFYDBAc9HMEKAAAHCX2FGqAcAaA8fCfEgGkebDLAqAaAcAkebDBAqADA8fgCfEgCB9HbDWAHCEFHHKApCLFGpCX9HMBKAxCXFHxAKCIFGKAS6MBKDNDNAHtMBAAHcAHH8aINAcCWFGljBBBBjBBJzAZAhAcYDBGaCDTFYDBC8s2FGpiDYG8l+VA8ljBBBB9beApiDWAMAcCLFGEYDBGqCX2FGkCWFiDBG8lnApiDZAkiDBG8jnApiDAmG8mA8mmmA8lnApiDLAkCLFiDBG8mnApiDcA8lnApiD3mG8lA8lmmA8mnApiDBA8jnApiDXA8mnApiDkmG8lA8lmmA8jnApiD8kmmm+LnGYjBBBBjBBJzAZAhAqAaAlYDBGkeGlCDTFYDBC8s2FGpiDYG8l+VA8ljBBBB9beApiDWAMAaAqAkeGxCX2FGkCWFiDBG8lnApiDZAkiDBG8jnApiDAmG8mA8mmmA8lnApiDLAkCLFiDBG8mnApiDcA8lnApiD3mG8lA8lmmA8mnApiDBA8jnApiDXA8mnApiDkmG8lA8lmmA8jnApiD8kmmm+LnG8lAYA8l9fGpeuDBAEAqAxApebDBAcAaAlApebDBAcCXFHcA8aCUFG8aMBKAQCJEFCBCJ/ABZ1JJJB8aA8xHpAHHcINAQCJEFApYDBCo4C/8zgFGaAaYDBCEFbDBApCXFHpAcCUFGcMBKCBHpCBHcINAQCJEFApFGaYDBHqAaAcbDBAqAcFHcApCLFGpCJ/AB9HMBKCBHpA8xHcINAQCJEFAcYDBCo4C/8zgFGaAaYDBGaCEFbDBA5AaCDTFApbDBAcCXFHcAHApCEFGp9HMBKASAO9rGaCI9uH81DNALtMBCBHpAIHcINAcApbDBAcCLFHcALApCEFGp9HMBKKCBHbA8wCBALZ1JJJBH83AaCo9uHuA81CE4H85CBH86CBHKDNINAAA5AKCDTFYDBCX2FGxiDWG8jA8s9eMEA86A819PMEjffUUH8lDNA85AH9PMBAAA5A85CDTFYDBCX2FiDWjBB/AznH8lKDNA8jA8l9etMBA86Au0MDKDNA83AhAxYDLG87CDTG88FYDBGaFG89rBBA83AhAxYDBGECDTG8+FYDBGzFGNrBBvMBDNA80AzCDTGpFYDBGqtMBA8yA8zApFYDBCITFHpAMAaCX2FG8eCWFHDA8eCLFHXAMAzCX2FG8fCWFHVA8fCLFHWCBHcCEHlDNINDNAIApYDBCDTFYDBGkAasMBAIApCLFYDBCDTFYDBG8aAasMBAMA8aCX2FG8aiDBAMAkCX2FGkiDBG8m+TG8lAWiDBAkCLFiDBGY+TGGnA8fiDBA8m+TG8kA8aCLFiDBAY+TG8jn+TA8lAXiDBAY+TG8pnA8eiDBA8m+TG8nA8jn+TnA8jAViDBAkCWFiDBGY+TGinAGA8aCWFiDBAY+TG8mn+TA8jADiDBAY+TGYnA8pA8mn+TnA8mA8knAiA8ln+TA8mA8nnAYA8ln+TnmmjBBBB9dMDKApCWFHpAcCEFGcAq6HlAqAc9HMBKKAlCEgtMBA85CEFH85XEKAxCWFHqAZAaC8s2FGpAZAzC8s2FGciDBApiDBmuDBApAciDLApiDLmuDLApAciDWApiDWmuDWApAciDXApiDXmuDXApAciDZApiDZmuDZApAciDcApiDcmuDcApAciDkApiDkmuDkApAciD3ApiD3muD3ApAciDAApiDAmuDAApAciD8kApiD8kmuD8kApAciDYApiDYmuDYDNDNDNDNAyAEFGcrBBC9+FpDEBDKAEHpINAIApCDTGpFAabDBAoApFYDBGpAE9HMBXIKKAoA88FYDBHpAoA8+FYDBHEAIA8+FA87bDBApH87KAIAECDTFA87bDBKANCE86BBA89CE86BBAqiDBG8lArArA8l9deHrAbCEFHbCECDAcrBBCEseA86FH86KAKCEFGKAH9HMBKKAbtMBDNALtMBCBHcAeHpINDNApYDBGaCUsMBDNAcAIAaCDTGqFYDBGa9HMBAeAqFYDBHaKApAabDBKApCLFHpALAcCEFGc9HMBKCBHcA3HpINDNApYDBGaCUsMBDNAcAIAaCDTGqFYDBGa9HMBA3AqFYDBHaKApAabDBKApCLFHpALAcCEFGc9HMBKKCBHDABHpCBHkINDNAIApYDBCDTFYDBGcAIApCLFYDBCDTFYDBGasMBAcAIApCWFYDBCDTFYDBGqsMBAaAqsMBABADCDTFG8aAcbDBA8aCLFAabDBA8aCWFAqbDBADCIFHDKApCXFHpAkCIFGkAS9PMDXBKKASHDXDKADAO0MBKKDNAdtMBAdAr+RuDBKAQYD94GpCDTAQCkFFC98FHhDNINAptMEAhYDBCBYD/w1JJBh+BJJJBBAhC98FHhApCUFHpXBKKAQCJ/BBF8kJJJJBADK/PLEOUABYDBCBAICDTZ1JJJB8aADCI9uHVDNADtMBABYDBHODNALtMBAEHRADHWINAOALARYDBCDTFYDBCDTFGdAdYDBCEFbDBARCLFHRAWCUFGWMBXDKKAEHRADHWINAOARYDBCDTFGdAdYDBCEFbDBARCLFHRAWCUFGWMBKKDNAItMBABYDBHRABYDLHWCBHdAIHOINAWAdbDBAWCLFHWARYDBAdFHdARCLFHRAOCUFGOMBKKDNADCI6MBAVCEAVCE0eHQABYDLHVABYDWHRINAECWFYDBHWAECLFYDBHdAEYDBHODNALtMBALAWCDTFYDBHWALAdCDTFYDBHdALAOCDTFYDBHOKARAVAOCDTFGDYDBCITFAdbDBARADYDBCITFAWbDLADADYDBCEFbDBARAVAdCDTFGDYDBCITFAWbDBARADYDBCITFAObDLADADYDBCEFbDBARAVAWCDTFGWYDBCITFAObDBARAWYDBCITFAdbDLAWAWYDBCEFbDBAECXFHEAQCUFGQMBKKDNAItMBABYDLHRABYDBHWINARARYDBAWYDB9rbDBAWCLFHWARCLFHRAICUFGIMBKKK+3LDOUV998jJJJJBCA9rGLCZFCWFCBYD11JJBbDBALCB8pDJ1JJB83IZALCWFCBYDn1JJBbDBALCB8pD+M1JJB83IBDNADtMBAICD4HVDNABtMBAVCDTHOCBHRAEHWINABARCX2FGIAEARAV2CDTFGdiDBuDBAIAdiDLuDLAIAdiDWuDWCBHIINALCZFAIFGdAWAIFiDBGQAdiDBGKAKAQ9eeuDBALAIFGdAQAdiDBGKAKAQ9deuDBAICLFGICX9HMBKAWAOFHWARCEFGRAD9HMBXDKKAVCDTHRCBHWINCBHIINALCZFAIFGdAEAIFiDBGQAdiDBGKAKAQ9eeuDBALAIFGdAQAdiDBGKAKAQ9deuDBAICLFGICX9HMBKAEARFHEAWCEFGWAD9HMBKKALiDBALiDZGK+TjBBBB+XGQALiDLALiDcGX+TGMAMAQ9deGQALiDWALiDkGM+TGpApAQ9deHpDNABtMBADtMBjBBBBjBBJzAp+VApjBBBB9beHQINABAQABiDBAK+TnuDBABCLFGIAQAIiDBAX+TnuDBABCWFGIAQAIiDBAM+TnuDBABCXFHBADCUFGDMBKKApK+qDIDUI99DUCBHI8jJJJJBCA9rGLCZFCWFCBYD11JJBbDBALCB8pDJ1JJB83IZALCWFCBYDn1JJBbDBALCB8pD+M1JJB83IBDNDNAEMBjBBJfHVjBBJfHOjBBJfHRXEKADCD4CDTHWINCBHDINALCZFADFGdABADFiDBGOAdiDBGRARAO9eeuDBALADFGdAOAdiDBGRARAO9deuDBADCLFGDCX9HMBKABAWFHBAICEFGIAE9HMBKALiDWALiDk+THRALiDLALiDc+THOALiDBALiDZ+THVKAVjBBBB+XGVAOAOAV9deGOARARAO9deK9dEEUABCfEAICDTZ1JJJBHLCBHIDNADtMBINDNALAEYDBCDTFGBYDBCU9HMBABAIbDBAICEFHIKAECLFHEADCUFGDMBKKAIK9TEIUCBCBYD/01JJBGEABCIFC98gFGBbD/01JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABK9TEIUCBCBYD/01JJBGEABCIFC98gFGBbD/01JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK9+EIUzBHEDNDNCBYD/01JJBGDAECZTGI9NMBCUHEADAI9rCffIFCZ4NBCUsMEKADHEKCBABAE9rCIFC98gCBYD/01JJBFGDbD/01JJBDNADzBCZTGE9NMBADAE9rCffIFCZ4NB8aKK6EIUCBHIDNADtMBDNINABrBBGLAErBBGV9HMEAECEFHEABCEFHBADCUFGDMBXDKKALAV9rHIKAIKK+CEDBCJWK9pffUUffUUffUUffUfffUfffUfBBBBBBBBEEEBEEBEBBEEEBEBBBBBEBEBBBBBEBBBDBBBBBBBBBBBBBBBEEEEEBEBBBBBEBBBBBEEBBBBBBC/sWKXEBBBDBBBJ9kBB", K = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var pe, me = WebAssembly.instantiate(ge(fe), {}).then(function (Se) { pe = Se.instance, pe.exports.__wasm_call_ctors() }); function ge(Se) { for (var Ce = new Uint8Array(Se.length), we = 0; we < Se.length; ++we) { var Be = Se.charCodeAt(we); Ce[we] = Be > 96 ? Be - 71 : Be > 64 ? Be - 65 : Be > 47 ? Be + 4 : Be > 46 ? 63 : 62 } for (var De = 0, we = 0; we < Se.length; ++we)Ce[De++] = Ce[we] < 60 ? K[Ce[we]] : (Ce[we] - 60) * 64 + Ce[++we]; return Ce.buffer.slice(0, De) } function xe(Se) { if (!Se) throw new Error("Assertion failed") } function ye(Se) { return new Uint8Array(Se.buffer, Se.byteOffset, Se.byteLength) } function ve(Se, Ce) { var we = pe.exports.sbrk, Be = we(Se.length * 4), De = we(Ce * 4), Re = new Uint8Array(pe.exports.memory.buffer), Ie = ye(Se); Re.set(Ie, Be); var Pe = pe.exports.meshopt_optimizeVertexFetchRemap(De, Be, Se.length, Ce); Re = new Uint8Array(pe.exports.memory.buffer); var Ne = new Uint32Array(Ce); new Uint8Array(Ne.buffer).set(Re.subarray(De, De + Ce * 4)), Ie.set(Re.subarray(Be, Be + Se.length * 4)), we(Be - we(0)); for (var ke = 0; ke < Se.length; ++ke)Se[ke] = Ne[Se[ke]]; return [Ne, Pe] } function _e(Se) { for (var Ce = 0, we = 0; we < Se.length; ++we) { var Be = Se[we]; Ce = Ce < Be ? Be : Ce } return Ce } function Ee(Se, Ce, we, Be, De, Re, Ie, Pe, Ne) { var ke = pe.exports.sbrk, Oe = ke(4), Ue = ke(we * 4), He = ke(De * Re), Ge = ke(we * 4), ze = new Uint8Array(pe.exports.memory.buffer); ze.set(ye(Be), He), ze.set(ye(Ce), Ge); var We = Se(Ue, Ge, we, He, De, Re, Ie, Pe, Ne, Oe); ze = new Uint8Array(pe.exports.memory.buffer); var Xe = new Uint32Array(We); ye(Xe).set(ze.subarray(Ue, Ue + We * 4)); var Ye = new Float32Array(1); return ye(Ye).set(ze.subarray(Oe, Oe + 4)), ke(Oe - ke(0)), [Xe, Ye[0]] } function be(Se, Ce, we, Be) { var De = pe.exports.sbrk, Re = De(we * Be), Ie = new Uint8Array(pe.exports.memory.buffer); Ie.set(ye(Ce), Re); var Pe = Se(Re, we, Be); return De(Re - De(0)), Pe } var Ae = { LockBorder: 1 }; return { ready: me, supported: !0, compactMesh: function (Se) { xe(Se instanceof Uint32Array || Se instanceof Int32Array || Se instanceof Uint16Array || Se instanceof Int16Array), xe(Se.length % 3 == 0); var Ce = Se.BYTES_PER_ELEMENT == 4 ? Se : new Uint32Array(Se); return ve(Ce, _e(Se) + 1) }, simplify: function (Se, Ce, we, Be, De, Re) { xe(Se instanceof Uint32Array || Se instanceof Int32Array || Se instanceof Uint16Array || Se instanceof Int16Array), xe(Se.length % 3 == 0), xe(Ce instanceof Float32Array), xe(Ce.length % we == 0), xe(we >= 3), xe(Be % 3 == 0); for (var Ie = 0, Pe = 0; Pe < (Re ? Re.length : 0); ++Pe)Ie |= Ae[Re[Pe]]; var Ne = Se.BYTES_PER_ELEMENT == 4 ? Se : new Uint32Array(Se), ke = Ee(pe.exports.meshopt_simplify, Ne, Se.length, Ce, Ce.length, we * 4, Be, De, Ie); return ke[0] = Se instanceof Uint32Array ? ke[0] : new Se.constructor(ke[0]), ke }, getScale: function (Se, Ce) { return xe(Se instanceof Float32Array), xe(Se.length % Ce == 0), be(pe.exports.meshopt_simplifyScale, Se, Se.length, Ce * 4) } } }(); function createLODs(fe, K, pe, me) { if (!fe || !K || me === "off") return { geometries: [], materials: [] }; let ge = [], xe = []; if (me === "auto") { K.computeBoundingSphere(); const _e = K.boundingSphere.radius, Ee = K.attributes.position.count; Ee > 1e4 ? ge = [.2, .05, .01] : Ee > 2e3 ? ge = [.4, .1, .03] : Ee > 500 ? ge = [.6, .2, .05] : ge = [.85, .4, .1]; const be = Math.sqrt(_e + 1e-5); xe = [1, 2, 3].map(Se => Se * be) } else ge = me.map(_e => _e[1]), xe = me.map(_e => _e[0]); const ye = [], ve = []; return ge.forEach((_e, Ee) => { const be = Math.floor(K.index.array.length * _e / 3) * 3, Ae = K.clone(), Se = MeshoptSimplifier.simplify(new Uint32Array(Ae.index.array), new Float32Array(Ae.attributes.position.array), 3, be, .01, ["LockBorder"])[0]; Ae.index.array.set(Se), Ae.index.needsUpdate = !0, Ae.setDrawRange(0, Se.length); const Ce = Array.isArray(pe) ? pe.map(we => we.clone()) : pe.clone(); fe.addLOD(Ae, Ce, xe[Ee]), ye.push(Ae), Array.isArray(Ce) ? ve.push(...Ce) : ve.push(Ce) }), { geometries: ye, materials: ve } } const BatchedMeshBase = React$4.forwardRef(function (K, pe) { const [me, ge] = React$4.useState(null); React$4.useImperativeHandle(pe, () => me, [me]); const xe = reactExports.useMemo(() => new Vector3, []), ye = reactExports.useMemo(() => new Quaternion, []), ve = reactExports.useMemo(() => new Vector3(1, 1, 1), []); return reactExports.useEffect(() => { const _e = new f$1(K.geometry, K.material, { capacity: 1 }); let Ee = [], be = []; if (K.lod !== "off") { const Ae = createLODs(_e, K.geometry, K.material, K.lod); Ee = Ae.geometries, be = Ae.materials } return ge(_e), () => { _e.disposeBVH(), _e.dispose(), Ee.forEach(Ae => Ae.dispose()), be.forEach(Ae => Ae.dispose()) } }, [K.geometry, K.lod, K.material]), reactExports.useEffect(() => { if (!me) return; const _e = K.batched_positions.byteLength / (3 * Float32Array.BYTES_PER_ELEMENT); me.instancesCount !== _e && (me.capacity < _e && me.resizeBuffers(_e), me.clearInstances(), me.addInstances(_e, () => { }), me.computeBVH()); const Ee = new DataView(K.batched_positions.buffer, K.batched_positions.byteOffset, K.batched_positions.byteLength), be = new DataView(K.batched_wxyzs.buffer, K.batched_wxyzs.byteOffset, K.batched_wxyzs.byteLength), Ae = K.batched_scales ? new DataView(K.batched_scales.buffer, K.batched_scales.byteOffset, K.batched_scales.byteLength) : null; me.updateInstances((Se, Ce) => { const we = Ce * 3 * 4, Be = Ce * 4 * 4, De = K.batched_scales && K.batched_scales.byteLength === K.batched_wxyzs.byteLength / 4 * 3 ? Ce * 3 * 4 : Ce * 4; if (xe.set(Ee.getFloat32(we, !0), Ee.getFloat32(we + 4, !0), Ee.getFloat32(we + 8, !0)), ye.set(be.getFloat32(Be + 4, !0), be.getFloat32(Be + 8, !0), be.getFloat32(Be + 12, !0), be.getFloat32(Be, !0)), Ae) if (K.batched_scales.byteLength === K.batched_wxyzs.byteLength / 4 * 3) ve.set(Ae.getFloat32(De, !0), Ae.getFloat32(De + 4, !0), Ae.getFloat32(De + 8, !0)); else { const Re = Ae.getFloat32(De, !0); ve.setScalar(Re) } else ve.set(1, 1, 1); Se.position.copy(xe), Se.quaternion.copy(ye), Se.scale.copy(ve) }) }, [K.batched_positions, K.batched_wxyzs, K.batched_scales, me]), React$4.useEffect(() => { if (!(me === null || K.batched_colors === null)) for (let _e = 0; _e < me.instancesCount; _e++) { let Ee; K.batched_colors.byteLength == 3 ? Ee = new Color$1(K.batched_colors[0] / 255, K.batched_colors[1] / 255, K.batched_colors[2] / 255) : K.batched_colors.byteLength === me.instancesCount * 3 ? Ee = new Color$1(K.batched_colors[_e * 3] / 255, K.batched_colors[_e * 3 + 1] / 255, K.batched_colors[_e * 3 + 2] / 255) : (console.error(`Invalid batched_colors length: ${K.batched_colors.byteLength}, expected 3 or ${me.instancesCount * 3}`), Ee = new Color$1(1, 1, 1)), me.setColorAt(_e, Ee) } }, [K.batched_colors, me]), reactExports.useEffect(() => { me && (me.castShadow = K.cast_shadow, me.receiveShadow = K.receive_shadow, me.LODinfo && me.LODinfo.objects && me.LODinfo.objects.forEach(_e => { _e.castShadow = K.cast_shadow, _e.receiveShadow = K.receive_shadow })) }, [K.cast_shadow, K.receive_shadow, me]), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [me && jsxRuntimeExports.jsx("primitive", { object: me }), K.clickable && jsxRuntimeExports.jsx(BatchedMeshHoverOutlines, { geometry: K.geometry, batched_positions: K.batched_positions, batched_wxyzs: K.batched_wxyzs, batched_scales: K.batched_scales })] }) }), BatchedMesh = React$4.forwardRef(function ({ children: K, ...pe }, me) { const xe = React$4.useContext(ViewerContext).useSceneTree(_e => _e.nodeFromName[pe.name]?.clickable) ?? !1, ye = reactExports.useMemo(() => { const _e = createStandardMaterial({ material: pe.props.material, wireframe: pe.props.wireframe, opacity: pe.props.opacity, flat_shading: pe.props.flat_shading, side: pe.props.side }); return pe.props.opacity !== null && pe.props.opacity < 1 && (_e.transparent = !0), _e }, [pe.props.material, pe.props.wireframe, pe.props.opacity, pe.props.flat_shading, pe.props.side]), ve = reactExports.useMemo(() => { const _e = new BufferGeometry; return _e.setAttribute("position", new BufferAttribute(new Float32Array(pe.props.vertices.buffer.slice(pe.props.vertices.byteOffset, pe.props.vertices.byteOffset + pe.props.vertices.byteLength)), 3)), _e.setIndex(new BufferAttribute(new Uint32Array(pe.props.faces.buffer.slice(pe.props.faces.byteOffset, pe.props.faces.byteOffset + pe.props.faces.byteLength)), 1)), _e.computeVertexNormals(), _e.computeBoundingSphere(), _e }, [pe.props.vertices.buffer, pe.props.faces.buffer]); return jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(BatchedMeshBase, { geometry: ve, material: ye, batched_positions: pe.props.batched_positions, batched_wxyzs: pe.props.batched_wxyzs, batched_scales: pe.props.batched_scales, batched_colors: pe.props.batched_colors, lod: pe.props.lod, cast_shadow: pe.props.cast_shadow, receive_shadow: pe.props.receive_shadow, clickable: xe }), K] }) }); function mergeGeometries(fe, K = !1) { const pe = fe[0].index !== null, me = new Set(Object.keys(fe[0].attributes)), ge = new Set(Object.keys(fe[0].morphAttributes)), xe = {}, ye = {}, ve = fe[0].morphTargetsRelative, _e = new BufferGeometry; let Ee = 0; for (let be = 0; be < fe.length; ++be) { const Ae = fe[be]; let Se = 0; if (pe !== (Ae.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (const Ce in Ae.attributes) { if (!me.has(Ce)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + '. All geometries must have compatible attributes; make sure "' + Ce + '" attribute exists among all geometries, or in none of them.'), null; xe[Ce] === void 0 && (xe[Ce] = []), xe[Ce].push(Ae.attributes[Ce]), Se++ } if (Se !== me.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + ". Make sure all geometries have the same number of attributes."), null; if (ve !== Ae.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (const Ce in Ae.morphAttributes) { if (!ge.has(Ce)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + ".  .morphAttributes must be consistent throughout all geometries."), null; ye[Ce] === void 0 && (ye[Ce] = []), ye[Ce].push(Ae.morphAttributes[Ce]) } if (K) { let Ce; if (pe) Ce = Ae.index.count; else if (Ae.attributes.position !== void 0) Ce = Ae.attributes.position.count; else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + be + ". The geometry must have either an index or a position attribute"), null; _e.addGroup(Ee, Ce, be), Ee += Ce } } if (pe) { let be = 0; const Ae = []; for (let Se = 0; Se < fe.length; ++Se) { const Ce = fe[Se].index; for (let we = 0; we < Ce.count; ++we)Ae.push(Ce.getX(we) + be); be += fe[Se].attributes.position.count } _e.setIndex(Ae) } for (const be in xe) { const Ae = mergeAttributes(xe[be]); if (!Ae) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + be + " attribute."), null; _e.setAttribute(be, Ae) } for (const be in ye) { const Ae = ye[be][0].length; if (Ae === 0) break; _e.morphAttributes = _e.morphAttributes || {}, _e.morphAttributes[be] = []; for (let Se = 0; Se < Ae; ++Se) { const Ce = []; for (let Be = 0; Be < ye[be].length; ++Be)Ce.push(ye[be][Be][Se]); const we = mergeAttributes(Ce); if (!we) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + be + " morphAttribute."), null; _e.morphAttributes[be].push(we) } } return _e } function mergeAttributes(fe) { let K, pe, me, ge = -1, xe = 0; for (let Ee = 0; Ee < fe.length; ++Ee) { const be = fe[Ee]; if (K === void 0 && (K = be.array.constructor), K !== be.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (pe === void 0 && (pe = be.itemSize), pe !== be.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (me === void 0 && (me = be.normalized), me !== be.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; if (ge === -1 && (ge = be.gpuType), ge !== be.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null; xe += be.count * pe } const ye = new K(xe), ve = new BufferAttribute(ye, pe, me); let _e = 0; for (let Ee = 0; Ee < fe.length; ++Ee) { const be = fe[Ee]; if (be.isInterleavedBufferAttribute) { const Ae = _e / pe; for (let Se = 0, Ce = be.count; Se < Ce; Se++)for (let we = 0; we < pe; we++) { const Be = be.getComponent(Se, we); ve.setComponent(Se + Ae, we, Be) } } else ye.set(be.array, _e); _e += be.count * pe } return ge !== void 0 && (ve.gpuType = ge), ve } function toTrianglesDrawMode(fe, K) { if (K === TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), fe; if (K === TriangleFanDrawMode || K === TriangleStripDrawMode) { let pe = fe.getIndex(); if (pe === null) { const ye = [], ve = fe.getAttribute("position"); if (ve !== void 0) { for (let _e = 0; _e < ve.count; _e++)ye.push(_e); fe.setIndex(ye), pe = fe.getIndex() } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), fe } const me = pe.count - 2, ge = []; if (K === TriangleFanDrawMode) for (let ye = 1; ye <= me; ye++)ge.push(pe.getX(0)), ge.push(pe.getX(ye)), ge.push(pe.getX(ye + 1)); else for (let ye = 0; ye < me; ye++)ye % 2 === 0 ? (ge.push(pe.getX(ye)), ge.push(pe.getX(ye + 1)), ge.push(pe.getX(ye + 2))) : (ge.push(pe.getX(ye + 2)), ge.push(pe.getX(ye + 1)), ge.push(pe.getX(ye))); ge.length / 3 !== me && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const xe = fe.clone(); return xe.setIndex(ge), xe.clearGroups(), xe } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", K), fe } class GLTFLoader extends Loader { constructor(K) { super(K), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (pe) { return new GLTFMaterialsClearcoatExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsDispersionExtension(pe) }), this.register(function (pe) { return new GLTFTextureBasisUExtension(pe) }), this.register(function (pe) { return new GLTFTextureWebPExtension(pe) }), this.register(function (pe) { return new GLTFTextureAVIFExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsSheenExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsTransmissionExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsVolumeExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsIorExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsEmissiveStrengthExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsSpecularExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsIridescenceExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsAnisotropyExtension(pe) }), this.register(function (pe) { return new GLTFMaterialsBumpExtension(pe) }), this.register(function (pe) { return new GLTFLightsExtension(pe) }), this.register(function (pe) { return new GLTFMeshoptCompression(pe) }), this.register(function (pe) { return new GLTFMeshGpuInstancing(pe) }) } load(K, pe, me, ge) { const xe = this; let ye; if (this.resourcePath !== "") ye = this.resourcePath; else if (this.path !== "") { const Ee = LoaderUtils.extractUrlBase(K); ye = LoaderUtils.resolveURL(Ee, this.path) } else ye = LoaderUtils.extractUrlBase(K); this.manager.itemStart(K); const ve = function (Ee) { ge ? ge(Ee) : console.error(Ee), xe.manager.itemError(K), xe.manager.itemEnd(K) }, _e = new FileLoader(this.manager); _e.setPath(this.path), _e.setResponseType("arraybuffer"), _e.setRequestHeader(this.requestHeader), _e.setWithCredentials(this.withCredentials), _e.load(K, function (Ee) { try { xe.parse(Ee, ye, function (be) { pe(be), xe.manager.itemEnd(K) }, ve) } catch (be) { ve(be) } }, me, ve) } setDRACOLoader(K) { return this.dracoLoader = K, this } setKTX2Loader(K) { return this.ktx2Loader = K, this } setMeshoptDecoder(K) { return this.meshoptDecoder = K, this } register(K) { return this.pluginCallbacks.indexOf(K) === -1 && this.pluginCallbacks.push(K), this } unregister(K) { return this.pluginCallbacks.indexOf(K) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(K), 1), this } parse(K, pe, me, ge) { let xe; const ye = {}, ve = {}, _e = new TextDecoder; if (typeof K == "string") xe = JSON.parse(K); else if (K instanceof ArrayBuffer) if (_e.decode(new Uint8Array(K, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) { try { ye[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(K) } catch (Ae) { ge && ge(Ae); return } xe = JSON.parse(ye[EXTENSIONS.KHR_BINARY_GLTF].content) } else xe = JSON.parse(_e.decode(K)); else xe = K; if (xe.asset === void 0 || xe.asset.version[0] < 2) { ge && ge(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const Ee = new GLTFParser(xe, { path: pe || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); Ee.fileLoader.setRequestHeader(this.requestHeader); for (let be = 0; be < this.pluginCallbacks.length; be++) { const Ae = this.pluginCallbacks[be](Ee); Ae.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), ve[Ae.name] = Ae, ye[Ae.name] = !0 } if (xe.extensionsUsed) for (let be = 0; be < xe.extensionsUsed.length; ++be) { const Ae = xe.extensionsUsed[be], Se = xe.extensionsRequired || []; switch (Ae) { case EXTENSIONS.KHR_MATERIALS_UNLIT: ye[Ae] = new GLTFMaterialsUnlitExtension; break; case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION: ye[Ae] = new GLTFDracoMeshCompressionExtension(xe, this.dracoLoader); break; case EXTENSIONS.KHR_TEXTURE_TRANSFORM: ye[Ae] = new GLTFTextureTransformExtension; break; case EXTENSIONS.KHR_MESH_QUANTIZATION: ye[Ae] = new GLTFMeshQuantizationExtension; break; default: Se.indexOf(Ae) >= 0 && ve[Ae] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + Ae + '".') } } Ee.setExtensions(ye), Ee.setPlugins(ve), Ee.parse(me, ge) } parseAsync(K, pe) { const me = this; return new Promise(function (ge, xe) { me.parse(K, pe, ge, xe) }) } } function GLTFRegistry() { let fe = {}; return { get: function (K) { return fe[K] }, add: function (K, pe) { fe[K] = pe }, remove: function (K) { delete fe[K] }, removeAll: function () { fe = {} } } } const EXTENSIONS = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class GLTFLightsExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const K = this.parser, pe = this.parser.json.nodes || []; for (let me = 0, ge = pe.length; me < ge; me++) { const xe = pe[me]; xe.extensions && xe.extensions[this.name] && xe.extensions[this.name].light !== void 0 && K._addNodeRef(this.cache, xe.extensions[this.name].light) } } _loadLight(K) { const pe = this.parser, me = "light:" + K; let ge = pe.cache.get(me); if (ge) return ge; const xe = pe.json, _e = ((xe.extensions && xe.extensions[this.name] || {}).lights || [])[K]; let Ee; const be = new Color$1(16777215); _e.color !== void 0 && be.setRGB(_e.color[0], _e.color[1], _e.color[2], LinearSRGBColorSpace); const Ae = _e.range !== void 0 ? _e.range : 0; switch (_e.type) { case "directional": Ee = new DirectionalLight(be), Ee.target.position.set(0, 0, -1), Ee.add(Ee.target); break; case "point": Ee = new PointLight(be), Ee.distance = Ae; break; case "spot": Ee = new SpotLight(be), Ee.distance = Ae, _e.spot = _e.spot || {}, _e.spot.innerConeAngle = _e.spot.innerConeAngle !== void 0 ? _e.spot.innerConeAngle : 0, _e.spot.outerConeAngle = _e.spot.outerConeAngle !== void 0 ? _e.spot.outerConeAngle : Math.PI / 4, Ee.angle = _e.spot.outerConeAngle, Ee.penumbra = 1 - _e.spot.innerConeAngle / _e.spot.outerConeAngle, Ee.target.position.set(0, 0, -1), Ee.add(Ee.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + _e.type) }return Ee.position.set(0, 0, 0), assignExtrasToUserData(Ee, _e), _e.intensity !== void 0 && (Ee.intensity = _e.intensity), Ee.name = pe.createUniqueName(_e.name || "light_" + K), ge = Promise.resolve(Ee), pe.cache.add(me, ge), ge } getDependency(K, pe) { if (K === "light") return this._loadLight(pe) } createNodeAttachment(K) { const pe = this, me = this.parser, xe = me.json.nodes[K], ve = (xe.extensions && xe.extensions[this.name] || {}).light; return ve === void 0 ? null : this._loadLight(ve).then(function (_e) { return me._getNodeRef(pe.cache, ve, _e) }) } } class GLTFMaterialsUnlitExtension { constructor() { this.name = EXTENSIONS.KHR_MATERIALS_UNLIT } getMaterialType() { return MeshBasicMaterial } extendParams(K, pe, me) { const ge = []; K.color = new Color$1(1, 1, 1), K.opacity = 1; const xe = pe.pbrMetallicRoughness; if (xe) { if (Array.isArray(xe.baseColorFactor)) { const ye = xe.baseColorFactor; K.color.setRGB(ye[0], ye[1], ye[2], LinearSRGBColorSpace), K.opacity = ye[3] } xe.baseColorTexture !== void 0 && ge.push(me.assignTexture(K, "map", xe.baseColorTexture, SRGBColorSpace)) } return Promise.all(ge) } } class GLTFMaterialsEmissiveStrengthExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(K, pe) { const ge = this.parser.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = ge.extensions[this.name].emissiveStrength; return xe !== void 0 && (pe.emissiveIntensity = xe), Promise.resolve() } } class GLTFMaterialsClearcoatExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; if (ye.clearcoatFactor !== void 0 && (pe.clearcoat = ye.clearcoatFactor), ye.clearcoatTexture !== void 0 && xe.push(me.assignTexture(pe, "clearcoatMap", ye.clearcoatTexture)), ye.clearcoatRoughnessFactor !== void 0 && (pe.clearcoatRoughness = ye.clearcoatRoughnessFactor), ye.clearcoatRoughnessTexture !== void 0 && xe.push(me.assignTexture(pe, "clearcoatRoughnessMap", ye.clearcoatRoughnessTexture)), ye.clearcoatNormalTexture !== void 0 && (xe.push(me.assignTexture(pe, "clearcoatNormalMap", ye.clearcoatNormalTexture)), ye.clearcoatNormalTexture.scale !== void 0)) { const ve = ye.clearcoatNormalTexture.scale; pe.clearcoatNormalScale = new Vector2(ve, ve) } return Promise.all(xe) } } class GLTFMaterialsDispersionExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const ge = this.parser.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = ge.extensions[this.name]; return pe.dispersion = xe.dispersion !== void 0 ? xe.dispersion : 0, Promise.resolve() } } class GLTFMaterialsIridescenceExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; return ye.iridescenceFactor !== void 0 && (pe.iridescence = ye.iridescenceFactor), ye.iridescenceTexture !== void 0 && xe.push(me.assignTexture(pe, "iridescenceMap", ye.iridescenceTexture)), ye.iridescenceIor !== void 0 && (pe.iridescenceIOR = ye.iridescenceIor), pe.iridescenceThicknessRange === void 0 && (pe.iridescenceThicknessRange = [100, 400]), ye.iridescenceThicknessMinimum !== void 0 && (pe.iridescenceThicknessRange[0] = ye.iridescenceThicknessMinimum), ye.iridescenceThicknessMaximum !== void 0 && (pe.iridescenceThicknessRange[1] = ye.iridescenceThicknessMaximum), ye.iridescenceThicknessTexture !== void 0 && xe.push(me.assignTexture(pe, "iridescenceThicknessMap", ye.iridescenceThicknessTexture)), Promise.all(xe) } } class GLTFMaterialsSheenExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = []; pe.sheenColor = new Color$1(0, 0, 0), pe.sheenRoughness = 0, pe.sheen = 1; const ye = ge.extensions[this.name]; if (ye.sheenColorFactor !== void 0) { const ve = ye.sheenColorFactor; pe.sheenColor.setRGB(ve[0], ve[1], ve[2], LinearSRGBColorSpace) } return ye.sheenRoughnessFactor !== void 0 && (pe.sheenRoughness = ye.sheenRoughnessFactor), ye.sheenColorTexture !== void 0 && xe.push(me.assignTexture(pe, "sheenColorMap", ye.sheenColorTexture, SRGBColorSpace)), ye.sheenRoughnessTexture !== void 0 && xe.push(me.assignTexture(pe, "sheenRoughnessMap", ye.sheenRoughnessTexture)), Promise.all(xe) } } class GLTFMaterialsTransmissionExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; return ye.transmissionFactor !== void 0 && (pe.transmission = ye.transmissionFactor), ye.transmissionTexture !== void 0 && xe.push(me.assignTexture(pe, "transmissionMap", ye.transmissionTexture)), Promise.all(xe) } } class GLTFMaterialsVolumeExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; pe.thickness = ye.thicknessFactor !== void 0 ? ye.thicknessFactor : 0, ye.thicknessTexture !== void 0 && xe.push(me.assignTexture(pe, "thicknessMap", ye.thicknessTexture)), pe.attenuationDistance = ye.attenuationDistance || 1 / 0; const ve = ye.attenuationColor || [1, 1, 1]; return pe.attenuationColor = new Color$1().setRGB(ve[0], ve[1], ve[2], LinearSRGBColorSpace), Promise.all(xe) } } class GLTFMaterialsIorExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_IOR } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const ge = this.parser.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = ge.extensions[this.name]; return pe.ior = xe.ior !== void 0 ? xe.ior : 1.5, Promise.resolve() } } class GLTFMaterialsSpecularExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; pe.specularIntensity = ye.specularFactor !== void 0 ? ye.specularFactor : 1, ye.specularTexture !== void 0 && xe.push(me.assignTexture(pe, "specularIntensityMap", ye.specularTexture)); const ve = ye.specularColorFactor || [1, 1, 1]; return pe.specularColor = new Color$1().setRGB(ve[0], ve[1], ve[2], LinearSRGBColorSpace), ye.specularColorTexture !== void 0 && xe.push(me.assignTexture(pe, "specularColorMap", ye.specularColorTexture, SRGBColorSpace)), Promise.all(xe) } } class GLTFMaterialsBumpExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.EXT_MATERIALS_BUMP } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; return pe.bumpScale = ye.bumpFactor !== void 0 ? ye.bumpFactor : 1, ye.bumpTexture !== void 0 && xe.push(me.assignTexture(pe, "bumpMap", ye.bumpTexture)), Promise.all(xe) } } class GLTFMaterialsAnisotropyExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY } getMaterialType(K) { const me = this.parser.json.materials[K]; return !me.extensions || !me.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(K, pe) { const me = this.parser, ge = me.json.materials[K]; if (!ge.extensions || !ge.extensions[this.name]) return Promise.resolve(); const xe = [], ye = ge.extensions[this.name]; return ye.anisotropyStrength !== void 0 && (pe.anisotropy = ye.anisotropyStrength), ye.anisotropyRotation !== void 0 && (pe.anisotropyRotation = ye.anisotropyRotation), ye.anisotropyTexture !== void 0 && xe.push(me.assignTexture(pe, "anisotropyMap", ye.anisotropyTexture)), Promise.all(xe) } } class GLTFTextureBasisUExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.KHR_TEXTURE_BASISU } loadTexture(K) { const pe = this.parser, me = pe.json, ge = me.textures[K]; if (!ge.extensions || !ge.extensions[this.name]) return null; const xe = ge.extensions[this.name], ye = pe.options.ktx2Loader; if (!ye) { if (me.extensionsRequired && me.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return pe.loadTextureImage(K, xe.source, ye) } } class GLTFTextureWebPExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(K) { const pe = this.name, me = this.parser, ge = me.json, xe = ge.textures[K]; if (!xe.extensions || !xe.extensions[pe]) return null; const ye = xe.extensions[pe], ve = ge.images[ye.source]; let _e = me.textureLoader; if (ve.uri) { const Ee = me.options.manager.getHandler(ve.uri); Ee !== null && (_e = Ee) } return this.detectSupport().then(function (Ee) { if (Ee) return me.loadTextureImage(K, ye.source, _e); if (ge.extensionsRequired && ge.extensionsRequired.indexOf(pe) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return me.loadTexture(K) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (K) { const pe = new Image; pe.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", pe.onload = pe.onerror = function () { K(pe.height === 1) } })), this.isSupported } } class GLTFTextureAVIFExtension { constructor(K) { this.parser = K, this.name = EXTENSIONS.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(K) { const pe = this.name, me = this.parser, ge = me.json, xe = ge.textures[K]; if (!xe.extensions || !xe.extensions[pe]) return null; const ye = xe.extensions[pe], ve = ge.images[ye.source]; let _e = me.textureLoader; if (ve.uri) { const Ee = me.options.manager.getHandler(ve.uri); Ee !== null && (_e = Ee) } return this.detectSupport().then(function (Ee) { if (Ee) return me.loadTextureImage(K, ye.source, _e); if (ge.extensionsRequired && ge.extensionsRequired.indexOf(pe) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return me.loadTexture(K) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (K) { const pe = new Image; pe.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", pe.onload = pe.onerror = function () { K(pe.height === 1) } })), this.isSupported } } class GLTFMeshoptCompression { constructor(K) { this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = K } loadBufferView(K) { const pe = this.parser.json, me = pe.bufferViews[K]; if (me.extensions && me.extensions[this.name]) { const ge = me.extensions[this.name], xe = this.parser.getDependency("buffer", ge.buffer), ye = this.parser.options.meshoptDecoder; if (!ye || !ye.supported) { if (pe.extensionsRequired && pe.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return xe.then(function (ve) { const _e = ge.byteOffset || 0, Ee = ge.byteLength || 0, be = ge.count, Ae = ge.byteStride, Se = new Uint8Array(ve, _e, Ee); return ye.decodeGltfBufferAsync ? ye.decodeGltfBufferAsync(be, Ae, Se, ge.mode, ge.filter).then(function (Ce) { return Ce.buffer }) : ye.ready.then(function () { const Ce = new ArrayBuffer(be * Ae); return ye.decodeGltfBuffer(new Uint8Array(Ce), be, Ae, Se, ge.mode, ge.filter), Ce }) }) } else return null } } class GLTFMeshGpuInstancing { constructor(K) { this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = K } createNodeMesh(K) { const pe = this.parser.json, me = pe.nodes[K]; if (!me.extensions || !me.extensions[this.name] || me.mesh === void 0) return null; const ge = pe.meshes[me.mesh]; for (const Ee of ge.primitives) if (Ee.mode !== WEBGL_CONSTANTS.TRIANGLES && Ee.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && Ee.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && Ee.mode !== void 0) return null; const ye = me.extensions[this.name].attributes, ve = [], _e = {}; for (const Ee in ye) ve.push(this.parser.getDependency("accessor", ye[Ee]).then(be => (_e[Ee] = be, _e[Ee]))); return ve.length < 1 ? null : (ve.push(this.parser.createNodeMesh(K)), Promise.all(ve).then(Ee => { const be = Ee.pop(), Ae = be.isGroup ? be.children : [be], Se = Ee[0].count, Ce = []; for (const we of Ae) { const Be = new Matrix4, De = new Vector3, Re = new Quaternion, Ie = new Vector3(1, 1, 1), Pe = new InstancedMesh(we.geometry, we.material, Se); for (let Ne = 0; Ne < Se; Ne++)_e.TRANSLATION && De.fromBufferAttribute(_e.TRANSLATION, Ne), _e.ROTATION && Re.fromBufferAttribute(_e.ROTATION, Ne), _e.SCALE && Ie.fromBufferAttribute(_e.SCALE, Ne), Pe.setMatrixAt(Ne, Be.compose(De, Re, Ie)); for (const Ne in _e) if (Ne === "_COLOR_0") { const ke = _e[Ne]; Pe.instanceColor = new InstancedBufferAttribute(ke.array, ke.itemSize, ke.normalized) } else Ne !== "TRANSLATION" && Ne !== "ROTATION" && Ne !== "SCALE" && we.geometry.setAttribute(Ne, _e[Ne]); Object3D.prototype.copy.call(Pe, we), this.parser.assignFinalMaterial(Pe), Ce.push(Pe) } return be.isGroup ? (be.clear(), be.add(...Ce), be) : Ce[0] })) } } const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 }; class GLTFBinaryExtension { constructor(K) { this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null; const pe = new DataView(K, 0, BINARY_EXTENSION_HEADER_LENGTH), me = new TextDecoder; if (this.header = { magic: me.decode(new Uint8Array(K.slice(0, 4))), version: pe.getUint32(4, !0), length: pe.getUint32(8, !0) }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const ge = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, xe = new DataView(K, BINARY_EXTENSION_HEADER_LENGTH); let ye = 0; for (; ye < ge;) { const ve = xe.getUint32(ye, !0); ye += 4; const _e = xe.getUint32(ye, !0); if (ye += 4, _e === BINARY_EXTENSION_CHUNK_TYPES.JSON) { const Ee = new Uint8Array(K, BINARY_EXTENSION_HEADER_LENGTH + ye, ve); this.content = me.decode(Ee) } else if (_e === BINARY_EXTENSION_CHUNK_TYPES.BIN) { const Ee = BINARY_EXTENSION_HEADER_LENGTH + ye; this.body = K.slice(Ee, Ee + ve) } ye += ve } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class GLTFDracoMeshCompressionExtension { constructor(K, pe) { if (!pe) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = K, this.dracoLoader = pe, this.dracoLoader.preload() } decodePrimitive(K, pe) { const me = this.json, ge = this.dracoLoader, xe = K.extensions[this.name].bufferView, ye = K.extensions[this.name].attributes, ve = {}, _e = {}, Ee = {}; for (const be in ye) { const Ae = ATTRIBUTES[be] || be.toLowerCase(); ve[Ae] = ye[be] } for (const be in K.attributes) { const Ae = ATTRIBUTES[be] || be.toLowerCase(); if (ye[be] !== void 0) { const Se = me.accessors[K.attributes[be]], Ce = WEBGL_COMPONENT_TYPES[Se.componentType]; Ee[Ae] = Ce.name, _e[Ae] = Se.normalized === !0 } } return pe.getDependency("bufferView", xe).then(function (be) { return new Promise(function (Ae, Se) { ge.decodeDracoFile(be, function (Ce) { for (const we in Ce.attributes) { const Be = Ce.attributes[we], De = _e[we]; De !== void 0 && (Be.normalized = De) } Ae(Ce) }, ve, Ee, LinearSRGBColorSpace, Se) }) }) } } class GLTFTextureTransformExtension { constructor() { this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM } extendTexture(K, pe) { return (pe.texCoord === void 0 || pe.texCoord === K.channel) && pe.offset === void 0 && pe.rotation === void 0 && pe.scale === void 0 || (K = K.clone(), pe.texCoord !== void 0 && (K.channel = pe.texCoord), pe.offset !== void 0 && K.offset.fromArray(pe.offset), pe.rotation !== void 0 && (K.rotation = pe.rotation), pe.scale !== void 0 && K.repeat.fromArray(pe.scale), K.needsUpdate = !0), K } } class GLTFMeshQuantizationExtension { constructor() { this.name = EXTENSIONS.KHR_MESH_QUANTIZATION } } class GLTFCubicSplineInterpolant extends Interpolant { constructor(K, pe, me, ge) { super(K, pe, me, ge) } copySampleValue_(K) { const pe = this.resultBuffer, me = this.sampleValues, ge = this.valueSize, xe = K * ge * 3 + ge; for (let ye = 0; ye !== ge; ye++)pe[ye] = me[xe + ye]; return pe } interpolate_(K, pe, me, ge) { const xe = this.resultBuffer, ye = this.sampleValues, ve = this.valueSize, _e = ve * 2, Ee = ve * 3, be = ge - pe, Ae = (me - pe) / be, Se = Ae * Ae, Ce = Se * Ae, we = K * Ee, Be = we - Ee, De = -2 * Ce + 3 * Se, Re = Ce - Se, Ie = 1 - De, Pe = Re - Se + Ae; for (let Ne = 0; Ne !== ve; Ne++) { const ke = ye[Be + Ne + ve], Oe = ye[Be + Ne + _e] * be, Ue = ye[we + Ne + ve], He = ye[we + Ne] * be; xe[Ne] = Ie * ke + Pe * Oe + De * Ue + Re * He } return xe } } const _q = new Quaternion; class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant { interpolate_(K, pe, me, ge) { const xe = super.interpolate_(K, pe, me, ge); return _q.fromArray(xe).normalize().toArray(xe), xe } } const WEBGL_CONSTANTS = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 }, WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, WEBGL_FILTERS = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }, WEBGL_WRAPPINGS = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }, WEBGL_TYPE_SIZES = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, ATTRIBUTES = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, PATH_PROPERTIES = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, INTERPOLATION = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }, ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function createDefaultMaterial(fe) { return fe.DefaultMaterial === void 0 && (fe.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: FrontSide })), fe.DefaultMaterial } function addUnknownExtensionsToUserData(fe, K, pe) { for (const me in pe.extensions) fe[me] === void 0 && (K.userData.gltfExtensions = K.userData.gltfExtensions || {}, K.userData.gltfExtensions[me] = pe.extensions[me]) } function assignExtrasToUserData(fe, K) { K.extras !== void 0 && (typeof K.extras == "object" ? Object.assign(fe.userData, K.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + K.extras)) } function addMorphTargets(fe, K, pe) { let me = !1, ge = !1, xe = !1; for (let Ee = 0, be = K.length; Ee < be; Ee++) { const Ae = K[Ee]; if (Ae.POSITION !== void 0 && (me = !0), Ae.NORMAL !== void 0 && (ge = !0), Ae.COLOR_0 !== void 0 && (xe = !0), me && ge && xe) break } if (!me && !ge && !xe) return Promise.resolve(fe); const ye = [], ve = [], _e = []; for (let Ee = 0, be = K.length; Ee < be; Ee++) { const Ae = K[Ee]; if (me) { const Se = Ae.POSITION !== void 0 ? pe.getDependency("accessor", Ae.POSITION) : fe.attributes.position; ye.push(Se) } if (ge) { const Se = Ae.NORMAL !== void 0 ? pe.getDependency("accessor", Ae.NORMAL) : fe.attributes.normal; ve.push(Se) } if (xe) { const Se = Ae.COLOR_0 !== void 0 ? pe.getDependency("accessor", Ae.COLOR_0) : fe.attributes.color; _e.push(Se) } } return Promise.all([Promise.all(ye), Promise.all(ve), Promise.all(_e)]).then(function (Ee) { const be = Ee[0], Ae = Ee[1], Se = Ee[2]; return me && (fe.morphAttributes.position = be), ge && (fe.morphAttributes.normal = Ae), xe && (fe.morphAttributes.color = Se), fe.morphTargetsRelative = !0, fe }) } function updateMorphTargets(fe, K) { if (fe.updateMorphTargets(), K.weights !== void 0) for (let pe = 0, me = K.weights.length; pe < me; pe++)fe.morphTargetInfluences[pe] = K.weights[pe]; if (K.extras && Array.isArray(K.extras.targetNames)) { const pe = K.extras.targetNames; if (fe.morphTargetInfluences.length === pe.length) { fe.morphTargetDictionary = {}; for (let me = 0, ge = pe.length; me < ge; me++)fe.morphTargetDictionary[pe[me]] = me } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function createPrimitiveKey(fe) { let K; const pe = fe.extensions && fe.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]; if (pe ? K = "draco:" + pe.bufferView + ":" + pe.indices + ":" + createAttributesKey(pe.attributes) : K = fe.indices + ":" + createAttributesKey(fe.attributes) + ":" + fe.mode, fe.targets !== void 0) for (let me = 0, ge = fe.targets.length; me < ge; me++)K += ":" + createAttributesKey(fe.targets[me]); return K } function createAttributesKey(fe) { let K = ""; const pe = Object.keys(fe).sort(); for (let me = 0, ge = pe.length; me < ge; me++)K += pe[me] + ":" + fe[pe[me]] + ";"; return K } function getNormalizedComponentScale(fe) { switch (fe) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function getImageURIMimeType(fe) { return fe.search(/\.jpe?g($|\?)/i) > 0 || fe.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : fe.search(/\.webp($|\?)/i) > 0 || fe.search(/^data\:image\/webp/) === 0 ? "image/webp" : fe.search(/\.ktx2($|\?)/i) > 0 || fe.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png" } const _identityMatrix = new Matrix4; class GLTFParser { constructor(K = {}, pe = {}) { this.json = K, this.extensions = {}, this.plugins = {}, this.options = pe, this.cache = new GLTFRegistry, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let me = !1, ge = -1, xe = !1, ye = -1; if (typeof navigator < "u") { const ve = navigator.userAgent; me = /^((?!chrome|android).)*safari/i.test(ve) === !0; const _e = ve.match(/Version\/(\d+)/); ge = me && _e ? parseInt(_e[1], 10) : -1, xe = ve.indexOf("Firefox") > -1, ye = xe ? ve.match(/Firefox\/([0-9]+)\./)[1] : -1 } typeof createImageBitmap > "u" || me && ge < 17 || xe && ye < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(K) { this.extensions = K } setPlugins(K) { this.plugins = K } parse(K, pe) { const me = this, ge = this.json, xe = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (ye) { return ye._markDefs && ye._markDefs() }), Promise.all(this._invokeAll(function (ye) { return ye.beforeRoot && ye.beforeRoot() })).then(function () { return Promise.all([me.getDependencies("scene"), me.getDependencies("animation"), me.getDependencies("camera")]) }).then(function (ye) { const ve = { scene: ye[0][ge.scene || 0], scenes: ye[0], animations: ye[1], cameras: ye[2], asset: ge.asset, parser: me, userData: {} }; return addUnknownExtensionsToUserData(xe, ve, ge), assignExtrasToUserData(ve, ge), Promise.all(me._invokeAll(function (_e) { return _e.afterRoot && _e.afterRoot(ve) })).then(function () { for (const _e of ve.scenes) _e.updateMatrixWorld(); K(ve) }) }).catch(pe) } _markDefs() { const K = this.json.nodes || [], pe = this.json.skins || [], me = this.json.meshes || []; for (let ge = 0, xe = pe.length; ge < xe; ge++) { const ye = pe[ge].joints; for (let ve = 0, _e = ye.length; ve < _e; ve++)K[ye[ve]].isBone = !0 } for (let ge = 0, xe = K.length; ge < xe; ge++) { const ye = K[ge]; ye.mesh !== void 0 && (this._addNodeRef(this.meshCache, ye.mesh), ye.skin !== void 0 && (me[ye.mesh].isSkinnedMesh = !0)), ye.camera !== void 0 && this._addNodeRef(this.cameraCache, ye.camera) } } _addNodeRef(K, pe) { pe !== void 0 && (K.refs[pe] === void 0 && (K.refs[pe] = K.uses[pe] = 0), K.refs[pe]++) } _getNodeRef(K, pe, me) { if (K.refs[pe] <= 1) return me; const ge = me.clone(), xe = (ye, ve) => { const _e = this.associations.get(ye); _e != null && this.associations.set(ve, _e); for (const [Ee, be] of ye.children.entries()) xe(be, ve.children[Ee]) }; return xe(me, ge), ge.name += "_instance_" + K.uses[pe]++, ge } _invokeOne(K) { const pe = Object.values(this.plugins); pe.push(this); for (let me = 0; me < pe.length; me++) { const ge = K(pe[me]); if (ge) return ge } return null } _invokeAll(K) { const pe = Object.values(this.plugins); pe.unshift(this); const me = []; for (let ge = 0; ge < pe.length; ge++) { const xe = K(pe[ge]); xe && me.push(xe) } return me } getDependency(K, pe) { const me = K + ":" + pe; let ge = this.cache.get(me); if (!ge) { switch (K) { case "scene": ge = this.loadScene(pe); break; case "node": ge = this._invokeOne(function (xe) { return xe.loadNode && xe.loadNode(pe) }); break; case "mesh": ge = this._invokeOne(function (xe) { return xe.loadMesh && xe.loadMesh(pe) }); break; case "accessor": ge = this.loadAccessor(pe); break; case "bufferView": ge = this._invokeOne(function (xe) { return xe.loadBufferView && xe.loadBufferView(pe) }); break; case "buffer": ge = this.loadBuffer(pe); break; case "material": ge = this._invokeOne(function (xe) { return xe.loadMaterial && xe.loadMaterial(pe) }); break; case "texture": ge = this._invokeOne(function (xe) { return xe.loadTexture && xe.loadTexture(pe) }); break; case "skin": ge = this.loadSkin(pe); break; case "animation": ge = this._invokeOne(function (xe) { return xe.loadAnimation && xe.loadAnimation(pe) }); break; case "camera": ge = this.loadCamera(pe); break; default: if (ge = this._invokeOne(function (xe) { return xe != this && xe.getDependency && xe.getDependency(K, pe) }), !ge) throw new Error("Unknown type: " + K); break }this.cache.add(me, ge) } return ge } getDependencies(K) { let pe = this.cache.get(K); if (!pe) { const me = this, ge = this.json[K + (K === "mesh" ? "es" : "s")] || []; pe = Promise.all(ge.map(function (xe, ye) { return me.getDependency(K, ye) })), this.cache.add(K, pe) } return pe } loadBuffer(K) { const pe = this.json.buffers[K], me = this.fileLoader; if (pe.type && pe.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + pe.type + " buffer type is not supported."); if (pe.uri === void 0 && K === 0) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body); const ge = this.options; return new Promise(function (xe, ye) { me.load(LoaderUtils.resolveURL(pe.uri, ge.path), xe, void 0, function () { ye(new Error('THREE.GLTFLoader: Failed to load buffer "' + pe.uri + '".')) }) }) } loadBufferView(K) { const pe = this.json.bufferViews[K]; return this.getDependency("buffer", pe.buffer).then(function (me) { const ge = pe.byteLength || 0, xe = pe.byteOffset || 0; return me.slice(xe, xe + ge) }) } loadAccessor(K) { const pe = this, me = this.json, ge = this.json.accessors[K]; if (ge.bufferView === void 0 && ge.sparse === void 0) { const ye = WEBGL_TYPE_SIZES[ge.type], ve = WEBGL_COMPONENT_TYPES[ge.componentType], _e = ge.normalized === !0, Ee = new ve(ge.count * ye); return Promise.resolve(new BufferAttribute(Ee, ye, _e)) } const xe = []; return ge.bufferView !== void 0 ? xe.push(this.getDependency("bufferView", ge.bufferView)) : xe.push(null), ge.sparse !== void 0 && (xe.push(this.getDependency("bufferView", ge.sparse.indices.bufferView)), xe.push(this.getDependency("bufferView", ge.sparse.values.bufferView))), Promise.all(xe).then(function (ye) { const ve = ye[0], _e = WEBGL_TYPE_SIZES[ge.type], Ee = WEBGL_COMPONENT_TYPES[ge.componentType], be = Ee.BYTES_PER_ELEMENT, Ae = be * _e, Se = ge.byteOffset || 0, Ce = ge.bufferView !== void 0 ? me.bufferViews[ge.bufferView].byteStride : void 0, we = ge.normalized === !0; let Be, De; if (Ce && Ce !== Ae) { const Re = Math.floor(Se / Ce), Ie = "InterleavedBuffer:" + ge.bufferView + ":" + ge.componentType + ":" + Re + ":" + ge.count; let Pe = pe.cache.get(Ie); Pe || (Be = new Ee(ve, Re * Ce, ge.count * Ce / be), Pe = new InterleavedBuffer(Be, Ce / be), pe.cache.add(Ie, Pe)), De = new InterleavedBufferAttribute(Pe, _e, Se % Ce / be, we) } else ve === null ? Be = new Ee(ge.count * _e) : Be = new Ee(ve, Se, ge.count * _e), De = new BufferAttribute(Be, _e, we); if (ge.sparse !== void 0) { const Re = WEBGL_TYPE_SIZES.SCALAR, Ie = WEBGL_COMPONENT_TYPES[ge.sparse.indices.componentType], Pe = ge.sparse.indices.byteOffset || 0, Ne = ge.sparse.values.byteOffset || 0, ke = new Ie(ye[1], Pe, ge.sparse.count * Re), Oe = new Ee(ye[2], Ne, ge.sparse.count * _e); ve !== null && (De = new BufferAttribute(De.array.slice(), De.itemSize, De.normalized)), De.normalized = !1; for (let Ue = 0, He = ke.length; Ue < He; Ue++) { const Ge = ke[Ue]; if (De.setX(Ge, Oe[Ue * _e]), _e >= 2 && De.setY(Ge, Oe[Ue * _e + 1]), _e >= 3 && De.setZ(Ge, Oe[Ue * _e + 2]), _e >= 4 && De.setW(Ge, Oe[Ue * _e + 3]), _e >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } De.normalized = we } return De }) } loadTexture(K) { const pe = this.json, me = this.options, xe = pe.textures[K].source, ye = pe.images[xe]; let ve = this.textureLoader; if (ye.uri) { const _e = me.manager.getHandler(ye.uri); _e !== null && (ve = _e) } return this.loadTextureImage(K, xe, ve) } loadTextureImage(K, pe, me) { const ge = this, xe = this.json, ye = xe.textures[K], ve = xe.images[pe], _e = (ve.uri || ve.bufferView) + ":" + ye.sampler; if (this.textureCache[_e]) return this.textureCache[_e]; const Ee = this.loadImageSource(pe, me).then(function (be) { be.flipY = !1, be.name = ye.name || ve.name || "", be.name === "" && typeof ve.uri == "string" && ve.uri.startsWith("data:image/") === !1 && (be.name = ve.uri); const Se = (xe.samplers || {})[ye.sampler] || {}; return be.magFilter = WEBGL_FILTERS[Se.magFilter] || LinearFilter, be.minFilter = WEBGL_FILTERS[Se.minFilter] || LinearMipmapLinearFilter, be.wrapS = WEBGL_WRAPPINGS[Se.wrapS] || RepeatWrapping, be.wrapT = WEBGL_WRAPPINGS[Se.wrapT] || RepeatWrapping, be.generateMipmaps = !be.isCompressedTexture && be.minFilter !== NearestFilter && be.minFilter !== LinearFilter, ge.associations.set(be, { textures: K }), be }).catch(function () { return null }); return this.textureCache[_e] = Ee, Ee } loadImageSource(K, pe) { const me = this, ge = this.json, xe = this.options; if (this.sourceCache[K] !== void 0) return this.sourceCache[K].then(Ae => Ae.clone()); const ye = ge.images[K], ve = self.URL || self.webkitURL; let _e = ye.uri || "", Ee = !1; if (ye.bufferView !== void 0) _e = me.getDependency("bufferView", ye.bufferView).then(function (Ae) { Ee = !0; const Se = new Blob([Ae], { type: ye.mimeType }); return _e = ve.createObjectURL(Se), _e }); else if (ye.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + K + " is missing URI and bufferView"); const be = Promise.resolve(_e).then(function (Ae) { return new Promise(function (Se, Ce) { let we = Se; pe.isImageBitmapLoader === !0 && (we = function (Be) { const De = new Texture(Be); De.needsUpdate = !0, Se(De) }), pe.load(LoaderUtils.resolveURL(Ae, xe.path), we, void 0, Ce) }) }).then(function (Ae) { return Ee === !0 && ve.revokeObjectURL(_e), assignExtrasToUserData(Ae, ye), Ae.userData.mimeType = ye.mimeType || getImageURIMimeType(ye.uri), Ae }).catch(function (Ae) { throw console.error("THREE.GLTFLoader: Couldn't load texture", _e), Ae }); return this.sourceCache[K] = be, be } assignTexture(K, pe, me, ge) { const xe = this; return this.getDependency("texture", me.index).then(function (ye) { if (!ye) return null; if (me.texCoord !== void 0 && me.texCoord > 0 && (ye = ye.clone(), ye.channel = me.texCoord), xe.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) { const ve = me.extensions !== void 0 ? me.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0; if (ve) { const _e = xe.associations.get(ye); ye = xe.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(ye, ve), xe.associations.set(ye, _e) } } return ge !== void 0 && (ye.colorSpace = ge), K[pe] = ye, ye }) } assignFinalMaterial(K) { const pe = K.geometry; let me = K.material; const ge = pe.attributes.tangent === void 0, xe = pe.attributes.color !== void 0, ye = pe.attributes.normal === void 0; if (K.isPoints) { const ve = "PointsMaterial:" + me.uuid; let _e = this.cache.get(ve); _e || (_e = new PointsMaterial, Material.prototype.copy.call(_e, me), _e.color.copy(me.color), _e.map = me.map, _e.sizeAttenuation = !1, this.cache.add(ve, _e)), me = _e } else if (K.isLine) { const ve = "LineBasicMaterial:" + me.uuid; let _e = this.cache.get(ve); _e || (_e = new LineBasicMaterial, Material.prototype.copy.call(_e, me), _e.color.copy(me.color), _e.map = me.map, this.cache.add(ve, _e)), me = _e } if (ge || xe || ye) { let ve = "ClonedMaterial:" + me.uuid + ":"; ge && (ve += "derivative-tangents:"), xe && (ve += "vertex-colors:"), ye && (ve += "flat-shading:"); let _e = this.cache.get(ve); _e || (_e = me.clone(), xe && (_e.vertexColors = !0), ye && (_e.flatShading = !0), ge && (_e.normalScale && (_e.normalScale.y *= -1), _e.clearcoatNormalScale && (_e.clearcoatNormalScale.y *= -1)), this.cache.add(ve, _e), this.associations.set(_e, this.associations.get(me))), me = _e } K.material = me } getMaterialType() { return MeshStandardMaterial } loadMaterial(K) { const pe = this, me = this.json, ge = this.extensions, xe = me.materials[K]; let ye; const ve = {}, _e = xe.extensions || {}, Ee = []; if (_e[EXTENSIONS.KHR_MATERIALS_UNLIT]) { const Ae = ge[EXTENSIONS.KHR_MATERIALS_UNLIT]; ye = Ae.getMaterialType(), Ee.push(Ae.extendParams(ve, xe, pe)) } else { const Ae = xe.pbrMetallicRoughness || {}; if (ve.color = new Color$1(1, 1, 1), ve.opacity = 1, Array.isArray(Ae.baseColorFactor)) { const Se = Ae.baseColorFactor; ve.color.setRGB(Se[0], Se[1], Se[2], LinearSRGBColorSpace), ve.opacity = Se[3] } Ae.baseColorTexture !== void 0 && Ee.push(pe.assignTexture(ve, "map", Ae.baseColorTexture, SRGBColorSpace)), ve.metalness = Ae.metallicFactor !== void 0 ? Ae.metallicFactor : 1, ve.roughness = Ae.roughnessFactor !== void 0 ? Ae.roughnessFactor : 1, Ae.metallicRoughnessTexture !== void 0 && (Ee.push(pe.assignTexture(ve, "metalnessMap", Ae.metallicRoughnessTexture)), Ee.push(pe.assignTexture(ve, "roughnessMap", Ae.metallicRoughnessTexture))), ye = this._invokeOne(function (Se) { return Se.getMaterialType && Se.getMaterialType(K) }), Ee.push(Promise.all(this._invokeAll(function (Se) { return Se.extendMaterialParams && Se.extendMaterialParams(K, ve) }))) } xe.doubleSided === !0 && (ve.side = DoubleSide); const be = xe.alphaMode || ALPHA_MODES.OPAQUE; if (be === ALPHA_MODES.BLEND ? (ve.transparent = !0, ve.depthWrite = !1) : (ve.transparent = !1, be === ALPHA_MODES.MASK && (ve.alphaTest = xe.alphaCutoff !== void 0 ? xe.alphaCutoff : .5)), xe.normalTexture !== void 0 && ye !== MeshBasicMaterial && (Ee.push(pe.assignTexture(ve, "normalMap", xe.normalTexture)), ve.normalScale = new Vector2(1, 1), xe.normalTexture.scale !== void 0)) { const Ae = xe.normalTexture.scale; ve.normalScale.set(Ae, Ae) } if (xe.occlusionTexture !== void 0 && ye !== MeshBasicMaterial && (Ee.push(pe.assignTexture(ve, "aoMap", xe.occlusionTexture)), xe.occlusionTexture.strength !== void 0 && (ve.aoMapIntensity = xe.occlusionTexture.strength)), xe.emissiveFactor !== void 0 && ye !== MeshBasicMaterial) { const Ae = xe.emissiveFactor; ve.emissive = new Color$1().setRGB(Ae[0], Ae[1], Ae[2], LinearSRGBColorSpace) } return xe.emissiveTexture !== void 0 && ye !== MeshBasicMaterial && Ee.push(pe.assignTexture(ve, "emissiveMap", xe.emissiveTexture, SRGBColorSpace)), Promise.all(Ee).then(function () { const Ae = new ye(ve); return xe.name && (Ae.name = xe.name), assignExtrasToUserData(Ae, xe), pe.associations.set(Ae, { materials: K }), xe.extensions && addUnknownExtensionsToUserData(ge, Ae, xe), Ae }) } createUniqueName(K) { const pe = PropertyBinding.sanitizeNodeName(K || ""); return pe in this.nodeNamesUsed ? pe + "_" + ++this.nodeNamesUsed[pe] : (this.nodeNamesUsed[pe] = 0, pe) } loadGeometries(K) { const pe = this, me = this.extensions, ge = this.primitiveCache; function xe(ve) { return me[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(ve, pe).then(function (_e) { return addPrimitiveAttributes(_e, ve, pe) }) } const ye = []; for (let ve = 0, _e = K.length; ve < _e; ve++) { const Ee = K[ve], be = createPrimitiveKey(Ee), Ae = ge[be]; if (Ae) ye.push(Ae.promise); else { let Se; Ee.extensions && Ee.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? Se = xe(Ee) : Se = addPrimitiveAttributes(new BufferGeometry, Ee, pe), ge[be] = { primitive: Ee, promise: Se }, ye.push(Se) } } return Promise.all(ye) } loadMesh(K) { const pe = this, me = this.json, ge = this.extensions, xe = me.meshes[K], ye = xe.primitives, ve = []; for (let _e = 0, Ee = ye.length; _e < Ee; _e++) { const be = ye[_e].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", ye[_e].material); ve.push(be) } return ve.push(pe.loadGeometries(ye)), Promise.all(ve).then(function (_e) { const Ee = _e.slice(0, _e.length - 1), be = _e[_e.length - 1], Ae = []; for (let Ce = 0, we = be.length; Ce < we; Ce++) { const Be = be[Ce], De = ye[Ce]; let Re; const Ie = Ee[Ce]; if (De.mode === WEBGL_CONSTANTS.TRIANGLES || De.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || De.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || De.mode === void 0) Re = xe.isSkinnedMesh === !0 ? new SkinnedMesh$1(Be, Ie) : new Mesh(Be, Ie), Re.isSkinnedMesh === !0 && Re.normalizeSkinWeights(), De.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? Re.geometry = toTrianglesDrawMode(Re.geometry, TriangleStripDrawMode) : De.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (Re.geometry = toTrianglesDrawMode(Re.geometry, TriangleFanDrawMode)); else if (De.mode === WEBGL_CONSTANTS.LINES) Re = new LineSegments(Be, Ie); else if (De.mode === WEBGL_CONSTANTS.LINE_STRIP) Re = new Line$2(Be, Ie); else if (De.mode === WEBGL_CONSTANTS.LINE_LOOP) Re = new LineLoop(Be, Ie); else if (De.mode === WEBGL_CONSTANTS.POINTS) Re = new Points(Be, Ie); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + De.mode); Object.keys(Re.geometry.morphAttributes).length > 0 && updateMorphTargets(Re, xe), Re.name = pe.createUniqueName(xe.name || "mesh_" + K), assignExtrasToUserData(Re, xe), De.extensions && addUnknownExtensionsToUserData(ge, Re, De), pe.assignFinalMaterial(Re), Ae.push(Re) } for (let Ce = 0, we = Ae.length; Ce < we; Ce++)pe.associations.set(Ae[Ce], { meshes: K, primitives: Ce }); if (Ae.length === 1) return xe.extensions && addUnknownExtensionsToUserData(ge, Ae[0], xe), Ae[0]; const Se = new Group; xe.extensions && addUnknownExtensionsToUserData(ge, Se, xe), pe.associations.set(Se, { meshes: K }); for (let Ce = 0, we = Ae.length; Ce < we; Ce++)Se.add(Ae[Ce]); return Se }) } loadCamera(K) { let pe; const me = this.json.cameras[K], ge = me[me.type]; if (!ge) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return me.type === "perspective" ? pe = new PerspectiveCamera(MathUtils.radToDeg(ge.yfov), ge.aspectRatio || 1, ge.znear || 1, ge.zfar || 2e6) : me.type === "orthographic" && (pe = new OrthographicCamera(-ge.xmag, ge.xmag, ge.ymag, -ge.ymag, ge.znear, ge.zfar)), me.name && (pe.name = this.createUniqueName(me.name)), assignExtrasToUserData(pe, me), Promise.resolve(pe) } loadSkin(K) { const pe = this.json.skins[K], me = []; for (let ge = 0, xe = pe.joints.length; ge < xe; ge++)me.push(this._loadNodeShallow(pe.joints[ge])); return pe.inverseBindMatrices !== void 0 ? me.push(this.getDependency("accessor", pe.inverseBindMatrices)) : me.push(null), Promise.all(me).then(function (ge) { const xe = ge.pop(), ye = ge, ve = [], _e = []; for (let Ee = 0, be = ye.length; Ee < be; Ee++) { const Ae = ye[Ee]; if (Ae) { ve.push(Ae); const Se = new Matrix4; xe !== null && Se.fromArray(xe.array, Ee * 16), _e.push(Se) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', pe.joints[Ee]) } return new Skeleton(ve, _e) }) } loadAnimation(K) { const pe = this.json, me = this, ge = pe.animations[K], xe = ge.name ? ge.name : "animation_" + K, ye = [], ve = [], _e = [], Ee = [], be = []; for (let Ae = 0, Se = ge.channels.length; Ae < Se; Ae++) { const Ce = ge.channels[Ae], we = ge.samplers[Ce.sampler], Be = Ce.target, De = Be.node, Re = ge.parameters !== void 0 ? ge.parameters[we.input] : we.input, Ie = ge.parameters !== void 0 ? ge.parameters[we.output] : we.output; Be.node !== void 0 && (ye.push(this.getDependency("node", De)), ve.push(this.getDependency("accessor", Re)), _e.push(this.getDependency("accessor", Ie)), Ee.push(we), be.push(Be)) } return Promise.all([Promise.all(ye), Promise.all(ve), Promise.all(_e), Promise.all(Ee), Promise.all(be)]).then(function (Ae) { const Se = Ae[0], Ce = Ae[1], we = Ae[2], Be = Ae[3], De = Ae[4], Re = []; for (let Ie = 0, Pe = Se.length; Ie < Pe; Ie++) { const Ne = Se[Ie], ke = Ce[Ie], Oe = we[Ie], Ue = Be[Ie], He = De[Ie]; if (Ne === void 0) continue; Ne.updateMatrix && Ne.updateMatrix(); const Ge = me._createAnimationTracks(Ne, ke, Oe, Ue, He); if (Ge) for (let ze = 0; ze < Ge.length; ze++)Re.push(Ge[ze]) } return new AnimationClip(xe, void 0, Re) }) } createNodeMesh(K) { const pe = this.json, me = this, ge = pe.nodes[K]; return ge.mesh === void 0 ? null : me.getDependency("mesh", ge.mesh).then(function (xe) { const ye = me._getNodeRef(me.meshCache, ge.mesh, xe); return ge.weights !== void 0 && ye.traverse(function (ve) { if (ve.isMesh) for (let _e = 0, Ee = ge.weights.length; _e < Ee; _e++)ve.morphTargetInfluences[_e] = ge.weights[_e] }), ye }) } loadNode(K) { const pe = this.json, me = this, ge = pe.nodes[K], xe = me._loadNodeShallow(K), ye = [], ve = ge.children || []; for (let Ee = 0, be = ve.length; Ee < be; Ee++)ye.push(me.getDependency("node", ve[Ee])); const _e = ge.skin === void 0 ? Promise.resolve(null) : me.getDependency("skin", ge.skin); return Promise.all([xe, Promise.all(ye), _e]).then(function (Ee) { const be = Ee[0], Ae = Ee[1], Se = Ee[2]; Se !== null && be.traverse(function (Ce) { Ce.isSkinnedMesh && Ce.bind(Se, _identityMatrix) }); for (let Ce = 0, we = Ae.length; Ce < we; Ce++)be.add(Ae[Ce]); return be }) } _loadNodeShallow(K) { const pe = this.json, me = this.extensions, ge = this; if (this.nodeCache[K] !== void 0) return this.nodeCache[K]; const xe = pe.nodes[K], ye = xe.name ? ge.createUniqueName(xe.name) : "", ve = [], _e = ge._invokeOne(function (Ee) { return Ee.createNodeMesh && Ee.createNodeMesh(K) }); return _e && ve.push(_e), xe.camera !== void 0 && ve.push(ge.getDependency("camera", xe.camera).then(function (Ee) { return ge._getNodeRef(ge.cameraCache, xe.camera, Ee) })), ge._invokeAll(function (Ee) { return Ee.createNodeAttachment && Ee.createNodeAttachment(K) }).forEach(function (Ee) { ve.push(Ee) }), this.nodeCache[K] = Promise.all(ve).then(function (Ee) { let be; if (xe.isBone === !0 ? be = new Bone : Ee.length > 1 ? be = new Group : Ee.length === 1 ? be = Ee[0] : be = new Object3D, be !== Ee[0]) for (let Ae = 0, Se = Ee.length; Ae < Se; Ae++)be.add(Ee[Ae]); if (xe.name && (be.userData.name = xe.name, be.name = ye), assignExtrasToUserData(be, xe), xe.extensions && addUnknownExtensionsToUserData(me, be, xe), xe.matrix !== void 0) { const Ae = new Matrix4; Ae.fromArray(xe.matrix), be.applyMatrix4(Ae) } else xe.translation !== void 0 && be.position.fromArray(xe.translation), xe.rotation !== void 0 && be.quaternion.fromArray(xe.rotation), xe.scale !== void 0 && be.scale.fromArray(xe.scale); return ge.associations.has(be) || ge.associations.set(be, {}), ge.associations.get(be).nodes = K, be }), this.nodeCache[K] } loadScene(K) { const pe = this.extensions, me = this.json.scenes[K], ge = this, xe = new Group; me.name && (xe.name = ge.createUniqueName(me.name)), assignExtrasToUserData(xe, me), me.extensions && addUnknownExtensionsToUserData(pe, xe, me); const ye = me.nodes || [], ve = []; for (let _e = 0, Ee = ye.length; _e < Ee; _e++)ve.push(ge.getDependency("node", ye[_e])); return Promise.all(ve).then(function (_e) { for (let be = 0, Ae = _e.length; be < Ae; be++)xe.add(_e[be]); const Ee = be => { const Ae = new Map; for (const [Se, Ce] of ge.associations) (Se instanceof Material || Se instanceof Texture) && Ae.set(Se, Ce); return be.traverse(Se => { const Ce = ge.associations.get(Se); Ce != null && Ae.set(Se, Ce) }), Ae }; return ge.associations = Ee(xe), xe }) } _createAnimationTracks(K, pe, me, ge, xe) { const ye = [], ve = K.name ? K.name : K.uuid, _e = []; PATH_PROPERTIES[xe.path] === PATH_PROPERTIES.weights ? K.traverse(function (Se) { Se.morphTargetInfluences && _e.push(Se.name ? Se.name : Se.uuid) }) : _e.push(ve); let Ee; switch (PATH_PROPERTIES[xe.path]) { case PATH_PROPERTIES.weights: Ee = NumberKeyframeTrack; break; case PATH_PROPERTIES.rotation: Ee = QuaternionKeyframeTrack; break; case PATH_PROPERTIES.position: case PATH_PROPERTIES.scale: Ee = VectorKeyframeTrack; break; default: switch (me.itemSize) { case 1: Ee = NumberKeyframeTrack; break; case 2: case 3: default: Ee = VectorKeyframeTrack; break }break }const be = ge.interpolation !== void 0 ? INTERPOLATION[ge.interpolation] : InterpolateLinear, Ae = this._getArrayFromAccessor(me); for (let Se = 0, Ce = _e.length; Se < Ce; Se++) { const we = new Ee(_e[Se] + "." + PATH_PROPERTIES[xe.path], pe.array, Ae, be); ge.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(we), ye.push(we) } return ye } _getArrayFromAccessor(K) { let pe = K.array; if (K.normalized) { const me = getNormalizedComponentScale(pe.constructor), ge = new Float32Array(pe.length); for (let xe = 0, ye = pe.length; xe < ye; xe++)ge[xe] = pe[xe] * me; pe = ge } return pe } _createCubicSplineTrackInterpolant(K) { K.createInterpolant = function (me) { const ge = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant; return new ge(this.times, this.values, this.getValueSize() / 3, me) }, K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function computeBounds(fe, K, pe) { const me = K.attributes, ge = new Box3; if (me.POSITION !== void 0) { const ve = pe.json.accessors[me.POSITION], _e = ve.min, Ee = ve.max; if (_e !== void 0 && Ee !== void 0) { if (ge.set(new Vector3(_e[0], _e[1], _e[2]), new Vector3(Ee[0], Ee[1], Ee[2])), ve.normalized) { const be = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[ve.componentType]); ge.min.multiplyScalar(be), ge.max.multiplyScalar(be) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const xe = K.targets; if (xe !== void 0) { const ve = new Vector3, _e = new Vector3; for (let Ee = 0, be = xe.length; Ee < be; Ee++) { const Ae = xe[Ee]; if (Ae.POSITION !== void 0) { const Se = pe.json.accessors[Ae.POSITION], Ce = Se.min, we = Se.max; if (Ce !== void 0 && we !== void 0) { if (_e.setX(Math.max(Math.abs(Ce[0]), Math.abs(we[0]))), _e.setY(Math.max(Math.abs(Ce[1]), Math.abs(we[1]))), _e.setZ(Math.max(Math.abs(Ce[2]), Math.abs(we[2]))), Se.normalized) { const Be = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[Se.componentType]); _e.multiplyScalar(Be) } ve.max(_e) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } ge.expandByVector(ve) } fe.boundingBox = ge; const ye = new Sphere; ge.getCenter(ye.center), ye.radius = ge.min.distanceTo(ge.max) / 2, fe.boundingSphere = ye } function addPrimitiveAttributes(fe, K, pe) { const me = K.attributes, ge = []; function xe(ye, ve) { return pe.getDependency("accessor", ye).then(function (_e) { fe.setAttribute(ve, _e) }) } for (const ye in me) { const ve = ATTRIBUTES[ye] || ye.toLowerCase(); ve in fe.attributes || ge.push(xe(me[ye], ve)) } if (K.indices !== void 0 && !fe.index) { const ye = pe.getDependency("accessor", K.indices).then(function (ve) { fe.setIndex(ve) }); ge.push(ye) } return ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in me && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(fe, K), computeBounds(fe, K, pe), Promise.all(ge).then(function () { return K.targets !== void 0 ? addMorphTargets(fe, K.targets, pe) : fe }) } const _taskCache = new WeakMap; class DRACOLoader extends Loader {
	constructor(K) { super(K), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(K) { return this.decoderPath = K, this } setDecoderConfig(K) { return this.decoderConfig = K, this } setWorkerLimit(K) { return this.workerLimit = K, this } load(K, pe, me, ge) { const xe = new FileLoader(this.manager); xe.setPath(this.path), xe.setResponseType("arraybuffer"), xe.setRequestHeader(this.requestHeader), xe.setWithCredentials(this.withCredentials), xe.load(K, ye => { this.parse(ye, pe, ge) }, me, ge) } parse(K, pe, me = () => { }) { this.decodeDracoFile(K, pe, null, null, SRGBColorSpace, me).catch(me) } decodeDracoFile(K, pe, me, ge, xe = LinearSRGBColorSpace, ye = () => { }) { const ve = { attributeIDs: me || this.defaultAttributeIDs, attributeTypes: ge || this.defaultAttributeTypes, useUniqueIDs: !!me, vertexColorSpace: xe }; return this.decodeGeometry(K, ve).then(pe).catch(ye) } decodeGeometry(K, pe) { const me = JSON.stringify(pe); if (_taskCache.has(K)) { const _e = _taskCache.get(K); if (_e.key === me) return _e.promise; if (K.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let ge; const xe = this.workerNextTaskID++, ye = K.byteLength, ve = this._getWorker(xe, ye).then(_e => (ge = _e, new Promise((Ee, be) => { ge._callbacks[xe] = { resolve: Ee, reject: be }, ge.postMessage({ type: "decode", id: xe, taskConfig: pe, buffer: K }, [K]) }))).then(_e => this._createGeometry(_e.geometry)); return ve.catch(() => !0).then(() => { ge && xe && this._releaseTask(ge, xe) }), _taskCache.set(K, { key: me, promise: ve }), ve } _createGeometry(K) { const pe = new BufferGeometry; K.index && pe.setIndex(new BufferAttribute(K.index.array, 1)); for (let me = 0; me < K.attributes.length; me++) { const ge = K.attributes[me], xe = ge.name, ye = ge.array, ve = ge.itemSize, _e = new BufferAttribute(ye, ve); xe === "color" && (this._assignVertexColorSpace(_e, ge.vertexColorSpace), _e.normalized = !(ye instanceof Float32Array)), pe.setAttribute(xe, _e) } return pe } _assignVertexColorSpace(K, pe) { if (pe !== SRGBColorSpace) return; const me = new Color$1; for (let ge = 0, xe = K.count; ge < xe; ge++)me.fromBufferAttribute(K, ge), ColorManagement.toWorkingColorSpace(me, SRGBColorSpace), K.setXYZ(ge, me.r, me.g, me.b) } _loadLibrary(K, pe) { const me = new FileLoader(this.manager); return me.setPath(this.decoderPath), me.setResponseType(pe), me.setWithCredentials(this.withCredentials), new Promise((ge, xe) => { me.load(K, ge, void 0, xe) }) } preload() { return this._initDecoder(), this } _initDecoder() {
		if (this.decoderPending) return this.decoderPending; const K = typeof WebAssembly != "object" || this.decoderConfig.type === "js", pe = []; return K ? pe.push(this._loadLibrary("draco_decoder.js", "text")) : (pe.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), pe.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(pe).then(me => {
			const ge = me[0]; K || (this.decoderConfig.wasmBinary = me[1]); const xe = DRACOWorker.toString(), ye = ["/* draco decoder */", ge, "", "/* worker */", xe.substring(xe.indexOf("{") + 1, xe.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([ye]))
		}), this.decoderPending
	} _getWorker(K, pe) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const ge = new Worker(this.workerSourceURL); ge._callbacks = {}, ge._taskCosts = {}, ge._taskLoad = 0, ge.postMessage({ type: "init", decoderConfig: this.decoderConfig }), ge.onmessage = function (xe) { const ye = xe.data; switch (ye.type) { case "decode": ge._callbacks[ye.id].resolve(ye); break; case "error": ge._callbacks[ye.id].reject(ye); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + ye.type + '"') } }, this.workerPool.push(ge) } else this.workerPool.sort(function (ge, xe) { return ge._taskLoad > xe._taskLoad ? -1 : 1 }); const me = this.workerPool[this.workerPool.length - 1]; return me._taskCosts[K] = pe, me._taskLoad += pe, me }) } _releaseTask(K, pe) { K._taskLoad -= K._taskCosts[pe], delete K._callbacks[pe], delete K._taskCosts[pe] } debug() { console.log("Task load: ", this.workerPool.map(K => K._taskLoad)) } dispose() { for (let K = 0; K < this.workerPool.length; ++K)this.workerPool[K].terminate(); return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this }
} function DRACOWorker() { let fe, K; onmessage = function (ye) { const ve = ye.data; switch (ve.type) { case "init": fe = ve.decoderConfig, K = new Promise(function (be) { fe.onModuleLoaded = function (Ae) { be({ draco: Ae }) }, DracoDecoderModule(fe) }); break; case "decode": const _e = ve.buffer, Ee = ve.taskConfig; K.then(be => { const Ae = be.draco, Se = new Ae.Decoder; try { const Ce = pe(Ae, Se, new Int8Array(_e), Ee), we = Ce.attributes.map(Be => Be.array.buffer); Ce.index && we.push(Ce.index.array.buffer), self.postMessage({ type: "decode", id: ve.id, geometry: Ce }, we) } catch (Ce) { console.error(Ce), self.postMessage({ type: "error", id: ve.id, error: Ce.message }) } finally { Ae.destroy(Se) } }); break } }; function pe(ye, ve, _e, Ee) { const be = Ee.attributeIDs, Ae = Ee.attributeTypes; let Se, Ce; const we = ve.GetEncodedGeometryType(_e); if (we === ye.TRIANGULAR_MESH) Se = new ye.Mesh, Ce = ve.DecodeArrayToMesh(_e, _e.byteLength, Se); else if (we === ye.POINT_CLOUD) Se = new ye.PointCloud, Ce = ve.DecodeArrayToPointCloud(_e, _e.byteLength, Se); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!Ce.ok() || Se.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + Ce.error_msg()); const Be = { index: null, attributes: [] }; for (const De in be) { const Re = self[Ae[De]]; let Ie, Pe; if (Ee.useUniqueIDs) Pe = be[De], Ie = ve.GetAttributeByUniqueId(Se, Pe); else { if (Pe = ve.GetAttributeId(Se, ye[be[De]]), Pe === -1) continue; Ie = ve.GetAttribute(Se, Pe) } const Ne = ge(ye, ve, Se, De, Re, Ie); De === "color" && (Ne.vertexColorSpace = Ee.vertexColorSpace), Be.attributes.push(Ne) } return we === ye.TRIANGULAR_MESH && (Be.index = me(ye, ve, Se)), ye.destroy(Se), Be } function me(ye, ve, _e) { const be = _e.num_faces() * 3, Ae = be * 4, Se = ye._malloc(Ae); ve.GetTrianglesUInt32Array(_e, Ae, Se); const Ce = new Uint32Array(ye.HEAPF32.buffer, Se, be).slice(); return ye._free(Se), { array: Ce, itemSize: 1 } } function ge(ye, ve, _e, Ee, be, Ae) { const Se = Ae.num_components(), we = _e.num_points() * Se, Be = we * be.BYTES_PER_ELEMENT, De = xe(ye, be), Re = ye._malloc(Be); ve.GetAttributeDataArrayForAllPoints(_e, Ae, De, Be, Re); const Ie = new be(ye.HEAPF32.buffer, Re, we).slice(); return ye._free(Re), { name: Ee, array: Ie, itemSize: Se } } function xe(ye, ve) { switch (ve) { case Float32Array: return ye.DT_FLOAT32; case Int8Array: return ye.DT_INT8; case Int16Array: return ye.DT_INT16; case Int32Array: return ye.DT_INT32; case Uint8Array: return ye.DT_UINT8; case Uint16Array: return ye.DT_UINT16; case Uint32Array: return ye.DT_UINT32 } } } const dracoLoader = new DRACOLoader; dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"); function disposeNode(fe) { fe instanceof Mesh && (fe.geometry && fe.geometry.dispose(), fe.material && (Array.isArray(fe.material) ? fe.material.forEach(K => { disposeMaterial(K) }) : disposeMaterial(fe.material))) } function useGlbLoader(fe) { const [K, pe] = React$4.useState(), [me, ge] = React$4.useState([]), xe = React$4.useRef(null); return React$4.useEffect(() => { const ye = new GLTFLoader; return ye.setDRACOLoader(dracoLoader), ye.parse(new Uint8Array(fe).buffer, "", ve => { ve.animations && ve.animations.length && (xe.current = new AnimationMixer(ve.scene), ve.animations.forEach(Ee => { xe.current.clipAction(Ee).play() })); const _e = []; ve?.scene.traverse(Ee => { Ee instanceof Mesh && (Ee.geometry.computeVertexNormals(), Ee.geometry.computeBoundingSphere(), _e.push(Ee)) }), ge(_e), pe(ve) }, ve => { console.log("Error loading GLB!"), console.log(ve) }), () => { xe.current && xe.current.stopAllAction(), K && K.scene.traverse(disposeNode) } }, [fe]), { gltf: K, meshes: me, mixerRef: xe } } const SingleGlbAsset = React$4.forwardRef(function ({ children: K, ...pe }, me) { const { gltf: ge, meshes: xe, mixerRef: ye } = useGlbLoader(pe.props.glb_data); React$4.useEffect(() => { ge && ge.scene.traverse(we => { we instanceof Mesh && (we.castShadow = pe.props.cast_shadow, we.receiveShadow = pe.props.receive_shadow) }) }, [ge, pe.props.cast_shadow, pe.props.receive_shadow]), useFrame((we, Be) => { ye.current?.update(Be) }); const ve = useThree(we => we.gl), _e = React$4.useMemo(() => ve.getDrawingBufferSize(new Vector2), [ve]), Ee = React$4.useMemo(() => { const we = new OutlinesMaterial({ side: BackSide }); return we.thickness = 10, we.color = new Color$1(16514816), we.opacity = .8, we.size = _e, we.transparent = !0, we.screenspace = !0, we.toneMapped = !0, we }, [_e]), be = React$4.useRef(null), Ae = React$4.useContext(HoverableContext), Se = React$4.useContext(ViewerContext); useFrame(() => { be.current !== null && (be.current.visible = Ae.current.isHovered) }); const Ce = Se.useSceneTree(we => we.nodeFromName[pe.name]?.clickable) ?? !1; return ge ? jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx("primitive", { object: ge.scene, scale: pe.props.scale }), Ce ? jsxRuntimeExports.jsx("group", { ref: be, visible: !1, children: xe.map((we, Be) => jsxRuntimeExports.jsx("mesh", { geometry: we.geometry, material: Ee }, Be)) }) : null, K] }) : null }), BatchedGlbAsset = React$4.forwardRef(function ({ children: K, ...pe }, me) { const xe = React$4.useContext(ViewerContext).useSceneTree(Ee => Ee.nodeFromName[pe.name]?.clickable) ?? !1, { gltf: ye } = useGlbLoader(pe.props.glb_data), { geometry: ve, material: _e } = reactExports.useMemo(() => { if (!ye) return { geometry: null, material: null }; const Ee = [], be = []; ye.scene.traverse(Ce => { Ce instanceof Mesh && Ce.parent && (Ce.geometry.applyMatrix4(Ce.matrixWorld), Ee.push(Ce.geometry), be.push(Ce.material)) }); const Ae = Ee.length === 1 ? Ee[0].clone() : mergeGeometries(Ee, !0), Se = be.length === 1 ? be[0] : be; return { geometry: Ae, material: Se } }, [ye]); return !ve || !_e ? null : jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(BatchedMeshBase, { geometry: ve, material: _e, batched_positions: pe.props.batched_positions, batched_wxyzs: pe.props.batched_wxyzs, batched_scales: pe.props.batched_scales, batched_colors: null, lod: pe.props.lod, cast_shadow: pe.props.cast_shadow, receive_shadow: pe.props.receive_shadow, clickable: xe }), K] }) }); function opencvXyFromPointerXy$1(fe, K) { const pe = new Vector2; return pe.x = (K[0] + .5) / fe.mutable.current.canvas.clientWidth, pe.y = (K[1] + .5) / fe.mutable.current.canvas.clientHeight, pe } function rgbToInt(fe) { return fe[0] << 16 | fe[1] << 8 | fe[2] } function SceneNodeLabel(fe) { return React$4.useContext(ViewerContext).useSceneTree(me => me.labelVisibleFromName[fe.name]) ? jsxRuntimeExports.jsx(Html, { children: jsxRuntimeExports.jsx("span", { style: { backgroundColor: "rgba(240, 240, 240, 0.9)", color: "#333", borderRadius: "0.2rem", userSelect: "none", padding: "0.1em 0.2em" }, children: fe.name }) }) : null } function tripletListFromFloat32Buffer(fe) { const K = new DataView(fe.buffer, fe.byteOffset, fe.byteLength), pe = []; for (let me = 0; me < K.byteLength; me += 12)pe.push([K.getFloat32(me, !0), K.getFloat32(me + 4, !0), K.getFloat32(me + 8, !0)]); return pe } function createObjectFactory(fe, K, pe) { if (fe === void 0) return { makeObject: () => null }; switch (fe.type) { case "FrameMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(CoordinateFrame, { ref: me, showAxes: fe.props.show_axes, axesLength: fe.props.axes_length, axesRadius: fe.props.axes_radius, originRadius: fe.props.origin_radius, originColor: rgbToInt(fe.props.origin_color), children: ge }) }; case "BatchedAxesMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(InstancedAxes, { ref: me, batched_wxyzs: fe.props.batched_wxyzs, batched_positions: fe.props.batched_positions, batched_scales: fe.props.batched_scales, axes_length: fe.props.axes_length, axes_radius: fe.props.axes_radius, children: ge }), computeClickInstanceIndexFromInstanceId: me => Math.floor(me / 3) }; case "GridMessage": { const me = new Quaternion().setFromEuler(fe.props.plane == "xz" ? new Euler(0, 0, 0) : fe.props.plane == "xy" ? new Euler(Math.PI / 2, 0, 0) : fe.props.plane == "yx" ? new Euler(0, Math.PI / 2, Math.PI / 2) : fe.props.plane == "yz" ? new Euler(0, 0, Math.PI / 2) : fe.props.plane == "zx" ? new Euler(0, Math.PI / 2, 0) : new Euler(-Math.PI / 2, 0, -Math.PI / 2)), ge = new Quaternion().setFromEuler(new Euler(-Math.PI / 2, 0, 0)).premultiply(me); let xe; return fe.props.shadow_opacity > 0 ? xe = jsxRuntimeExports.jsxs("mesh", { receiveShadow: !0, position: [0, 0, -.01], quaternion: ge, children: [jsxRuntimeExports.jsx("planeGeometry", { args: [fe.props.width, fe.props.height] }), jsxRuntimeExports.jsx("shadowMaterial", { opacity: fe.props.shadow_opacity, color: 0, depthWrite: !1 })] }) : xe = null, { makeObject: (ye, ve) => jsxRuntimeExports.jsxs("group", { ref: ye, children: [jsxRuntimeExports.jsx(Grid, { args: [fe.props.width, fe.props.height, fe.props.width_segments, fe.props.height_segments], side: DoubleSide, cellColor: rgbToInt(fe.props.cell_color), cellThickness: fe.props.cell_thickness, cellSize: fe.props.cell_size, sectionColor: rgbToInt(fe.props.section_color), sectionThickness: fe.props.section_thickness, sectionSize: fe.props.section_size, quaternion: me }), xe, ve] }) } } case "PointCloudMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(PointCloud, { ref: me, ...fe, children: ge }) }; case "SkinnedMeshMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(SkinnedMesh, { ref: me, ...fe, children: ge }) }; case "MeshMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(BasicMesh, { ref: me, ...fe, children: ge }) }; case "BoxMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(BoxMesh, { ref: me, ...fe, children: ge }) }; case "IcosphereMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(IcosphereMesh, { ref: me, ...fe, children: ge }) }; case "BatchedMeshesMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(BatchedMesh, { ref: me, ...fe, children: ge }), computeClickInstanceIndexFromInstanceId: fe.type === "BatchedMeshesMessage" ? me => me : void 0 }; case "CameraFrustumMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(CameraFrustumComponent, { ref: me, ...fe, children: ge }) }; case "TransformControlsMessage": { const { send: me, flush: ge } = makeThrottledMessageSender(K, 50); let xe = !1; return { makeObject: (ye, ve) => jsxRuntimeExports.jsx("group", { onClick: _e => _e.stopPropagation(), children: jsxRuntimeExports.jsx(PivotControls, { ref: ye, scale: fe.props.scale, lineWidth: fe.props.line_width, fixed: fe.props.fixed, activeAxes: fe.props.active_axes, disableAxes: fe.props.disable_axes, disableSliders: fe.props.disable_sliders, disableRotations: fe.props.disable_rotations, disableScaling: !0, translationLimits: fe.props.translation_limits, rotationLimits: fe.props.rotation_limits, depthTest: fe.props.depth_test, opacity: fe.props.opacity, onDragStart: () => { xe = !0, K.mutable.current.sendMessage({ type: "TransformControlsDragStartMessage", name: fe.name }) }, onDrag: _e => { const Ee = new Quaternion; Ee.setFromRotationMatrix(_e); const be = new Vector3().setFromMatrixPosition(_e), Ae = [Ee.w, Ee.x, Ee.y, Ee.z], Se = be.toArray(); K.useSceneTree.getState().updateNodeAttributes(fe.name, { wxyz: Ae, position: Se }), me({ type: "TransformControlsUpdateMessage", name: fe.name, wxyz: Ae, position: Se }) }, onDragEnd: () => { xe && (xe = !1, ge(), K.mutable.current.sendMessage({ type: "TransformControlsDragEndMessage", name: fe.name })) }, children: ve }) }), unmountWhenInvisible: !0 } } case "LabelMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(Html, { children: jsxRuntimeExports.jsx("div", { style: { width: "10em", fontSize: "0.8em", transform: "translateX(0.1em) translateY(0.5em)" }, children: jsxRuntimeExports.jsx("span", { style: { background: "#fff", border: "1px solid #777", borderRadius: "0.2em", color: "#333", padding: "0.2em" }, children: fe.props.text }) }) }), ge] }), unmountWhenInvisible: !0 }; case "Gui3DMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(Html, { children: jsxRuntimeExports.jsx(pe, { children: jsxRuntimeExports.jsx(Paper, { style: { width: "18em", fontSize: "0.875em", marginLeft: "0.5em", marginTop: "0.5em" }, shadow: "0 0 0.8em 0 rgba(0,0,0,0.1)", pb: "0.25em", onPointerDown: xe => { xe.stopPropagation() }, children: jsxRuntimeExports.jsx(GeneratedGuiContainer, { containerUuid: fe.props.container_uuid }) }) }) }), ge] }), unmountWhenInvisible: !0 }; case "ImageMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(ViserImage, { ref: me, ...fe, children: ge }) }; case "GlbMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(SingleGlbAsset, { ref: me, ...fe, children: ge }) }; case "BatchedGlbMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(BatchedGlbAsset, { ref: me, ...fe, children: ge }), computeClickInstanceIndexFromInstanceId: me => me }; case "LineSegmentsMessage": return { makeObject: (me, ge) => { const xe = new Float32Array(fe.props.points.buffer.slice(fe.props.points.byteOffset, fe.props.points.byteOffset + fe.props.points.byteLength)), ye = new Uint8Array(fe.props.colors.buffer.slice(fe.props.colors.byteOffset, fe.props.colors.byteOffset + fe.props.colors.byteLength)); return jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(Line, { points: xe, lineWidth: fe.props.line_width, vertexColors: ye, segments: !0 }), ge] }) } }; case "CatmullRomSplineMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(CatmullRomLine, { points: tripletListFromFloat32Buffer(fe.props.points), closed: fe.props.closed, curveType: fe.props.curve_type, tension: fe.props.tension, lineWidth: fe.props.line_width, color: rgbToInt(fe.props.color), segments: fe.props.segments ?? void 0 }), ge] }) }; case "CubicBezierSplineMessage": return { makeObject: (me, ge) => { const xe = tripletListFromFloat32Buffer(fe.props.points), ye = tripletListFromFloat32Buffer(fe.props.control_points); return jsxRuntimeExports.jsxs("group", { ref: me, children: [[...Array(xe.length - 1).keys()].map(ve => jsxRuntimeExports.jsx(CubicBezierLine, { start: xe[ve], end: xe[ve + 1], midA: ye[2 * ve], midB: ye[2 * ve + 1], lineWidth: fe.props.line_width, color: rgbToInt(fe.props.color), segments: fe.props.segments ?? void 0 }, ve)), ge] }) } }; case "GaussianSplatsMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx(SplatObject, { ref: me, buffer: new Uint32Array(fe.props.buffer.buffer.slice(fe.props.buffer.byteOffset, fe.props.buffer.byteOffset + fe.props.buffer.byteLength)), children: ge }) }; case "DirectionalLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsxs("group", { ref: me, children: [jsxRuntimeExports.jsx(CsmDirectionalLight, { lightIntensity: fe.props.intensity, color: rgbToInt(fe.props.color), castShadow: fe.props.cast_shadow }), ge] }), unmountWhenInvisible: !0 }; case "AmbientLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx("ambientLight", { ref: me, intensity: fe.props.intensity, color: rgbToInt(fe.props.color), children: ge }) }; case "HemisphereLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx("hemisphereLight", { ref: me, intensity: fe.props.intensity, color: rgbToInt(fe.props.sky_color), groundColor: rgbToInt(fe.props.ground_color), children: ge }) }; case "PointLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx("pointLight", { ref: me, intensity: fe.props.intensity, color: rgbToInt(fe.props.color), distance: fe.props.distance, decay: fe.props.decay, castShadow: fe.props.cast_shadow, ...shadowArgs, children: ge }) }; case "RectAreaLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx("rectAreaLight", { ref: me, intensity: fe.props.intensity, color: rgbToInt(fe.props.color), width: fe.props.width, height: fe.props.height, children: ge }) }; case "SpotLightMessage": return { makeObject: (me, ge) => jsxRuntimeExports.jsx("spotLight", { ref: me, intensity: fe.props.intensity, color: rgbToInt(fe.props.color), distance: fe.props.distance, angle: fe.props.angle, penumbra: fe.props.penumbra, decay: fe.props.decay, castShadow: fe.props.cast_shadow, ...shadowArgs, children: ge }) }; default: return console.log("Received message did not match any known types:", fe), { makeObject: () => null } } } function SceneNodeThreeObject(fe) { const K = React$4.useContext(ViewerContext), pe = K.useSceneTree(ke => ke.nodeFromName[fe.name]?.message), me = x$3(), ge = K.useSceneTree(ke => ke.updateNodeAttributes), { makeObject: xe, unmountWhenInvisible: ye, computeClickInstanceIndexFromInstanceId: ve } = React$4.useMemo(() => createObjectFactory(pe, K, me), [pe, K, me]), [_e, Ee] = React$4.useState(!1), be = K.useSceneTree(ke => ke.nodeFromName[fe.name]?.clickable) ?? !1, Ae = React$4.useRef(null), Se = React$4.useRef(), Ce = React$4.useMemo(() => jsxRuntimeExports.jsx(SceneNodeChildren, { name: fe.name }), []), we = K.mutable.current, Be = React$4.useMemo(() => xe === void 0 ? null : xe(ke => { Ae.current = ke, we.nodeRefFromName[fe.name] = Ae.current }, Ce), [xe, Ce]), De = React$4.useRef(null); function Re() { const ke = K.useSceneTree.getState().nodeAttributesFromName[fe.name]; if (((ke?.overrideVisibility === void 0 ? ke?.visibility : ke.overrideVisibility) ?? !0) === !1) return !1; if (Se.current && Se.current.parent !== null && (De.current = Se.current.parent), De.current !== null) { let Ue = De.current.visible; return Ue && De.current.traverseAncestors(He => { Ue = Ue && He.visible }), Ue } return !0 } React$4.useEffect(() => { ge(fe.name, { poseUpdateState: "needsUpdate" }) }, [Be]), useFrame(() => { const ke = K.useSceneTree.getState().nodeAttributesFromName[fe.name]; if (ye) { const Ue = Re(); Ue && _e && (Ae.current !== null && (Ae.current.visible = !1), ge(fe.name, { poseUpdateState: "needsUpdate" }), Ee(!1)), !Ue && !_e && Ee(!0) } if (Ae.current === null || ke === void 0) return; const Oe = (ke?.overrideVisibility === void 0 ? ke?.visibility : ke.overrideVisibility) ?? !0; if (Ae.current.visible = Oe, ke.poseUpdateState == "needsUpdate") { ge(fe.name, { poseUpdateState: "updated" }); const Ue = ke.wxyz ?? [1, 0, 0, 0]; Ae.current.quaternion.set(Ue[1], Ue[2], Ue[3], Ue[0]); const He = ke.position ?? [0, 0, 0]; Ae.current.position.set(He[0], He[1], He[2]), Ae.current.matrixAutoUpdate || Ae.current.updateMatrix(), Ae.current.matrixWorldAutoUpdate || Ae.current.updateMatrixWorld() } }, -1e3); const Ie = useThrottledMessageSender(50).send, Pe = React$4.useRef({ isHovered: !1, instanceId: null, clickable: !1 }); Pe.current.clickable = be, !be && Pe.current.isHovered && (Pe.current.isHovered = !1, we.hoveredElementsCount--, we.hoveredElementsCount === 0 && (document.body.style.cursor = "auto")); const Ne = React$4.useRef({ dragging: !1, startClientX: 0, startClientY: 0 }); return Be === void 0 || _e ? null : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("group", { ref: Se, onPointerDown: be ? ke => { if (!Re()) return; ke.stopPropagation(); const Oe = Ne.current, Ue = we.canvas.getBoundingClientRect(); Oe.startClientX = ke.clientX - Ue.left, Oe.startClientY = ke.clientY - Ue.top, Oe.dragging = !1 } : void 0, onPointerMove: be ? ke => { if (!Re()) return; ke.stopPropagation(); const Oe = Ne.current, Ue = we.canvas.getBoundingClientRect(), He = ke.clientX - Ue.left - Oe.startClientX, Ge = ke.clientY - Ue.top - Oe.startClientY; Math.abs(He) <= 3 && Math.abs(Ge) <= 3 || (Oe.dragging = !0) } : void 0, onPointerUp: be ? ke => { if (!Re() || (ke.stopPropagation(), Ne.current.dragging)) return; const Ue = rayToViserCoords(K, ke.ray), He = we.canvas.getBoundingClientRect(), Ge = opencvXyFromPointerXy$1(K, [ke.clientX - He.left, ke.clientY - He.top]); Ie({ type: "SceneNodeClickMessage", name: fe.name, instance_index: ve === void 0 ? null : ve(ke.instanceId), ray_origin: [Ue.origin.x, Ue.origin.y, Ue.origin.z], ray_direction: [Ue.direction.x, Ue.direction.y, Ue.direction.z], screen_pos: [Ge.x, Ge.y] }) } : void 0, onPointerOver: be ? ke => { Re() && (ke.stopPropagation(), Pe.current.isHovered = !0, Pe.current.instanceId = ke.instanceId ?? null, we.hoveredElementsCount++, we.hoveredElementsCount === 1 && (document.body.style.cursor = "pointer")) } : void 0, onPointerOut: be ? () => { Re() && (Pe.current.isHovered = !1, Pe.current.instanceId = null, we.hoveredElementsCount--, we.hoveredElementsCount === 0 && (document.body.style.cursor = "auto")) } : void 0, children: jsxRuntimeExports.jsx(HoverableContext.Provider, { value: Pe, children: Be }) }) }) } function SceneNodeChildren(fe) { const pe = React$4.useContext(ViewerContext).useSceneTree(me => me.nodeFromName[fe.name]?.children); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [pe && pe.map(me => jsxRuntimeExports.jsx(SceneNodeThreeObject, { name: me }, me)), jsxRuntimeExports.jsx(SceneNodeLabel, { name: fe.name })] }) } var lib = {}, ErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 }, mode$1 = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, mode = mode$1; function QR8bitByte(fe) { this.mode = mode.MODE_8BIT_BYTE, this.data = fe } QR8bitByte.prototype = { getLength: function (fe) { return this.data.length }, write: function (fe) { for (var K = 0; K < this.data.length; K++)fe.put(this.data.charCodeAt(K), 8) } }; var _8BitByte = QR8bitByte, ECL = ErrorCorrectLevel; function QRRSBlock(fe, K) { this.totalCount = fe, this.dataCount = K } QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]; QRRSBlock.getRSBlocks = function (fe, K) { var pe = QRRSBlock.getRsBlockTable(fe, K); if (pe == null) throw new Error("bad rs block @ typeNumber:" + fe + "/errorCorrectLevel:" + K); for (var me = pe.length / 3, ge = new Array, xe = 0; xe < me; xe++)for (var ye = pe[xe * 3 + 0], ve = pe[xe * 3 + 1], _e = pe[xe * 3 + 2], Ee = 0; Ee < ye; Ee++)ge.push(new QRRSBlock(ve, _e)); return ge }; QRRSBlock.getRsBlockTable = function (fe, K) { switch (K) { case ECL.L: return QRRSBlock.RS_BLOCK_TABLE[(fe - 1) * 4 + 0]; case ECL.M: return QRRSBlock.RS_BLOCK_TABLE[(fe - 1) * 4 + 1]; case ECL.Q: return QRRSBlock.RS_BLOCK_TABLE[(fe - 1) * 4 + 2]; case ECL.H: return QRRSBlock.RS_BLOCK_TABLE[(fe - 1) * 4 + 3]; default: return } }; var RSBlock$1 = QRRSBlock; function QRBitBuffer() { this.buffer = new Array, this.length = 0 } QRBitBuffer.prototype = { get: function (fe) { var K = Math.floor(fe / 8); return (this.buffer[K] >>> 7 - fe % 8 & 1) == 1 }, put: function (fe, K) { for (var pe = 0; pe < K; pe++)this.putBit((fe >>> K - pe - 1 & 1) == 1) }, getLengthInBits: function () { return this.length }, putBit: function (fe) { var K = Math.floor(this.length / 8); this.buffer.length <= K && this.buffer.push(0), fe && (this.buffer[K] |= 128 >>> this.length % 8), this.length++ } }; var BitBuffer$1 = QRBitBuffer, QRMath = { glog: function (fe) { if (fe < 1) throw new Error("glog(" + fe + ")"); return QRMath.LOG_TABLE[fe] }, gexp: function (fe) { for (; fe < 0;)fe += 255; for (; fe >= 256;)fe -= 255; return QRMath.EXP_TABLE[fe] }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }; for (var i$2 = 0; i$2 < 8; i$2++)QRMath.EXP_TABLE[i$2] = 1 << i$2; for (var i$2 = 8; i$2 < 256; i$2++)QRMath.EXP_TABLE[i$2] = QRMath.EXP_TABLE[i$2 - 4] ^ QRMath.EXP_TABLE[i$2 - 5] ^ QRMath.EXP_TABLE[i$2 - 6] ^ QRMath.EXP_TABLE[i$2 - 8]; for (var i$2 = 0; i$2 < 255; i$2++)QRMath.LOG_TABLE[QRMath.EXP_TABLE[i$2]] = i$2; var math$2 = QRMath, math$1 = math$2; function QRPolynomial(fe, K) { if (fe.length == null) throw new Error(fe.length + "/" + K); for (var pe = 0; pe < fe.length && fe[pe] == 0;)pe++; this.num = new Array(fe.length - pe + K); for (var me = 0; me < fe.length - pe; me++)this.num[me] = fe[me + pe] } QRPolynomial.prototype = { get: function (fe) { return this.num[fe] }, getLength: function () { return this.num.length }, multiply: function (fe) { for (var K = new Array(this.getLength() + fe.getLength() - 1), pe = 0; pe < this.getLength(); pe++)for (var me = 0; me < fe.getLength(); me++)K[pe + me] ^= math$1.gexp(math$1.glog(this.get(pe)) + math$1.glog(fe.get(me))); return new QRPolynomial(K, 0) }, mod: function (fe) { if (this.getLength() - fe.getLength() < 0) return this; for (var K = math$1.glog(this.get(0)) - math$1.glog(fe.get(0)), pe = new Array(this.getLength()), me = 0; me < this.getLength(); me++)pe[me] = this.get(me); for (var me = 0; me < fe.getLength(); me++)pe[me] ^= math$1.gexp(math$1.glog(fe.get(me)) + K); return new QRPolynomial(pe, 0).mod(fe) } }; var Polynomial$2 = QRPolynomial, Mode = mode$1, Polynomial$1 = Polynomial$2, math = math$2, QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 }, QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function (fe) { for (var K = fe << 10; QRUtil.getBCHDigit(K) - QRUtil.getBCHDigit(QRUtil.G15) >= 0;)K ^= QRUtil.G15 << QRUtil.getBCHDigit(K) - QRUtil.getBCHDigit(QRUtil.G15); return (fe << 10 | K) ^ QRUtil.G15_MASK }, getBCHTypeNumber: function (fe) { for (var K = fe << 12; QRUtil.getBCHDigit(K) - QRUtil.getBCHDigit(QRUtil.G18) >= 0;)K ^= QRUtil.G18 << QRUtil.getBCHDigit(K) - QRUtil.getBCHDigit(QRUtil.G18); return fe << 12 | K }, getBCHDigit: function (fe) { for (var K = 0; fe != 0;)K++, fe >>>= 1; return K }, getPatternPosition: function (fe) { return QRUtil.PATTERN_POSITION_TABLE[fe - 1] }, getMask: function (fe, K, pe) { switch (fe) { case QRMaskPattern.PATTERN000: return (K + pe) % 2 == 0; case QRMaskPattern.PATTERN001: return K % 2 == 0; case QRMaskPattern.PATTERN010: return pe % 3 == 0; case QRMaskPattern.PATTERN011: return (K + pe) % 3 == 0; case QRMaskPattern.PATTERN100: return (Math.floor(K / 2) + Math.floor(pe / 3)) % 2 == 0; case QRMaskPattern.PATTERN101: return K * pe % 2 + K * pe % 3 == 0; case QRMaskPattern.PATTERN110: return (K * pe % 2 + K * pe % 3) % 2 == 0; case QRMaskPattern.PATTERN111: return (K * pe % 3 + (K + pe) % 2) % 2 == 0; default: throw new Error("bad maskPattern:" + fe) } }, getErrorCorrectPolynomial: function (fe) { for (var K = new Polynomial$1([1], 0), pe = 0; pe < fe; pe++)K = K.multiply(new Polynomial$1([1, math.gexp(pe)], 0)); return K }, getLengthInBits: function (fe, K) { if (1 <= K && K < 10) switch (fe) { case Mode.MODE_NUMBER: return 10; case Mode.MODE_ALPHA_NUM: return 9; case Mode.MODE_8BIT_BYTE: return 8; case Mode.MODE_KANJI: return 8; default: throw new Error("mode:" + fe) } else if (K < 27) switch (fe) { case Mode.MODE_NUMBER: return 12; case Mode.MODE_ALPHA_NUM: return 11; case Mode.MODE_8BIT_BYTE: return 16; case Mode.MODE_KANJI: return 10; default: throw new Error("mode:" + fe) } else if (K < 41) switch (fe) { case Mode.MODE_NUMBER: return 14; case Mode.MODE_ALPHA_NUM: return 13; case Mode.MODE_8BIT_BYTE: return 16; case Mode.MODE_KANJI: return 12; default: throw new Error("mode:" + fe) } else throw new Error("type:" + K) }, getLostPoint: function (fe) { for (var K = fe.getModuleCount(), pe = 0, me = 0; me < K; me++)for (var ge = 0; ge < K; ge++) { for (var xe = 0, ye = fe.isDark(me, ge), ve = -1; ve <= 1; ve++)if (!(me + ve < 0 || K <= me + ve)) for (var _e = -1; _e <= 1; _e++)ge + _e < 0 || K <= ge + _e || ve == 0 && _e == 0 || ye == fe.isDark(me + ve, ge + _e) && xe++; xe > 5 && (pe += 3 + xe - 5) } for (var me = 0; me < K - 1; me++)for (var ge = 0; ge < K - 1; ge++) { var Ee = 0; fe.isDark(me, ge) && Ee++, fe.isDark(me + 1, ge) && Ee++, fe.isDark(me, ge + 1) && Ee++, fe.isDark(me + 1, ge + 1) && Ee++, (Ee == 0 || Ee == 4) && (pe += 3) } for (var me = 0; me < K; me++)for (var ge = 0; ge < K - 6; ge++)fe.isDark(me, ge) && !fe.isDark(me, ge + 1) && fe.isDark(me, ge + 2) && fe.isDark(me, ge + 3) && fe.isDark(me, ge + 4) && !fe.isDark(me, ge + 5) && fe.isDark(me, ge + 6) && (pe += 40); for (var ge = 0; ge < K; ge++)for (var me = 0; me < K - 6; me++)fe.isDark(me, ge) && !fe.isDark(me + 1, ge) && fe.isDark(me + 2, ge) && fe.isDark(me + 3, ge) && fe.isDark(me + 4, ge) && !fe.isDark(me + 5, ge) && fe.isDark(me + 6, ge) && (pe += 40); for (var be = 0, ge = 0; ge < K; ge++)for (var me = 0; me < K; me++)fe.isDark(me, ge) && be++; var Ae = Math.abs(100 * be / K / K - 50) / 5; return pe += Ae * 10, pe } }, util$1 = QRUtil, BitByte = _8BitByte, RSBlock = RSBlock$1, BitBuffer = BitBuffer$1, util = util$1, Polynomial = Polynomial$2; function QRCode$1(fe, K) { this.typeNumber = fe, this.errorCorrectLevel = K, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [] } var proto = QRCode$1.prototype; proto.addData = function (fe) { var K = new BitByte(fe); this.dataList.push(K), this.dataCache = null }; proto.isDark = function (fe, K) { if (fe < 0 || this.moduleCount <= fe || K < 0 || this.moduleCount <= K) throw new Error(fe + "," + K); return this.modules[fe][K] }; proto.getModuleCount = function () { return this.moduleCount }; proto.make = function () { if (this.typeNumber < 1) { var fe = 1; for (fe = 1; fe < 40; fe++) { for (var K = RSBlock.getRSBlocks(fe, this.errorCorrectLevel), pe = new BitBuffer, me = 0, ge = 0; ge < K.length; ge++)me += K[ge].dataCount; for (var ge = 0; ge < this.dataList.length; ge++) { var xe = this.dataList[ge]; pe.put(xe.mode, 4), pe.put(xe.getLength(), util.getLengthInBits(xe.mode, fe)), xe.write(pe) } if (pe.getLengthInBits() <= me * 8) break } this.typeNumber = fe } this.makeImpl(!1, this.getBestMaskPattern()) }; proto.makeImpl = function (fe, K) { this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount); for (var pe = 0; pe < this.moduleCount; pe++) { this.modules[pe] = new Array(this.moduleCount); for (var me = 0; me < this.moduleCount; me++)this.modules[pe][me] = null } this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(fe, K), this.typeNumber >= 7 && this.setupTypeNumber(fe), this.dataCache == null && (this.dataCache = QRCode$1.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, K) }; proto.setupPositionProbePattern = function (fe, K) { for (var pe = -1; pe <= 7; pe++)if (!(fe + pe <= -1 || this.moduleCount <= fe + pe)) for (var me = -1; me <= 7; me++)K + me <= -1 || this.moduleCount <= K + me || (0 <= pe && pe <= 6 && (me == 0 || me == 6) || 0 <= me && me <= 6 && (pe == 0 || pe == 6) || 2 <= pe && pe <= 4 && 2 <= me && me <= 4 ? this.modules[fe + pe][K + me] = !0 : this.modules[fe + pe][K + me] = !1) }; proto.getBestMaskPattern = function () { for (var fe = 0, K = 0, pe = 0; pe < 8; pe++) { this.makeImpl(!0, pe); var me = util.getLostPoint(this); (pe == 0 || fe > me) && (fe = me, K = pe) } return K }; proto.createMovieClip = function (fe, K, pe) { var me = fe.createEmptyMovieClip(K, pe), ge = 1; this.make(); for (var xe = 0; xe < this.modules.length; xe++)for (var ye = xe * ge, ve = 0; ve < this.modules[xe].length; ve++) { var _e = ve * ge, Ee = this.modules[xe][ve]; Ee && (me.beginFill(0, 100), me.moveTo(_e, ye), me.lineTo(_e + ge, ye), me.lineTo(_e + ge, ye + ge), me.lineTo(_e, ye + ge), me.endFill()) } return me }; proto.setupTimingPattern = function () { for (var fe = 8; fe < this.moduleCount - 8; fe++)this.modules[fe][6] == null && (this.modules[fe][6] = fe % 2 == 0); for (var K = 8; K < this.moduleCount - 8; K++)this.modules[6][K] == null && (this.modules[6][K] = K % 2 == 0) }; proto.setupPositionAdjustPattern = function () { for (var fe = util.getPatternPosition(this.typeNumber), K = 0; K < fe.length; K++)for (var pe = 0; pe < fe.length; pe++) { var me = fe[K], ge = fe[pe]; if (this.modules[me][ge] == null) for (var xe = -2; xe <= 2; xe++)for (var ye = -2; ye <= 2; ye++)xe == -2 || xe == 2 || ye == -2 || ye == 2 || xe == 0 && ye == 0 ? this.modules[me + xe][ge + ye] = !0 : this.modules[me + xe][ge + ye] = !1 } }; proto.setupTypeNumber = function (fe) { for (var K = util.getBCHTypeNumber(this.typeNumber), pe = 0; pe < 18; pe++) { var me = !fe && (K >> pe & 1) == 1; this.modules[Math.floor(pe / 3)][pe % 3 + this.moduleCount - 8 - 3] = me } for (var pe = 0; pe < 18; pe++) { var me = !fe && (K >> pe & 1) == 1; this.modules[pe % 3 + this.moduleCount - 8 - 3][Math.floor(pe / 3)] = me } }; proto.setupTypeInfo = function (fe, K) { for (var pe = this.errorCorrectLevel << 3 | K, me = util.getBCHTypeInfo(pe), ge = 0; ge < 15; ge++) { var xe = !fe && (me >> ge & 1) == 1; ge < 6 ? this.modules[ge][8] = xe : ge < 8 ? this.modules[ge + 1][8] = xe : this.modules[this.moduleCount - 15 + ge][8] = xe } for (var ge = 0; ge < 15; ge++) { var xe = !fe && (me >> ge & 1) == 1; ge < 8 ? this.modules[8][this.moduleCount - ge - 1] = xe : ge < 9 ? this.modules[8][15 - ge - 1 + 1] = xe : this.modules[8][15 - ge - 1] = xe } this.modules[this.moduleCount - 8][8] = !fe }; proto.mapData = function (fe, K) { for (var pe = -1, me = this.moduleCount - 1, ge = 7, xe = 0, ye = this.moduleCount - 1; ye > 0; ye -= 2)for (ye == 6 && ye--; ;) { for (var ve = 0; ve < 2; ve++)if (this.modules[me][ye - ve] == null) { var _e = !1; xe < fe.length && (_e = (fe[xe] >>> ge & 1) == 1); var Ee = util.getMask(K, me, ye - ve); Ee && (_e = !_e), this.modules[me][ye - ve] = _e, ge--, ge == -1 && (xe++, ge = 7) } if (me += pe, me < 0 || this.moduleCount <= me) { me -= pe, pe = -pe; break } } }; QRCode$1.PAD0 = 236; QRCode$1.PAD1 = 17; QRCode$1.createData = function (fe, K, pe) { for (var me = RSBlock.getRSBlocks(fe, K), ge = new BitBuffer, xe = 0; xe < pe.length; xe++) { var ye = pe[xe]; ge.put(ye.mode, 4), ge.put(ye.getLength(), util.getLengthInBits(ye.mode, fe)), ye.write(ge) } for (var ve = 0, xe = 0; xe < me.length; xe++)ve += me[xe].dataCount; if (ge.getLengthInBits() > ve * 8) throw new Error("code length overflow. (" + ge.getLengthInBits() + ">" + ve * 8 + ")"); for (ge.getLengthInBits() + 4 <= ve * 8 && ge.put(0, 4); ge.getLengthInBits() % 8 != 0;)ge.putBit(!1); for (; !(ge.getLengthInBits() >= ve * 8 || (ge.put(QRCode$1.PAD0, 8), ge.getLengthInBits() >= ve * 8));)ge.put(QRCode$1.PAD1, 8); return QRCode$1.createBytes(ge, me) }; QRCode$1.createBytes = function (fe, K) { for (var pe = 0, me = 0, ge = 0, xe = new Array(K.length), ye = new Array(K.length), ve = 0; ve < K.length; ve++) { var _e = K[ve].dataCount, Ee = K[ve].totalCount - _e; me = Math.max(me, _e), ge = Math.max(ge, Ee), xe[ve] = new Array(_e); for (var be = 0; be < xe[ve].length; be++)xe[ve][be] = 255 & fe.buffer[be + pe]; pe += _e; var Ae = util.getErrorCorrectPolynomial(Ee), Se = new Polynomial(xe[ve], Ae.getLength() - 1), Ce = Se.mod(Ae); ye[ve] = new Array(Ae.getLength() - 1); for (var be = 0; be < ye[ve].length; be++) { var we = be + Ce.getLength() - ye[ve].length; ye[ve][be] = we >= 0 ? Ce.get(we) : 0 } } for (var Be = 0, be = 0; be < K.length; be++)Be += K[be].totalCount; for (var De = new Array(Be), Re = 0, be = 0; be < me; be++)for (var ve = 0; ve < K.length; ve++)be < xe[ve].length && (De[Re++] = xe[ve][be]); for (var be = 0; be < ge; be++)for (var ve = 0; ve < K.length; ve++)be < ye[ve].length && (De[Re++] = ye[ve][be]); return De }; var QRCode_1 = QRCode$1, QRCodeSvg$1 = {}; Object.defineProperty(QRCodeSvg$1, "__esModule", { value: !0 }); var _extends$1 = Object.assign || function (fe) { for (var K = 1; K < arguments.length; K++) { var pe = arguments[K]; for (var me in pe) Object.prototype.hasOwnProperty.call(pe, me) && (fe[me] = pe[me]) } return fe }, _propTypes$1 = propTypesExports, _propTypes2$1 = _interopRequireDefault$1(_propTypes$1), _react$1 = reactExports, _react2$1 = _interopRequireDefault$1(_react$1); function _interopRequireDefault$1(fe) { return fe && fe.__esModule ? fe : { default: fe } } function _objectWithoutProperties$1(fe, K) { var pe = {}; for (var me in fe) K.indexOf(me) >= 0 || Object.prototype.hasOwnProperty.call(fe, me) && (pe[me] = fe[me]); return pe } var propTypes$1 = { bgColor: _propTypes2$1.default.oneOfType([_propTypes2$1.default.object, _propTypes2$1.default.string]).isRequired, bgD: _propTypes2$1.default.string.isRequired, fgColor: _propTypes2$1.default.oneOfType([_propTypes2$1.default.object, _propTypes2$1.default.string]).isRequired, fgD: _propTypes2$1.default.string.isRequired, size: _propTypes2$1.default.number.isRequired, title: _propTypes2$1.default.string, viewBoxSize: _propTypes2$1.default.number.isRequired, xmlns: _propTypes2$1.default.string }, QRCodeSvg = (0, _react$1.forwardRef)(function (fe, K) { var pe = fe.bgColor, me = fe.bgD, ge = fe.fgD, xe = fe.fgColor, ye = fe.size, ve = fe.title, _e = fe.viewBoxSize, Ee = fe.xmlns, be = Ee === void 0 ? "http://www.w3.org/2000/svg" : Ee, Ae = _objectWithoutProperties$1(fe, ["bgColor", "bgD", "fgD", "fgColor", "size", "title", "viewBoxSize", "xmlns"]); return _react2$1.default.createElement("svg", _extends$1({}, Ae, { height: ye, ref: K, viewBox: "0 0 " + _e + " " + _e, width: ye, xmlns: be }), ve ? _react2$1.default.createElement("title", null, ve) : null, _react2$1.default.createElement("path", { d: me, fill: pe }), _react2$1.default.createElement("path", { d: ge, fill: xe })) }); QRCodeSvg.displayName = "QRCodeSvg"; QRCodeSvg.propTypes = propTypes$1; QRCodeSvg$1.default = QRCodeSvg; Object.defineProperty(lib, "__esModule", { value: !0 }); lib.QRCode = void 0; var _extends = Object.assign || function (fe) { for (var K = 1; K < arguments.length; K++) { var pe = arguments[K]; for (var me in pe) Object.prototype.hasOwnProperty.call(pe, me) && (fe[me] = pe[me]) } return fe }, _propTypes = propTypesExports, _propTypes2 = _interopRequireDefault(_propTypes), _ErrorCorrectLevel = ErrorCorrectLevel, _ErrorCorrectLevel2 = _interopRequireDefault(_ErrorCorrectLevel), _QRCode = QRCode_1, _QRCode2 = _interopRequireDefault(_QRCode), _react = reactExports, _react2 = _interopRequireDefault(_react), _QRCodeSvg = QRCodeSvg$1, _QRCodeSvg2 = _interopRequireDefault(_QRCodeSvg); function _interopRequireDefault(fe) { return fe && fe.__esModule ? fe : { default: fe } } function _objectWithoutProperties(fe, K) { var pe = {}; for (var me in fe) K.indexOf(me) >= 0 || Object.prototype.hasOwnProperty.call(fe, me) && (pe[me] = fe[me]); return pe } var propTypes = { bgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]), fgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]), level: _propTypes2.default.string, size: _propTypes2.default.number, value: _propTypes2.default.string.isRequired }, QRCode = (0, _react.forwardRef)(function (fe, K) { var pe = fe.bgColor, me = pe === void 0 ? "#FFFFFF" : pe, ge = fe.fgColor, xe = ge === void 0 ? "#000000" : ge, ye = fe.level, ve = ye === void 0 ? "L" : ye, _e = fe.size, Ee = _e === void 0 ? 256 : _e, be = fe.value, Ae = _objectWithoutProperties(fe, ["bgColor", "fgColor", "level", "size", "value"]), Se = new _QRCode2.default(-1, _ErrorCorrectLevel2.default[ve]); Se.addData(be), Se.make(); var Ce = Se.modules; return _react2.default.createElement(_QRCodeSvg2.default, _extends({}, Ae, { bgColor: me, bgD: Ce.map(function (we, Be) { return we.map(function (De, Re) { return De ? "" : "M " + Re + " " + Be + " l 1 0 0 1 -1 0 Z" }).join(" ") }).join(" "), fgColor: xe, fgD: Ce.map(function (we, Be) { return we.map(function (De, Re) { return De ? "M " + Re + " " + Be + " l 1 0 0 1 -1 0 Z" : "" }).join(" ") }).join(" "), ref: K, size: Ee, viewBoxSize: Ce.length })) }); lib.QRCode = QRCode; QRCode.displayName = "QRCode"; QRCode.propTypes = propTypes; var _default = lib.default = QRCode, tableWrapper = "z8daqr0", propsWrapper = "z8daqr1", editIconWrapper = "z8daqr2", tableRow = "z8daqr3", tableHierarchyLine = "z8daqr4"; function validateFormName(fe) { if (!/^[0-9a-zA-Z-]+$/.test(fe)) throw new Error(`[@mantine/use-form] Form name "${fe}" is invalid, it should contain only letters, numbers and dashes`) } const useIsomorphicEffect = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect; function useFormEvent(fe, K) { useIsomorphicEffect(() => { if (fe) return window.addEventListener(fe, K), () => window.removeEventListener(fe, K) }, [fe]) } function useFormActions(fe, K) { fe && validateFormName(fe), useFormEvent(`mantine-form:${fe}:set-field-value`, pe => K.setFieldValue(pe.detail.path, pe.detail.value)), useFormEvent(`mantine-form:${fe}:set-values`, pe => K.setValues(pe.detail)), useFormEvent(`mantine-form:${fe}:set-initial-values`, pe => K.setInitialValues(pe.detail)), useFormEvent(`mantine-form:${fe}:set-errors`, pe => K.setErrors(pe.detail)), useFormEvent(`mantine-form:${fe}:set-field-error`, pe => K.setFieldError(pe.detail.path, pe.detail.error)), useFormEvent(`mantine-form:${fe}:clear-field-error`, pe => K.clearFieldError(pe.detail)), useFormEvent(`mantine-form:${fe}:clear-errors`, K.clearErrors), useFormEvent(`mantine-form:${fe}:reset`, K.reset), useFormEvent(`mantine-form:${fe}:validate`, K.validate), useFormEvent(`mantine-form:${fe}:validate-field`, pe => K.validateField(pe.detail)), useFormEvent(`mantine-form:${fe}:reorder-list-item`, pe => K.reorderListItem(pe.detail.path, pe.detail.payload)), useFormEvent(`mantine-form:${fe}:remove-list-item`, pe => K.removeListItem(pe.detail.path, pe.detail.index)), useFormEvent(`mantine-form:${fe}:insert-list-item`, pe => K.insertListItem(pe.detail.path, pe.detail.item, pe.detail.index)), useFormEvent(`mantine-form:${fe}:set-dirty`, pe => K.setDirty(pe.detail)), useFormEvent(`mantine-form:${fe}:set-touched`, pe => K.setTouched(pe.detail)), useFormEvent(`mantine-form:${fe}:reset-dirty`, pe => K.resetDirty(pe.detail)), useFormEvent(`mantine-form:${fe}:reset-touched`, K.resetTouched) } function getInputOnChange(fe) { return K => { if (!K) fe(K); else if (typeof K == "function") fe(K); else if (typeof K == "object" && "nativeEvent" in K) { const { currentTarget: pe } = K; pe instanceof HTMLInputElement ? pe.type === "checkbox" ? fe(pe.checked) : fe(pe.value) : (pe instanceof HTMLTextAreaElement || pe instanceof HTMLSelectElement) && fe(pe.value) } else fe(K) } } function filterErrors(fe) { return fe === null || typeof fe != "object" ? {} : Object.keys(fe).reduce((K, pe) => { const me = fe[pe]; return me != null && me !== !1 && (K[pe] = me), K }, {}) } function useFormErrors(fe) { const [K, pe] = reactExports.useState(filterErrors(fe)), me = reactExports.useRef(K), ge = reactExports.useCallback(_e => { pe(Ee => { const be = filterErrors(typeof _e == "function" ? _e(Ee) : _e); return me.current = be, be }) }, []), xe = reactExports.useCallback(() => ge({}), []), ye = reactExports.useCallback(_e => { me.current[_e] !== void 0 && ge(Ee => { const be = { ...Ee }; return delete be[_e], be }) }, [K]), ve = reactExports.useCallback((_e, Ee) => { Ee == null || Ee === !1 ? ye(_e) : me.current[_e] !== Ee && ge(be => ({ ...be, [_e]: Ee })) }, [K]); return { errorsState: K, setErrors: ge, clearErrors: xe, setFieldError: ve, clearFieldError: ye } } function clearListState(fe, K) { if (K === null || typeof K != "object") return {}; const pe = { ...K }; return Object.keys(K).forEach(me => { me.includes(`${String(fe)}.`) && delete pe[me] }), pe } function getIndexFromKeyAfterPath(fe, K) { const pe = fe.substring(K.length + 1).split(".")[0]; return parseInt(pe, 10) } function changeErrorIndices(fe, K, pe, me) { if (K === void 0) return pe; const ge = `${String(fe)}`; let xe = pe; me === -1 && (xe = clearListState(`${ge}.${K}`, xe)); const ye = { ...xe }, ve = new Set; return Object.entries(xe).filter(([_e]) => { if (!_e.startsWith(`${ge}.`)) return !1; const Ee = getIndexFromKeyAfterPath(_e, ge); return Number.isNaN(Ee) ? !1 : Ee >= K }).forEach(([_e, Ee]) => { const be = getIndexFromKeyAfterPath(_e, ge), Ae = _e.replace(`${ge}.${be}`, `${ge}.${be + me}`); ye[Ae] = Ee, ve.add(Ae), ve.has(_e) || delete ye[_e] }), ye } function reorderErrors(fe, { from: K, to: pe }, me) { const ge = `${fe}.${K}`, xe = `${fe}.${pe}`, ye = { ...me }, ve = new Set; return Object.keys(me).forEach(_e => { if (ve.has(_e)) return; let Ee, be; if (_e.startsWith(ge) ? (Ee = _e, be = _e.replace(ge, xe)) : _e.startsWith(xe) && (Ee = _e.replace(xe, ge), be = _e), Ee && be) { const Ae = ye[Ee], Se = ye[be]; Se === void 0 ? delete ye[Ee] : ye[Ee] = Se, Ae === void 0 ? delete ye[be] : ye[be] = Ae, ve.add(Ee), ve.add(be) } }), ye } function set$1(fe, K, pe) { typeof pe.value == "object" && (pe.value = klona(pe.value)), !pe.enumerable || pe.get || pe.set || !pe.configurable || !pe.writable || K === "__proto__" ? Object.defineProperty(fe, K, pe) : fe[K] = pe.value } function klona(fe) { if (typeof fe != "object") return fe; var K = 0, pe, me, ge, xe = Object.prototype.toString.call(fe); if (xe === "[object Object]" ? ge = Object.create(fe.__proto__ || null) : xe === "[object Array]" ? ge = Array(fe.length) : xe === "[object Set]" ? (ge = new Set, fe.forEach(function (ye) { ge.add(klona(ye)) })) : xe === "[object Map]" ? (ge = new Map, fe.forEach(function (ye, ve) { ge.set(klona(ve), klona(ye)) })) : xe === "[object Date]" ? ge = new Date(+fe) : xe === "[object RegExp]" ? ge = new RegExp(fe.source, fe.flags) : xe === "[object DataView]" ? ge = new fe.constructor(klona(fe.buffer)) : xe === "[object ArrayBuffer]" ? ge = fe.slice(0) : xe.slice(-6) === "Array]" && (ge = new fe.constructor(fe)), ge) { for (me = Object.getOwnPropertySymbols(fe); K < me.length; K++)set$1(ge, me[K], Object.getOwnPropertyDescriptor(fe, me[K])); for (K = 0, me = Object.getOwnPropertyNames(fe); K < me.length; K++)Object.hasOwnProperty.call(ge, pe = me[K]) && ge[pe] === fe[pe] || set$1(ge, pe, Object.getOwnPropertyDescriptor(fe, pe)) } return ge || fe } function getSplittedPath(fe) { return typeof fe != "string" ? [] : fe.split(".") } function getPath(fe, K) { const pe = getSplittedPath(fe); if (pe.length === 0 || typeof K != "object" || K === null) return; let me = K[pe[0]]; for (let ge = 1; ge < pe.length && me != null; ge += 1)me = me[pe[ge]]; return me } function setPath(fe, K, pe) { const me = getSplittedPath(fe); if (me.length === 0) return pe; const ge = klona(pe); if (me.length === 1) return ge[me[0]] = K, ge; let xe = ge[me[0]]; for (let ye = 1; ye < me.length - 1; ye += 1) { if (xe === void 0) return ge; xe = xe[me[ye]] } return xe[me[me.length - 1]] = K, ge } function reorderPath(fe, { from: K, to: pe }, me) { const ge = getPath(fe, me); if (!Array.isArray(ge)) return me; const xe = [...ge], ye = ge[K]; return xe.splice(K, 1), xe.splice(pe, 0, ye), setPath(fe, xe, me) } function insertPath(fe, K, pe, me) { const ge = getPath(fe, me); if (!Array.isArray(ge)) return me; const xe = [...ge]; return xe.splice(typeof pe == "number" ? pe : xe.length, 0, K), setPath(fe, xe, me) } function removePath(fe, K, pe) { const me = getPath(fe, pe); return Array.isArray(me) ? setPath(fe, me.filter((ge, xe) => xe !== K), pe) : pe } function replacePath(fe, K, pe, me) { const ge = getPath(fe, me); if (!Array.isArray(ge) || ge.length <= pe) return me; const xe = [...ge]; return xe[pe] = K, setPath(fe, xe, me) } function useFormList({ $values: fe, $errors: K, $status: pe }) { const me = reactExports.useCallback((ve, _e) => { pe.clearFieldDirty(ve), K.setErrors(Ee => reorderErrors(ve, _e, Ee)), fe.setValues({ values: reorderPath(ve, _e, fe.refValues.current), updateState: !0 }) }, []), ge = reactExports.useCallback((ve, _e) => { pe.clearFieldDirty(ve), K.setErrors(Ee => changeErrorIndices(ve, _e, Ee, -1)), fe.setValues({ values: removePath(ve, _e, fe.refValues.current), updateState: !0 }) }, []), xe = reactExports.useCallback((ve, _e, Ee) => { pe.clearFieldDirty(ve), K.setErrors(be => changeErrorIndices(ve, Ee, be, 1)), fe.setValues({ values: insertPath(ve, _e, Ee, fe.refValues.current), updateState: !0 }) }, []), ye = reactExports.useCallback((ve, _e, Ee) => { pe.clearFieldDirty(ve), fe.setValues({ values: replacePath(ve, Ee, _e, fe.refValues.current), updateState: !0 }) }, []); return { reorderListItem: me, removeListItem: ge, insertListItem: xe, replaceListItem: ye } } var fastDeepEqual = function fe(K, pe) { if (K === pe) return !0; if (K && pe && typeof K == "object" && typeof pe == "object") { if (K.constructor !== pe.constructor) return !1; var me, ge, xe; if (Array.isArray(K)) { if (me = K.length, me != pe.length) return !1; for (ge = me; ge-- !== 0;)if (!fe(K[ge], pe[ge])) return !1; return !0 } if (K.constructor === RegExp) return K.source === pe.source && K.flags === pe.flags; if (K.valueOf !== Object.prototype.valueOf) return K.valueOf() === pe.valueOf(); if (K.toString !== Object.prototype.toString) return K.toString() === pe.toString(); if (xe = Object.keys(K), me = xe.length, me !== Object.keys(pe).length) return !1; for (ge = me; ge-- !== 0;)if (!Object.prototype.hasOwnProperty.call(pe, xe[ge])) return !1; for (ge = me; ge-- !== 0;) { var ye = xe[ge]; if (!fe(K[ye], pe[ye])) return !1 } return !0 } return K !== K && pe !== pe }; const isEqual = getDefaultExportFromCjs(fastDeepEqual); function getStatus(fe, K) { const pe = Object.keys(fe); if (typeof K == "string") { const me = pe.filter(ge => ge.startsWith(`${K}.`)); return fe[K] || me.some(ge => fe[ge]) || !1 } return pe.some(me => fe[me]) } function useFormStatus({ initialDirty: fe, initialTouched: K, mode: pe, $values: me }) { const [ge, xe] = reactExports.useState(K), [ye, ve] = reactExports.useState(fe), _e = reactExports.useRef(K), Ee = reactExports.useRef(fe), be = reactExports.useCallback(Oe => { const Ue = typeof Oe == "function" ? Oe(_e.current) : Oe; _e.current = Ue, pe === "controlled" && xe(Ue) }, []), Ae = reactExports.useCallback((Oe, Ue = !1) => { const He = typeof Oe == "function" ? Oe(Ee.current) : Oe; Ee.current = He, (pe === "controlled" || Ue) && ve(He) }, []), Se = reactExports.useCallback(() => be({}), []), Ce = reactExports.useCallback(Oe => { const Ue = Oe ? { ...me.refValues.current, ...Oe } : me.refValues.current; me.setValuesSnapshot(Ue), Ae({}) }, []), we = reactExports.useCallback((Oe, Ue) => { be(He => getStatus(He, Oe) === Ue ? He : { ...He, [Oe]: Ue }) }, []), Be = reactExports.useCallback((Oe, Ue, He) => { Ae(Ge => getStatus(Ge, Oe) === Ue ? Ge : { ...Ge, [Oe]: Ue }, He) }, []), De = reactExports.useCallback((Oe, Ue) => { const He = getStatus(Ee.current, Oe), Ge = !isEqual(getPath(Oe, me.getValuesSnapshot()), Ue), ze = clearListState(Oe, Ee.current); ze[Oe] = Ge, Ae(ze, He !== Ge) }, []), Re = reactExports.useCallback(Oe => getStatus(_e.current, Oe), []), Ie = reactExports.useCallback(Oe => Ae(Ue => { if (typeof Oe != "string") return Ue; const He = clearListState(Oe, Ue); return delete He[Oe], isEqual(He, Ue) ? Ue : He }), []), Pe = reactExports.useCallback(Oe => { if (Oe) { const He = getPath(Oe, Ee.current); if (typeof He == "boolean") return He; const Ge = getPath(Oe, me.refValues.current), ze = getPath(Oe, me.valuesSnapshot.current); return !isEqual(Ge, ze) } return Object.keys(Ee.current).length > 0 ? getStatus(Ee.current) : !isEqual(me.refValues.current, me.valuesSnapshot.current) }, []), Ne = reactExports.useCallback(() => Ee.current, []), ke = reactExports.useCallback(() => _e.current, []); return { touchedState: ge, dirtyState: ye, touchedRef: _e, dirtyRef: Ee, setTouched: be, setDirty: Ae, resetDirty: Ce, resetTouched: Se, isTouched: Re, setFieldTouched: we, setFieldDirty: Be, setTouchedState: xe, setDirtyState: ve, clearFieldDirty: Ie, isDirty: Pe, getDirty: Ne, getTouched: ke, setCalculatedFieldDirty: De } } function useFormValues({ initialValues: fe, onValuesChange: K, mode: pe }) { const me = reactExports.useRef(!1), [ge, xe] = reactExports.useState(fe || {}), ye = reactExports.useRef(ge), ve = reactExports.useRef(ge), _e = reactExports.useCallback(({ values: Be, subscribers: De, updateState: Re = !0, mergeWithPreviousValues: Ie = !0 }) => { const Pe = ye.current, Ne = Be instanceof Function ? Be(ye.current) : Be, ke = Ie ? { ...Pe, ...Ne } : Ne; ye.current = ke, Re && xe(ke), K?.(ke, Pe), De?.filter(Boolean).forEach(Oe => Oe({ updatedValues: ke, previousValues: Pe })) }, [K]), Ee = reactExports.useCallback(Be => { const De = getPath(Be.path, ye.current), Re = Be.value instanceof Function ? Be.value(De) : Be.value; if (De !== Re) { const Ie = ye.current, Pe = setPath(Be.path, Re, ye.current); _e({ values: Pe, updateState: Be.updateState }), Be.subscribers?.filter(Boolean).forEach(Ne => Ne({ path: Be.path, updatedValues: Pe, previousValues: Ie })) } }, [_e]), be = reactExports.useCallback(Be => { ve.current = Be }, []), Ae = reactExports.useCallback((Be, De) => { me.current || (me.current = !0, _e({ values: Be, updateState: pe === "controlled" }), be(Be), De()) }, [_e]), Se = reactExports.useCallback(() => { _e({ values: ve.current, updateState: !0, mergeWithPreviousValues: !1 }) }, [_e]), Ce = reactExports.useCallback(() => ye.current, []), we = reactExports.useCallback(() => ve.current, []); return { initialized: me, stateValues: ge, refValues: ye, valuesSnapshot: ve, setValues: _e, setFieldValue: Ee, resetValues: Se, setValuesSnapshot: be, initialize: Ae, getValues: Ce, getValuesSnapshot: we } } function useFormWatch({ $status: fe }) { const K = reactExports.useRef({}), pe = reactExports.useCallback((ge, xe) => { reactExports.useEffect(() => (K.current[ge] = K.current[ge] || [], K.current[ge].push(xe), () => { K.current[ge] = K.current[ge].filter(ye => ye !== xe) }), [xe]) }, []), me = reactExports.useCallback(ge => K.current[ge] ? K.current[ge].map(xe => ye => xe({ previousValue: getPath(ge, ye.previousValues), value: getPath(ge, ye.updatedValues), touched: fe.isTouched(ge), dirty: fe.isDirty(ge) })) : [], []); return { subscribers: K, watch: pe, getFieldSubscribers: me } } function getDataPath(fe, K) { return fe ? `${fe}-${K.toString()}` : K.toString() } const formRootRule = Symbol("root-rule"); function getValidationResults(fe) { const K = filterErrors(fe); return { hasErrors: Object.keys(K).length > 0, errors: K } } function validateRulesRecord(fe, K, pe = "", me = {}) { return typeof fe != "object" || fe === null ? me : Object.keys(fe).reduce((ge, xe) => { const ye = fe[xe], ve = `${pe === "" ? "" : `${pe}.`}${xe}`, _e = getPath(ve, K); let Ee = !1; return typeof ye == "function" && (ge[ve] = ye(_e, K, ve)), typeof ye == "object" && Array.isArray(_e) && (Ee = !0, _e.forEach((be, Ae) => validateRulesRecord(ye, K, `${ve}.${Ae}`, ge)), formRootRule in ye && (ge[ve] = ye[formRootRule](_e, K, ve))), typeof ye == "object" && typeof _e == "object" && _e !== null && (Ee || validateRulesRecord(ye, K, ve, ge), formRootRule in ye && (ge[ve] = ye[formRootRule](_e, K, ve))), ge }, me) } function validateValues(fe, K) { return getValidationResults(typeof fe == "function" ? fe(K) : validateRulesRecord(fe, K)) } function validateFieldValue(fe, K, pe) { if (typeof fe != "string") return { hasError: !1, error: null }; const me = validateValues(K, pe), ge = Object.keys(me.errors).find(xe => fe.split(".").every((ye, ve) => ye === xe.split(".")[ve])); return { hasError: !!ge, error: ge ? me.errors[ge] : null } } const FORM_INDEX = "__MANTINE_FORM_INDEX__"; function shouldValidateOnChange(fe, K) { return K ? typeof K == "boolean" ? K : Array.isArray(K) ? K.includes(fe.replace(/[.][0-9]+/g, `.${FORM_INDEX}`)) : !1 : !1 } function useForm({ name: fe, mode: K = "controlled", initialValues: pe, initialErrors: me = {}, initialDirty: ge = {}, initialTouched: xe = {}, clearInputErrorOnChange: ye = !0, validateInputOnChange: ve = !1, validateInputOnBlur: _e = !1, onValuesChange: Ee, transformValues: be = Be => Be, enhanceGetInputProps: Ae, validate: Se, onSubmitPreventDefault: Ce = "always", touchTrigger: we = "change" } = {}) { const Be = useFormErrors(me), De = useFormValues({ initialValues: pe, onValuesChange: Ee, mode: K }), Re = useFormStatus({ initialDirty: ge, initialTouched: xe, $values: De, mode: K }), Ie = useFormList({ $values: De, $errors: Be, $status: Re }), Pe = useFormWatch({ $status: Re }), [Ne, ke] = reactExports.useState(0), [Oe, Ue] = reactExports.useState({}), [He, Ge] = reactExports.useState(!1), ze = reactExports.useCallback(() => { De.resetValues(), Be.clearErrors(), Re.resetDirty(), Re.resetTouched(), K === "uncontrolled" && ke($t => $t + 1) }, []), We = reactExports.useCallback($t => { ye && Be.clearErrors(), K === "uncontrolled" && ke(an => an + 1), Object.keys(Pe.subscribers.current).forEach(an => { const gn = getPath(an, De.refValues.current), Mn = getPath(an, $t); gn !== Mn && Pe.getFieldSubscribers(an).forEach(Xn => Xn({ previousValues: $t, updatedValues: De.refValues.current })) }) }, [ye]), Xe = reactExports.useCallback($t => { const an = De.refValues.current; De.initialize($t, () => K === "uncontrolled" && ke(gn => gn + 1)), We(an) }, [We]), Ye = reactExports.useCallback(($t, an, gn) => { const Mn = shouldValidateOnChange($t, ve), Xn = an instanceof Function ? an(getPath($t, De.refValues.current)) : an; Re.setCalculatedFieldDirty($t, Xn), we === "change" && Re.setFieldTouched($t, !0), !Mn && ye && Be.clearFieldError($t), De.setFieldValue({ path: $t, value: an, updateState: K === "controlled", subscribers: [...Pe.getFieldSubscribers($t), Mn ? Ln => { const Gn = validateFieldValue($t, Se, Ln.updatedValues); Gn.hasError ? Be.setFieldError($t, Gn.error) : Be.clearFieldError($t) } : null, gn?.forceUpdate !== !1 && K !== "controlled" ? () => Ue(Ln => ({ ...Ln, [$t]: (Ln[$t] || 0) + 1 })) : null] }) }, [Ee, Se]), Ze = reactExports.useCallback($t => { const an = De.refValues.current; De.setValues({ values: $t, updateState: K === "controlled" }), We(an) }, [Ee, We]), ot = reactExports.useCallback(() => { const $t = validateValues(Se, De.refValues.current); return Be.setErrors($t.errors), $t }, [Se]), qe = reactExports.useCallback($t => { const an = validateFieldValue($t, Se, De.refValues.current); return an.hasError ? Be.setFieldError($t, an.error) : Be.clearFieldError($t), an }, [Se]), Qe = ($t, { type: an = "input", withError: gn = !0, withFocus: Mn = !0, ...Xn } = {}) => { const Gn = { onChange: getInputOnChange(wn => Ye($t, wn, { forceUpdate: !1 })), "data-path": getDataPath(fe, $t) }; return gn && (Gn.error = Be.errorsState[$t]), an === "checkbox" ? Gn[K === "controlled" ? "checked" : "defaultChecked"] = getPath($t, De.refValues.current) : Gn[K === "controlled" ? "value" : "defaultValue"] = getPath($t, De.refValues.current), Mn && (Gn.onFocus = () => Re.setFieldTouched($t, !0), Gn.onBlur = () => { if (shouldValidateOnChange($t, _e)) { const wn = validateFieldValue($t, Se, De.refValues.current); wn.hasError ? Be.setFieldError($t, wn.error) : Be.clearFieldError($t) } }), Object.assign(Gn, Ae?.({ inputProps: Gn, field: $t, options: { type: an, withError: gn, withFocus: Mn, ...Xn }, form: nn })) }, st = ($t, an) => gn => { Ce === "always" && gn?.preventDefault(); const Mn = ot(); if (Mn.hasErrors) Ce === "validation-failed" && gn?.preventDefault(), an?.(Mn.errors, De.refValues.current, gn); else { const Xn = $t?.(be(De.refValues.current), gn); Xn instanceof Promise && (Ge(!0), Xn.finally(() => Ge(!1))) } }, Nt = $t => be($t || De.refValues.current), Je = reactExports.useCallback($t => { $t.preventDefault(), ze() }, []), jt = reactExports.useCallback($t => $t ? !validateFieldValue($t, Se, De.refValues.current).hasError : !validateValues(Se, De.refValues.current).hasErrors, [Se]), Xt = $t => `${Ne}-${$t}-${Oe[$t] || 0}`, ct = reactExports.useCallback($t => document.querySelector(`[data-path="${getDataPath(fe, $t)}"]`), []), nn = { watch: Pe.watch, initialized: De.initialized.current, values: De.stateValues, getValues: De.getValues, getInitialValues: De.getValuesSnapshot, setInitialValues: De.setValuesSnapshot, initialize: Xe, setValues: Ze, setFieldValue: Ye, submitting: He, setSubmitting: Ge, errors: Be.errorsState, setErrors: Be.setErrors, setFieldError: Be.setFieldError, clearFieldError: Be.clearFieldError, clearErrors: Be.clearErrors, resetDirty: Re.resetDirty, setTouched: Re.setTouched, setDirty: Re.setDirty, isTouched: Re.isTouched, resetTouched: Re.resetTouched, isDirty: Re.isDirty, getTouched: Re.getTouched, getDirty: Re.getDirty, reorderListItem: Ie.reorderListItem, insertListItem: Ie.insertListItem, removeListItem: Ie.removeListItem, replaceListItem: Ie.replaceListItem, reset: ze, validate: ot, validateField: qe, getInputProps: Qe, onSubmit: st, onReset: Je, isValid: jt, getTransformedValues: Nt, key: Xt, getInputNode: ct }; return useFormActions(fe, nn), nn } function EditNodeProps({ nodeName: fe, closePopoverFn: K }) { const pe = React$4.useContext(ViewerContext), me = pe.useSceneTree(Ae => Ae.nodeFromName[fe]), ge = pe.useSceneTree(Ae => Ae.updateSceneNode); if (me === void 0) return null; function xe(Ae) { return Ae == Number.POSITIVE_INFINITY ? "Infinity" : JSON.stringify(Ae) } function ye(Ae) { return Ae === "Infinity" ? Number.POSITIVE_INFINITY : JSON.parse(Ae) } const ve = me.message.props, _e = Object.fromEntries(Object.entries(ve).filter(([, Ae]) => !(Ae instanceof Uint8Array)).map(([Ae, Se]) => [Ae, xe(Se)])), Ee = useForm({ initialValues: { ..._e }, validate: { ...Object.fromEntries(Object.keys(_e).map(Ae => [Ae, Se => { try { return ye(Se), null } catch { return "Invalid JSON" } }])) } }), be = Ae => { Object.entries(Ae).forEach(([Se, Ce]) => { if (Ce !== _e[Se]) try { const we = ye(Ce); ge(fe, { [Se]: we }), Ee.setFieldValue(Se, xe(we)) } catch (we) { console.error("Failed to parse JSON:", we) } }) }; return jsxRuntimeExports.jsxs(Box, { className: propsWrapper, component: "form", onSubmit: Ee.onSubmit(be), w: "15em", children: [jsxRuntimeExports.jsxs(Box, { children: [jsxRuntimeExports.jsxs(Box, { style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsxs(Box, { style: { fontWeight: "500", flexGrow: "1" }, fz: "sm", children: [me.message.type.replace("Message", "").replace(/([a-z])(\d[A-Z])/g, "$1 $2").replace(/([a-z])([A-Z])/g, "$1 $2").trim(), " ", "Props"] }), jsxRuntimeExports.jsx(Tooltip, { label: "Close props", children: jsxRuntimeExports.jsx(IconX, { style: { cursor: "pointer", width: "1em", height: "1em", display: "block", opacity: "0.7" }, onClick: Ae => { Ae.stopPropagation(), K() } }) })] }), jsxRuntimeExports.jsx(Box, { style: { opacity: "0.5" }, fz: "xs", children: fe })] }), jsxRuntimeExports.jsx(ScrollArea.Autosize, { mah: "30vh", scrollbarSize: 6, offsetScrollbars: "present", type: "auto", children: jsxRuntimeExports.jsx(Box, { style: { display: "flex", flexDirection: "column", gap: "0.5rem" }, children: Object.entries(ve).map(([Ae, Se]) => { if (Se instanceof Uint8Array || Ae.startsWith("_")) return null; const Ce = Ee.values[Ae] !== _e[Ae]; return jsxRuntimeExports.jsxs(Flex, { align: "center", children: [jsxRuntimeExports.jsx(Box, { style: { flexGrow: "1" }, fz: "xs", children: Ae.charAt(0).toUpperCase() + Ae.slice(1).split("_").join(" ") }), jsxRuntimeExports.jsx(Flex, { gap: "xs", style: { width: "9em" }, children: (() => { try { const we = ye(Ee.values[Ae]); if (Ae.toLowerCase().includes("color") && Array.isArray(we) && we.length === 3 && we.every(De => typeof De == "number")) { const De = (Ie, Pe, Ne) => { const ke = Oe => { const Ue = Math.round(Oe).toString(16); return Ue.length === 1 ? "0" + Ue : Ue }; return "#" + ke(Ie) + ke(Pe) + ke(Ne) }, Re = Ie => { const Pe = parseInt(Ie.slice(1, 3), 16), Ne = parseInt(Ie.slice(3, 5), 16), ke = parseInt(Ie.slice(5, 7), 16); return [Pe, Ne, ke] }; return jsxRuntimeExports.jsx(ColorInput, { size: "xs", styles: { input: { height: "1.625rem", minHeight: "1.625rem" } }, style: { width: "100%" }, value: De(we[0], we[1], we[2]), onChange: Ie => { const Pe = Re(Ie); Ee.setFieldValue(Ae, xe(Pe)), Ee.onSubmit(be)() }, onKeyDown: Ie => { Ie.key === "Enter" && (Ie.preventDefault(), Ee.onSubmit(be)()) } }) } } catch { } return jsxRuntimeExports.jsx(TextInput, { size: "xs", styles: { input: { height: "1.625rem", minHeight: "1.625rem", width: "100%" } }, style: { width: "100%" }, ...Ee.getInputProps(Ae), onKeyDown: we => { we.key === "Enter" && (we.preventDefault(), Ee.onSubmit(be)()) }, rightSection: jsxRuntimeExports.jsx(IconDeviceFloppy, { style: { width: "1rem", height: "1rem", opacity: Ce ? 1 : .3, cursor: Ce ? "pointer" : "default" }, onClick: () => { Ce && Ee.onSubmit(be)() } }) }) })() })] }, Ae) }) }) }), jsxRuntimeExports.jsx(Box, { style: { opacity: "0.4", marginTop: "0.5rem" }, fz: "xs", children: "Updates from the server will overwrite local changes." })] }) } function SceneTreeTable() { const K = React$4.useContext(ViewerContext).useSceneTree(pe => pe.nodeFromName[""].children); return jsxRuntimeExports.jsx(ScrollArea, { className: tableWrapper, children: jsxRuntimeExports.jsx(PropsPopoverProvider, { children: jsxRuntimeExports.jsx(VisibilityPaintProvider, { children: K.map(pe => jsxRuntimeExports.jsx(SceneTreeTableRow, { nodeName: pe, isParentVisible: !0, indentCount: 0 }, pe)) }) }) }) } const VisibilityPaintContext = React$4.createContext(null), PropsPopoverContext = React$4.createContext(null); function VisibilityPaintProvider({ children: fe }) { const K = React$4.useRef(!1), pe = React$4.useRef(!1), me = xe => { K.current = !0, pe.current = xe }, ge = () => { K.current = !1 }; return React$4.useEffect(() => (window.addEventListener("mouseup", ge), () => { window.removeEventListener("mouseup", ge) }), [ge]), jsxRuntimeExports.jsx(VisibilityPaintContext.Provider, { value: { paintingRef: K, paintValueRef: pe, startPainting: me, stopPainting: ge }, children: fe }) } function PropsPopoverProvider({ children: fe }) { const [K, pe] = React$4.useState(null); return jsxRuntimeExports.jsx(PropsPopoverContext.Provider, { value: { openPopoverNodeName: K, setOpenPopoverNodeName: pe }, children: fe }) } const SceneTreeTableRow = React$4.memo(function fe(K) { const pe = React$4.useContext(ViewerContext), me = useMantineTheme(), { colorScheme: ge } = useMantineColorScheme(), { paintingRef: xe, paintValueRef: ye, startPainting: ve } = React$4.useContext(VisibilityPaintContext), { openPopoverNodeName: _e, setOpenPopoverNodeName: Ee } = React$4.useContext(PropsPopoverContext), be = He => { He.stopPropagation(); const Ge = !Pe; ve(Ge), pe.useSceneTree.getState().updateNodeAttributes(K.nodeName, { overrideVisibility: Ge }) }, Ae = () => { xe.current && pe.useSceneTree.getState().updateNodeAttributes(K.nodeName, { overrideVisibility: ye.current }) }, Se = pe.useSceneTree(He => He.nodeFromName[K.nodeName].children), Ce = Se.length > 0, [we, { toggle: Be }] = useDisclosure(!1), De = pe.useSceneTree(He => He.setLabelVisibility), Re = pe.useSceneTree(He => He.nodeAttributesFromName[K.nodeName]?.visibility) ?? !0, Ie = pe.useSceneTree(He => He.nodeAttributesFromName[K.nodeName]?.overrideVisibility), Pe = Ie !== void 0 ? Ie : Re; React$4.useEffect(() => () => { De(K.nodeName, !1) }); const Ne = Pe && K.isParentVisible, ke = Pe ? IconEye : IconEyeOff, Oe = () => { Ee(null) }, Ue = () => { _e === K.nodeName ? Ee(null) : Ee(K.nodeName) }; return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Box, { className: tableRow, style: { cursor: Ce ? "pointer" : void 0 }, onClick: Ce ? Be : void 0, onMouseEnter: () => De(K.nodeName, !0), onMouseLeave: () => De(K.nodeName, !1), children: [new Array(K.indentCount).fill(null).map((He, Ge) => jsxRuntimeExports.jsx(Box, { className: tableHierarchyLine }, Ge)), jsxRuntimeExports.jsx(Box, { style: { opacity: Ce ? .7 : .1 }, children: we ? jsxRuntimeExports.jsx(IconCaretDown, { style: { height: "1em", width: "1em", transform: "translateY(0.1em)" } }) : jsxRuntimeExports.jsx(IconCaretRight, { style: { height: "1em", width: "1em", transform: "translateY(0.1em)" } }) }), jsxRuntimeExports.jsx(Box, { style: { width: "1.5em", height: "1.5em" }, children: jsxRuntimeExports.jsx(Tooltip, { label: "Toggle visibility override", children: jsxRuntimeExports.jsx(ke, { style: { cursor: "pointer", opacity: Ne ? .85 : .25, width: "1.5em", height: "1.5em", display: "block", ...Ie !== void 0 && { color: me.colors[me.primaryColor][ge === "dark" ? 4 : 6], filter: `drop-shadow(0 0 2px ${me.colors[me.primaryColor][ge === "dark" ? 4 : 6]}30)` } }, onMouseDown: be, onMouseEnter: Ae }) }) }), jsxRuntimeExports.jsxs(Box, { style: { flexGrow: "1", userSelect: "none" }, children: [jsxRuntimeExports.jsx("span", { style: { opacity: "0.3" }, children: "/" }), K.nodeName.split("/").at(-1)] }), Ie !== void 0 ? jsxRuntimeExports.jsx(Box, { className: editIconWrapper, style: { width: "1.25em", height: "1.25em", display: "block", transition: "opacity 0.2s", marginRight: "0.25em" }, children: jsxRuntimeExports.jsx(Tooltip, { label: "Clear visibility override", children: jsxRuntimeExports.jsx(IconEyeX, { style: { cursor: "pointer", width: "1.25em", height: "1.25em", display: "block", opacity: .7, color: me.colors[me.primaryColor][ge === "dark" ? 4 : 6], filter: `drop-shadow(0 0 2px ${me.colors[me.primaryColor][ge === "dark" ? 4 : 6]}30)` }, onClick: He => { He.stopPropagation(), pe.useSceneTree.getState().updateNodeAttributes(K.nodeName, { overrideVisibility: void 0 }) } }) }) }) : null, jsxRuntimeExports.jsxs(Popover, { position: "bottom", withArrow: !0, shadow: "sm", arrowSize: 10, opened: _e === K.nodeName, onDismiss: Oe, middlewares: { flip: !0, shift: !0 }, withinPortal: !0, children: [jsxRuntimeExports.jsx(Popover.Target, { children: jsxRuntimeExports.jsx(Box, { className: editIconWrapper, style: { width: "1.25em", height: "1.25em", display: "block", transition: "opacity 0.2s" }, children: jsxRuntimeExports.jsx(Tooltip, { label: "Local props", children: jsxRuntimeExports.jsx(IconPencil, { style: { cursor: "pointer", width: "1.25em", height: "1.25em", display: "block" }, onClick: He => { He.stopPropagation(), Ue() } }) }) }) }), jsxRuntimeExports.jsx(Popover.Dropdown, { onMouseDown: He => He.stopPropagation(), onClick: He => He.stopPropagation(), children: jsxRuntimeExports.jsx(EditNodeProps, { nodeName: K.nodeName, closePopoverFn: Oe }) })] })] }), we ? Se.map(He => jsxRuntimeExports.jsx(fe, { nodeName: He, isParentVisible: Ne, indentCount: K.indentCount + 1 }, He)) : null] }) }), MemoizedTable = React$4.memo(SceneTreeTable); function ServerControls() { const fe = React$4.useContext(ViewerContext), K = fe.mutable.current, [pe, me] = React$4.useState(!1), ge = fe.useGui(xe => xe.theme.control_width); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [pe ? jsxRuntimeExports.jsx(Stats, { className: "stats-panel" }) : null, jsxRuntimeExports.jsxs(Stack, { gap: "xs", mt: "0.3em", children: [jsxRuntimeExports.jsx(Tooltip, { label: "Server URL", position: "top-start", children: jsxRuntimeExports.jsx(TextInput, { leftSection: jsxRuntimeExports.jsx(Image$1, { src: "./logo.svg", style: { width: "1rem", height: "auto", filter: "grayscale(100%) opacity(0.3)" } }), leftSectionWidth: "1.8rem", defaultValue: fe.useGui(xe => xe.server), onBlur: xe => fe.useGui.setState({ server: xe.currentTarget.value }), onKeyDown: xe => { xe.key === "Enter" && (xe.currentTarget.blur(), xe.currentTarget.focus()) } }) }), jsxRuntimeExports.jsxs(Group$1, { gap: "0.5em", children: [jsxRuntimeExports.jsx(Button, { onClick: async () => { if ("showSaveFilePicker" in window && (() => { try { return window.self === window.top } catch { return !1 } })()) { const ye = window.showSaveFilePicker({ suggestedName: "render.png", types: [{ accept: { "image/png": [".png"] } }] }); K.canvas?.toBlob(async ve => { if (ve === null) { console.error("Export failed"); return } const Ee = await (await ye).createWritable(); await Ee.write(ve), await Ee.close() }) } else K.canvas?.toBlob(ye => { if (ye === null) { console.error("Export failed"); return } const ve = URL.createObjectURL(ye), _e = document.createElement("a"); _e.href = ve; const Ee = "render.png"; _e.download = Ee, document.body.appendChild(_e), _e.click(), document.body.removeChild(_e), URL.revokeObjectURL(ve) }) }, flex: 1, leftSection: ge === "small" ? void 0 : jsxRuntimeExports.jsx(IconPhoto, { size: "1rem" }), px: "0", style: { height: "1.875rem" }, children: "Save Canvas" }), jsxRuntimeExports.jsx(Button, { onClick: () => { K.resetCameraView() }, flex: 1, leftSection: ge === "small" ? void 0 : jsxRuntimeExports.jsx(IconHomeMove, { size: "1rem" }), px: "0", style: { height: "1.875rem" }, children: "Reset View" })] }), jsxRuntimeExports.jsxs(Group$1, { gap: "md", children: [jsxRuntimeExports.jsx(Tooltip, { label: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: ["Show tool for setting the look-at point and", jsxRuntimeExports.jsx("br", {}), "up direction of the camera.", jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("br", {}), "This can be used to set the origin of the", jsxRuntimeExports.jsx("br", {}), "camera's orbit controls."] }), refProp: "rootRef", position: "top-start", children: jsxRuntimeExports.jsx(Checkbox, { radius: "xs", label: "Orbit Origin Tool", onChange: xe => { fe.useGui.setState({ showOrbitOriginTool: xe.currentTarget.checked }) }, styles: { label: { paddingLeft: "8px", letterSpacing: "-0.3px" }, root: { flex: 1 } }, size: "sm" }) }), jsxRuntimeExports.jsx(Tooltip, { label: "Show WebGL statistics.", refProp: "rootRef", position: "top-start", children: jsxRuntimeExports.jsx(Checkbox, { radius: "xs", label: "WebGL Stats", onChange: xe => { me(xe.currentTarget.checked) }, styles: { label: { paddingLeft: "8px", letterSpacing: "-0.3px" }, root: { flex: 1 } }, size: "sm" }) })] }), jsxRuntimeExports.jsx(Divider, { mt: "xs" }), jsxRuntimeExports.jsxs(Box, { children: [jsxRuntimeExports.jsx(Tooltip, { label: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: ["Hierarchical view of all objects in the 3D scene.", jsxRuntimeExports.jsx("br", {}), "Use to override visibility and properties."] }), position: "top-start", children: jsxRuntimeExports.jsx(Text, { style: { fontWeight: 500 }, fz: "sm", children: "Scene tree" }) }), jsxRuntimeExports.jsx(MemoizedTable, {})] })] })] }) } const BottomPanelContext = React$4.createContext(null); function BottomPanel({ children: fe }) { const K = React$4.useRef(null), [pe, { toggle: me }] = useDisclosure(!0); return jsxRuntimeExports.jsx(BottomPanelContext.Provider, { value: { wrapperRef: K, expanded: pe, toggleExpanded: me }, children: jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx(Paper, { radius: "0", shadow: "0 0 1em 0 rgba(0,0,0,0.1)", style: { boxSizing: "border-box", zIndex: 10, position: "fixed", bottom: 0, right: 0, margin: 0, minHeight: "3.5em", maxHeight: "60%", width: "20em", transition: "height 0.3s linear" }, ref: K, children: jsxRuntimeExports.jsx(ScrollArea.Autosize, { children: jsxRuntimeExports.jsx(Box, { style: { width: "20em" }, children: fe }) }) }) }) }) } BottomPanel.Handle = function ({ children: K }) { const pe = React$4.useContext(BottomPanelContext); return jsxRuntimeExports.jsx(Box, { style: { cursor: "pointer", position: "relative", fontWeight: 400, userSelect: "none", display: "flex", alignItems: "center", padding: "0 0.8em", height: "3.5em" }, onClick: () => { pe.toggleExpanded() }, children: K }) }; BottomPanel.Contents = function ({ children: K }) { const pe = React$4.useContext(BottomPanelContext); return jsxRuntimeExports.jsxs(Collapse, { in: pe.expanded, children: [jsxRuntimeExports.jsx(Divider, { mx: "xs" }), K] }) }; BottomPanel.HideWhenCollapsed = function ({ children: K }) { return React$4.useContext(BottomPanelContext)?.expanded ?? !0 ? K : null }; const touchEvents = { move: "touchmove", end: "touchend" }, mouseEvents = { move: "mousemove", end: "mouseup" }; function isTouchEvent(fe) { return fe.type === "touchmove" } function isMouseEvent(fe) { return fe.type === "mousemove" } const FloatingPanelContext = React$4.createContext(null); function FloatingPanel({ children: fe, width: K }) { const pe = React$4.useRef(null), [me, { toggle: ge }] = useDisclosure(!0), [xe, ye] = React$4.useState(800), ve = React$4.useRef({ dragging: !1, startPosX: 0, startPosY: 0, startClientX: 0, startClientY: 0 }), _e = React$4.useRef({}), Ee = (Ce, we, Be) => Math.abs(Ce + we / 2) < Math.abs(Ce - Be + we / 2) ? Ce : Ce - Be, be = 15; function Ae(Ce, we) { const Be = pe.current; if (Be === null) return [Ce, we]; const De = Be.parentElement; if (De === null) return [Ce, we]; let Re = Ce, Ie = we; return Re = Math.min(Re, De.clientWidth - Be.clientWidth - be), Re = Math.max(Re, be), Ie = Math.min(Ie, De.clientHeight - Be.clientHeight - be), Ie = Math.max(Ie, be), Be.style.top = `${Ie.toString()}px`, Be.style.left = `${Re.toString()}px`, [Ee(Re, Be.clientWidth, De.clientWidth), Ee(Ie, Be.clientHeight, De.clientHeight)] } React$4.useEffect(() => { const Ce = pe.current; if (Ce === null) return; const we = Ce.parentElement; if (we === null) return; const Be = new ResizeObserver(() => { _e.current.x === void 0 && (_e.current.x = Ee(Ce.offsetLeft, Ce.clientWidth, we.clientWidth)), _e.current.y === void 0 && (_e.current.y = Ee(Ce.offsetTop, Ce.clientHeight, we.clientHeight)); const De = we.clientHeight - be * 2; xe !== De && ye(De); let Re = _e.current.x, Ie = _e.current.y; for (; Re < 0;)Re += we.clientWidth; for (; Ie < 0;)Ie += we.clientHeight; Ae(Re, Ie) }); return Be.observe(Ce), Be.observe(we), () => { Be.disconnect() } }); const Se = Ce => { const we = ve.current, Be = pe.current; if (!Be) return; Ce.type == "touchstart" ? (Ce = Ce, we.startClientX = Ce.touches[0].clientX, we.startClientY = Ce.touches[0].clientY) : (Ce = Ce, we.startClientX = Ce.clientX, we.startClientY = Ce.clientY), we.startPosX = Be.offsetLeft, we.startPosY = Be.offsetTop; const De = Ce.type == "touchstart" ? touchEvents : mouseEvents; function Re(Ie) { let Pe = 0, Ne = 0; if (isTouchEvent(Ie) ? (Ie = Ie, Pe = Ie.touches[0].clientX - we.startClientX, Ne = Ie.touches[0].clientY - we.startClientY) : isMouseEvent(Ie) && (Ie = Ie, Pe = Ie.clientX - we.startClientX, Ne = Ie.clientY - we.startClientY), Math.abs(Pe) <= 3 && Math.abs(Ne) <= 3) return; we.dragging = !0; const ke = we.startPosX + Pe, Oe = we.startPosY + Ne;[_e.current.x, _e.current.y] = Ae(ke, Oe) } window.addEventListener(De.move, Re), window.addEventListener(De.end, () => { Ce.type == "touchstart" && (we.dragging = !1), window.removeEventListener(De.move, Re) }, { once: !0 }) }; return jsxRuntimeExports.jsx(FloatingPanelContext.Provider, { value: { wrapperRef: pe, expanded: me, width: K, maxHeight: xe, toggleExpanded: ge, dragHandler: Se, dragInfo: ve }, children: jsxRuntimeExports.jsx(Paper, { radius: "xs", shadow: "0.1em 0 1em 0 rgba(0,0,0,0.1)", style: { boxSizing: "border-box", width: K, zIndex: 10, position: "absolute", top: "1em", right: "1em", margin: 0, "& .expandIcon": { transform: "rotate(0)" }, overflow: "hidden" }, ref: pe, children: fe }) }) } FloatingPanel.Handle = function ({ children: K }) { const pe = React$4.useContext(FloatingPanelContext); return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx(Box, { style: { borderRadius: "0.2em 0.2em 0 0", lineHeight: "1.5em", cursor: "pointer", position: "relative", fontWeight: 400, userSelect: "none", display: "flex", alignItems: "center", padding: "0 0.75em", height: "2.75em" }, onClick: () => { const me = pe.dragInfo.current; if (me.dragging) { me.dragging = !1; return } pe.toggleExpanded() }, onTouchStart: me => { pe.dragHandler(me) }, onMouseDown: me => { pe.dragHandler(me) }, children: K }) }) }; FloatingPanel.Contents = function ({ children: K }) { const pe = React$4.useContext(FloatingPanelContext); return jsxRuntimeExports.jsxs(Collapse, { in: pe.expanded, children: [jsxRuntimeExports.jsx(Divider, { mx: "xs" }), jsxRuntimeExports.jsx(ScrollArea.Autosize, { mah: pe.maxHeight, children: jsxRuntimeExports.jsx(Box, { style: { width: pe.width }, children: K }) })] }) }; FloatingPanel.HideWhenCollapsed = function ({ children: K }) { return React$4.useContext(FloatingPanelContext)?.expanded ?? !0 ? K : null }; const SidebarPanelContext = React$4.createContext(null); function SidebarPanel({ children: fe, collapsible: K, width: pe }) { const [me, { toggle: ge }] = useDisclosure(!1), xe = jsxRuntimeExports.jsx(Box, { style: ye => ({ position: "absolute", top: 0, right: me ? "0em" : "-3em", transitionProperty: "right", transitionDuration: "0.5s", transitionDelay: "0.25s", borderBottomLeftRadius: "0.5em", backgroundColor: useMantineColorScheme().colorScheme == "dark" ? ye.colors.dark[5] : ye.colors.gray[2], padding: "0.5em" }), children: jsxRuntimeExports.jsx(ActionIcon, { onClick: ye => { ye.stopPropagation(), ge() }, children: jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: "Show sidebar", children: jsxRuntimeExports.jsx(IconChevronLeft, {}) }) }) }); return jsxRuntimeExports.jsxs(SidebarPanelContext.Provider, { value: { collapsible: K, toggleCollapsed: ge }, children: [xe, jsxRuntimeExports.jsx(Paper, { shadow: "0 0 1em 0 rgba(0,0,0,0.1)", style: { width: me ? 0 : pe, boxSizing: "content-box", transition: "width 0.5s 0s", zIndex: 8 } }), jsxRuntimeExports.jsx(Paper, { radius: 0, style: { width: me ? 0 : pe, top: 0, bottom: 0, right: 0, position: "absolute", boxSizing: "content-box", transition: "width 0.5s 0s", zIndex: 20 }, children: jsxRuntimeExports.jsx(Box, { style: { width: pe, height: "100%", display: "flex", flexDirection: "column" }, children: fe }) })] }) } SidebarPanel.Handle = function ({ children: K }) { const { toggleCollapsed: pe, collapsible: me } = React$4.useContext(SidebarPanelContext), ge = jsxRuntimeExports.jsx(ActionIcon, { onClick: xe => { xe.stopPropagation(), pe() }, children: jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: "Collapse sidebar", children: jsxRuntimeExports.jsx(IconChevronRight, { stroke: 1.625 }) }) }); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Box, { p: "xs", style: { lineHeight: "1.5em", fontWeight: 400, position: "relative", zIndex: 20, alignItems: "center", display: "flex", flexDirection: "row" }, children: [K, me ? ge : null] }), jsxRuntimeExports.jsx(Divider, { mx: "xs" })] }) }; SidebarPanel.Contents = function ({ children: K }) { return jsxRuntimeExports.jsx(ScrollArea, { style: { flexGrow: 1 }, children: K }) }; const ROOT_CONTAINER_ID = "root", MemoizedGeneratedGuiContainer = React$4.memo(GeneratedGuiContainer); function ControlPanel(fe) { const K = useMantineTheme(), pe = useMediaQuery(`(max-width: ${K.breakpoints.xs})`), me = React$4.useContext(ViewerContext), ge = me.useGui(Ae => "root" in Ae.guiUuidSetFromContainerUuid), [xe, { toggle: ye }] = useDisclosure(!1), ve = me.useGui(Ae => Ae.theme.control_width), _e = ve == "small" ? "16em" : ve == "medium" ? "20em" : ve == "large" ? "24em" : null, Ee = jsxRuntimeExports.jsx(ActionIcon, { onClick: Ae => { Ae.stopPropagation(), ye() }, style: { display: ge ? void 0 : "none", transform: "translateY(0.05em)" }, children: jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: xe ? "Return to GUI" : "Configuration & diagnostics", withinPortal: !0, children: xe ? jsxRuntimeExports.jsx(IconArrowBack, { stroke: 1.625 }) : jsxRuntimeExports.jsx(IconAdjustments, { stroke: 1.625 }) }) }), be = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Collapse, { in: !ge || xe, children: jsxRuntimeExports.jsx(Box, { p: "xs", pt: "0.375em", children: jsxRuntimeExports.jsx(ServerControls, {}) }) }), jsxRuntimeExports.jsx(Collapse, { in: ge && !xe, children: jsxRuntimeExports.jsx(MemoizedGeneratedGuiContainer, { containerUuid: ROOT_CONTAINER_ID }) })] }); return pe ? jsxRuntimeExports.jsxs(BottomPanel, { children: [jsxRuntimeExports.jsxs(BottomPanel.Handle, { children: [jsxRuntimeExports.jsx(ConnectionStatus, {}), jsxRuntimeExports.jsxs(BottomPanel.HideWhenCollapsed, { children: [jsxRuntimeExports.jsx(ShareButton, {}), Ee] })] }), jsxRuntimeExports.jsx(BottomPanel.Contents, { children: be })] }) : fe.control_layout === "floating" ? jsxRuntimeExports.jsxs(FloatingPanel, { width: _e, children: [jsxRuntimeExports.jsxs(FloatingPanel.Handle, { children: [jsxRuntimeExports.jsx(ConnectionStatus, {}), jsxRuntimeExports.jsxs(FloatingPanel.HideWhenCollapsed, { children: [jsxRuntimeExports.jsx(ShareButton, {}), Ee] })] }), jsxRuntimeExports.jsx(FloatingPanel.Contents, { children: be })] }) : jsxRuntimeExports.jsxs(SidebarPanel, { width: _e, collapsible: fe.control_layout === "collapsible", children: [jsxRuntimeExports.jsxs(SidebarPanel.Handle, { children: [jsxRuntimeExports.jsx(ConnectionStatus, {}), jsxRuntimeExports.jsx(ShareButton, {}), Ee] }), jsxRuntimeExports.jsx(SidebarPanel.Contents, { children: be })] }) } function ConnectionStatus() { const { useGui: fe } = React$4.useContext(ViewerContext), K = fe(me => me.websocketConnected), pe = fe(me => me.label); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { style: { width: "1.1em" } }), " ", jsxRuntimeExports.jsx(Transition$1, { transition: "skew-down", mounted: K, children: me => jsxRuntimeExports.jsx(IconCloudCheck, { color: "#0b0", style: { position: "absolute", width: "1.25em", height: "1.25em", ...me } }) }), jsxRuntimeExports.jsx(Transition$1, { transition: "skew-down", mounted: !K, children: me => jsxRuntimeExports.jsx(Loader$1, { size: "xs", type: "dots", color: "red", style: { position: "absolute", ...me } }) }), jsxRuntimeExports.jsx(Box, { px: "xs", style: { flexGrow: 1, letterSpacing: "-0.5px" }, pt: "0.1em", children: pe !== "" ? pe : K ? "Connected" : "Connecting..." })] }) } function ShareButton() { const fe = React$4.useContext(ViewerContext), K = fe.mutable.current, pe = fe.useGui(Ce => Ce.websocketConnected), me = fe.useGui(Ce => Ce.shareUrl), ge = fe.useGui(Ce => Ce.setShareUrl), [xe, ye] = React$4.useState(!1), [ve, { open: _e, close: Ee }] = useDisclosure(!1), [be, { toggle: Ae }] = useDisclosure(); React$4.useEffect(() => { me !== null && ye(!1) }, [me]), React$4.useEffect(() => { !pe && ve && Ee() }, [pe, ve]); const Se = useMantineColorScheme().colorScheme; return fe.useGui(Ce => Ce.theme).show_share_button === !1 ? null : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: pe ? "Share" : "Share (needs connection)", withinPortal: !0, children: jsxRuntimeExports.jsx(ActionIcon, { onClick: Ce => { Ce.stopPropagation(), _e() }, style: { transform: "translateY(0.05em)" }, disabled: !pe, children: jsxRuntimeExports.jsx(IconShare, { stroke: 2, height: "1.125em", width: "1.125em" }) }) }), jsxRuntimeExports.jsxs(Modal, { title: "Share", opened: ve, onClose: Ee, withCloseButton: !1, zIndex: 100, withinPortal: !0, onClick: Ce => Ce.stopPropagation(), onMouseDown: Ce => Ce.stopPropagation(), onMouseMove: Ce => Ce.stopPropagation(), onMouseUp: Ce => Ce.stopPropagation(), styles: { title: { fontWeight: 600 } }, children: [me === null ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: xe ? jsxRuntimeExports.jsx(Stack, { mb: "xl", children: jsxRuntimeExports.jsx(Loader$1, { size: "xl", mx: "auto", type: "dots" }) }) : jsxRuntimeExports.jsxs(Stack, { mb: "md", children: [jsxRuntimeExports.jsx(Text, { children: "Create a public, shareable URL to this Viser instance." }), jsxRuntimeExports.jsx(Button, { fullWidth: !0, onClick: () => { K.sendMessage({ type: "ShareUrlRequest" }), ye(!0) }, children: "Request Share URL" })] }) }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Text, { children: "Share URL is connected." }), jsxRuntimeExports.jsxs(Stack, { gap: "xs", my: "md", children: [jsxRuntimeExports.jsx(TextInput, { value: me }), jsxRuntimeExports.jsxs(Flex, { justify: "space-between", columnGap: "0.5em", align: "center", children: [jsxRuntimeExports.jsx(CopyButton, { value: me, children: ({ copied: Ce, copy: we }) => jsxRuntimeExports.jsx(Button, { style: { width: "50%" }, leftSection: Ce ? jsxRuntimeExports.jsx(IconCheck, { height: "1.375em", width: "1.375em" }) : jsxRuntimeExports.jsx(IconCopy, { height: "1.375em", width: "1.375em" }), onClick: we, variant: Ce ? "outline" : "filled", children: Ce ? "Copied!" : "Copy URL" }) }), jsxRuntimeExports.jsx(Button, { style: { flexGrow: 1 }, leftSection: be ? jsxRuntimeExports.jsx(IconQrcodeOff, {}) : jsxRuntimeExports.jsx(IconQrcode, {}), onClick: Ae, children: "QR Code" }), jsxRuntimeExports.jsx(Tooltip, { zIndex: 100, label: "Disconnect", withinPortal: !0, children: jsxRuntimeExports.jsx(Button, { color: "red", onClick: () => { K.sendMessage({ type: "ShareUrlDisconnect" }), ge(null) }, children: jsxRuntimeExports.jsx(IconPlugConnectedX, {}) }) })] }), jsxRuntimeExports.jsx(Collapse, { in: be, children: jsxRuntimeExports.jsx(_default, { value: me, fgColor: Se === "dark" ? "#ffffff" : "#000000", bgColor: "rgba(0,0,0,0)", level: "M", style: { width: "100%", height: "auto", margin: "1em auto 0 auto" } }) })] })] }), jsxRuntimeExports.jsxs(Text, { size: "xs", children: ["Share links are experimental and bandwidth-limited. Problems? Consider", " ", jsxRuntimeExports.jsx(Anchor, { href: "https://github.com/nerfstudio-project/viser/issues", children: "reporting on GitHub" }), "."] })] })] }) } var t, e, s, i$1; (function (fe) { fe.HEX = "HEX", fe.RGB = "RGB", fe.HSL = "HSL", fe.CIELab = "CIELab", fe.CMYK = "CMYK" })(t || (t = {})), function (fe) { fe.ANALOGOUS = "ANALOGOUS", fe.COMPLEMENTARY = "COMPLEMENTARY", fe.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", fe.TRIADIC = "TRIADIC", fe.TETRADIC = "TETRADIC", fe.SQUARE = "SQUARE" }(e || (e = {})), function (fe) { fe.ADDITIVE = "ADDITIVE", fe.SUBTRACTIVE = "SUBTRACTIVE" }(s || (s = {})), function (fe) { fe.black = "#000000", fe.silver = "#C0C0C0", fe.gray = "#808080", fe.white = "#FFFFFF", fe.maroon = "#800000", fe.red = "#FF0000", fe.purple = "#800080", fe.fuchsia = "#FF00FF", fe.green = "#008000", fe.lime = "#00FF00", fe.olive = "#808000", fe.yellow = "#FFFF00", fe.navy = "#000080", fe.blue = "#0000FF", fe.teal = "#008080", fe.aqua = "#00FFFF", fe.orange = "#FFA500", fe.aliceblue = "#F0F8FF", fe.antiquewhite = "#FAEBD7", fe.aquamarine = "#7FFFD4", fe.azure = "#F0FFFF", fe.beige = "#F5F5DC", fe.bisque = "#FFE4C4", fe.blanchedalmond = "#FFEBCD", fe.blueviolet = "#8A2BE2", fe.brown = "#A52A2A", fe.burlywood = "#DEB887", fe.cadetblue = "#5F9EA0", fe.chartreuse = "#7FFF00", fe.chocolate = "#D2691E", fe.coral = "#FF7F50", fe.cornflowerblue = "#6495ED", fe.cornsilk = "#FFF8DC", fe.crimson = "#DC143C", fe.cyan = "#00FFFF", fe.darkblue = "#00008B", fe.darkcyan = "#008B8B", fe.darkgoldenrod = "#B8860B", fe.darkgray = "#A9A9A9", fe.darkgreen = "#006400", fe.darkgrey = "#A9A9A9", fe.darkkhaki = "#BDB76B", fe.darkmagenta = "#8B008B", fe.darkolivegreen = "#556B2F", fe.darkorange = "#FF8C00", fe.darkorchid = "#9932CC", fe.darkred = "#8B0000", fe.darksalmon = "#E9967A", fe.darkseagreen = "#8FBC8F", fe.darkslateblue = "#483D8B", fe.darkslategray = "#2F4F4F", fe.darkslategrey = "#2F4F4F", fe.darkturquoise = "#00CED1", fe.darkviolet = "#9400D3", fe.deeppink = "#FF1493", fe.deepskyblue = "#00BFFF", fe.dimgray = "#696969", fe.dimgrey = "#696969", fe.dodgerblue = "#1E90FF", fe.firebrick = "#B22222", fe.floralwhite = "#FFFAF0", fe.forestgreen = "#228B22", fe.gainsboro = "#DCDCDC", fe.ghostwhite = "#F8F8FF", fe.gold = "#FFD700", fe.goldenrod = "#DAA520", fe.greenyellow = "#ADFF2F", fe.grey = "#808080", fe.honeydew = "#F0FFF0", fe.hotpink = "#FF69B4", fe.indianred = "#CD5C5C", fe.indigo = "#4B0082", fe.ivory = "#FFFFF0", fe.khaki = "#F0E68C", fe.lavender = "#E6E6FA", fe.lavenderblush = "#FFF0F5", fe.lawngreen = "#7CFC00", fe.lemonchiffon = "#FFFACD", fe.lightblue = "#ADD8E6", fe.lightcoral = "#F08080", fe.lightcyan = "#E0FFFF", fe.lightgoldenrodyellow = "#FAFAD2", fe.lightgray = "#D3D3D3", fe.lightgreen = "#90EE90", fe.lightgrey = "#D3D3D3", fe.lightpink = "#FFB6C1", fe.lightsalmon = "#FFA07A", fe.lightseagreen = "#20B2AA", fe.lightskyblue = "#87CEFA", fe.lightslategray = "#778899", fe.lightslategrey = "#778899", fe.lightsteelblue = "#B0C4DE", fe.lightyellow = "#FFFFE0", fe.limegreen = "#32CD32", fe.linen = "#FAF0E6", fe.magenta = "#FF00FF", fe.mediumaquamarine = "#66CDAA", fe.mediumblue = "#0000CD", fe.mediumorchid = "#BA55D3", fe.mediumpurple = "#9370DB", fe.mediumseagreen = "#3CB371", fe.mediumslateblue = "#7B68EE", fe.mediumspringgreen = "#00FA9A", fe.mediumturquoise = "#48D1CC", fe.mediumvioletred = "#C71585", fe.midnightblue = "#191970", fe.mintcream = "#F5FFFA", fe.mistyrose = "#FFE4E1", fe.moccasin = "#FFE4B5", fe.navajowhite = "#FFDEAD", fe.oldlace = "#FDF5E6", fe.olivedrab = "#6B8E23", fe.orangered = "#FF4500", fe.orchid = "#DA70D6", fe.palegoldenrod = "#EEE8AA", fe.palegreen = "#98FB98", fe.paleturquoise = "#AFEEEE", fe.palevioletred = "#DB7093", fe.papayawhip = "#FFEFD5", fe.peachpuff = "#FFDAB9", fe.peru = "#CD853F", fe.pink = "#FFC0CB", fe.plum = "#DDA0DD", fe.powderblue = "#B0E0E6", fe.rosybrown = "#BC8F8F", fe.royalblue = "#4169E1", fe.saddlebrown = "#8B4513", fe.salmon = "#FA8072", fe.sandybrown = "#F4A460", fe.seagreen = "#2E8B57", fe.seashell = "#FFF5EE", fe.sienna = "#A0522D", fe.skyblue = "#87CEEB", fe.slateblue = "#6A5ACD", fe.slategray = "#708090", fe.slategrey = "#708090", fe.snow = "#FFFAFA", fe.springgreen = "#00FF7F", fe.steelblue = "#4682B4", fe.tan = "#D2B48C", fe.thistle = "#D8BFD8", fe.tomato = "#FF6347", fe.turquoise = "#40E0D0", fe.violet = "#EE82EE", fe.wheat = "#F5DEB3", fe.whitesmoke = "#F5F5F5", fe.yellowgreen = "#9ACD32", fe.rebeccapurple = "#663399" }(i$1 || (i$1 = {})); const a = Object.keys(i$1), r = { HEX: ["R", "G", "B", "A"], RGB: ["R", "G", "B", "A"], HSL: ["H", "S", "L", "A"], CIELab: ["L", "a", "b", "A"], CMYK: ["C", "M", "Y", "K", "A"] }, n = { BGR: t.RGB, ABGR: t.RGB, HLS: t.HSL, AHLS: t.HSL, LAB: t.CIELab, ALAB: t.CIELab, CKMY: t.CMYK, ACKMY: t.CMYK }; var c; (function (fe) { fe.NUMBER = "number", fe.BOOLEAN = "boolean" })(c || (c = {})); const o = { [t.HEX]: /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, [t.RGB]: /^rgba?\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, [t.HSL]: /^hsla?\s*\(\s*(?:(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*((?:\d*\.)?\d+)%\s*,\s*((?:\d*\.)?\d+)%(?:\s*,\s*((?:\d*\.)?\d+))?|(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*((?:\d*\.)?\d+)%\s*((?:\d*\.)?\d+)%(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, [t.CIELab]: /^lab\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*(-?(?:\d*\.)?\d+%?)\s*(-?(?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, [t.CMYK]: /^(?:device-cmyk|cmyk)\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/ }, A = /^(-?(?:\d*\.)?\d+)((?:deg|grad|rad|turn)?)$/, h = /^(-?\d+(?:\.\d+)?|-?\.\d+)%$/, u = /^0x([a-f\d]{1,2})$/i, d = /\{(\d+)\}/g, m = "The provided string color doesn't have a correct format", b = "The provided color object doesn't have the proper keys or format"; var C, L, g; (function (fe) { fe.NONE = "none", fe.DEGREES = "deg", fe.GRADIANS = "grad", fe.RADIANS = "rad", fe.TURNS = "turn" })(C || (C = {})), function (fe) { fe.NONE = "none", fe.PERCENT = "percent" }(L || (L = {})), function (fe) { fe.DEVICE_CMYK = "device-cmyk", fe.CMYK = "cmyk" }(g || (g = {})); C.NONE, L.NONE, L.NONE, L.PERCENT, L.NONE, g.DEVICE_CMYK; const p = (fe, K) => Object.prototype.hasOwnProperty.call(fe, K), H = fe => +`${fe}`.replace(h, "$1"), F = fe => h.test(`${fe}`) ? H(fe) : Math.min(+fe, 100), R = fe => (fe.length === 1 && (fe += fe), parseInt(fe, 16)), S = fe => { const K = D(fe, 0).toString(16).toUpperCase(); return K.length === 1 ? `0x0${K}` : `0x${K}` }, I = (fe, K = !1) => !K && h.test(fe) ? Math.min(255 * H(fe) / 100, 255) : u.test(fe) ? (fe.length === 3 && (fe += fe.slice(-1)), K ? D(fe) / 255 : D(fe)) : Math.min(+fe, K ? 1 : 255), G = fe => h.test(fe) ? f(125 * H(fe) / 100, -125, 125) : f(+fe, -125, 125), M = fe => Math.min(h.test(fe) ? H(fe) / 100 : +fe, 1), y = fe => [...fe].sort().join("").toUpperCase(), D = (fe, K = 6) => { const pe = Math.pow(10, K); return Math.round(+fe * pe) / pe }, f = (fe, K, pe) => Math.max(K, Math.min(fe, pe)), O = fe => { if (typeof fe == "string") { const K = fe.match(A), pe = +K[1]; switch (K[2]) { case C.RADIANS: fe = D(180 * pe / Math.PI); break; case C.TURNS: fe = D(360 * pe); break; case C.GRADIANS: fe = D(.9 * pe); break; case C.DEGREES: default: fe = pe } } return (fe > 360 || fe < 0) && (fe -= 360 * Math.floor(fe / 360)), fe }, Y = (fe, K) => { let pe; switch (K) { case C.RADIANS: pe = D((me => me * Math.PI / 180)(fe)); break; case C.TURNS: pe = D(fe / 360); break; case C.GRADIANS: pe = D(10 / 9 * fe); break; case C.DEGREES: case C.NONE: default: pe = fe }return pe }, X = [[.4360747, .3850649, .1430804], [.2225045, .7168786, .0606169], [.0139322, .0971045, .7141733]], T = [[3.1338561, -1.6168667, -.4906146], [-.9787684, 1.9161415, .033454], [.0719453, -.2289914, 1.4052427]], N = X.map(fe => fe.reduce((K, pe) => K + pe, 0)), $ = (fe, K, pe) => (pe < 0 && (pe += 6), pe >= 6 && (pe -= 6), D(pe < 1 ? 255 * ((K - fe) * pe + fe) : pe < 3 ? 255 * K : pe < 4 ? 255 * ((K - fe) * (4 - pe) + fe) : 255 * fe)), j = fe => fe <= .04045 ? fe / 12.92 : ((fe + .055) / 1.055) ** 2.4, U = fe => fe <= .0031308 ? 12.92 * fe : 1.055 * fe ** (1 / 2.4) - .055, w = (fe, K, pe, me) => { const ge = [0, 0, 0], xe = [fe, K, pe]; return me.forEach((ye, ve) => { ye.forEach((_e, Ee) => { ge[ve] += _e * xe[Ee] }) }), ge }, x$1 = (fe, K, pe) => { K /= 100; const me = (pe /= 100) <= .5 ? pe * (K + 1) : pe + K - pe * K, ge = 2 * pe - me; return { R: $(ge, me, (fe /= 60) + 2), G: $(ge, me, fe), B: $(ge, me, fe - 2) } }, v = (fe, K, pe, me = 1) => { fe /= 255, K /= 255, pe /= 255, me = Math.min(me, 1); const ge = Math.max(fe, K, pe), xe = Math.min(fe, K, pe), ye = ge - xe; let ve = 0, _e = 0; const Ee = (ge + xe) / 2; if (ye !== 0) { switch (ge) { case fe: ve = (K - pe) / ye % 6; break; case K: ve = (pe - fe) / ye + 2; break; case pe: ve = (fe - K) / ye + 4 }ve = D(60 * ve), ve < 0 && (ve += 360), _e = ye / (1 - Math.abs(2 * Ee - 1)) } return { H: ve, S: D(100 * _e), L: D(100 * Ee), A: me } }, V = (fe, K, pe) => { const me = [fe / 255, K / 255, pe / 255].map(j), ge = w(me[0], me[1], me[2], X), xe = ((ye, ve, _e) => { const Ee = Se => Se > .008856451679035631 ? Math.cbrt(Se) : Se / .12841854934601665 + .13793103448275862, be = Ee(ye / N[0]), Ae = Ee(ve / N[1]); return [116 * Ae - 16, 500 * (be - Ae), 200 * (Ae - Ee(_e / N[2]))] })(ge[0], ge[1], ge[2]); return { L: xe[0], a: xe[1], b: xe[2] } }, P = (fe, K, pe) => { const me = ((xe, ye, ve) => { const _e = Se => Se > .20689655172413793 ? Se ** 3 : .12841854934601665 * (Se - .13793103448275862), Ee = (xe + 16) / 116, be = ye / 500, Ae = ve / 200; return [N[0] * _e(Ee + be), N[1] * _e(Ee), N[2] * _e(Ee - Ae)] })(fe, K, pe), ge = w(me[0], me[1], me[2], T).map(U); return { R: f(255 * ge[0], 0, 255), G: f(255 * ge[1], 0, 255), B: f(255 * ge[2], 0, 255) } }, q = (fe, K, pe, me) => ({ R: D(255 * (1 - fe) * (me = 1 - me)), G: D(255 * (1 - K) * me), B: D(255 * (1 - pe) * me) }), _ = (fe, K, pe) => { fe /= 255, K /= 255, pe /= 255; const me = 1 - Math.max(fe, K, pe), ge = 1 - me, xe = ge && (ge - K) / ge, ye = ge && (ge - pe) / ge; return { C: D(100 * (ge && (ge - fe) / ge)), M: D(100 * xe), Y: D(100 * ye), K: D(100 * me) } }, Q = fe => fe ? ", " : ",", W = (fe, K) => { const pe = y(Object.keys(fe)); return r[n[pe]].reduce((me, ge, xe) => { const ye = fe[ge]; return ye !== void 0 && me.push(K(ye, xe)), me }, []) }, J = (fe, K) => fe.replace(d, (pe, me) => `${K[+me - 1]}`), Z = (fe, K, pe = !1) => { const { alphaUnit: me, legacyCSS: ge, decimals: xe } = K; return me !== L.PERCENT || ge && !pe ? D(fe, xe) : `${D(100 * fe, xe)}%` }, tt = { [t.HEX]: fe => { const K = W(fe, me => (ge => { let xe = D(ge, 0).toString(16).toUpperCase(); return xe.length === 1 && (xe = `0${xe}`), xe })(D(me))), pe = K.length === 4 ? "#{1}{2}{3}{4}" : "#{1}{2}{3}"; return J(pe, K) }, [t.RGB]: (fe, K) => { const { decimals: pe, legacyCSS: me, spacesAfterCommas: ge, rgbUnit: xe } = K, ye = Q(ge), ve = W(fe, (Ee, be) => xe === L.PERCENT && be < 3 ? `${((Ae, Se) => D(Ae / 255 * 100, Se))(Ee, pe)}%` : be === 3 ? Z(Ee, K) : D(Ee, pe)), _e = me ? ve.length === 4 ? `rgba({1}${ye}{2}${ye}{3}${ye}{4})` : `rgb({1}${ye}{2}${ye}{3})` : ve.length === 4 ? "rgb({1} {2} {3} / {4})" : "rgb({1} {2} {3})"; return J(_e, ve) }, [t.HSL]: (fe, K) => { const { decimals: pe, legacyCSS: me, spacesAfterCommas: ge, anglesUnit: xe } = K, ye = Q(ge), ve = W(fe, (Ee, be) => be === 0 && xe !== C.NONE ? `${D(Y(Ee, xe), pe)}${xe}` : be === 3 ? Z(Ee, K) : D(Ee, pe)), _e = me ? ve.length === 4 ? `hsla({1}${ye}{2}%${ye}{3}%${ye}{4})` : `hsl({1}${ye}{2}%${ye}{3}%)` : ve.length === 4 ? "hsl({1} {2}% {3}% / {4})" : "hsl({1} {2}% {3}%)"; return J(_e, ve) }, [t.CIELab]: (fe, K) => { const { decimals: pe, labUnit: me } = K, ge = W(fe, (ye, ve) => { if (ve === 0) { const _e = D(F(ye), pe); return me === L.PERCENT ? `${_e}%` : `${_e}` } return ve < 3 ? me === L.PERCENT ? `${((_e, Ee) => D(_e / 125 * 100, Ee))(ye, pe)}%` : D(ye, pe) : Z(ye, K, !0) }), xe = ge.length === 4 ? "lab({1} {2} {3} / {4})" : "lab({1} {2} {3})"; return J(xe, ge) }, [t.CMYK]: (fe, K) => { const { decimals: pe, legacyCSS: me, spacesAfterCommas: ge, cmykUnit: xe, cmykFunction: ye } = K, ve = Q(ge), _e = W(fe, (be, Ae) => xe === L.PERCENT && Ae < 4 ? `${D(be, pe)}%` : Ae === 4 ? Z(be, K) : D(be / 100, pe)), Ee = me ? _e.length === 5 ? `${ye}({1}${ve}{2}${ve}{3}${ve}{4}${ve}{5})` : `${ye}({1}${ve}{2}${ve}{3}${ve}{4})` : _e.length === 5 ? `${ye}({1} {2} {3} {4} / {5})` : `${ye}({1} {2} {3} {4})`; return J(Ee, _e) } }, et$1 = fe => (typeof fe == "string" && (fe = h.test(fe) ? H(fe) / 100 : +fe), isNaN(+fe) || fe > 1 ? 1 : D(fe)), At = fe => typeof fe == "string" ? (K => { let pe; if (Object.keys(t).some(me => { if (o[me].test(K)) return pe = me, !0 }), !pe && ~a.indexOf(K) && (pe = t.HEX), !pe) throw new Error(m); return pe })(fe) : (K => { let pe, me = !1; const ge = y(Object.keys(K)); if (n[ge] && (pe = n[ge]), pe && pe === t.RGB) { const xe = Object.entries(K).some(ve => !u.test(`${ve[1]}`)), ye = Object.entries(K).some(ve => !(h.test(`${ve[1]}`) || !u.test(`${ve[1]}`) && !isNaN(+ve[1]) && +ve[1] <= 255)); xe && ye && (me = !0), xe || (pe = t.HEX) } if (!pe || me) throw new Error(b); return pe })(fe), ht = { [t.HEX](fe) { const K = (~a.indexOf(fe) ? i$1[fe] : fe).match(o.HEX), pe = { R: R(K[1] || K[5]), G: R(K[2] || K[6]), B: R(K[3] || K[7]) }, me = K[4] || K[8]; return me !== void 0 && (pe.A = R(me) / 255), pe }, [t.RGB](fe) { const K = fe.match(o.RGB), pe = I(K[1] || K[5]), me = I(K[2] || K[6]), ge = I(K[3] || K[7]), xe = K[4] || K[8], ye = { R: Math.min(pe, 255), G: Math.min(me, 255), B: Math.min(ge, 255) }; return xe !== void 0 && (ye.A = et$1(xe)), ye }, [t.HSL](fe) { const K = fe.match(o.HSL), pe = O(K[1] || K[5]), me = F(K[2] || K[6]), ge = F(K[3] || K[7]), xe = K[4] || K[8], ye = x$1(pe, me, ge); return xe !== void 0 && (ye.A = et$1(xe)), ye }, [t.CIELab](fe) { const K = fe.match(o.CIELab), pe = F(K[1]), me = G(K[2]), ge = G(K[3]), xe = K[4], ye = P(pe, me, ge); return xe !== void 0 && (ye.A = et$1(xe)), ye }, [t.CMYK](fe) { const K = fe.match(o.CMYK), pe = M(K[1] || K[6]), me = M(K[2] || K[7]), ge = M(K[3] || K[8]), xe = M(K[4] || K[9]), ye = K[5] || K[10], ve = q(pe, me, ge, xe); return ye !== void 0 && (ve.A = et$1(ye)), ve } }, ut = { [t.HEX](fe) { const K = { R: I(`${fe.R}`), G: I(`${fe.G}`), B: I(`${fe.B}`) }; return p(fe, "A") && (K.A = Math.min(I(`${fe.A}`, !0), 1)), K }, [t.RGB](fe) { return this.HEX(fe) }, [t.HSL](fe) { const K = F(`${fe.S}`), pe = F(`${fe.L}`), me = x$1(O(fe.H), K, pe); return p(fe, "A") && (me.A = et$1(fe.A)), me }, [t.CIELab](fe) { const K = F(`${fe.L}`), pe = G(`${fe.a}`), me = G(`${fe.b}`), ge = P(K, pe, me); return p(fe, "A") && (ge.A = et$1(fe.A)), ge }, [t.CMYK](fe) { const K = M(`${fe.C}`), pe = M(`${fe.M}`), me = M(`${fe.Y}`), ge = M(`${fe.K}`), xe = q(K, pe, me, ge); return p(fe, "A") && (xe.A = et$1(fe.A)), xe } }, dt = (fe, K = At(fe)) => typeof fe == "string" ? ht[K](fe) : ut[K](fe), lt = { [t.HEX]: fe => ({ R: S(fe.R), G: S(fe.G), B: S(fe.B) }), HEXA(fe) { const K = lt.HEX(fe); return K.A = p(fe, "A") ? S(255 * fe.A) : "0xFF", K }, [t.RGB](fe, K) { const pe = Ct(fe, K); return p(pe, "A") && delete pe.A, pe }, RGBA(fe, K) { const pe = lt.RGB(fe, K); return pe.A = p(fe, "A") ? D(fe.A) : 1, pe }, [t.HSL](fe, K) { const pe = v(fe.R, fe.G, fe.B); return delete pe.A, Lt(pe, K) }, HSLA(fe, K) { const pe = lt.HSL(fe, K); return pe.A = p(fe, "A") ? D(fe.A, K) : 1, pe }, [t.CIELab](fe, K) { const pe = V(fe.R, fe.G, fe.B); return gt(pe, K) }, CIELabA(fe, K) { const pe = lt.CIELab(fe, K); return pe.A = p(fe, "A") ? D(fe.A, K) : 1, pe }, [t.CMYK]: (fe, K) => Bt(_(fe.R, fe.G, fe.B), K), CMYKA(fe, K) { const pe = lt.CMYK(fe, K); return pe.A = p(fe, "A") ? D(fe.A, K) : 1, pe } }; t.HEX + "", t.RGB + "", t.HSL + "", t.CIELab + ""; t.HEX + "", t.RGB + "", t.HSL + "", t.CIELab + ""; const Ct = (fe, K) => ({ R: D(fe.R, K), G: D(fe.G, K), B: D(fe.B, K), ...p(fe, "A") ? { A: D(fe.A, K) } : {} }), Lt = (fe, K) => ({ H: D(fe.H, K), S: D(fe.S, K), L: D(fe.L, K), ...p(fe, "A") ? { A: D(fe.A, K) } : {} }), gt = (fe, K) => ({ L: D(fe.L, K), a: D(fe.a, K), b: D(fe.b, K) }), Bt = (fe, K) => ({ C: D(fe.C, K), M: D(fe.M, K), Y: D(fe.Y, K), K: D(fe.K, K) }); var NOTHING = Symbol.for("immer-nothing"), DRAFTABLE = Symbol.for("immer-draftable"), DRAFT_STATE = Symbol.for("immer-state"); function die(fe, ...K) { throw new Error(`[Immer] minified error nr: ${fe}. Full error at: https://bit.ly/3cXEKWf`) } var getPrototypeOf = Object.getPrototypeOf; function isDraft(fe) { return !!fe && !!fe[DRAFT_STATE] } function isDraftable(fe) { return fe ? isPlainObject(fe) || Array.isArray(fe) || !!fe[DRAFTABLE] || !!fe.constructor?.[DRAFTABLE] || isMap(fe) || isSet(fe) : !1 } var objectCtorString = Object.prototype.constructor.toString(); function isPlainObject(fe) { if (!fe || typeof fe != "object") return !1; const K = getPrototypeOf(fe); if (K === null) return !0; const pe = Object.hasOwnProperty.call(K, "constructor") && K.constructor; return pe === Object ? !0 : typeof pe == "function" && Function.toString.call(pe) === objectCtorString } function each(fe, K) { getArchtype(fe) === 0 ? Reflect.ownKeys(fe).forEach(pe => { K(pe, fe[pe], fe) }) : fe.forEach((pe, me) => K(me, pe, fe)) } function getArchtype(fe) { const K = fe[DRAFT_STATE]; return K ? K.type_ : Array.isArray(fe) ? 1 : isMap(fe) ? 2 : isSet(fe) ? 3 : 0 } function has(fe, K) { return getArchtype(fe) === 2 ? fe.has(K) : Object.prototype.hasOwnProperty.call(fe, K) } function set(fe, K, pe) { const me = getArchtype(fe); me === 2 ? fe.set(K, pe) : me === 3 ? fe.add(pe) : fe[K] = pe } function is(fe, K) { return fe === K ? fe !== 0 || 1 / fe === 1 / K : fe !== fe && K !== K } function isMap(fe) { return fe instanceof Map } function isSet(fe) { return fe instanceof Set } function latest(fe) { return fe.copy_ || fe.base_ } function shallowCopy(fe, K) { if (isMap(fe)) return new Map(fe); if (isSet(fe)) return new Set(fe); if (Array.isArray(fe)) return Array.prototype.slice.call(fe); const pe = isPlainObject(fe); if (K === !0 || K === "class_only" && !pe) { const me = Object.getOwnPropertyDescriptors(fe); delete me[DRAFT_STATE]; let ge = Reflect.ownKeys(me); for (let xe = 0; xe < ge.length; xe++) { const ye = ge[xe], ve = me[ye]; ve.writable === !1 && (ve.writable = !0, ve.configurable = !0), (ve.get || ve.set) && (me[ye] = { configurable: !0, writable: !0, enumerable: ve.enumerable, value: fe[ye] }) } return Object.create(getPrototypeOf(fe), me) } else { const me = getPrototypeOf(fe); if (me !== null && pe) return { ...fe }; const ge = Object.create(me); return Object.assign(ge, fe) } } function freeze(fe, K = !1) { return isFrozen(fe) || isDraft(fe) || !isDraftable(fe) || (getArchtype(fe) > 1 && (fe.set = fe.add = fe.clear = fe.delete = dontMutateFrozenCollections), Object.freeze(fe), K && Object.entries(fe).forEach(([pe, me]) => freeze(me, !0))), fe } function dontMutateFrozenCollections() { die(2) } function isFrozen(fe) { return Object.isFrozen(fe) } var plugins = {}; function getPlugin(fe) { const K = plugins[fe]; return K || die(0, fe), K } function loadPlugin(fe, K) { plugins[fe] || (plugins[fe] = K) } var currentScope; function getCurrentScope() { return currentScope } function createScope(fe, K) { return { drafts_: [], parent_: fe, immer_: K, canAutoFreeze_: !0, unfinalizedDrafts_: 0 } } function usePatchesInScope(fe, K) { K && (getPlugin("Patches"), fe.patches_ = [], fe.inversePatches_ = [], fe.patchListener_ = K) } function revokeScope(fe) { leaveScope(fe), fe.drafts_.forEach(revokeDraft), fe.drafts_ = null } function leaveScope(fe) { fe === currentScope && (currentScope = fe.parent_) } function enterScope(fe) { return currentScope = createScope(currentScope, fe) } function revokeDraft(fe) { const K = fe[DRAFT_STATE]; K.type_ === 0 || K.type_ === 1 ? K.revoke_() : K.revoked_ = !0 } function processResult(fe, K) { K.unfinalizedDrafts_ = K.drafts_.length; const pe = K.drafts_[0]; return fe !== void 0 && fe !== pe ? (pe[DRAFT_STATE].modified_ && (revokeScope(K), die(4)), isDraftable(fe) && (fe = finalize(K, fe), K.parent_ || maybeFreeze(K, fe)), K.patches_ && getPlugin("Patches").generateReplacementPatches_(pe[DRAFT_STATE].base_, fe, K.patches_, K.inversePatches_)) : fe = finalize(K, pe, []), revokeScope(K), K.patches_ && K.patchListener_(K.patches_, K.inversePatches_), fe !== NOTHING ? fe : void 0 } function finalize(fe, K, pe) { if (isFrozen(K)) return K; const me = K[DRAFT_STATE]; if (!me) return each(K, (ge, xe) => finalizeProperty(fe, me, K, ge, xe, pe)), K; if (me.scope_ !== fe) return K; if (!me.modified_) return maybeFreeze(fe, me.base_, !0), me.base_; if (!me.finalized_) { me.finalized_ = !0, me.scope_.unfinalizedDrafts_--; const ge = me.copy_; let xe = ge, ye = !1; me.type_ === 3 && (xe = new Set(ge), ge.clear(), ye = !0), each(xe, (ve, _e) => finalizeProperty(fe, me, ge, ve, _e, pe, ye)), maybeFreeze(fe, ge, !1), pe && fe.patches_ && getPlugin("Patches").generatePatches_(me, pe, fe.patches_, fe.inversePatches_) } return me.copy_ } function finalizeProperty(fe, K, pe, me, ge, xe, ye) { if (isDraft(ge)) { const ve = xe && K && K.type_ !== 3 && !has(K.assigned_, me) ? xe.concat(me) : void 0, _e = finalize(fe, ge, ve); if (set(pe, me, _e), isDraft(_e)) fe.canAutoFreeze_ = !1; else return } else ye && pe.add(ge); if (isDraftable(ge) && !isFrozen(ge)) { if (!fe.immer_.autoFreeze_ && fe.unfinalizedDrafts_ < 1) return; finalize(fe, ge), (!K || !K.scope_.parent_) && typeof me != "symbol" && Object.prototype.propertyIsEnumerable.call(pe, me) && maybeFreeze(fe, ge) } } function maybeFreeze(fe, K, pe = !1) { !fe.parent_ && fe.immer_.autoFreeze_ && fe.canAutoFreeze_ && freeze(K, pe) } function createProxyProxy(fe, K) { const pe = Array.isArray(fe), me = { type_: pe ? 1 : 0, scope_: K ? K.scope_ : getCurrentScope(), modified_: !1, finalized_: !1, assigned_: {}, parent_: K, base_: fe, draft_: null, copy_: null, revoke_: null, isManual_: !1 }; let ge = me, xe = objectTraps; pe && (ge = [me], xe = arrayTraps); const { revoke: ye, proxy: ve } = Proxy.revocable(ge, xe); return me.draft_ = ve, me.revoke_ = ye, ve } var objectTraps = { get(fe, K) { if (K === DRAFT_STATE) return fe; const pe = latest(fe); if (!has(pe, K)) return readPropFromProto(fe, pe, K); const me = pe[K]; return fe.finalized_ || !isDraftable(me) ? me : me === peek(fe.base_, K) ? (prepareCopy(fe), fe.copy_[K] = createProxy(me, fe)) : me }, has(fe, K) { return K in latest(fe) }, ownKeys(fe) { return Reflect.ownKeys(latest(fe)) }, set(fe, K, pe) { const me = getDescriptorFromProto(latest(fe), K); if (me?.set) return me.set.call(fe.draft_, pe), !0; if (!fe.modified_) { const ge = peek(latest(fe), K), xe = ge?.[DRAFT_STATE]; if (xe && xe.base_ === pe) return fe.copy_[K] = pe, fe.assigned_[K] = !1, !0; if (is(pe, ge) && (pe !== void 0 || has(fe.base_, K))) return !0; prepareCopy(fe), markChanged(fe) } return fe.copy_[K] === pe && (pe !== void 0 || K in fe.copy_) || Number.isNaN(pe) && Number.isNaN(fe.copy_[K]) || (fe.copy_[K] = pe, fe.assigned_[K] = !0), !0 }, deleteProperty(fe, K) { return peek(fe.base_, K) !== void 0 || K in fe.base_ ? (fe.assigned_[K] = !1, prepareCopy(fe), markChanged(fe)) : delete fe.assigned_[K], fe.copy_ && delete fe.copy_[K], !0 }, getOwnPropertyDescriptor(fe, K) { const pe = latest(fe), me = Reflect.getOwnPropertyDescriptor(pe, K); return me && { writable: !0, configurable: fe.type_ !== 1 || K !== "length", enumerable: me.enumerable, value: pe[K] } }, defineProperty() { die(11) }, getPrototypeOf(fe) { return getPrototypeOf(fe.base_) }, setPrototypeOf() { die(12) } }, arrayTraps = {}; each(objectTraps, (fe, K) => { arrayTraps[fe] = function () { return arguments[0] = arguments[0][0], K.apply(this, arguments) } }); arrayTraps.deleteProperty = function (fe, K) { return arrayTraps.set.call(this, fe, K, void 0) }; arrayTraps.set = function (fe, K, pe) { return objectTraps.set.call(this, fe[0], K, pe, fe[0]) }; function peek(fe, K) { const pe = fe[DRAFT_STATE]; return (pe ? latest(pe) : fe)[K] } function readPropFromProto(fe, K, pe) { const me = getDescriptorFromProto(K, pe); return me ? "value" in me ? me.value : me.get?.call(fe.draft_) : void 0 } function getDescriptorFromProto(fe, K) { if (!(K in fe)) return; let pe = getPrototypeOf(fe); for (; pe;) { const me = Object.getOwnPropertyDescriptor(pe, K); if (me) return me; pe = getPrototypeOf(pe) } } function markChanged(fe) { fe.modified_ || (fe.modified_ = !0, fe.parent_ && markChanged(fe.parent_)) } function prepareCopy(fe) { fe.copy_ || (fe.copy_ = shallowCopy(fe.base_, fe.scope_.immer_.useStrictShallowCopy_)) } var Immer2 = class { constructor(fe) { this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (K, pe, me) => { if (typeof K == "function" && typeof pe != "function") { const xe = pe; pe = K; const ye = this; return function (_e = xe, ...Ee) { return ye.produce(_e, be => pe.call(this, be, ...Ee)) } } typeof pe != "function" && die(6), me !== void 0 && typeof me != "function" && die(7); let ge; if (isDraftable(K)) { const xe = enterScope(this), ye = createProxy(K, void 0); let ve = !0; try { ge = pe(ye), ve = !1 } finally { ve ? revokeScope(xe) : leaveScope(xe) } return usePatchesInScope(xe, me), processResult(ge, xe) } else if (!K || typeof K != "object") { if (ge = pe(K), ge === void 0 && (ge = K), ge === NOTHING && (ge = void 0), this.autoFreeze_ && freeze(ge, !0), me) { const xe = [], ye = []; getPlugin("Patches").generateReplacementPatches_(K, ge, xe, ye), me(xe, ye) } return ge } else die(1, K) }, this.produceWithPatches = (K, pe) => { if (typeof K == "function") return (ye, ...ve) => this.produceWithPatches(ye, _e => K(_e, ...ve)); let me, ge; return [this.produce(K, pe, (ye, ve) => { me = ye, ge = ve }), me, ge] }, typeof fe?.autoFreeze == "boolean" && this.setAutoFreeze(fe.autoFreeze), typeof fe?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(fe.useStrictShallowCopy) } createDraft(fe) { isDraftable(fe) || die(8), isDraft(fe) && (fe = current(fe)); const K = enterScope(this), pe = createProxy(fe, void 0); return pe[DRAFT_STATE].isManual_ = !0, leaveScope(K), pe } finishDraft(fe, K) { const pe = fe && fe[DRAFT_STATE]; (!pe || !pe.isManual_) && die(9); const { scope_: me } = pe; return usePatchesInScope(me, K), processResult(void 0, me) } setAutoFreeze(fe) { this.autoFreeze_ = fe } setUseStrictShallowCopy(fe) { this.useStrictShallowCopy_ = fe } applyPatches(fe, K) { let pe; for (pe = K.length - 1; pe >= 0; pe--) { const ge = K[pe]; if (ge.path.length === 0 && ge.op === "replace") { fe = ge.value; break } } pe > -1 && (K = K.slice(pe + 1)); const me = getPlugin("Patches").applyPatches_; return isDraft(fe) ? me(fe, K) : this.produce(fe, ge => me(ge, K)) } }; function createProxy(fe, K) { const pe = isMap(fe) ? getPlugin("MapSet").proxyMap_(fe, K) : isSet(fe) ? getPlugin("MapSet").proxySet_(fe, K) : createProxyProxy(fe, K); return (K ? K.scope_ : getCurrentScope()).drafts_.push(pe), pe } function current(fe) { return isDraft(fe) || die(10, fe), currentImpl(fe) } function currentImpl(fe) { if (!isDraftable(fe) || isFrozen(fe)) return fe; const K = fe[DRAFT_STATE]; let pe; if (K) { if (!K.modified_) return K.base_; K.finalized_ = !0, pe = shallowCopy(fe, K.scope_.immer_.useStrictShallowCopy_) } else pe = shallowCopy(fe, !0); return each(pe, (me, ge) => { set(pe, me, currentImpl(ge)) }), K && (K.finalized_ = !1), pe } function enableMapSet() { class fe extends Map { constructor(_e, Ee) { super(), this[DRAFT_STATE] = { type_: 2, parent_: Ee, scope_: Ee ? Ee.scope_ : getCurrentScope(), modified_: !1, finalized_: !1, copy_: void 0, assigned_: void 0, base_: _e, draft_: this, isManual_: !1, revoked_: !1 } } get size() { return latest(this[DRAFT_STATE]).size } has(_e) { return latest(this[DRAFT_STATE]).has(_e) } set(_e, Ee) { const be = this[DRAFT_STATE]; return ye(be), (!latest(be).has(_e) || latest(be).get(_e) !== Ee) && (pe(be), markChanged(be), be.assigned_.set(_e, !0), be.copy_.set(_e, Ee), be.assigned_.set(_e, !0)), this } delete(_e) { if (!this.has(_e)) return !1; const Ee = this[DRAFT_STATE]; return ye(Ee), pe(Ee), markChanged(Ee), Ee.base_.has(_e) ? Ee.assigned_.set(_e, !1) : Ee.assigned_.delete(_e), Ee.copy_.delete(_e), !0 } clear() { const _e = this[DRAFT_STATE]; ye(_e), latest(_e).size && (pe(_e), markChanged(_e), _e.assigned_ = new Map, each(_e.base_, Ee => { _e.assigned_.set(Ee, !1) }), _e.copy_.clear()) } forEach(_e, Ee) { const be = this[DRAFT_STATE]; latest(be).forEach((Ae, Se, Ce) => { _e.call(Ee, this.get(Se), Se, this) }) } get(_e) { const Ee = this[DRAFT_STATE]; ye(Ee); const be = latest(Ee).get(_e); if (Ee.finalized_ || !isDraftable(be) || be !== Ee.base_.get(_e)) return be; const Ae = createProxy(be, Ee); return pe(Ee), Ee.copy_.set(_e, Ae), Ae } keys() { return latest(this[DRAFT_STATE]).keys() } values() { const _e = this.keys(); return { [Symbol.iterator]: () => this.values(), next: () => { const Ee = _e.next(); return Ee.done ? Ee : { done: !1, value: this.get(Ee.value) } } } } entries() { const _e = this.keys(); return { [Symbol.iterator]: () => this.entries(), next: () => { const Ee = _e.next(); if (Ee.done) return Ee; const be = this.get(Ee.value); return { done: !1, value: [Ee.value, be] } } } } [Symbol.iterator]() { return this.entries() } } function K(ve, _e) { return new fe(ve, _e) } function pe(ve) { ve.copy_ || (ve.assigned_ = new Map, ve.copy_ = new Map(ve.base_)) } class me extends Set { constructor(_e, Ee) { super(), this[DRAFT_STATE] = { type_: 3, parent_: Ee, scope_: Ee ? Ee.scope_ : getCurrentScope(), modified_: !1, finalized_: !1, copy_: void 0, base_: _e, draft_: this, drafts_: new Map, revoked_: !1, isManual_: !1 } } get size() { return latest(this[DRAFT_STATE]).size } has(_e) { const Ee = this[DRAFT_STATE]; return ye(Ee), Ee.copy_ ? !!(Ee.copy_.has(_e) || Ee.drafts_.has(_e) && Ee.copy_.has(Ee.drafts_.get(_e))) : Ee.base_.has(_e) } add(_e) { const Ee = this[DRAFT_STATE]; return ye(Ee), this.has(_e) || (xe(Ee), markChanged(Ee), Ee.copy_.add(_e)), this } delete(_e) { if (!this.has(_e)) return !1; const Ee = this[DRAFT_STATE]; return ye(Ee), xe(Ee), markChanged(Ee), Ee.copy_.delete(_e) || (Ee.drafts_.has(_e) ? Ee.copy_.delete(Ee.drafts_.get(_e)) : !1) } clear() { const _e = this[DRAFT_STATE]; ye(_e), latest(_e).size && (xe(_e), markChanged(_e), _e.copy_.clear()) } values() { const _e = this[DRAFT_STATE]; return ye(_e), xe(_e), _e.copy_.values() } entries() { const _e = this[DRAFT_STATE]; return ye(_e), xe(_e), _e.copy_.entries() } keys() { return this.values() } [Symbol.iterator]() { return this.values() } forEach(_e, Ee) { const be = this.values(); let Ae = be.next(); for (; !Ae.done;)_e.call(Ee, Ae.value, Ae.value, this), Ae = be.next() } } function ge(ve, _e) { return new me(ve, _e) } function xe(ve) { ve.copy_ || (ve.copy_ = new Set, ve.base_.forEach(_e => { if (isDraftable(_e)) { const Ee = createProxy(_e, ve); ve.drafts_.set(_e, Ee), ve.copy_.add(Ee) } else ve.copy_.add(_e) })) } function ye(ve) { ve.revoked_ && die(3, JSON.stringify(latest(ve))) } loadPlugin("MapSet", { proxyMap_: K, proxySet_: ge }) } var immer$1 = new Immer2, produce = immer$1.produce; immer$1.produceWithPatches.bind(immer$1); immer$1.setAutoFreeze.bind(immer$1); immer$1.setUseStrictShallowCopy.bind(immer$1); immer$1.applyPatches.bind(immer$1); immer$1.createDraft.bind(immer$1); immer$1.finishDraft.bind(immer$1); const immerImpl = fe => (K, pe, me) => (me.setState = (ge, xe, ...ye) => { const ve = typeof ge == "function" ? produce(ge) : ge; return K(ve, xe, ...ye) }, fe(me.setState, pe, me)), immer = immerImpl, cleanGuiState = { theme: { type: "ThemeConfigurationMessage", titlebar_content: null, control_layout: "floating", control_width: "medium", dark_mode: !1, show_logo: !0, show_share_button: !0, colors: null }, label: "", server: "ws://localhost:8080", shareUrl: null, websocketConnected: !1, backgroundAvailable: !1, showOrbitOriginTool: !1, guiUuidSetFromContainerUuid: {}, modals: [], guiOrderFromUuid: {}, guiConfigFromUuid: {}, uploadsInProgress: {} }; function useGuiState(fe) { return React$4.useState(() => create$3(immer(K => ({ ...cleanGuiState, server: fe, setTheme: pe => K(me => { me.theme = pe }), setShareUrl: pe => K(me => { me.shareUrl = pe }), addGui: pe => K(me => { me.guiOrderFromUuid[pe.uuid] = pe.props.order, me.guiConfigFromUuid[pe.uuid] = pe, pe.container_uuid in me.guiUuidSetFromContainerUuid || (me.guiUuidSetFromContainerUuid[pe.container_uuid] = {}), me.guiUuidSetFromContainerUuid[pe.container_uuid][pe.uuid] = !0 }), addModal: pe => K(me => { me.modals.push(pe) }), removeModal: pe => K(me => { me.modals = me.modals.filter(ge => ge.uuid !== pe) }), removeGui: pe => K(me => { const ge = me.guiConfigFromUuid[pe]; if (ge == null) { console.warn("(OK) Tried to remove non-existent component", pe); return } delete me.guiUuidSetFromContainerUuid[ge.container_uuid][pe], delete me.guiOrderFromUuid[pe], delete me.guiConfigFromUuid[pe], Object.keys(me.guiUuidSetFromContainerUuid[ge.container_uuid]).length == 0 && delete me.guiUuidSetFromContainerUuid[ge.container_uuid] }), resetGui: () => K(pe => { pe.shareUrl = cleanGuiState.shareUrl, pe.guiUuidSetFromContainerUuid = cleanGuiState.guiUuidSetFromContainerUuid, pe.modals = cleanGuiState.modals, pe.guiOrderFromUuid = cleanGuiState.guiOrderFromUuid, pe.guiConfigFromUuid = cleanGuiState.guiConfigFromUuid, pe.uploadsInProgress = cleanGuiState.uploadsInProgress }), updateUploadState: pe => K(me => { const { componentId: ge, ...xe } = pe; me.uploadsInProgress[ge] = { ...me.uploadsInProgress[ge], ...xe } }), updateGuiProps: (pe, me) => { K(ge => { const xe = ge.guiConfigFromUuid[pe]; if (xe === void 0) { console.error(`Tried to update non-existent component '${pe}' with`, me); return } for (const [ye, ve] of Object.entries(me)) ye === "value" ? ge.guiConfigFromUuid[pe].value = ve : ye in xe.props ? xe.props[ye] = ve : console.error(`Tried to update nonexistent property '${ye}' of GUI element ${pe}!`) }) } }))))[0] } const searchParamKey = "websocket"; function syncSearchParamServer(fe) { const K = new URLSearchParams(window.location.search), pe = window.location.host.includes(fe.replace("ws://", "").replace("/", "")) || window.location.host.includes(fe.replace("wss://", "").replace("/", "")); pe && K.has(searchParamKey) ? K.delete(searchParamKey) : pe || K.set(searchParamKey, fe), window.history.replaceState(null, "Viser", K.size === 0 ? window.location.href.split("?")[0] : "?" + Array.from(K.entries()).map(([me, ge]) => `${me}=${ge}`).join("&")) } function WorkerWrapper(fe) { return new Worker("" + new URL("WebsocketServerWorker-DxUc0rA2.js", import.meta.url).href, { type: "module", name: fe?.name }) } function WebsocketMessageProducer() { const fe = reactExports.useContext(ViewerContext), K = fe.mutable.current, pe = fe.useGui(xe => xe.server), me = fe.useGui(xe => xe.resetGui), ge = fe.useSceneTree(xe => xe.resetScene); return syncSearchParamServer(pe), React$4.useEffect(() => { const xe = new WorkerWrapper; xe.onmessage = ve => { const _e = ve.data; _e.type === "connected" ? (me(), ge(), fe.useGui.setState({ websocketConnected: !0 }), K.sendMessage = Ee => { ye({ type: "send", message: Ee }) }) : _e.type === "closed" ? (me(), fe.useGui.setState({ websocketConnected: !1 }), K.sendMessage = Ee => { console.log(`Tried to send ${Ee.type} but websocket is not connected!`) }, _e.versionMismatch && notifications.show({ id: "version-mismatch", title: "Connection rejected", message: `${_e.closeReason}.`, color: "red", autoClose: 5e3, withCloseButton: !0 })) : _e.type === "message_batch" && K.messageQueue.push(..._e.messages) }; function ye(ve) { xe.postMessage(ve) } return ye({ type: "set_server", server: pe }), () => { ye({ type: "close" }), K.sendMessage = ve => console.log(`Tried to send ${ve.type} but websocket is not connected!`), fe.useGui.setState({ websocketConnected: !1 }) } }, [pe, me, ge]), null } function assertUnreachable(fe) { throw new Error("Didn't expect to get here", fe) } function getIcon(fe) { let K = null; switch (fe) { case null: break; case "GitHub": K = IconBrandGithub; break; case "Description": K = IconFileDescription; break; case "Keyboard": K = IconKeyboard; break; default: assertUnreachable(fe) }return K } function TitlebarButton(fe) { const K = getIcon(fe.icon); return jsxRuntimeExports.jsx(Button, { component: "a", variant: "default", size: "compact-sm", href: fe.href || void 0, target: "_blank", leftSection: K === null ? null : jsxRuntimeExports.jsx(K, { size: "1em" }), ml: "xs", color: "gray", children: fe.text }) } function MobileTitlebarButton(fe) { const K = getIcon(fe.icon); return jsxRuntimeExports.jsx(Button, { m: "sm", component: "a", variant: "default", href: fe.href || void 0, target: "_blank", leftSection: K === null ? null : jsxRuntimeExports.jsx(K, { size: "1.5em" }), ml: "sm", color: "gray", children: fe.text }) } function TitlebarImage(fe, K) { let pe; fe.image_url_dark == null || K === "light" ? pe = fe.image_url_light : pe = fe.image_url_dark; const me = jsxRuntimeExports.jsx("img", { src: pe, alt: fe.image_alt, style: { height: "1.8em", margin: "0 0.5em" } }); return fe.href == null ? me : jsxRuntimeExports.jsx("a", { style: { display: "block", height: "1.8em" }, href: fe.href, children: me }) } function Titlebar() { const K = reactExports.useContext(ViewerContext).useGui(ve => ve.theme.titlebar_content), pe = useMantineColorScheme().colorScheme, [me, ge] = useDisclosure(!1); if (K == null) return null; const xe = K.buttons, ye = K.image; return jsxRuntimeExports.jsx(Box, { style: { height: "3.2em", margin: 0, border: "0", zIndex: 10 }, children: jsxRuntimeExports.jsxs(Paper, { shadow: "0 0 0.8em 0 rgba(0,0,0,0.1)", style: { height: "100%" }, children: [jsxRuntimeExports.jsxs(Container, { fluid: !0, style: () => ({ height: "100%", display: "flex", alignItems: "center" }), children: [jsxRuntimeExports.jsx(Group$1, { style: () => ({ marginRight: "auto" }), children: ye !== null ? TitlebarImage(ye, pe) : null }), jsxRuntimeExports.jsx(Group$1, { display: { base: "none", xs: "flex" }, style: () => ({ flexWrap: "nowrap", overflowX: "scroll", msOverflowStyle: "none", scrollbarWidth: "none" }), children: xe?.map((ve, _e) => reactExports.createElement(TitlebarButton, { ...ve, key: _e })) }), jsxRuntimeExports.jsx(Burger, { size: "sm", opened: me, onClick: ge.toggle, title: me ? "Close navigation" : "Open navigation", display: { base: "block", xs: "none" } })] }), jsxRuntimeExports.jsx(Portal$1, { children: jsxRuntimeExports.jsx(Paper, { display: { base: "flex", xs: "none" }, radius: "0", style: { flexDirection: "column", position: "absolute", top: "3.2em", zIndex: 2e3, height: me ? "calc(100vh - 2.375em)" : "0", width: "100vw", transition: "all 0.5s", overflow: me ? "scroll" : "hidden", padding: me ? "1rem" : "0" }, children: xe?.map((ve, _e) => reactExports.createElement(MobileTitlebarButton, { ...ve, key: _e })) }) })] }) }) } function ViserModal() { return reactExports.useContext(ViewerContext).useGui(me => me.modals).map((me, ge) => jsxRuntimeExports.jsx(GeneratedModal, { conf: me, index: ge }, me.uuid)) } function GeneratedModal({ conf: fe, index: K }) { return jsxRuntimeExports.jsx(Modal, { opened: !0, title: fe.title, onClose: () => { }, withCloseButton: !1, centered: !0, zIndex: 100 + K, children: jsxRuntimeExports.jsx(GeneratedGuiContainer, { containerUuid: fe.uuid }) }) } const rootNodeTemplate = { message: { type: "FrameMessage", name: "", props: { show_axes: !1, axes_length: .5, axes_radius: .0125, origin_radius: .025, origin_color: [236, 236, 0] } }, children: ["/WorldAxes"], clickable: !1 }, worldAxesNodeTemplate = { message: { type: "FrameMessage", name: "/WorldAxes", props: { show_axes: !0, axes_length: .5, axes_radius: .0125, origin_radius: .025, origin_color: [236, 236, 0] } }, children: [], clickable: !1 }; function useSceneTreeState(fe) { return React$4.useState(() => create$3(immer(K => ({ nodeFromName: { "": rootNodeTemplate, "/WorldAxes": worldAxesNodeTemplate }, nodeAttributesFromName: { "": { wxyz: (() => { const pe = new Quaternion().setFromEuler(new Euler(Math.PI / 2, Math.PI, -Math.PI / 2)); return [pe.w, pe.x, pe.y, pe.z] })() } }, labelVisibleFromName: {}, enableDefaultLights: !0, enableDefaultLightsShadows: !0, environmentMap: { type: "EnvironmentMapMessage", hdri: "city", background: !1, background_blurriness: 0, background_intensity: 1, background_wxyz: [1, 0, 0, 0], environment_intensity: 1, environment_wxyz: [1, 0, 0, 0] }, setClickable: (pe, me) => K(ge => { const xe = ge.nodeFromName[pe]; xe !== void 0 && (xe.clickable = me) }), addSceneNode: pe => K(me => { const ge = me.nodeFromName[pe.name]; if (ge !== void 0) delete fe[pe.name], me.nodeFromName[pe.name] = { ...ge, message: pe }; else { const xe = pe.name.split("/").slice(0, -1).join("/"); me.nodeFromName[pe.name] = { message: pe, children: [], clickable: !1 }, me.nodeFromName[xe].children.push(pe.name) } }), removeSceneNode: pe => K(me => { const ge = []; function xe(ve) { ge.push(ve), me.nodeFromName[ve].children.forEach(xe) } xe(pe), ge.forEach(ve => { delete me.nodeFromName[ve], delete fe[ve] }); const ye = pe.split("/").slice(0, -1).join("/"); me.nodeFromName[ye].children = me.nodeFromName[ye].children.filter(ve => ve !== pe) }), updateSceneNode: (pe, me) => K(ge => { if (ge.nodeFromName[pe] === void 0) { console.error(`Attempted to update non-existent node ${pe} with updates:`, me); return } ge.nodeFromName[pe].message.props = { ...ge.nodeFromName[pe].message.props, ...me } }), resetScene: () => K(pe => { for (const ge of Object.keys(pe.nodeFromName)) ge !== "" && ge !== "/WorldAxes" && delete pe.nodeFromName[ge]; pe.nodeFromName[""] = rootNodeTemplate, pe.nodeFromName["/WorldAxes"] = worldAxesNodeTemplate; const me = pe.nodeAttributesFromName[""]; pe.nodeAttributesFromName = me ? { "": me } : {} }), setLabelVisibility: (pe, me) => K(ge => { ge.labelVisibleFromName[pe] = me }), updateNodeAttributes: (pe, me) => K(ge => { me === void 0 ? delete ge.nodeAttributesFromName[pe] : (ge.nodeAttributesFromName[pe] || (ge.nodeAttributesFromName[pe] = {}), ge.nodeAttributesFromName[pe] = { ...ge.nodeAttributesFromName[pe], ...me }) }) }))))[0] } function getSizesVariables(fe, K, pe) { return Object.keys(fe[K]).reduce((me, ge) => (me[ge] = `var(--mantine-${pe}-${ge})`, me), {}) } function getBreakpointValue(fe, K) { return fe in K.breakpoints ? K.breakpoints[fe] : em(fe) } function themeToVars(fe) { const K = mergeMantineTheme(DEFAULT_THEME, fe), pe = getSizesVariables(K, "fontSizes", "font-size"), me = getSizesVariables(K, "lineHeights", "line-height"), ge = getSizesVariables(K, "shadows", "shadow"), xe = getSizesVariables(K, "radius", "radius"), ye = getSizesVariables(K, "spacing", "spacing"), ve = Object.keys(K.headings.sizes).reduce((Ee, be) => (Ee[be] = { fontSize: `var(--mantine-${be}-font-size)`, lineHeight: `var(--mantine-${be}-line-height)`, fontWeight: `var(--mantine-${be}-font-weight)` }, Ee), {}), _e = Object.keys(K.colors).reduce((Ee, be) => (Ee[be] = { 0: `var(--mantine-color-${be}-0)`, 1: `var(--mantine-color-${be}-1)`, 2: `var(--mantine-color-${be}-2)`, 3: `var(--mantine-color-${be}-3)`, 4: `var(--mantine-color-${be}-4)`, 5: `var(--mantine-color-${be}-5)`, 6: `var(--mantine-color-${be}-6)`, 7: `var(--mantine-color-${be}-7)`, 8: `var(--mantine-color-${be}-8)`, 9: `var(--mantine-color-${be}-9)`, filled: `var(--mantine-color-${be}-filled)`, filledHover: `var(--mantine-color-${be}-filled-hover)`, light: `var(--mantine-color-${be}-light)`, lightHover: `var(--mantine-color-${be}-light-hover)`, lightColor: `var(--mantine-color-${be}-light-color)`, outline: `var(--mantine-color-${be}-outline)`, outlineHover: `var(--mantine-color-${be}-outline-hover)` }, Ee), { primary: "var(--mantine-primary-color-filled)", primaryColors: { 0: "var(--mantine-primary-color-0)", 1: "var(--mantine-primary-color-1)", 2: "var(--mantine-primary-color-2)", 3: "var(--mantine-primary-color-3)", 4: "var(--mantine-primary-color-4)", 5: "var(--mantine-primary-color-5)", 6: "var(--mantine-primary-color-6)", 7: "var(--mantine-primary-color-7)", 8: "var(--mantine-primary-color-8)", 9: "var(--mantine-primary-color-9)", filled: "var(--mantine-primary-color-filled)", filledHover: "var(--mantine-primary-color-filled-hover)", light: "var(--mantine-primary-color-light)", lightHover: "var(--mantine-primary-color-light-hover)", lightColor: "var(--mantine-primary-color-light-color)", outline: "var(--mantine-primary-color-outline)", outlineHover: "var(--mantine-primary-color-outline-hover)" }, white: "var(--mantine-color-white)", black: "var(--mantine-color-black)", text: "var(--mantine-color-text)", body: "var(--mantine-color-body)", error: "var(--mantine-color-error)", placeholder: "var(--mantine-color-placeholder)", anchor: "var(--mantine-color-anchor)", default: "var(--mantine-color-default)", defaultHover: "var(--mantine-color-default-hover)", defaultColor: "var(--mantine-color-default-color)", defaultBorder: "var(--mantine-color-default-border)", dimmed: "var(--mantine-color-dimmed)", disabledBody: "var(--mantine-color-disabled)", disabledText: "var(--mantine-color-disabled-color)", disabledBorder: "var(--mantine-color-disabled-border)" }); return { scale: "var(--mantine-scale)", cursorType: "var(--mantine-cursor-type)", webkitFontSmoothing: "var(--mantine-webkit-font-smoothing)", mozFontSmoothing: "var(--mantine-moz-font-smoothing)", lineHeight: "var(--mantine-line-height)", fontFamily: "var(--mantine-font-family)", fontFamilyMonospace: "var(--mantine-font-family-monospace)", fontFamilyHeadings: "var(--mantine-font-family-headings)", headingFontWeight: "var(--mantine-heading-font-weight)", radiusDefault: "var(--mantine-radius-default)", breakpoints: K.breakpoints, fontSizes: pe, lineHeights: me, shadows: ge, radius: xe, headings: ve, spacing: ye, colors: _e, rtlSelector: '[dir="rtl"] &', darkSelector: '[data-mantine-color-scheme="dark"] &', lightSelector: '[data-mantine-color-scheme="light"] &', smallerThan: Ee => `(max-width: ${getBreakpointValue(Ee, K)})`, largerThan: Ee => `(min-width: ${getBreakpointValue(Ee, K)})` } } const theme = { fontFamily: "Inter", autoContrast: !0, components: { Checkbox: Checkbox.extend({ defaultProps: { radius: "xs" } }), ColorInput: ColorInput.extend({ defaultProps: { radius: "xs" } }), Select: Select.extend({ defaultProps: { radius: "sm" } }), Textarea: Textarea.extend({ defaultProps: { radius: "xs" } }), TextInput: TextInput.extend({ defaultProps: { radius: "xs" } }), NumberInput: NumberInput.extend({ defaultProps: { radius: "xs" } }), Paper: Paper.extend({ defaultProps: { radius: "xs", shadow: "0" } }), ActionIcon: ActionIcon.extend({ defaultProps: { variant: "subtle", color: "gray", radius: "xs" } }), Button: Button.extend({ defaultProps: { radius: "xs", styles: { label: { fontWeight: 450 } } } }) } }; themeToVars(theme); const typeSetSceneNodeMessage = new Set(["CameraFrustumMessage", "GlbMessage", "FrameMessage", "BatchedAxesMessage", "GridMessage", "LabelMessage", "Gui3DMessage", "PointCloudMessage", "DirectionalLightMessage", "AmbientLightMessage", "HemisphereLightMessage", "PointLightMessage", "RectAreaLightMessage", "SpotLightMessage", "MeshMessage", "BoxMessage", "IcosphereMessage", "SkinnedMeshMessage", "BatchedMeshesMessage", "BatchedGlbMessage", "TransformControlsMessage", "ImageMessage", "LineSegmentsMessage", "CatmullRomSplineMessage", "CubicBezierSplineMessage", "GaussianSplatsMessage"]); function isSceneNodeMessage(fe) { return typeSetSceneNodeMessage.has(fe.type) } const typeSetGuiComponentMessage = new Set(["GuiFolderMessage", "GuiMarkdownMessage", "GuiHtmlMessage", "GuiProgressBarMessage", "GuiPlotlyMessage", "GuiUplotMessage", "GuiImageMessage", "GuiTabGroupMessage", "GuiButtonMessage", "GuiUploadButtonMessage", "GuiSliderMessage", "GuiMultiSliderMessage", "GuiNumberMessage", "GuiRgbMessage", "GuiRgbaMessage", "GuiCheckboxMessage", "GuiVector2Message", "GuiVector3Message", "GuiTextMessage", "GuiDropdownMessage", "GuiButtonGroupMessage"]); function isGuiComponentMessage(fe) { return typeSetGuiComponentMessage.has(fe.type) } function useMessageHandler() { const viewer = reactExports.useContext(ViewerContext), viewerMutable = viewer.mutable.current, updateSceneNode = viewer.useSceneTree(fe => fe.updateSceneNode), removeSceneNode = viewer.useSceneTree(fe => fe.removeSceneNode), addSceneNode = viewer.useSceneTree(fe => fe.addSceneNode), updateNodeAttributes = viewer.useSceneTree(fe => fe.updateNodeAttributes), setTheme = viewer.useGui(fe => fe.setTheme), setShareUrl = viewer.useGui(fe => fe.setShareUrl), addGui = viewer.useGui(fe => fe.addGui), addModal = viewer.useGui(fe => fe.addModal), removeModal = viewer.useGui(fe => fe.removeModal), removeGui = viewer.useGui(fe => fe.removeGui), updateGuiProps = viewer.useGui(fe => fe.updateGuiProps), setClickable = viewer.useSceneTree(fe => fe.setClickable), updateUploadState = viewer.useGui(fe => fe.updateUploadState); function addSceneNodeMakeParents(fe) { const K = viewer.useSceneTree.getState().nodeAttributesFromName[fe.name]; updateNodeAttributes(fe.name, { overrideVisibility: K?.overrideVisibility }); const pe = viewer.useSceneTree.getState().nodeFromName[fe.name]?.message; if (pe === void 0 || fe !== pe) { const xe = viewer.useSceneTree.getState().nodeAttributesFromName[fe.name]; updateNodeAttributes(fe.name, { ...xe, poseUpdateState: "waitForMakeObject" }) } const me = viewer.useSceneTree.getState().nodeFromName, ge = fe.name.split("/").slice(0, -1).join("/"); ge in me || addSceneNodeMakeParents({ ...rootNodeTemplate.message, name: ge }), addSceneNode(fe) } const fileDownloadHandler = useFileDownloadHandler(); return message => { if (isGuiComponentMessage(message)) { addGui(message); return } if (isSceneNodeMessage(message)) { if (message.type === "SkinnedMeshMessage") { viewerMutable.skinnedMeshState[message.name] = { initialized: !1, poses: [] }; const fe = new Float32Array(message.props.bone_wxyzs.buffer.slice(message.props.bone_wxyzs.byteOffset, message.props.bone_wxyzs.byteOffset + message.props.bone_wxyzs.byteLength)), K = new Float32Array(message.props.bone_positions.buffer.slice(message.props.bone_positions.byteOffset, message.props.bone_positions.byteOffset + message.props.bone_positions.byteLength)); for (let pe = 0; pe < message.props.bone_wxyzs.length; pe++)viewerMutable.skinnedMeshState[message.name].poses.push({ wxyz: [fe[4 * pe], fe[4 * pe + 1], fe[4 * pe + 2], fe[4 * pe + 3]], position: [K[3 * pe], K[3 * pe + 1], K[3 * pe + 2]] }) } addSceneNodeMakeParents(message); return } switch (message.type) { case "SceneNodeUpdateMessage": { updateSceneNode(message.name, message.updates); return } case "ShareUrlUpdated": { setShareUrl(message.share_url); return } case "GetRenderRequestMessage": { viewerMutable.getRenderRequest = message, viewerMutable.getRenderRequestState = "triggered"; return } case "SetGuiPanelLabelMessage": { viewer.useGui.setState({ label: message.label ?? "" }); return } case "ThemeConfigurationMessage": { setTheme(message); return } case "RunJavascriptMessage": { eval(message.source); return } case "NotificationMessage": { console.log(message.uuid, message.props.loading), (message.mode === "show" ? notifications.show : notifications.update)({ id: message.uuid, title: message.props.title, message: message.props.body, withCloseButton: message.props.with_close_button, loading: message.props.loading, autoClose: message.props.auto_close_seconds === null ? !1 : message.props.auto_close_seconds * 1e3, color: toMantineColor(message.props.color) }); return } case "RemoveNotificationMessage": { notifications.hide(message.uuid); return } case "ScenePointerEnableMessage": { viewerMutable.scenePointerInfo.enabled = message.enable ? message.event_type : !1, viewerMutable.canvas.style.cursor = message.enable ? "pointer" : "auto"; return } case "EnvironmentMapMessage": { viewer.useSceneTree.setState({ environmentMap: message }); return } case "EnableLightsMessage": { viewer.useSceneTree.setState({ enableDefaultLights: message.enabled, enableDefaultLightsShadows: message.cast_shadow }); return } case "GuiModalMessage": { addModal(message); return } case "GuiCloseModalMessage": { removeModal(message.uuid); return } case "SetBoneOrientationMessage": { const fe = viewerMutable.skinnedMeshState; fe[message.name].poses[message.bone_index].wxyz = message.wxyz; break } case "SetBonePositionMessage": { const fe = viewerMutable.skinnedMeshState; fe[message.name].poses[message.bone_index].position = message.position; break } case "SetCameraLookAtMessage": { const fe = viewerMutable.cameraControl, K = computeT_threeworld_world(viewer), pe = new Vector3(message.look_at[0], message.look_at[1], message.look_at[2]); pe.applyMatrix4(K), fe.setTarget(pe.x, pe.y, pe.z, !1); return } case "SetCameraUpDirectionMessage": { const fe = viewerMutable.camera, K = viewerMutable.cameraControl, pe = computeT_threeworld_world(viewer), me = new Vector3(message.position[0], message.position[1], message.position[2]).normalize().applyQuaternion(new Quaternion().setFromRotationMatrix(pe)); fe.up.set(me.x, me.y, me.z); const ge = new Vector3; K.getPosition(ge), K.updateCameraUp(), K.setPosition(ge.x, ge.y, ge.z, !1); return } case "SetCameraPositionMessage": { const fe = viewerMutable.cameraControl, K = new Vector3(message.position[0], message.position[1], message.position[2]), pe = computeT_threeworld_world(viewer); K.applyMatrix4(pe), fe.setPosition(K.x, K.y, K.z); return } case "SetCameraFovMessage": { const fe = viewerMutable.camera; fe.setFocalLength(.5 * fe.getFilmHeight() / Math.tan(message.fov / 2)), viewerMutable.sendCamera !== null && viewerMutable.sendCamera(); return } case "SetCameraNearMessage": { const fe = viewerMutable.camera; fe.near = message.near, fe.updateProjectionMatrix(); return } case "SetCameraFarMessage": { const fe = viewerMutable.camera; fe.far = message.far, fe.updateProjectionMatrix(); return } case "SetOrientationMessage": { const fe = viewer.useSceneTree.getState().nodeAttributesFromName[message.name] || {}, K = fe.poseUpdateState !== "waitForMakeObject" ? "needsUpdate" : fe.poseUpdateState; updateNodeAttributes(message.name, { ...fe, wxyz: message.wxyz, poseUpdateState: K }); break } case "SetPositionMessage": { const fe = viewer.useSceneTree.getState().nodeAttributesFromName[message.name] || {}, K = fe.poseUpdateState !== "waitForMakeObject" ? "needsUpdate" : fe.poseUpdateState; updateNodeAttributes(message.name, { position: message.position, poseUpdateState: K }); break } case "SetSceneNodeVisibilityMessage": { const fe = viewer.useSceneTree.getState().nodeAttributesFromName[message.name] || {}; updateNodeAttributes(message.name, { ...fe, visibility: message.visible }); break } case "BackgroundImageMessage": { if (message.rgb_data !== null) { const fe = URL.createObjectURL(new Blob([message.rgb_data], { type: "image/" + message.format })); new TextureLoader().load(fe, K => { URL.revokeObjectURL(fe); const pe = viewerMutable.backgroundMaterial.uniforms.colorMap.value; viewerMutable.backgroundMaterial.uniforms.colorMap.value = K, isTexture(pe) && pe.dispose() }), viewerMutable.backgroundMaterial.uniforms.enabled.value = !0 } else { const fe = viewerMutable.backgroundMaterial.uniforms.colorMap.value; isTexture(fe) && fe.dispose(), viewerMutable.backgroundMaterial.uniforms.enabled.value = !1 } if (viewerMutable.backgroundMaterial.uniforms.hasDepth.value = message.depth_data !== null, message.depth_data !== null) { const fe = URL.createObjectURL(new Blob([message.depth_data], { type: "image/" + message.format })); new TextureLoader().load(fe, K => { URL.revokeObjectURL(fe); const pe = viewerMutable.backgroundMaterial?.uniforms.depthMap.value; viewerMutable.backgroundMaterial.uniforms.depthMap.value = K, isTexture(pe) && pe.dispose() }) } return } case "RemoveSceneNodeMessage": { console.log("Removing scene node:", message.name); const fe = viewer.useSceneTree.getState().nodeFromName; if (!(message.name in fe)) { console.log("(OK) Skipping scene node removal for " + message.name); return } removeSceneNode(message.name), updateNodeAttributes(message.name, void 0), viewerMutable.skinnedMeshState[message.name] !== void 0 && delete viewerMutable.skinnedMeshState[message.name]; return } case "SetSceneNodeClickableMessage": { setTimeout(() => setClickable(message.name, message.clickable), 50); return } case "GuiUpdateMessage": { updateGuiProps(message.uuid, message.updates); return } case "GuiRemoveMessage": { removeGui(message.uuid); return } case "FileTransferStartDownload": case "FileTransferPart": { fileDownloadHandler(message); return } case "FileTransferPartAck": { updateUploadState({ componentId: message.source_component_uuid, uploadedBytes: message.transferred_bytes, totalBytes: message.total_bytes }); return } default: { console.log("Received message did not match any known types:", message); return } } } } function useFileDownloadHandler() { const fe = React$4.useRef({}); return K => { const pe = "download-" + K.transfer_uuid; switch (K.type) { case "FileTransferStartDownload": { let ye = K.size_bytes; const ve = ["B", "K", "M", "G", "T", "P"]; let _e = 0; for (; ye >= 100 && _e < ve.length - 1;)ye /= 1024, _e += 1; fe.current[K.transfer_uuid] = { metadata: K, notificationId: pe, parts: [], bytesDownloaded: 0, displayFilesize: `${ye.toFixed(1)}${ve[_e]}` }; break } case "FileTransferPart": { const ye = fe.current[K.transfer_uuid]; K.part_index != ye.parts.length && console.error("A file download message was received out of order!"), ye.parts.push(K), ye.bytesDownloaded += K.content.length; break } }const me = fe.current[K.transfer_uuid], ge = 100 * me.bytesDownloaded / me.metadata.size_bytes, xe = me.bytesDownloaded == me.metadata.size_bytes; if ((me.bytesDownloaded == 0 ? notifications.show : notifications.update)({ title: (xe ? "Received " : "Receiving ") + `${me.metadata.filename} (${me.displayFilesize})`, message: jsxRuntimeExports.jsx(Progress, { size: "sm", value: ge }), id: pe, autoClose: xe && me.metadata.save_immediately, withCloseButton: xe, loading: !xe, icon: xe ? jsxRuntimeExports.jsx(IconCheck, {}) : void 0 }), xe) { const ye = window.URL.createObjectURL(new Blob(me.parts.sort((ve, _e) => ve.part_index - _e.part_index).map(ve => ve.content), { type: me.metadata.mime_type })); if (me.metadata.save_immediately) { const ve = document.createElement("a"); ve.href = ye, ve.download = me.metadata.filename, ve.click(), ve.remove(), delete fe.current[K.transfer_uuid], URL.revokeObjectURL(ye) } else notifications.update({ id: pe, title: "", message: jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("a", { href: ye, download: me.metadata.filename, children: jsxRuntimeExports.jsx(Button, { leftSection: jsxRuntimeExports.jsx(IconDownload, { size: 14 }), variant: "light", size: "sm", mt: "0.05em", style: { width: "100%" }, children: `${me.metadata.filename} (${me.displayFilesize})` }) }) }), autoClose: !1, onClose: () => { URL.revokeObjectURL(ye), delete fe.current[K.transfer_uuid] } }) } } } function FrameSynchronizedMessageHandler() { const fe = useMessageHandler(), K = reactExports.useContext(ViewerContext), pe = K.mutable.current, me = pe.messageQueue, ge = React$4.useContext(GaussianSplatsContext); return useFrame(() => { if (pe.getRenderRequestState === "triggered") pe.getRenderRequestState = "pause"; else if (pe.getRenderRequestState === "pause") { const xe = pe.getRenderRequest.position, ye = pe.getRenderRequest.wxyz, ve = pe.getRenderRequest.fov, _e = pe.getRenderRequest.width, Ee = pe.getRenderRequest.height, be = computeT_threeworld_world(K), Ae = new PerspectiveCamera(MathUtils.radToDeg(ve), _e / Ee, .01, 1e3); Ae.position.set(...xe).applyMatrix4(be), Ae.setRotationFromQuaternion(new Quaternion(ye[1], ye[2], ye[3], ye[0]).premultiply(new Quaternion().setFromRotationMatrix(be)).multiply(new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI))); const Se = ge.meshPropsRef.current, Ce = Se !== null ? Se.sortedIndexAttribute.array.slice() : null; ge.updateCamera.current !== null && ge.updateCamera.current(Ae, _e, Ee, !0); const we = new WebGLRenderer({ antialias: !0, alpha: !0 }); we.setSize(_e, Ee), we.setClearColor(16777215, pe.getRenderRequest.format == "image/png" ? 0 : 1), we.render(pe.scene, Ae), Ce !== null && Se !== null && (Se.sortedIndexAttribute.array = Ce, Se.sortedIndexAttribute.needsUpdate = !0), pe.getRenderRequestState = "in_progress", we.domElement.toBlob(async Be => { we.dispose(), we.forceContextLoss(), pe.sendMessage({ type: "GetRenderResponseMessage", payload: new Uint8Array(await Be.arrayBuffer()) }), pe.getRenderRequestState = "ready" }, pe.getRenderRequest.format) } if (pe.getRenderRequestState === "ready") { const xe = me.findIndex(_e => _e.type === "GetRenderRequestMessage"), ye = xe !== -1 ? xe + 1 : me.length; me.splice(0, ye).forEach(fe) } }, -1e5), null } new TextEncoder; const CHUNK_SIZE = 4096; function utf8DecodeJs(fe, K, pe) { let me = K; const ge = me + pe, xe = []; let ye = ""; for (; me < ge;) { const ve = fe[me++]; if (!(ve & 128)) xe.push(ve); else if ((ve & 224) === 192) { const _e = fe[me++] & 63; xe.push((ve & 31) << 6 | _e) } else if ((ve & 240) === 224) { const _e = fe[me++] & 63, Ee = fe[me++] & 63; xe.push((ve & 31) << 12 | _e << 6 | Ee) } else if ((ve & 248) === 240) { const _e = fe[me++] & 63, Ee = fe[me++] & 63, be = fe[me++] & 63; let Ae = (ve & 7) << 18 | _e << 12 | Ee << 6 | be; Ae > 65535 && (Ae -= 65536, xe.push(Ae >>> 10 & 1023 | 55296), Ae = 56320 | Ae & 1023), xe.push(Ae) } else xe.push(ve); xe.length >= CHUNK_SIZE && (ye += String.fromCharCode(...xe), xe.length = 0) } return xe.length > 0 && (ye += String.fromCharCode(...xe)), ye } const sharedTextDecoder = new TextDecoder, TEXT_DECODER_THRESHOLD = 200; function utf8DecodeTD(fe, K, pe) { const me = fe.subarray(K, K + pe); return sharedTextDecoder.decode(me) } function utf8Decode(fe, K, pe) { return pe > TEXT_DECODER_THRESHOLD ? utf8DecodeTD(fe, K, pe) : utf8DecodeJs(fe, K, pe) } class ExtData { constructor(K, pe) { this.type = K, this.data = pe } } class DecodeError extends Error { constructor(K) { super(K); const pe = Object.create(DecodeError.prototype); Object.setPrototypeOf(this, pe), Object.defineProperty(this, "name", { configurable: !0, enumerable: !1, value: DecodeError.name }) } } const UINT32_MAX = 4294967295; function setInt64(fe, K, pe) { const me = Math.floor(pe / 4294967296), ge = pe; fe.setUint32(K, me), fe.setUint32(K + 4, ge) } function getInt64(fe, K) { const pe = fe.getInt32(K), me = fe.getUint32(K + 4); return pe * 4294967296 + me } function getUint64(fe, K) { const pe = fe.getUint32(K), me = fe.getUint32(K + 4); return pe * 4294967296 + me } const EXT_TIMESTAMP = -1, TIMESTAMP32_MAX_SEC = 4294967296 - 1, TIMESTAMP64_MAX_SEC = 17179869184 - 1; function encodeTimeSpecToTimestamp({ sec: fe, nsec: K }) { if (fe >= 0 && K >= 0 && fe <= TIMESTAMP64_MAX_SEC) if (K === 0 && fe <= TIMESTAMP32_MAX_SEC) { const pe = new Uint8Array(4); return new DataView(pe.buffer).setUint32(0, fe), pe } else { const pe = fe / 4294967296, me = fe & 4294967295, ge = new Uint8Array(8), xe = new DataView(ge.buffer); return xe.setUint32(0, K << 2 | pe & 3), xe.setUint32(4, me), ge } else { const pe = new Uint8Array(12), me = new DataView(pe.buffer); return me.setUint32(0, K), setInt64(me, 4, fe), pe } } function encodeDateToTimeSpec(fe) { const K = fe.getTime(), pe = Math.floor(K / 1e3), me = (K - pe * 1e3) * 1e6, ge = Math.floor(me / 1e9); return { sec: pe + ge, nsec: me - ge * 1e9 } } function encodeTimestampExtension(fe) { if (fe instanceof Date) { const K = encodeDateToTimeSpec(fe); return encodeTimeSpecToTimestamp(K) } else return null } function decodeTimestampToTimeSpec(fe) { const K = new DataView(fe.buffer, fe.byteOffset, fe.byteLength); switch (fe.byteLength) { case 4: return { sec: K.getUint32(0), nsec: 0 }; case 8: { const pe = K.getUint32(0), me = K.getUint32(4), ge = (pe & 3) * 4294967296 + me, xe = pe >>> 2; return { sec: ge, nsec: xe } } case 12: { const pe = getInt64(K, 4), me = K.getUint32(0); return { sec: pe, nsec: me } } default: throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${fe.length}`) } } function decodeTimestampExtension(fe) { const K = decodeTimestampToTimeSpec(fe); return new Date(K.sec * 1e3 + K.nsec / 1e6) } const timestampExtension = { type: EXT_TIMESTAMP, encode: encodeTimestampExtension, decode: decodeTimestampExtension }; class ExtensionCodec { constructor() { this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(timestampExtension) } register({ type: K, encode: pe, decode: me }) { if (K >= 0) this.encoders[K] = pe, this.decoders[K] = me; else { const ge = -1 - K; this.builtInEncoders[ge] = pe, this.builtInDecoders[ge] = me } } tryToEncode(K, pe) { for (let me = 0; me < this.builtInEncoders.length; me++) { const ge = this.builtInEncoders[me]; if (ge != null) { const xe = ge(K, pe); if (xe != null) { const ye = -1 - me; return new ExtData(ye, xe) } } } for (let me = 0; me < this.encoders.length; me++) { const ge = this.encoders[me]; if (ge != null) { const xe = ge(K, pe); if (xe != null) { const ye = me; return new ExtData(ye, xe) } } } return K instanceof ExtData ? K : null } decode(K, pe, me) { const ge = pe < 0 ? this.builtInDecoders[-1 - pe] : this.decoders[pe]; return ge ? ge(K, pe, me) : new ExtData(pe, K) } } ExtensionCodec.defaultCodec = new ExtensionCodec; function isArrayBufferLike(fe) { return fe instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && fe instanceof SharedArrayBuffer } function ensureUint8Array(fe) { return fe instanceof Uint8Array ? fe : ArrayBuffer.isView(fe) ? new Uint8Array(fe.buffer, fe.byteOffset, fe.byteLength) : isArrayBufferLike(fe) ? new Uint8Array(fe) : Uint8Array.from(fe) } function prettyByte(fe) { return `${fe < 0 ? "-" : ""}0x${Math.abs(fe).toString(16).padStart(2, "0")}` } const DEFAULT_MAX_KEY_LENGTH = 16, DEFAULT_MAX_LENGTH_PER_KEY = 16; class CachedKeyDecoder { constructor(K = DEFAULT_MAX_KEY_LENGTH, pe = DEFAULT_MAX_LENGTH_PER_KEY) { this.hit = 0, this.miss = 0, this.maxKeyLength = K, this.maxLengthPerKey = pe, this.caches = []; for (let me = 0; me < this.maxKeyLength; me++)this.caches.push([]) } canBeCached(K) { return K > 0 && K <= this.maxKeyLength } find(K, pe, me) { const ge = this.caches[me - 1]; e: for (const xe of ge) { const ye = xe.bytes; for (let ve = 0; ve < me; ve++)if (ye[ve] !== K[pe + ve]) continue e; return xe.str } return null } store(K, pe) { const me = this.caches[K.length - 1], ge = { bytes: K, str: pe }; me.length >= this.maxLengthPerKey ? me[Math.random() * me.length | 0] = ge : me.push(ge) } decode(K, pe, me) { const ge = this.find(K, pe, me); if (ge != null) return this.hit++, ge; this.miss++; const xe = utf8DecodeJs(K, pe, me), ye = Uint8Array.prototype.slice.call(K, pe, pe + me); return this.store(ye, xe), xe } } const STATE_ARRAY = "array", STATE_MAP_KEY = "map_key", STATE_MAP_VALUE = "map_value", mapKeyConverter = fe => { if (typeof fe == "string" || typeof fe == "number") return fe; throw new DecodeError("The type of key must be string or number but " + typeof fe) }; class StackPool { constructor() { this.stack = [], this.stackHeadPosition = -1 } get length() { return this.stackHeadPosition + 1 } top() { return this.stack[this.stackHeadPosition] } pushArrayState(K) { const pe = this.getUninitializedStateFromPool(); pe.type = STATE_ARRAY, pe.position = 0, pe.size = K, pe.array = new Array(K) } pushMapState(K) { const pe = this.getUninitializedStateFromPool(); pe.type = STATE_MAP_KEY, pe.readCount = 0, pe.size = K, pe.map = {} } getUninitializedStateFromPool() { if (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length) { const K = { type: void 0, size: 0, array: void 0, position: 0, readCount: 0, map: void 0, key: null }; this.stack.push(K) } return this.stack[this.stackHeadPosition] } release(K) { if (this.stack[this.stackHeadPosition] !== K) throw new Error("Invalid stack state. Released state is not on top of the stack."); if (K.type === STATE_ARRAY) { const me = K; me.size = 0, me.array = void 0, me.position = 0, me.type = void 0 } if (K.type === STATE_MAP_KEY || K.type === STATE_MAP_VALUE) { const me = K; me.size = 0, me.map = void 0, me.readCount = 0, me.type = void 0 } this.stackHeadPosition-- } reset() { this.stack.length = 0, this.stackHeadPosition = -1 } } const HEAD_BYTE_REQUIRED = -1, EMPTY_VIEW = new DataView(new ArrayBuffer(0)), EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer); try { EMPTY_VIEW.getInt8(0) } catch (fe) { if (!(fe instanceof RangeError)) throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access") } const MORE_DATA = new RangeError("Insufficient data"), sharedCachedKeyDecoder = new CachedKeyDecoder; class Decoder { constructor(K) { this.totalPos = 0, this.pos = 0, this.view = EMPTY_VIEW, this.bytes = EMPTY_BYTES, this.headByte = HEAD_BYTE_REQUIRED, this.stack = new StackPool, this.entered = !1, this.extensionCodec = K?.extensionCodec ?? ExtensionCodec.defaultCodec, this.context = K?.context, this.useBigInt64 = K?.useBigInt64 ?? !1, this.rawStrings = K?.rawStrings ?? !1, this.maxStrLength = K?.maxStrLength ?? UINT32_MAX, this.maxBinLength = K?.maxBinLength ?? UINT32_MAX, this.maxArrayLength = K?.maxArrayLength ?? UINT32_MAX, this.maxMapLength = K?.maxMapLength ?? UINT32_MAX, this.maxExtLength = K?.maxExtLength ?? UINT32_MAX, this.keyDecoder = K?.keyDecoder !== void 0 ? K.keyDecoder : sharedCachedKeyDecoder, this.mapKeyConverter = K?.mapKeyConverter ?? mapKeyConverter } clone() { return new Decoder({ extensionCodec: this.extensionCodec, context: this.context, useBigInt64: this.useBigInt64, rawStrings: this.rawStrings, maxStrLength: this.maxStrLength, maxBinLength: this.maxBinLength, maxArrayLength: this.maxArrayLength, maxMapLength: this.maxMapLength, maxExtLength: this.maxExtLength, keyDecoder: this.keyDecoder }) } reinitializeState() { this.totalPos = 0, this.headByte = HEAD_BYTE_REQUIRED, this.stack.reset() } setBuffer(K) { const pe = ensureUint8Array(K); this.bytes = pe, this.view = new DataView(pe.buffer, pe.byteOffset, pe.byteLength), this.pos = 0 } appendBuffer(K) { if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) this.setBuffer(K); else { const pe = this.bytes.subarray(this.pos), me = ensureUint8Array(K), ge = new Uint8Array(pe.length + me.length); ge.set(pe), ge.set(me, pe.length), this.setBuffer(ge) } } hasRemaining(K) { return this.view.byteLength - this.pos >= K } createExtraByteError(K) { const { view: pe, pos: me } = this; return new RangeError(`Extra ${pe.byteLength - me} of ${pe.byteLength} byte(s) found at buffer[${K}]`) } decode(K) { if (this.entered) return this.clone().decode(K); try { this.entered = !0, this.reinitializeState(), this.setBuffer(K); const pe = this.doDecodeSync(); if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos); return pe } finally { this.entered = !1 } } *decodeMulti(K) { if (this.entered) { yield* this.clone().decodeMulti(K); return } try { for (this.entered = !0, this.reinitializeState(), this.setBuffer(K); this.hasRemaining(1);)yield this.doDecodeSync() } finally { this.entered = !1 } } async decodeAsync(K) { if (this.entered) return this.clone().decodeAsync(K); try { this.entered = !0; let pe = !1, me; for await (const ve of K) { if (pe) throw this.entered = !1, this.createExtraByteError(this.totalPos); this.appendBuffer(ve); try { me = this.doDecodeSync(), pe = !0 } catch (_e) { if (!(_e instanceof RangeError)) throw _e } this.totalPos += this.pos } if (pe) { if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos); return me } const { headByte: ge, pos: xe, totalPos: ye } = this; throw new RangeError(`Insufficient data in parsing ${prettyByte(ge)} at ${ye} (${xe} in the current buffer)`) } finally { this.entered = !1 } } decodeArrayStream(K) { return this.decodeMultiAsync(K, !0) } decodeStream(K) { return this.decodeMultiAsync(K, !1) } async*decodeMultiAsync(K, pe) { if (this.entered) { yield* this.clone().decodeMultiAsync(K, pe); return } try { this.entered = !0; let me = pe, ge = -1; for await (const xe of K) { if (pe && ge === 0) throw this.createExtraByteError(this.totalPos); this.appendBuffer(xe), me && (ge = this.readArraySize(), me = !1, this.complete()); try { for (; yield this.doDecodeSync(), --ge !== 0;); } catch (ye) { if (!(ye instanceof RangeError)) throw ye } this.totalPos += this.pos } } finally { this.entered = !1 } } doDecodeSync() { e: for (; ;) { const K = this.readHeadByte(); let pe; if (K >= 224) pe = K - 256; else if (K < 192) if (K < 128) pe = K; else if (K < 144) { const ge = K - 128; if (ge !== 0) { this.pushMapState(ge), this.complete(); continue e } else pe = {} } else if (K < 160) { const ge = K - 144; if (ge !== 0) { this.pushArrayState(ge), this.complete(); continue e } else pe = [] } else { const ge = K - 160; pe = this.decodeString(ge, 0) } else if (K === 192) pe = null; else if (K === 194) pe = !1; else if (K === 195) pe = !0; else if (K === 202) pe = this.readF32(); else if (K === 203) pe = this.readF64(); else if (K === 204) pe = this.readU8(); else if (K === 205) pe = this.readU16(); else if (K === 206) pe = this.readU32(); else if (K === 207) this.useBigInt64 ? pe = this.readU64AsBigInt() : pe = this.readU64(); else if (K === 208) pe = this.readI8(); else if (K === 209) pe = this.readI16(); else if (K === 210) pe = this.readI32(); else if (K === 211) this.useBigInt64 ? pe = this.readI64AsBigInt() : pe = this.readI64(); else if (K === 217) { const ge = this.lookU8(); pe = this.decodeString(ge, 1) } else if (K === 218) { const ge = this.lookU16(); pe = this.decodeString(ge, 2) } else if (K === 219) { const ge = this.lookU32(); pe = this.decodeString(ge, 4) } else if (K === 220) { const ge = this.readU16(); if (ge !== 0) { this.pushArrayState(ge), this.complete(); continue e } else pe = [] } else if (K === 221) { const ge = this.readU32(); if (ge !== 0) { this.pushArrayState(ge), this.complete(); continue e } else pe = [] } else if (K === 222) { const ge = this.readU16(); if (ge !== 0) { this.pushMapState(ge), this.complete(); continue e } else pe = {} } else if (K === 223) { const ge = this.readU32(); if (ge !== 0) { this.pushMapState(ge), this.complete(); continue e } else pe = {} } else if (K === 196) { const ge = this.lookU8(); pe = this.decodeBinary(ge, 1) } else if (K === 197) { const ge = this.lookU16(); pe = this.decodeBinary(ge, 2) } else if (K === 198) { const ge = this.lookU32(); pe = this.decodeBinary(ge, 4) } else if (K === 212) pe = this.decodeExtension(1, 0); else if (K === 213) pe = this.decodeExtension(2, 0); else if (K === 214) pe = this.decodeExtension(4, 0); else if (K === 215) pe = this.decodeExtension(8, 0); else if (K === 216) pe = this.decodeExtension(16, 0); else if (K === 199) { const ge = this.lookU8(); pe = this.decodeExtension(ge, 1) } else if (K === 200) { const ge = this.lookU16(); pe = this.decodeExtension(ge, 2) } else if (K === 201) { const ge = this.lookU32(); pe = this.decodeExtension(ge, 4) } else throw new DecodeError(`Unrecognized type byte: ${prettyByte(K)}`); this.complete(); const me = this.stack; for (; me.length > 0;) { const ge = me.top(); if (ge.type === STATE_ARRAY) if (ge.array[ge.position] = pe, ge.position++, ge.position === ge.size) pe = ge.array, me.release(ge); else continue e; else if (ge.type === STATE_MAP_KEY) { if (pe === "__proto__") throw new DecodeError("The key __proto__ is not allowed"); ge.key = this.mapKeyConverter(pe), ge.type = STATE_MAP_VALUE; continue e } else if (ge.map[ge.key] = pe, ge.readCount++, ge.readCount === ge.size) pe = ge.map, me.release(ge); else { ge.key = null, ge.type = STATE_MAP_KEY; continue e } } return pe } } readHeadByte() { return this.headByte === HEAD_BYTE_REQUIRED && (this.headByte = this.readU8()), this.headByte } complete() { this.headByte = HEAD_BYTE_REQUIRED } readArraySize() { const K = this.readHeadByte(); switch (K) { case 220: return this.readU16(); case 221: return this.readU32(); default: { if (K < 160) return K - 144; throw new DecodeError(`Unrecognized array type byte: ${prettyByte(K)}`) } } } pushMapState(K) { if (K > this.maxMapLength) throw new DecodeError(`Max length exceeded: map length (${K}) > maxMapLengthLength (${this.maxMapLength})`); this.stack.pushMapState(K) } pushArrayState(K) { if (K > this.maxArrayLength) throw new DecodeError(`Max length exceeded: array length (${K}) > maxArrayLength (${this.maxArrayLength})`); this.stack.pushArrayState(K) } decodeString(K, pe) { return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(K, pe) : this.decodeBinary(K, pe) } decodeUtf8String(K, pe) { if (K > this.maxStrLength) throw new DecodeError(`Max length exceeded: UTF-8 byte length (${K}) > maxStrLength (${this.maxStrLength})`); if (this.bytes.byteLength < this.pos + pe + K) throw MORE_DATA; const me = this.pos + pe; let ge; return this.stateIsMapKey() && this.keyDecoder?.canBeCached(K) ? ge = this.keyDecoder.decode(this.bytes, me, K) : ge = utf8Decode(this.bytes, me, K), this.pos += pe + K, ge } stateIsMapKey() { return this.stack.length > 0 ? this.stack.top().type === STATE_MAP_KEY : !1 } decodeBinary(K, pe) { if (K > this.maxBinLength) throw new DecodeError(`Max length exceeded: bin length (${K}) > maxBinLength (${this.maxBinLength})`); if (!this.hasRemaining(K + pe)) throw MORE_DATA; const me = this.pos + pe, ge = this.bytes.subarray(me, me + K); return this.pos += pe + K, ge } decodeExtension(K, pe) { if (K > this.maxExtLength) throw new DecodeError(`Max length exceeded: ext length (${K}) > maxExtLength (${this.maxExtLength})`); const me = this.view.getInt8(this.pos + pe), ge = this.decodeBinary(K, pe + 1); return this.extensionCodec.decode(ge, me, this.context) } lookU8() { return this.view.getUint8(this.pos) } lookU16() { return this.view.getUint16(this.pos) } lookU32() { return this.view.getUint32(this.pos) } readU8() { const K = this.view.getUint8(this.pos); return this.pos++, K } readI8() { const K = this.view.getInt8(this.pos); return this.pos++, K } readU16() { const K = this.view.getUint16(this.pos); return this.pos += 2, K } readI16() { const K = this.view.getInt16(this.pos); return this.pos += 2, K } readU32() { const K = this.view.getUint32(this.pos); return this.pos += 4, K } readI32() { const K = this.view.getInt32(this.pos); return this.pos += 4, K } readU64() { const K = getUint64(this.view, this.pos); return this.pos += 8, K } readI64() { const K = getInt64(this.view, this.pos); return this.pos += 8, K } readU64AsBigInt() { const K = this.view.getBigUint64(this.pos); return this.pos += 8, K } readI64AsBigInt() { const K = this.view.getBigInt64(this.pos); return this.pos += 8, K } readF32() { const K = this.view.getFloat32(this.pos); return this.pos += 4, K } readF64() { const K = this.view.getFloat64(this.pos); return this.pos += 8, K } } function decode(fe, K) { return new Decoder(K).decode(fe) } function isAsyncIterable(fe) { return fe[Symbol.asyncIterator] != null } async function* asyncIterableFromStream(fe) { const K = fe.getReader(); try { for (; ;) { const { done: pe, value: me } = await K.read(); if (pe) return; yield me } } finally { K.releaseLock() } } function ensureAsyncIterable(fe) { return isAsyncIterable(fe) ? fe : asyncIterableFromStream(fe) } async function decodeAsync(fe, K) { const pe = ensureAsyncIterable(fe); return new Decoder(K).decodeAsync(pe) } var ch2 = {}, wk = function (fe, K, pe, me, ge) { var xe = new Worker(ch2[K] || (ch2[K] = URL.createObjectURL(new Blob([fe + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'], { type: "text/javascript" })))); return xe.onmessage = function (ye) { var ve = ye.data, _e = ve.$e$; if (_e) { var Ee = new Error(_e[0]); Ee.code = _e[1], Ee.stack = _e[2], ge(Ee, null) } else ge(null, ve) }, xe.postMessage(pe, me), xe }, u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array, fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), freb = function (fe, K) { for (var pe = new u16(31), me = 0; me < 31; ++me)pe[me] = K += 1 << fe[me - 1]; for (var ge = new i32(pe[30]), me = 1; me < 30; ++me)for (var xe = pe[me]; xe < pe[me + 1]; ++xe)ge[xe] = xe - pe[me] << 5 | me; return { b: pe, r: ge } }, _a = freb(fleb, 2), fl = _a.b, revfl = _a.r; fl[28] = 258, revfl[258] = 28; var _b = freb(fdeb, 0), fd = _b.b, rev = new u16(32768); for (var i = 0; i < 32768; ++i) { var x = (i & 43690) >> 1 | (i & 21845) << 1; x = (x & 52428) >> 2 | (x & 13107) << 2, x = (x & 61680) >> 4 | (x & 3855) << 4, rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1 } var hMap = function (fe, K, pe) { for (var me = fe.length, ge = 0, xe = new u16(K); ge < me; ++ge)fe[ge] && ++xe[fe[ge] - 1]; var ye = new u16(K); for (ge = 1; ge < K; ++ge)ye[ge] = ye[ge - 1] + xe[ge - 1] << 1; var ve; if (pe) { ve = new u16(1 << K); var _e = 15 - K; for (ge = 0; ge < me; ++ge)if (fe[ge]) for (var Ee = ge << 4 | fe[ge], be = K - fe[ge], Ae = ye[fe[ge] - 1]++ << be, Se = Ae | (1 << be) - 1; Ae <= Se; ++Ae)ve[rev[Ae] >> _e] = Ee } else for (ve = new u16(me), ge = 0; ge < me; ++ge)fe[ge] && (ve[ge] = rev[ye[fe[ge] - 1]++] >> 15 - fe[ge]); return ve }, flt = new u8(288); for (var i = 0; i < 144; ++i)flt[i] = 8; for (var i = 144; i < 256; ++i)flt[i] = 9; for (var i = 256; i < 280; ++i)flt[i] = 7; for (var i = 280; i < 288; ++i)flt[i] = 8; var fdt = new u8(32); for (var i = 0; i < 32; ++i)fdt[i] = 5; var flrm = hMap(flt, 9, 1), fdrm = hMap(fdt, 5, 1), max = function (fe) { for (var K = fe[0], pe = 1; pe < fe.length; ++pe)fe[pe] > K && (K = fe[pe]); return K }, bits = function (fe, K, pe) { var me = K / 8 | 0; return (fe[me] | fe[me + 1] << 8) >> (K & 7) & pe }, bits16 = function (fe, K) { var pe = K / 8 | 0; return (fe[pe] | fe[pe + 1] << 8 | fe[pe + 2] << 16) >> (K & 7) }, shft = function (fe) { return (fe + 7) / 8 | 0 }, slc = function (fe, K, pe) { return (K == null || K < 0) && (K = 0), (pe == null || pe > fe.length) && (pe = fe.length), new u8(fe.subarray(K, pe)) }, ec = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], err = function (fe, K, pe) { var me = new Error(K || ec[fe]); if (me.code = fe, Error.captureStackTrace && Error.captureStackTrace(me, err), !pe) throw me; return me }, inflt = function (fe, K, pe, me) { var ge = fe.length, xe = me ? me.length : 0; if (!ge || K.f && !K.l) return pe || new u8(0); var ye = !pe, ve = ye || K.i != 2, _e = K.i; ye && (pe = new u8(ge * 3)); var Ee = function (Gn) { var wn = pe.length; if (Gn > wn) { var Bn = new u8(Math.max(wn * 2, Gn)); Bn.set(pe), pe = Bn } }, be = K.f || 0, Ae = K.p || 0, Se = K.b || 0, Ce = K.l, we = K.d, Be = K.m, De = K.n, Re = ge * 8; do { if (!Ce) { be = bits(fe, Ae, 1); var Ie = bits(fe, Ae + 1, 3); if (Ae += 3, Ie) if (Ie == 1) Ce = flrm, we = fdrm, Be = 9, De = 5; else if (Ie == 2) { var Oe = bits(fe, Ae, 31) + 257, Ue = bits(fe, Ae + 10, 15) + 4, He = Oe + bits(fe, Ae + 5, 31) + 1; Ae += 14; for (var Ge = new u8(He), ze = new u8(19), We = 0; We < Ue; ++We)ze[clim[We]] = bits(fe, Ae + We * 3, 7); Ae += Ue * 3; for (var Xe = max(ze), Ye = (1 << Xe) - 1, Ze = hMap(ze, Xe, 1), We = 0; We < He;) { var ot = Ze[bits(fe, Ae, Ye)]; Ae += ot & 15; var Pe = ot >> 4; if (Pe < 16) Ge[We++] = Pe; else { var qe = 0, Qe = 0; for (Pe == 16 ? (Qe = 3 + bits(fe, Ae, 3), Ae += 2, qe = Ge[We - 1]) : Pe == 17 ? (Qe = 3 + bits(fe, Ae, 7), Ae += 3) : Pe == 18 && (Qe = 11 + bits(fe, Ae, 127), Ae += 7); Qe--;)Ge[We++] = qe } } var st = Ge.subarray(0, Oe), Nt = Ge.subarray(Oe); Be = max(st), De = max(Nt), Ce = hMap(st, Be, 1), we = hMap(Nt, De, 1) } else err(1); else { var Pe = shft(Ae) + 4, Ne = fe[Pe - 4] | fe[Pe - 3] << 8, ke = Pe + Ne; if (ke > ge) { _e && err(0); break } ve && Ee(Se + Ne), pe.set(fe.subarray(Pe, ke), Se), K.b = Se += Ne, K.p = Ae = ke * 8, K.f = be; continue } if (Ae > Re) { _e && err(0); break } } ve && Ee(Se + 131072); for (var Je = (1 << Be) - 1, jt = (1 << De) - 1, Xt = Ae; ; Xt = Ae) { var qe = Ce[bits16(fe, Ae) & Je], ct = qe >> 4; if (Ae += qe & 15, Ae > Re) { _e && err(0); break } if (qe || err(2), ct < 256) pe[Se++] = ct; else if (ct == 256) { Xt = Ae, Ce = null; break } else { var nn = ct - 254; if (ct > 264) { var We = ct - 257, $t = fleb[We]; nn = bits(fe, Ae, (1 << $t) - 1) + fl[We], Ae += $t } var an = we[bits16(fe, Ae) & jt], gn = an >> 4; an || err(3), Ae += an & 15; var Nt = fd[gn]; if (gn > 3) { var $t = fdeb[gn]; Nt += bits16(fe, Ae) & (1 << $t) - 1, Ae += $t } if (Ae > Re) { _e && err(0); break } ve && Ee(Se + 131072); var Mn = Se + nn; if (Se < Nt) { var Xn = xe - Nt, Ln = Math.min(Nt, Mn); for (Xn + Se < 0 && err(3); Se < Ln; ++Se)pe[Se] = me[Xn + Se] } for (; Se < Mn; ++Se)pe[Se] = pe[Se - Nt] } } K.l = Ce, K.p = Xt, K.b = Se, K.f = be, Ce && (be = 1, K.m = Be, K.d = we, K.n = De) } while (!be); return Se != pe.length && ye ? slc(pe, 0, Se) : pe.subarray(0, Se) }, et = new u8(0), mrg = function (fe, K) { var pe = {}; for (var me in fe) pe[me] = fe[me]; for (var me in K) pe[me] = K[me]; return pe }, wcln = function (fe, K, pe) { for (var me = fe(), ge = fe.toString(), xe = ge.slice(ge.indexOf("[") + 1, ge.lastIndexOf("]")).replace(/\s+/g, "").split(","), ye = 0; ye < me.length; ++ye) { var ve = me[ye], _e = xe[ye]; if (typeof ve == "function") { K += ";" + _e + "="; var Ee = ve.toString(); if (ve.prototype) if (Ee.indexOf("[native code]") != -1) { var be = Ee.indexOf(" ", 8) + 1; K += Ee.slice(be, Ee.indexOf("(", be)) } else { K += Ee; for (var Ae in ve.prototype) K += ";" + _e + ".prototype." + Ae + "=" + ve.prototype[Ae].toString() } else K += Ee } else pe[_e] = ve } return K }, ch = [], cbfs = function (fe) { var K = []; for (var pe in fe) fe[pe].buffer && K.push((fe[pe] = new fe[pe].constructor(fe[pe])).buffer); return K }, wrkr = function (fe, K, pe, me) { if (!ch[pe]) { for (var ge = "", xe = {}, ye = fe.length - 1, ve = 0; ve < ye; ++ve)ge = wcln(fe[ve], ge, xe); ch[pe] = { c: wcln(fe[ye], ge, xe), e: xe } } var _e = mrg({}, ch[pe].e); return wk(ch[pe].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + K.toString() + "}", pe, _e, cbfs(_e), me) }, bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt] }, guze = function () { return [gzs, gzl] }, zule = function () { return [zls] }, pbf = function (fe) { return postMessage(fe, [fe.buffer]) }, gopt = function (fe) { return fe && { out: fe.size && new u8(fe.size), dictionary: fe.dictionary } }, cbify = function (fe, K, pe, me, ge, xe) { var ye = wrkr(pe, me, ge, function (ve, _e) { ye.terminate(), xe(ve, _e) }); return ye.postMessage([fe, K], K.consume ? [fe.buffer] : []), function () { ye.terminate() } }, gzs = function (fe) { (fe[0] != 31 || fe[1] != 139 || fe[2] != 8) && err(6, "invalid gzip data"); var K = fe[3], pe = 10; K & 4 && (pe += (fe[10] | fe[11] << 8) + 2); for (var me = (K >> 3 & 1) + (K >> 4 & 1); me > 0; me -= !fe[pe++]); return pe + (K & 2) }, gzl = function (fe) { var K = fe.length; return (fe[K - 4] | fe[K - 3] << 8 | fe[K - 2] << 16 | fe[K - 1] << 24) >>> 0 }, zls = function (fe, K) { return ((fe[0] & 15) != 8 || fe[0] >> 4 > 7 || (fe[0] << 8 | fe[1]) % 31) && err(6, "invalid zlib data"), (fe[1] >> 5 & 1) == +!K && err(6, "invalid zlib data: " + (fe[1] & 32 ? "need" : "unexpected") + " dictionary"), (fe[1] >> 3 & 4) + 2 }; function inflate(fe, K, pe) { return pe || (pe = K, K = {}), typeof pe != "function" && err(7), cbify(fe, K, [bInflt], function (me) { return pbf(inflateSync(me.data[0], gopt(me.data[1]))) }, 1, pe) } function inflateSync(fe, K) { return inflt(fe, { i: 2 }, K && K.out, K && K.dictionary) } function gunzip(fe, K, pe) { return pe || (pe = K, K = {}), typeof pe != "function" && err(7), cbify(fe, K, [bInflt, guze, function () { return [gunzipSync] }], function (me) { return pbf(gunzipSync(me.data[0], me.data[1])) }, 3, pe) } function gunzipSync(fe, K) { var pe = gzs(fe); return pe + 8 > fe.length && err(6, "invalid gzip data"), inflt(fe.subarray(pe, -8), { i: 2 }, K && K.out || new u8(gzl(fe)), K && K.dictionary) } function unzlib(fe, K, pe) { return pe || (pe = K, K = {}), typeof pe != "function" && err(7), cbify(fe, K, [bInflt, zule, function () { return [unzlibSync] }], function (me) { return pbf(unzlibSync(me.data[0], gopt(me.data[1]))) }, 5, pe) } function unzlibSync(fe, K) { return inflt(fe.subarray(zls(fe, K && K.dictionary), -4), { i: 2 }, K && K.out, K && K.dictionary) } function decompress(fe, K, pe) { return pe || (pe = K, K = {}), typeof pe != "function" && err(7), fe[0] == 31 && fe[1] == 139 && fe[2] == 8 ? gunzip(fe, K, pe) : (fe[0] & 15) != 8 || fe[0] >> 4 > 7 || (fe[0] << 8 | fe[1]) % 31 ? inflate(fe, K, pe) : unzlib(fe, K, pe) } var td = typeof TextDecoder < "u" && new TextDecoder, tds = 0; try { td.decode(et, { stream: !0 }), tds = 1 } catch (fe) { } async function deserializeGzippedMsgpackFile(fe, K) { const pe = await fetch(fe); if (!pe.ok) throw new Error(`Failed to fetch the file: ${pe.statusText}`); return new Promise(me => { const ge = parseInt(pe.headers.get("Content-Length")); if (typeof DecompressionStream > "u") console.log("DecompressionStream is unavailable. Using fallback."), K({ downloaded: .1 * ge, total: ge }), pe.arrayBuffer().then(xe => { K({ downloaded: .8 * ge, total: ge }), decompress(new Uint8Array(xe), (ye, ve) => { K({ downloaded: 1 * ge, total: ge }), me(decode(ve)) }) }); else { let xe = 0; const ye = new TransformStream({ transform(ve, _e) { xe += ve.length, K({ downloaded: xe, total: ge }), _e.enqueue(ve) } }); decodeAsync(pe.body.pipeThrough(ye).pipeThrough(new DecompressionStream("gzip"))).then(ve => me(ve)) } }) } function PlaybackFromFile({ fileUrl: fe }) { const K = reactExports.useContext(ViewerContext), pe = K.mutable.current, me = K.useGui(Pe => Pe.theme.dark_mode), [ge, xe] = reactExports.useState({ downloaded: 0, total: 0 }), [ye, ve] = reactExports.useState("1x"), [_e, Ee] = reactExports.useState(!1), [be, Ae] = reactExports.useState(null); function Se() { const Pe = K.useSceneTree.getState(), Ne = Pe.nodeAttributesFromName; Object.keys(Ne).forEach(ke => { if (ke === "") return; const Oe = Pe.nodeFromName[ke]?.message; Oe !== void 0 && (Oe.type !== "FrameMessage" || Oe.props.show_axes) ? Pe.updateNodeAttributes(ke, { visibility: !1, wxyz: [1, 0, 0, 0], position: [0, 0, 0] }) : Pe.updateNodeAttributes(ke, { wxyz: [1, 0, 0, 0], position: [0, 0, 0] }) }) } const [Ce, we] = reactExports.useState(0), Be = useMantineTheme(); reactExports.useEffect(() => { deserializeGzippedMsgpackFile(fe, xe).then(Pe => { console.log("File loaded! Saved with Viser version:", Pe.viserVersion), Ae(Pe) }) }, []); const De = reactExports.useRef({ currentTime: 0, currentIndex: 0 }), Re = reactExports.useCallback(() => { if (be === null) return; const Pe = De.current; for (Pe.currentIndex == 0 && Se(); Pe.currentIndex < be.messages.length && be.messages[Pe.currentIndex][0] <= Pe.currentTime; Pe.currentIndex++) { const Ne = be.messages[Pe.currentIndex][1]; pe.messageQueue.push(Ne) } Pe.currentTime >= be.durationSeconds && (Pe.currentIndex = 0, Pe.currentTime = be.messages[0][0]), we(Pe.currentTime) }, [be]); reactExports.useEffect(() => { const Pe = parseFloat(ye); if (be !== null && !_e) { let Ne = Date.now(); const ke = setInterval(() => { const Oe = Date.now(); De.current.currentTime += (Oe - Ne) / 1e3 * Pe, Ne = Oe, Re(), De.current.currentIndex === be.messages.length && be.durationSeconds === 0 && clearInterval(ke) }, 1e3 / 120); return () => clearInterval(ke) } }, [Re, be, _e, ye, pe.messageQueue, we]), reactExports.useEffect(() => { function Pe(Ne) { Ne.code === "Space" && Ee(!_e) } return window.addEventListener("keydown", Pe), () => { window.removeEventListener("keydown", Pe) } }, [_e]); const Ie = reactExports.useCallback(Pe => { Pe < De.current.currentTime && (Se(), De.current.currentIndex = 0), De.current.currentTime = Pe, we(Pe), Ee(!0), Re() }, [be]); return be === null ? jsxRuntimeExports.jsx("div", { style: { position: "fixed", zIndex: 1, top: 0, bottom: 0, left: 0, right: 0, backgroundColor: me ? Be.colors.dark[9] : "#fff" }, children: jsxRuntimeExports.jsx(Progress, { value: ge.downloaded / ge.total * 100, radius: 0, transitionDuration: 0 }) }) : jsxRuntimeExports.jsxs(Paper, { radius: "xs", shadow: "0.1em 0 1em 0 rgba(0,0,0,0.1)", style: { position: "fixed", bottom: "1em", left: "50%", transform: "translateX(-50%)", width: "25em", maxWidth: "95%", zIndex: 1, padding: "0.5em", display: be.durationSeconds === 0 ? "none" : "flex", alignItems: "center", justifyContent: "space-between", gap: "0.375em" }, children: [jsxRuntimeExports.jsx(ActionIcon, { size: "md", variant: "subtle", onClick: () => Ee(!_e), children: _e ? jsxRuntimeExports.jsx(IconPlayerPlayFilled, { height: "1.125em", width: "1.125em" }) : jsxRuntimeExports.jsx(IconPlayerPauseFilled, { height: "1.125em", width: "1.125em" }) }), jsxRuntimeExports.jsx(NumberInput, { size: "xs", hideControls: !0, value: Ce.toFixed(1), step: .01, styles: { wrapper: { width: "3.1em" }, input: { padding: "0.2em", fontFamily: Be.fontFamilyMonospace, textAlign: "center" } }, onChange: Pe => Ie(typeof Pe == "number" ? Pe : parseFloat(Pe)) }), jsxRuntimeExports.jsx(Slider, { thumbSize: 0, radius: "xs", step: 1e-4, style: { flexGrow: 1 }, min: 0, max: be.durationSeconds, value: Ce, onChange: Ie, styles: { thumb: { display: "none" } } }), jsxRuntimeExports.jsx(Tooltip, { zIndex: 10, label: "Playback speed", withinPortal: !0, children: jsxRuntimeExports.jsx(Select, { size: "xs", value: ye, onChange: Pe => Pe === null ? null : ve(Pe), radius: "xs", data: ["0.5x", "1x", "2x", "4x", "8x"], styles: { wrapper: { width: "3.25em" } }, comboboxProps: { zIndex: 5, width: "5.25em" } }) })] }) } var __spreadArray = function (fe, K, pe) { if (pe || arguments.length === 2) for (var me = 0, ge = K.length, xe; me < ge; me++)(xe || !(me in K)) && (xe || (xe = Array.prototype.slice.call(K, 0, me)), xe[me] = K[me]); return fe.concat(xe || Array.prototype.slice.call(K)) }, BrowserInfo = function () { function fe(K, pe, me) { this.name = K, this.version = pe, this.os = me, this.type = "browser" } return fe }(), NodeInfo = function () { function fe(K) { this.version = K, this.type = "node", this.name = "node", this.os = process.platform } return fe }(), SearchBotDeviceInfo = function () { function fe(K, pe, me, ge) { this.name = K, this.version = pe, this.os = me, this.bot = ge, this.type = "bot-device" } return fe }(), BotInfo = function () { function fe() { this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null } return fe }(), ReactNativeInfo = function () { function fe() { this.type = "react-native", this.name = "react-native", this.version = null, this.os = null } return fe }(), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", SEARCHBOX_UA_REGEX]], operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]]; function detect(fe) { return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion() } function matchUserAgent(fe) { return fe !== "" && userAgentRules.reduce(function (K, pe) { var me = pe[0], ge = pe[1]; if (K) return K; var xe = ge.exec(fe); return !!xe && [me, xe] }, !1) } function parseUserAgent(fe) { var K = matchUserAgent(fe); if (!K) return null; var pe = K[0], me = K[1]; if (pe === "searchbot") return new BotInfo; var ge = me[1] && me[1].split(".").join("_").split("_").slice(0, 3); ge ? ge.length < REQUIRED_VERSION_PARTS && (ge = __spreadArray(__spreadArray([], ge, !0), createVersionParts(REQUIRED_VERSION_PARTS - ge.length), !0)) : ge = []; var xe = ge.join("."), ye = detectOS(fe), ve = SEARCHBOT_OS_REGEX.exec(fe); return ve && ve[1] ? new SearchBotDeviceInfo(pe, xe, ye, ve[1]) : new BrowserInfo(pe, xe, ye) } function detectOS(fe) { for (var K = 0, pe = operatingSystemRules.length; K < pe; K++) { var me = operatingSystemRules[K], ge = me[0], xe = me[1], ye = xe.exec(fe); if (ye) return ge } return null } function getNodeVersion() { var fe = typeof process < "u" && process.version; return fe ? new NodeInfo(process.version.slice(1)) : null } function createVersionParts(fe) { for (var K = [], pe = 0; pe < fe; pe++)K.push("0"); return K } function BrowserWarning() { return reactExports.useEffect(() => { const fe = detect(); if (fe === null || fe.version === null) console.log("Failed to detect browser"), notifications.show({ title: "Could not detect browser version", message: "Your browser version could not be detected. It may not be supported.", autoClose: !1, color: "red" }); else { const K = parseFloat(fe.version); console.log(`Detected ${fe.name} version ${K}`), (fe.name === "chrome" && K < 91 || fe.name === "edge" && K < 91 || fe.name === "firefox" && K < 89 || fe.name === "opera" && K < 77 || fe.name === "safari" && K < 16.4) && notifications.show({ title: "Unsuppported browser", message: `Your browser (${fe.name.slice(0, 1).toUpperCase() + fe.name.slice(1)}/${fe.version}) is outdated, which may cause problems. Consider updating.`, autoClose: !1, color: "red" }) } }), null } function MacWindowWrapper({ children: fe, title: K, width: pe, height: me, fill: ge = !1 }) { return jsxRuntimeExports.jsxs("div", { style: { width: ge ? "100vw" : `${pe}px`, height: ge ? "100vh" : `${me}px`, borderRadius: "10px", overflow: "hidden", border: "1px solid rgba(0,0,0,0.2)", backgroundColor: "white", transform: "translateX(-50%) translateY(-50%)", top: "50%", left: "50%", position: "absolute" }, children: [jsxRuntimeExports.jsxs("div", { style: { height: "36px", backgroundColor: "#f6f6f6", borderBottom: "1px solid rgba(0,0,0,0.075)", display: "flex", alignItems: "center", paddingLeft: "12px", gap: "8px" }, children: [jsxRuntimeExports.jsx("div", { style: { width: "12px", height: "12px", borderRadius: "50%", backgroundColor: "#ff5f57" } }), jsxRuntimeExports.jsx("div", { style: { width: "12px", height: "12px", borderRadius: "50%", backgroundColor: "#febc2e" } }), jsxRuntimeExports.jsx("div", { style: { width: "12px", height: "12px", borderRadius: "50%", backgroundColor: "#28c840" } }), jsxRuntimeExports.jsx("div", { style: { position: "absolute", left: "50%", transform: "translateX(-50%)", color: "#000", opacity: .4, fontSize: "14px", fontFamily: "-apple-system, BlinkMacSystemFont, sans-serif", fontWeight: 500 }, children: K })] }), jsxRuntimeExports.jsx("div", { style: { height: "calc(100% - 36px)" }, children: fe })] }) } const VISER_VERSION = "1.0.3", GITHUB_CONTRIBUTORS = [{ login: "brentyi", html_url: "https://github.com/brentyi" }, { login: "chungmin99", html_url: "https://github.com/chungmin99" }, { login: "kerrj", html_url: "https://github.com/kerrj" }, { login: "tancik", html_url: "https://github.com/tancik" }, { login: "jonahbedouch", html_url: "https://github.com/jonahbedouch" }, { login: "hangg7", html_url: "https://github.com/hangg7" }, { login: "BrianSantoso", html_url: "https://github.com/BrianSantoso" }, { login: "origamiman72", html_url: "https://github.com/origamiman72" }, { login: "ginazhouhuiwu", html_url: "https://github.com/ginazhouhuiwu" }, { login: "sea-bass", html_url: "https://github.com/sea-bass" }, { login: "jkulhanek", html_url: "https://github.com/jkulhanek" }, { login: "ethanweber", html_url: "https://github.com/ethanweber" }, { login: "zerolover", html_url: "https://github.com/zerolover" }, { login: "beckyfeng08", html_url: "https://github.com/beckyfeng08" }, { login: "vye16", html_url: "https://github.com/vye16" }, { login: "AdamRashid96", html_url: "https://github.com/AdamRashid96" }, { login: "slecleach", html_url: "https://github.com/slecleach" }, { login: "pritzza", html_url: "https://github.com/pritzza" }, { login: "yzslab", html_url: "https://github.com/yzslab" }, { login: "kikislater", html_url: "https://github.com/kikislater" }, { login: "simonbethke", html_url: "https://github.com/simonbethke" }, { login: "nlml", html_url: "https://github.com/nlml" }, { login: "kdexd", html_url: "https://github.com/kdexd" }, { login: "ojh6404", html_url: "https://github.com/ojh6404" }, { login: "hongsukchoi", html_url: "https://github.com/hongsukchoi" }, { login: "mcallisterdavid", html_url: "https://github.com/mcallisterdavid" }, { login: "cvachha", html_url: "https://github.com/cvachha" }, { login: "ArthurAllshire", html_url: "https://github.com/ArthurAllshire" }, { login: "Alescontrela", html_url: "https://github.com/Alescontrela" }, { login: "alberthli", html_url: "https://github.com/alberthli" }]; function ndcFromPointerXy(fe, K) { const pe = new Vector2; return pe.x = 2 * ((K[0] + .5) / fe.mutable.current.canvas.clientWidth) - 1, pe.y = 1 - 2 * ((K[1] + .5) / fe.mutable.current.canvas.clientHeight), pe.x < 1 && pe.x > -1 && pe.y < 1 && pe.y > -1 ? pe : null } function opencvXyFromPointerXy(fe, K) { const pe = new Vector2; return pe.x = (K[0] + .5) / fe.mutable.current.canvas.clientWidth, pe.y = (K[1] + .5) / fe.mutable.current.canvas.clientHeight, pe } const getDefaultServerFromUrl = () => { let fe = window.location.href; return fe = fe.replace("http://", "ws://"), fe = fe.replace("https://", "wss://"), fe = fe.split("?")[0], fe.endsWith("/") && (fe = fe.slice(0, -1)), fe }, DisableRender = () => useFrame(() => null, 1e3); function Root() { const fe = new URLSearchParams(window.location.search), K = fe.get("dummyWindowDimensions"), pe = fe.get("dummyWindowTitle") ?? "localhost:8080", me = jsxRuntimeExports.jsx("div", { style: { width: "100%", height: "100%", position: "relative", display: "flex", flexDirection: "column" }, children: jsxRuntimeExports.jsx(ViewerRoot, {}) }); if (!K) return me; if (K === "fill") return jsxRuntimeExports.jsx(MacWindowWrapper, { title: pe, width: window.innerWidth, height: window.innerHeight, fill: !0, children: me }); const [ge, xe] = K.split("x").map(Number); return isNaN(ge) || isNaN(xe) ? me : jsxRuntimeExports.jsx(MacWindowWrapper, { title: pe, width: ge, height: xe, children: me }) } function ViewerRoot() { const fe = new URLSearchParams(window.location.search).getAll(searchParamKey), K = fe.length >= 1 ? fe[0] : getDefaultServerFromUrl(), pe = new URLSearchParams(window.location.search), me = pe.get("playbackPath"), ge = pe.get("darkMode") !== null, xe = pe.get("showStats") !== null, ye = pe.get("hideViserLogo") !== null, ve = me === null ? "websocket" : "file_playback", _e = {}, Ee = React$4.useRef({ sendMessage: me == null ? Ae => console.log(`Tried to send ${Ae.type} but websocket is not connected!`) : () => null, sendCamera: null, resetCameraView: null, canvas: null, canvas2d: null, scene: null, camera: null, backgroundMaterial: null, cameraControl: null, nodeRefFromName: _e, messageQueue: [], getRenderRequestState: "ready", getRenderRequest: null, scenePointerInfo: { enabled: !1, dragStart: [0, 0], dragEnd: [0, 0], isDragging: !1 }, skinnedMeshState: {}, hoveredElementsCount: 0 }), be = { messageSource: ve, useSceneTree: useSceneTreeState(Ee.current.nodeRefFromName), useGui: useGuiState(K), mutable: Ee }; return ge && (be.useGui.getState().theme.dark_mode = ge), jsxRuntimeExports.jsx(ViewerContext.Provider, { value: be, children: jsxRuntimeExports.jsxs(ViewerContents, { hideViserLogo: ye, children: [ve === "websocket" && jsxRuntimeExports.jsx(WebsocketMessageProducer, {}), ve === "file_playback" && jsxRuntimeExports.jsx(PlaybackFromFile, { fileUrl: me }), xe && jsxRuntimeExports.jsx(Stats, { className: "stats-panel" })] }) }) } function ViewerContents({ children: fe, hideViserLogo: K }) { const pe = React$4.useContext(ViewerContext), me = pe.useGui(Ee => Ee.theme.dark_mode), ge = pe.useGui(Ee => Ee.theme.colors), xe = pe.useGui(Ee => Ee.theme.control_layout), ye = pe.useGui(Ee => Ee.theme.show_logo), { messageSource: ve } = pe, _e = reactExports.useMemo(() => ({ ...theme, ...ge === null ? {} : { colors: { custom: ge }, primaryColor: "custom" } }), [ge]); return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(MantineProvider, { theme: _e, defaultColorScheme: me ? "dark" : "light", colorSchemeManager: { get: Ee => Ee, set: () => null, subscribe: () => null, unsubscribe: () => null, clear: () => null }, children: [fe, jsxRuntimeExports.jsx(ColorSchemeSetter, { darkMode: me }), jsxRuntimeExports.jsx(NotificationsPanel, {}), jsxRuntimeExports.jsx(BrowserWarning, {}), jsxRuntimeExports.jsx(ViserModal, {}), jsxRuntimeExports.jsxs(Box, { style: { width: "100%", height: "100%", display: "flex", position: "relative", flexDirection: "column" }, children: [jsxRuntimeExports.jsx(Titlebar, {}), jsxRuntimeExports.jsxs(Box, { style: { width: "100%", position: "relative", flexGrow: 1, overflow: "hidden", display: "flex" }, children: [jsxRuntimeExports.jsxs(Box, { style: Ee => ({ backgroundColor: me ? Ee.colors.dark[9] : "#fff", flexGrow: 1, overflow: "hidden", height: "100%" }), children: [jsxRuntimeExports.jsx(Viewer2DCanvas, {}), jsxRuntimeExports.jsx(ViewerCanvas, { children: jsxRuntimeExports.jsx(FrameSynchronizedMessageHandler, {}) }), ye && !K && ve === "websocket" && jsxRuntimeExports.jsx(ViserLogo, {})] }), ve === "websocket" && jsxRuntimeExports.jsx(ControlPanel, { control_layout: xe })] })] })] }) }) } function ColorSchemeSetter(fe) { const K = useMantineColorScheme(); return reactExports.useEffect(() => { K.setColorScheme(fe.darkMode ? "dark" : "light") }, [fe.darkMode]), null } function NotificationsPanel() { return jsxRuntimeExports.jsx(Notifications, { position: "top-left", limit: 10, containerWidth: "20em", withinPortal: !1, styles: { root: { boxShadow: "0.1em 0 1em 0 rgba(0,0,0,0.1) !important", position: "absolute", top: "1em", left: "1em", pointerEvents: "none" }, notification: { pointerEvents: "all" } } }) } function ViewerCanvas({ children: fe }) { const K = React$4.useContext(ViewerContext), pe = useThrottledMessageSender(20).send, me = useMantineTheme(), { ref: ge, inView: xe } = useInView(), ve = new URLSearchParams(window.location.search).get("fixedDpr"), _e = ve ? parseFloat(ve) : null, Ee = _e === null, be = reactExports.useMemo(() => jsxRuntimeExports.jsx(SynchronizedCameraControls, {}), []), Ae = we => { const { mutable: Be } = K, De = Be.current.scenePointerInfo; if (De.enabled === !1) return; const Re = Be.current.canvas.getBoundingClientRect(); if (De.dragStart = [we.clientX - Re.left, we.clientY - Re.top], De.dragEnd = De.dragStart, ndcFromPointerXy(K, De.dragEnd) === null || De.isDragging) return; De.isDragging = !0, Be.current.cameraControl.enabled = !1; const Ie = Be.current.canvas2d.getContext("2d"); Ie.clearRect(0, 0, Ie.canvas.width, Ie.canvas.height) }, Se = we => { const { mutable: Be } = K, De = Be.current.scenePointerInfo; if (De.enabled === !1 || !De.isDragging) return; const Re = Be.current.canvas.getBoundingClientRect(), Ie = [we.clientX - Re.left, we.clientY - Re.top]; if (ndcFromPointerXy(K, Ie) !== null && (De.dragEnd = Ie, !(Math.abs(De.dragEnd[0] - De.dragStart[0]) <= 3 && Math.abs(De.dragEnd[1] - De.dragStart[1]) <= 3) && De.enabled === "rect-select")) { const Pe = Be.current.canvas2d.getContext("2d"); Pe.clearRect(0, 0, Pe.canvas.width, Pe.canvas.height), Pe.beginPath(), Pe.fillStyle = me.primaryColor, Pe.strokeStyle = "blue", Pe.globalAlpha = .2, Pe.fillRect(De.dragStart[0], De.dragStart[1], De.dragEnd[0] - De.dragStart[0], De.dragEnd[1] - De.dragStart[1]), Pe.globalAlpha = 1, Pe.stroke() } }, Ce = () => { const { mutable: we } = K, Be = we.current.scenePointerInfo; if (we.current.cameraControl.enabled = !0, Be.enabled === !1 || !Be.isDragging) return; const De = we.current.canvas2d.getContext("2d"); De.clearRect(0, 0, De.canvas.width, De.canvas.height), Be.enabled === "click" ? sendClickMessage(K, Be.dragEnd, pe) : Be.enabled === "rect-select" && sendRectSelectMessage(K, Be, pe), Be.isDragging = !1 }; return jsxRuntimeExports.jsx("div", { ref: ge, style: { position: "relative", zIndex: 0, width: "100%", height: "100%" }, children: jsxRuntimeExports.jsx(Canvas, { camera: { position: [-3, 3, -3], near: .01, far: 1e3 }, gl: { preserveDrawingBuffer: !0 }, style: { width: "100%", height: "100%" }, ref: we => K.mutable.current.canvas = we, onPointerDown: Ae, onPointerMove: Se, onPointerUp: Ce, shadows: !0, dpr: _e ?? void 0, children: jsxRuntimeExports.jsxs(Bvh, { firstHitOnly: !0, children: [!xe && jsxRuntimeExports.jsx(DisableRender, {}), jsxRuntimeExports.jsx(BackgroundImage, {}), jsxRuntimeExports.jsx(SceneContextSetter, {}), be, jsxRuntimeExports.jsxs(SplatRenderContext, { children: [Ee && jsxRuntimeExports.jsx(AdaptiveDpr, {}), fe, jsxRuntimeExports.jsx(SceneNodeThreeObject, { name: "" })] }), jsxRuntimeExports.jsx(DefaultLights, {})] }) }) }) } function sendClickMessage(fe, K, pe) { const me = new Raycaster, ge = ndcFromPointerXy(fe, K); if (ge === null) return; me.setFromCamera(ge, fe.mutable.current.camera); const xe = rayToViserCoords(fe, me.ray), ye = opencvXyFromPointerXy(fe, K); pe({ type: "ScenePointerMessage", event_type: "click", ray_origin: [xe.origin.x, xe.origin.y, xe.origin.z], ray_direction: [xe.direction.x, xe.direction.y, xe.direction.z], screen_pos: [[ye.x, ye.y]] }) } function sendRectSelectMessage(fe, K, pe) { const me = opencvXyFromPointerXy(fe, K.dragStart), ge = opencvXyFromPointerXy(fe, K.dragEnd), xe = Math.min(me.x, ge.x), ye = Math.max(me.x, ge.x), ve = Math.min(me.y, ge.y), _e = Math.max(me.y, ge.y); pe({ type: "ScenePointerMessage", event_type: "rect-select", ray_origin: null, ray_direction: null, screen_pos: [[xe, ve], [ye, _e]] }) } function DefaultLights() { const fe = React$4.useContext(ViewerContext), K = fe.useSceneTree(ye => ye.enableDefaultLights), pe = fe.useSceneTree(ye => ye.enableDefaultLightsShadows), me = fe.useSceneTree(ye => ye.environmentMap), ge = fe.useSceneTree(ye => ye.nodeAttributesFromName[""]?.wxyz ?? [1, 0, 0, 0]), xe = reactExports.useMemo(() => { if (me.hdri === null) return null; const ye = { apartment: "lebombo_1k.hdr", city: "potsdamer_platz_1k.hdr", dawn: "kiara_1_dawn_1k.hdr", forest: "forest_slope_1k.hdr", lobby: "st_fagans_interior_1k.hdr", night: "dikhololo_night_1k.hdr", park: "rooitou_park_1k.hdr", studio: "studio_small_03_1k.hdr", sunset: "venice_sunset_1k.hdr", warehouse: "empty_warehouse_01_1k.hdr" }, ve = new Quaternion(ge[1], ge[2], ge[3], ge[0]), _e = ve.clone().invert(), Ee = new Euler().setFromQuaternion(new Quaternion(me.background_wxyz[1], me.background_wxyz[2], me.background_wxyz[3], me.background_wxyz[0]).premultiply(ve).multiply(_e)), be = new Euler().setFromQuaternion(new Quaternion(me.environment_wxyz[1], me.environment_wxyz[2], me.environment_wxyz[3], me.environment_wxyz[0]).premultiply(ve).multiply(_e)); return jsxRuntimeExports.jsx(Environment, { files: `hdri/${ye[me.hdri]}`, background: me.background, backgroundBlurriness: me.background_blurriness, backgroundIntensity: me.background_intensity, backgroundRotation: Ee, environmentIntensity: me.environment_intensity, environmentRotation: be }) }, [me, ge]); return K ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CsmDirectionalLight, { fade: !0, lightIntensity: 3, position: [-.2, 1, -.2], cascades: 3, color: 16777215, maxFar: 20, mode: "practical", shadowBias: -1e-4, castShadow: pe }), jsxRuntimeExports.jsx(CsmDirectionalLight, { color: 16777215, lightIntensity: .4, position: [0, -1, 0], castShadow: !1 }), xe] }) : xe } function AdaptiveDpr() { const fe = useThree(K => K.setDpr); return jsxRuntimeExports.jsx(PerformanceMonitor, { factor: 1, step: .2, bounds: K => { const pe = Math.min(K * .75, 85); return [Math.max(pe * .5, 38), pe] }, onChange: ({ factor: K, fps: pe, refreshrate: me }) => { const ge = window.devicePixelRatio * (.2 + .8 * K); console.log(`[Performance] Setting DPR to ${ge}; FPS=${pe}/${me}`), fe(ge) } }) } function Viewer2DCanvas() { const fe = React$4.useContext(ViewerContext); return reactExports.useEffect(() => { const K = fe.mutable.current.canvas2d, pe = new ResizeObserver(me => { const { width: ge, height: xe } = me[0].contentRect; K.width = ge, K.height = xe }); return pe.observe(K), () => pe.disconnect() }, []), jsxRuntimeExports.jsx("canvas", { ref: K => fe.mutable.current.canvas2d = K, style: { position: "absolute", zIndex: 1, width: "100%", height: "100%", pointerEvents: "none" } }) } function BackgroundImage() {
	const fe = reactExports.useMemo(() => ({
		vert: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `, frag: `
    #include <packing>
    precision highp float;
    precision highp int;

    varying vec2 vUv;
    uniform sampler2D colorMap;
    uniform sampler2D depthMap;
    uniform float cameraNear;
    uniform float cameraFar;
    uniform bool enabled;
    uniform bool hasDepth;

    float readDepth(sampler2D depthMap, vec2 coord) {
      vec4 rgbPacked = texture(depthMap, coord);
      // Important: BGR format, because buffer was encoded using OpenCV.
      float depth = rgbPacked.b * 0.00255 + rgbPacked.g * 0.6528 + rgbPacked.r * 167.1168;
      return depth;
    }

    void main() {
      if (!enabled) {
        discard;
      }
      vec4 color = texture(colorMap, vUv);
      gl_FragColor = vec4(color.rgb, 1.0);

      float bufDepth;
      if(hasDepth){
        float depth = readDepth(depthMap, vUv);
        bufDepth = viewZToPerspectiveDepth(-depth, cameraNear, cameraFar);
      } else {
        bufDepth = 1.0;
      }
      gl_FragDepth = bufDepth;
    }
    `}), []), K = reactExports.useMemo(() => new ShaderMaterial({ fragmentShader: fe.frag, vertexShader: fe.vert, uniforms: { enabled: { value: !1 }, depthMap: { value: null }, colorMap: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, hasDepth: { value: !1 } } }), [fe]), { mutable: pe } = React$4.useContext(ViewerContext); pe.current.backgroundMaterial = K; const me = React$4.useRef(null); return useFrame(({ camera: ge }) => { if (!(ge instanceof PerspectiveCamera)) { console.error("Camera is not a perspective camera, cannot render background image."); return } const xe = me.current, ye = ge.getWorldDirection(new Vector3); xe.position.copy(ge.position).addScaledVector(ye, 1), xe.quaternion.copy(ge.quaternion); const ve = ge.getFocalLength(); xe.scale.set(ge.getFilmWidth() / ve, ge.getFilmHeight() / ve, 1), K.uniforms.cameraNear.value = ge.near, K.uniforms.cameraFar.value = ge.far }), jsxRuntimeExports.jsx("mesh", { ref: me, material: K, children: jsxRuntimeExports.jsx("planeGeometry", { attach: "geometry", args: [1, 1] }) })
} function SceneContextSetter() { const { mutable: fe } = React$4.useContext(ViewerContext); return fe.current.scene = useThree(K => K.scene), fe.current.camera = useThree(K => K.camera), null } function ViserLogo() { const [fe, { open: K, close: pe }] = useDisclosure(!1); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, { label: `Viser ${VISER_VERSION}`, children: jsxRuntimeExports.jsx(Box, { style: { position: "absolute", bottom: "1em", left: "1em", cursor: "pointer" }, component: "a", onClick: K, title: "About Viser", children: jsxRuntimeExports.jsx(Image$1, { src: "./logo.svg", style: { width: "2.5em", height: "auto" } }) }) }), jsxRuntimeExports.jsxs(Modal, { opened: fe, onClose: pe, withCloseButton: !1, size: "xl", style: { textAlign: "center" }, trapFocus: !1, children: [jsxRuntimeExports.jsx(Box, { pt: "lg", pb: "xs", children: "Viser is a 3D visualization toolkit developed at UC Berkeley." }), jsxRuntimeExports.jsxs(Box, { pb: "lg", children: [jsxRuntimeExports.jsx(Anchor, { href: "https://viser.studio/main", target: "_blank", style: { fontWeight: "600" }, children: "Documentation" }), "", jsxRuntimeExports.jsx(Anchor, { href: "https://github.com/nerfstudio-project/viser", target: "_blank", style: { fontWeight: "600" }, children: "GitHub" })] }), jsxRuntimeExports.jsx(Divider, {}), jsxRuntimeExports.jsxs(Box, { style: { textAlign: "left", maxHeight: "120px", overflowY: "auto", lineHeight: "1", fontSize: "0.8rem", opacity: "0.75" }, px: "md", pt: "sm", children: ["Thanks to our contributors!", " ", GITHUB_CONTRIBUTORS.map((me, ge) => jsxRuntimeExports.jsxs("span", { children: [jsxRuntimeExports.jsx(Anchor, { href: me.html_url, target: "_blank", style: { textDecoration: "none", fontSize: "0.75rem" }, children: me.login }), ge < GITHUB_CONTRIBUTORS.length - 1 && ", "] }, me.login))] })] })] }) } enableMapSet(); ReactDOM.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(Root, {}));
